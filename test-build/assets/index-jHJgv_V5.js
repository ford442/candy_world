true              &&(function polyfill() {
	const relList = document.createElement("link").relList;
	if (relList && relList.supports && relList.supports("modulepreload")) return;
	for (const link of document.querySelectorAll("link[rel=\"modulepreload\"]")) processPreload(link);
	new MutationObserver((mutations) => {
		for (const mutation of mutations) {
			if (mutation.type !== "childList") continue;
			for (const node of mutation.addedNodes) if (node.tagName === "LINK" && node.rel === "modulepreload") processPreload(node);
		}
	}).observe(document, {
		childList: true,
		subtree: true
	});
	function getFetchOpts(link) {
		const fetchOpts = {};
		if (link.integrity) fetchOpts.integrity = link.integrity;
		if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
		if (link.crossOrigin === "use-credentials") fetchOpts.credentials = "include";
		else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
		else fetchOpts.credentials = "same-origin";
		return fetchOpts;
	}
	function processPreload(link) {
		if (link.ep) return;
		link.ep = true;
		const fetchOpts = getFetchOpts(link);
		fetch(link.href, fetchOpts);
	}
}());

/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const REVISION = '171';
const CullFaceNone = 0;
const CullFaceBack = 1;
const CullFaceFront = 2;
const BasicShadowMap = 0;
const PCFShadowMap = 1;
const VSMShadowMap = 3;
const FrontSide = 0;
const BackSide = 1;
const DoubleSide = 2;
const NoBlending = 0;
const NormalBlending = 1;
const AdditiveBlending = 2;
const SubtractiveBlending = 3;
const MultiplyBlending = 4;
const CustomBlending = 5;
const AddEquation = 100;
const SubtractEquation = 101;
const ReverseSubtractEquation = 102;
const MinEquation = 103;
const MaxEquation = 104;
const ZeroFactor = 200;
const OneFactor = 201;
const SrcColorFactor = 202;
const OneMinusSrcColorFactor = 203;
const SrcAlphaFactor = 204;
const OneMinusSrcAlphaFactor = 205;
const DstAlphaFactor = 206;
const OneMinusDstAlphaFactor = 207;
const DstColorFactor = 208;
const OneMinusDstColorFactor = 209;
const SrcAlphaSaturateFactor = 210;
const NeverDepth = 0;
const AlwaysDepth = 1;
const LessDepth = 2;
const LessEqualDepth = 3;
const EqualDepth = 4;
const GreaterEqualDepth = 5;
const GreaterDepth = 6;
const NotEqualDepth = 7;
const MultiplyOperation = 0;
const MixOperation = 1;
const AddOperation = 2;
const NoToneMapping = 0;
const LinearToneMapping = 1;
const ReinhardToneMapping = 2;
const CineonToneMapping = 3;
const ACESFilmicToneMapping = 4;
const AgXToneMapping = 6;
const NeutralToneMapping = 7;

const UVMapping = 300;
const CubeReflectionMapping = 301;
const CubeRefractionMapping = 302;
const EquirectangularReflectionMapping = 303;
const EquirectangularRefractionMapping = 304;
const CubeUVReflectionMapping = 306;
const RepeatWrapping = 1000;
const ClampToEdgeWrapping = 1001;
const MirroredRepeatWrapping = 1002;
const NearestFilter = 1003;
const NearestMipmapNearestFilter = 1004;
const NearestMipmapLinearFilter = 1005;
const LinearFilter = 1006;
const LinearMipmapNearestFilter = 1007;
const LinearMipmapLinearFilter = 1008;
const LinearMipMapLinearFilter = 1008;
const UnsignedByteType = 1009;
const ByteType = 1010;
const ShortType = 1011;
const UnsignedShortType = 1012;
const IntType = 1013;
const UnsignedIntType = 1014;
const FloatType = 1015;
const HalfFloatType = 1016;
const UnsignedShort4444Type = 1017;
const UnsignedShort5551Type = 1018;
const UnsignedInt248Type = 1020;
const UnsignedInt5999Type = 35902;
const AlphaFormat = 1021;
const RGBFormat = 1022;
const RGBAFormat = 1023;
const LuminanceFormat = 1024;
const LuminanceAlphaFormat = 1025;
const DepthFormat = 1026;
const DepthStencilFormat = 1027;
const RedFormat = 1028;
const RedIntegerFormat = 1029;
const RGFormat = 1030;
const RGIntegerFormat = 1031;
const RGBIntegerFormat = 1032;
const RGBAIntegerFormat = 1033;

const RGB_S3TC_DXT1_Format = 33776;
const RGBA_S3TC_DXT1_Format = 33777;
const RGBA_S3TC_DXT3_Format = 33778;
const RGBA_S3TC_DXT5_Format = 33779;
const RGB_PVRTC_4BPPV1_Format = 35840;
const RGB_PVRTC_2BPPV1_Format = 35841;
const RGBA_PVRTC_4BPPV1_Format = 35842;
const RGBA_PVRTC_2BPPV1_Format = 35843;
const RGB_ETC1_Format = 36196;
const RGB_ETC2_Format = 37492;
const RGBA_ETC2_EAC_Format = 37496;
const RGBA_ASTC_4x4_Format = 37808;
const RGBA_ASTC_5x4_Format = 37809;
const RGBA_ASTC_5x5_Format = 37810;
const RGBA_ASTC_6x5_Format = 37811;
const RGBA_ASTC_6x6_Format = 37812;
const RGBA_ASTC_8x5_Format = 37813;
const RGBA_ASTC_8x6_Format = 37814;
const RGBA_ASTC_8x8_Format = 37815;
const RGBA_ASTC_10x5_Format = 37816;
const RGBA_ASTC_10x6_Format = 37817;
const RGBA_ASTC_10x8_Format = 37818;
const RGBA_ASTC_10x10_Format = 37819;
const RGBA_ASTC_12x10_Format = 37820;
const RGBA_ASTC_12x12_Format = 37821;
const RGBA_BPTC_Format = 36492;
const RED_RGTC1_Format = 36283;
const SIGNED_RED_RGTC1_Format = 36284;
const RED_GREEN_RGTC2_Format = 36285;
const SIGNED_RED_GREEN_RGTC2_Format = 36286;
const TangentSpaceNormalMap = 0;
const ObjectSpaceNormalMap = 1;

// Color space string identifiers, matching CSS Color Module Level 4 and WebGPU names where available.
const NoColorSpace = '';
const SRGBColorSpace = 'srgb';
const LinearSRGBColorSpace = 'srgb-linear';

const LinearTransfer = 'linear';
const SRGBTransfer = 'srgb';

const ZeroStencilOp = 0;
const KeepStencilOp = 7680;
const ReplaceStencilOp = 7681;
const IncrementStencilOp = 7682;
const DecrementStencilOp = 7683;
const IncrementWrapStencilOp = 34055;
const DecrementWrapStencilOp = 34056;
const InvertStencilOp = 5386;

const NeverStencilFunc = 512;
const LessStencilFunc = 513;
const EqualStencilFunc = 514;
const LessEqualStencilFunc = 515;
const GreaterStencilFunc = 516;
const NotEqualStencilFunc = 517;
const GreaterEqualStencilFunc = 518;
const AlwaysStencilFunc = 519;

const NeverCompare = 512;
const LessCompare = 513;
const EqualCompare = 514;
const LessEqualCompare = 515;
const GreaterCompare = 516;
const NotEqualCompare = 517;
const GreaterEqualCompare = 518;
const AlwaysCompare = 519;

const StaticDrawUsage = 35044;
const DynamicDrawUsage = 35048;

const WebGLCoordinateSystem = 2000;
const WebGPUCoordinateSystem = 2001;

/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */

class EventDispatcher {

	addEventListener( type, listener ) {

		if ( this._listeners === undefined ) this._listeners = {};

		const listeners = this._listeners;

		if ( listeners[ type ] === undefined ) {

			listeners[ type ] = [];

		}

		if ( listeners[ type ].indexOf( listener ) === -1 ) {

			listeners[ type ].push( listener );

		}

	}

	hasEventListener( type, listener ) {

		if ( this._listeners === undefined ) return false;

		const listeners = this._listeners;

		return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== -1;

	}

	removeEventListener( type, listener ) {

		if ( this._listeners === undefined ) return;

		const listeners = this._listeners;
		const listenerArray = listeners[ type ];

		if ( listenerArray !== undefined ) {

			const index = listenerArray.indexOf( listener );

			if ( index !== -1 ) {

				listenerArray.splice( index, 1 );

			}

		}

	}

	dispatchEvent( event ) {

		if ( this._listeners === undefined ) return;

		const listeners = this._listeners;
		const listenerArray = listeners[ event.type ];

		if ( listenerArray !== undefined ) {

			event.target = this;

			// Make a copy, in case listeners are removed while iterating.
			const array = listenerArray.slice( 0 );

			for ( let i = 0, l = array.length; i < l; i ++ ) {

				array[ i ].call( this, event );

			}

			event.target = null;

		}

	}

}

const _lut = [ '00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '0d', '0e', '0f', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '2d', '2e', '2f', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '4d', '4e', '4f', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '5d', '5e', '5f', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '6e', '6f', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '7d', '7e', '7f', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '8d', '8e', '8f', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', '9d', '9e', '9f', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'dd', 'de', 'df', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff' ];

let _seed = 1234567;


const DEG2RAD = Math.PI / 180;
const RAD2DEG = 180 / Math.PI;

// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
function generateUUID() {

	const d0 = Math.random() * 0xffffffff | 0;
	const d1 = Math.random() * 0xffffffff | 0;
	const d2 = Math.random() * 0xffffffff | 0;
	const d3 = Math.random() * 0xffffffff | 0;
	const uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +
			_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +
			_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +
			_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];

	// .toLowerCase() here flattens concatenated strings to save heap memory space.
	return uuid.toLowerCase();

}

function clamp$1( value, min, max ) {

	return Math.max( min, Math.min( max, value ) );

}

// compute euclidean modulo of m % n
// https://en.wikipedia.org/wiki/Modulo_operation
function euclideanModulo( n, m ) {

	return ( ( n % m ) + m ) % m;

}

// Linear mapping from range <a1, a2> to range <b1, b2>
function mapLinear( x, a1, a2, b1, b2 ) {

	return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

}

// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/
function inverseLerp( x, y, value ) {

	if ( x !== y ) {

		return ( value - x ) / ( y - x );

	} else {

		return 0;

	}

}

// https://en.wikipedia.org/wiki/Linear_interpolation
function lerp$1( x, y, t ) {

	return ( 1 - t ) * x + t * y;

}

// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/
function damp( x, y, lambda, dt ) {

	return lerp$1( x, y, 1 - Math.exp( - lambda * dt ) );

}

// https://www.desmos.com/calculator/vcsjnyz7x4
function pingpong( x, length = 1 ) {

	return length - Math.abs( euclideanModulo( x, length * 2 ) - length );

}

// http://en.wikipedia.org/wiki/Smoothstep
function smoothstep$2( x, min, max ) {

	if ( x <= min ) return 0;
	if ( x >= max ) return 1;

	x = ( x - min ) / ( max - min );

	return x * x * ( 3 - 2 * x );

}

function smootherstep( x, min, max ) {

	if ( x <= min ) return 0;
	if ( x >= max ) return 1;

	x = ( x - min ) / ( max - min );

	return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

}

// Random integer from <low, high> interval
function randInt( low, high ) {

	return low + Math.floor( Math.random() * ( high - low + 1 ) );

}

// Random float from <low, high> interval
function randFloat( low, high ) {

	return low + Math.random() * ( high - low );

}

// Random float from <-range/2, range/2> interval
function randFloatSpread( range ) {

	return range * ( 0.5 - Math.random() );

}

// Deterministic pseudo-random float in the interval [ 0, 1 ]
function seededRandom( s ) {

	if ( s !== undefined ) _seed = s;

	// Mulberry32 generator

	let t = _seed += 0x6D2B79F5;

	t = Math.imul( t ^ t >>> 15, t | 1 );

	t ^= t + Math.imul( t ^ t >>> 7, t | 61 );

	return ( ( t ^ t >>> 14 ) >>> 0 ) / 4294967296;

}

function degToRad( degrees ) {

	return degrees * DEG2RAD;

}

function radToDeg( radians ) {

	return radians * RAD2DEG;

}

function isPowerOfTwo( value ) {

	return ( value & ( value - 1 ) ) === 0 && value !== 0;

}

function ceilPowerOfTwo( value ) {

	return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );

}

function floorPowerOfTwo( value ) {

	return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

}

function setQuaternionFromProperEuler( q, a, b, c, order ) {

	// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles

	// rotations are applied to the axes in the order specified by 'order'
	// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
	// angles are in radians

	const cos = Math.cos;
	const sin = Math.sin;

	const c2 = cos( b / 2 );
	const s2 = sin( b / 2 );

	const c13 = cos( ( a + c ) / 2 );
	const s13 = sin( ( a + c ) / 2 );

	const c1_3 = cos( ( a - c ) / 2 );
	const s1_3 = sin( ( a - c ) / 2 );

	const c3_1 = cos( ( c - a ) / 2 );
	const s3_1 = sin( ( c - a ) / 2 );

	switch ( order ) {

		case 'XYX':
			q.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );
			break;

		case 'YZY':
			q.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );
			break;

		case 'ZXZ':
			q.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );
			break;

		case 'XZX':
			q.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );
			break;

		case 'YXY':
			q.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );
			break;

		case 'ZYZ':
			q.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );
			break;

		default:
			console.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order );

	}

}

function denormalize( value, array ) {

	switch ( array.constructor ) {

		case Float32Array:

			return value;

		case Uint32Array:

			return value / 4294967295.0;

		case Uint16Array:

			return value / 65535.0;

		case Uint8Array:

			return value / 255.0;

		case Int32Array:

			return Math.max( value / 2147483647.0, -1 );

		case Int16Array:

			return Math.max( value / 32767.0, -1 );

		case Int8Array:

			return Math.max( value / 127.0, -1 );

		default:

			throw new Error( 'Invalid component type.' );

	}

}

function normalize$2( value, array ) {

	switch ( array.constructor ) {

		case Float32Array:

			return value;

		case Uint32Array:

			return Math.round( value * 4294967295.0 );

		case Uint16Array:

			return Math.round( value * 65535.0 );

		case Uint8Array:

			return Math.round( value * 255.0 );

		case Int32Array:

			return Math.round( value * 2147483647.0 );

		case Int16Array:

			return Math.round( value * 32767.0 );

		case Int8Array:

			return Math.round( value * 127.0 );

		default:

			throw new Error( 'Invalid component type.' );

	}

}

const MathUtils = {
	DEG2RAD: DEG2RAD,
	RAD2DEG: RAD2DEG,
	generateUUID: generateUUID,
	clamp: clamp$1,
	euclideanModulo: euclideanModulo,
	mapLinear: mapLinear,
	inverseLerp: inverseLerp,
	lerp: lerp$1,
	damp: damp,
	pingpong: pingpong,
	smoothstep: smoothstep$2,
	smootherstep: smootherstep,
	randInt: randInt,
	randFloat: randFloat,
	randFloatSpread: randFloatSpread,
	seededRandom: seededRandom,
	degToRad: degToRad,
	radToDeg: radToDeg,
	isPowerOfTwo: isPowerOfTwo,
	ceilPowerOfTwo: ceilPowerOfTwo,
	floorPowerOfTwo: floorPowerOfTwo,
	setQuaternionFromProperEuler: setQuaternionFromProperEuler,
	normalize: normalize$2,
	denormalize: denormalize
};

class Vector2 {

	constructor( x = 0, y = 0 ) {

		Vector2.prototype.isVector2 = true;

		this.x = x;
		this.y = y;

	}

	get width() {

		return this.x;

	}

	set width( value ) {

		this.x = value;

	}

	get height() {

		return this.y;

	}

	set height( value ) {

		this.y = value;

	}

	set( x, y ) {

		this.x = x;
		this.y = y;

		return this;

	}

	setScalar( scalar ) {

		this.x = scalar;
		this.y = scalar;

		return this;

	}

	setX( x ) {

		this.x = x;

		return this;

	}

	setY( y ) {

		this.y = y;

		return this;

	}

	setComponent( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	}

	getComponent( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			default: throw new Error( 'index is out of range: ' + index );

		}

	}

	clone() {

		return new this.constructor( this.x, this.y );

	}

	copy( v ) {

		this.x = v.x;
		this.y = v.y;

		return this;

	}

	add( v ) {

		this.x += v.x;
		this.y += v.y;

		return this;

	}

	addScalar( s ) {

		this.x += s;
		this.y += s;

		return this;

	}

	addVectors( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;

		return this;

	}

	addScaledVector( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;

		return this;

	}

	sub( v ) {

		this.x -= v.x;
		this.y -= v.y;

		return this;

	}

	subScalar( s ) {

		this.x -= s;
		this.y -= s;

		return this;

	}

	subVectors( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;

		return this;

	}

	multiply( v ) {

		this.x *= v.x;
		this.y *= v.y;

		return this;

	}

	multiplyScalar( scalar ) {

		this.x *= scalar;
		this.y *= scalar;

		return this;

	}

	divide( v ) {

		this.x /= v.x;
		this.y /= v.y;

		return this;

	}

	divideScalar( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	}

	applyMatrix3( m ) {

		const x = this.x, y = this.y;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];

		return this;

	}

	min( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );

		return this;

	}

	max( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );

		return this;

	}

	clamp( min, max ) {

		// assumes min < max, componentwise

		this.x = clamp$1( this.x, min.x, max.x );
		this.y = clamp$1( this.y, min.y, max.y );

		return this;

	}

	clampScalar( minVal, maxVal ) {

		this.x = clamp$1( this.x, minVal, maxVal );
		this.y = clamp$1( this.y, minVal, maxVal );

		return this;

	}

	clampLength( min, max ) {

		const length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( clamp$1( length, min, max ) );

	}

	floor() {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );

		return this;

	}

	ceil() {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );

		return this;

	}

	round() {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );

		return this;

	}

	roundToZero() {

		this.x = Math.trunc( this.x );
		this.y = Math.trunc( this.y );

		return this;

	}

	negate() {

		this.x = - this.x;
		this.y = - this.y;

		return this;

	}

	dot( v ) {

		return this.x * v.x + this.y * v.y;

	}

	cross( v ) {

		return this.x * v.y - this.y * v.x;

	}

	lengthSq() {

		return this.x * this.x + this.y * this.y;

	}

	length() {

		return Math.sqrt( this.x * this.x + this.y * this.y );

	}

	manhattanLength() {

		return Math.abs( this.x ) + Math.abs( this.y );

	}

	normalize() {

		return this.divideScalar( this.length() || 1 );

	}

	angle() {

		// computes the angle in radians with respect to the positive x-axis

		const angle = Math.atan2( - this.y, - this.x ) + Math.PI;

		return angle;

	}

	angleTo( v ) {

		const denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );

		if ( denominator === 0 ) return Math.PI / 2;

		const theta = this.dot( v ) / denominator;

		// clamp, to handle numerical problems

		return Math.acos( clamp$1( theta, -1, 1 ) );

	}

	distanceTo( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	}

	distanceToSquared( v ) {

		const dx = this.x - v.x, dy = this.y - v.y;
		return dx * dx + dy * dy;

	}

	manhattanDistanceTo( v ) {

		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

	}

	setLength( length ) {

		return this.normalize().multiplyScalar( length );

	}

	lerp( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;

		return this;

	}

	lerpVectors( v1, v2, alpha ) {

		this.x = v1.x + ( v2.x - v1.x ) * alpha;
		this.y = v1.y + ( v2.y - v1.y ) * alpha;

		return this;

	}

	equals( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) );

	}

	fromArray( array, offset = 0 ) {

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;

		return array;

	}

	fromBufferAttribute( attribute, index ) {

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );

		return this;

	}

	rotateAround( center, angle ) {

		const c = Math.cos( angle ), s = Math.sin( angle );

		const x = this.x - center.x;
		const y = this.y - center.y;

		this.x = x * c - y * s + center.x;
		this.y = x * s + y * c + center.y;

		return this;

	}

	random() {

		this.x = Math.random();
		this.y = Math.random();

		return this;

	}

	*[ Symbol.iterator ]() {

		yield this.x;
		yield this.y;

	}

}

class Matrix3 {

	constructor( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

		Matrix3.prototype.isMatrix3 = true;

		this.elements = [

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		];

		if ( n11 !== undefined ) {

			this.set( n11, n12, n13, n21, n22, n23, n31, n32, n33 );

		}

	}

	set( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

		const te = this.elements;

		te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
		te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
		te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

		return this;

	}

	identity() {

		this.set(

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		);

		return this;

	}

	copy( m ) {

		const te = this.elements;
		const me = m.elements;

		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
		te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
		te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];

		return this;

	}

	extractBasis( xAxis, yAxis, zAxis ) {

		xAxis.setFromMatrix3Column( this, 0 );
		yAxis.setFromMatrix3Column( this, 1 );
		zAxis.setFromMatrix3Column( this, 2 );

		return this;

	}

	setFromMatrix4( m ) {

		const me = m.elements;

		this.set(

			me[ 0 ], me[ 4 ], me[ 8 ],
			me[ 1 ], me[ 5 ], me[ 9 ],
			me[ 2 ], me[ 6 ], me[ 10 ]

		);

		return this;

	}

	multiply( m ) {

		return this.multiplyMatrices( this, m );

	}

	premultiply( m ) {

		return this.multiplyMatrices( m, this );

	}

	multiplyMatrices( a, b ) {

		const ae = a.elements;
		const be = b.elements;
		const te = this.elements;

		const a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
		const a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
		const a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];

		const b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
		const b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
		const b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
		te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
		te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
		te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
		te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
		te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
		te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

		return this;

	}

	multiplyScalar( s ) {

		const te = this.elements;

		te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
		te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
		te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

		return this;

	}

	determinant() {

		const te = this.elements;

		const a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
			d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
			g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

		return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

	}

	invert() {

		const te = this.elements,

			n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ],
			n12 = te[ 3 ], n22 = te[ 4 ], n32 = te[ 5 ],
			n13 = te[ 6 ], n23 = te[ 7 ], n33 = te[ 8 ],

			t11 = n33 * n22 - n32 * n23,
			t12 = n32 * n13 - n33 * n12,
			t13 = n23 * n12 - n22 * n13,

			det = n11 * t11 + n21 * t12 + n31 * t13;

		if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 );

		const detInv = 1 / det;

		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
		te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

		te[ 3 ] = t12 * detInv;
		te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
		te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

		te[ 6 ] = t13 * detInv;
		te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
		te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

		return this;

	}

	transpose() {

		let tmp;
		const m = this.elements;

		tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
		tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
		tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

		return this;

	}

	getNormalMatrix( matrix4 ) {

		return this.setFromMatrix4( matrix4 ).invert().transpose();

	}

	transposeIntoArray( r ) {

		const m = this.elements;

		r[ 0 ] = m[ 0 ];
		r[ 1 ] = m[ 3 ];
		r[ 2 ] = m[ 6 ];
		r[ 3 ] = m[ 1 ];
		r[ 4 ] = m[ 4 ];
		r[ 5 ] = m[ 7 ];
		r[ 6 ] = m[ 2 ];
		r[ 7 ] = m[ 5 ];
		r[ 8 ] = m[ 8 ];

		return this;

	}

	setUvTransform( tx, ty, sx, sy, rotation, cx, cy ) {

		const c = Math.cos( rotation );
		const s = Math.sin( rotation );

		this.set(
			sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
			- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
			0, 0, 1
		);

		return this;

	}

	//

	scale( sx, sy ) {

		this.premultiply( _m3.makeScale( sx, sy ) );

		return this;

	}

	rotate( theta ) {

		this.premultiply( _m3.makeRotation( - theta ) );

		return this;

	}

	translate( tx, ty ) {

		this.premultiply( _m3.makeTranslation( tx, ty ) );

		return this;

	}

	// for 2D Transforms

	makeTranslation( x, y ) {

		if ( x.isVector2 ) {

			this.set(

				1, 0, x.x,
				0, 1, x.y,
				0, 0, 1

			);

		} else {

			this.set(

				1, 0, x,
				0, 1, y,
				0, 0, 1

			);

		}

		return this;

	}

	makeRotation( theta ) {

		// counterclockwise

		const c = Math.cos( theta );
		const s = Math.sin( theta );

		this.set(

			c, - s, 0,
			s, c, 0,
			0, 0, 1

		);

		return this;

	}

	makeScale( x, y ) {

		this.set(

			x, 0, 0,
			0, y, 0,
			0, 0, 1

		);

		return this;

	}

	//

	equals( matrix ) {

		const te = this.elements;
		const me = matrix.elements;

		for ( let i = 0; i < 9; i ++ ) {

			if ( te[ i ] !== me[ i ] ) return false;

		}

		return true;

	}

	fromArray( array, offset = 0 ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.elements[ i ] = array[ i + offset ];

		}

		return this;

	}

	toArray( array = [], offset = 0 ) {

		const te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];

		array[ offset + 3 ] = te[ 3 ];
		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];

		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];
		array[ offset + 8 ] = te[ 8 ];

		return array;

	}

	clone() {

		return new this.constructor().fromArray( this.elements );

	}

}

const _m3 = /*@__PURE__*/ new Matrix3();

function arrayNeedsUint32$1( array ) {

	// assumes larger values usually on last

	for ( let i = array.length - 1; i >= 0; -- i ) {

		if ( array[ i ] >= 65535 ) return true; // account for PRIMITIVE_RESTART_FIXED_INDEX, #24565

	}

	return false;

}

function createElementNS( name ) {

	return document.createElementNS( 'http://www.w3.org/1999/xhtml', name );

}

function createCanvasElement() {

	const canvas = createElementNS( 'canvas' );
	canvas.style.display = 'block';
	return canvas;

}

const _cache$2 = {};

function warnOnce( message ) {

	if ( message in _cache$2 ) return;

	_cache$2[ message ] = true;

	console.warn( message );

}

const LINEAR_REC709_TO_XYZ = /*@__PURE__*/ new Matrix3().set(
	0.4123908, 0.3575843, 0.1804808,
	0.2126390, 0.7151687, 0.0721923,
	0.0193308, 0.1191948, 0.9505322
);

const XYZ_TO_LINEAR_REC709 = /*@__PURE__*/ new Matrix3().set(
	3.2409699, -1.5373832, -0.4986108,
	-0.9692436, 1.8759675, 0.0415551,
	0.0556301, -0.203977, 1.0569715
);

function createColorManagement() {

	const ColorManagement = {

		enabled: true,

		workingColorSpace: LinearSRGBColorSpace,

		/**
		 * Implementations of supported color spaces.
		 *
		 * Required:
		 *	- primaries: chromaticity coordinates [ rx ry gx gy bx by ]
		 *	- whitePoint: reference white [ x y ]
		 *	- transfer: transfer function (pre-defined)
		 *	- toXYZ: Matrix3 RGB to XYZ transform
		 *	- fromXYZ: Matrix3 XYZ to RGB transform
		 *	- luminanceCoefficients: RGB luminance coefficients
		 *
		 * Optional:
		 *  - outputColorSpaceConfig: { drawingBufferColorSpace: ColorSpace }
		 *  - workingColorSpaceConfig: { unpackColorSpace: ColorSpace }
		 *
		 * Reference:
		 * - https://www.russellcottrell.com/photo/matrixCalculator.htm
		 */
		spaces: {},

		convert: function ( color, sourceColorSpace, targetColorSpace ) {

			if ( this.enabled === false || sourceColorSpace === targetColorSpace || ! sourceColorSpace || ! targetColorSpace ) {

				return color;

			}

			if ( this.spaces[ sourceColorSpace ].transfer === SRGBTransfer ) {

				color.r = SRGBToLinear( color.r );
				color.g = SRGBToLinear( color.g );
				color.b = SRGBToLinear( color.b );

			}

			if ( this.spaces[ sourceColorSpace ].primaries !== this.spaces[ targetColorSpace ].primaries ) {

				color.applyMatrix3( this.spaces[ sourceColorSpace ].toXYZ );
				color.applyMatrix3( this.spaces[ targetColorSpace ].fromXYZ );

			}

			if ( this.spaces[ targetColorSpace ].transfer === SRGBTransfer ) {

				color.r = LinearToSRGB( color.r );
				color.g = LinearToSRGB( color.g );
				color.b = LinearToSRGB( color.b );

			}

			return color;

		},

		fromWorkingColorSpace: function ( color, targetColorSpace ) {

			return this.convert( color, this.workingColorSpace, targetColorSpace );

		},

		toWorkingColorSpace: function ( color, sourceColorSpace ) {

			return this.convert( color, sourceColorSpace, this.workingColorSpace );

		},

		getPrimaries: function ( colorSpace ) {

			return this.spaces[ colorSpace ].primaries;

		},

		getTransfer: function ( colorSpace ) {

			if ( colorSpace === NoColorSpace ) return LinearTransfer;

			return this.spaces[ colorSpace ].transfer;

		},

		getLuminanceCoefficients: function ( target, colorSpace = this.workingColorSpace ) {

			return target.fromArray( this.spaces[ colorSpace ].luminanceCoefficients );

		},

		define: function ( colorSpaces ) {

			Object.assign( this.spaces, colorSpaces );

		},

		// Internal APIs

		_getMatrix: function ( targetMatrix, sourceColorSpace, targetColorSpace ) {

			return targetMatrix
				.copy( this.spaces[ sourceColorSpace ].toXYZ )
				.multiply( this.spaces[ targetColorSpace ].fromXYZ );

		},

		_getDrawingBufferColorSpace: function ( colorSpace ) {

			return this.spaces[ colorSpace ].outputColorSpaceConfig.drawingBufferColorSpace;

		},

		_getUnpackColorSpace: function ( colorSpace = this.workingColorSpace ) {

			return this.spaces[ colorSpace ].workingColorSpaceConfig.unpackColorSpace;

		}

	};

	/******************************************************************************
	 * sRGB definitions
	 */

	const REC709_PRIMARIES = [ 0.640, 0.330, 0.300, 0.600, 0.150, 0.060 ];
	const REC709_LUMINANCE_COEFFICIENTS = [ 0.2126, 0.7152, 0.0722 ];
	const D65 = [ 0.3127, 0.3290 ];

	ColorManagement.define( {

		[ LinearSRGBColorSpace ]: {
			primaries: REC709_PRIMARIES,
			whitePoint: D65,
			transfer: LinearTransfer,
			toXYZ: LINEAR_REC709_TO_XYZ,
			fromXYZ: XYZ_TO_LINEAR_REC709,
			luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,
			workingColorSpaceConfig: { unpackColorSpace: SRGBColorSpace },
			outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }
		},

		[ SRGBColorSpace ]: {
			primaries: REC709_PRIMARIES,
			whitePoint: D65,
			transfer: SRGBTransfer,
			toXYZ: LINEAR_REC709_TO_XYZ,
			fromXYZ: XYZ_TO_LINEAR_REC709,
			luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,
			outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }
		},

	} );

	return ColorManagement;

}

const ColorManagement = /*@__PURE__*/ createColorManagement();

function SRGBToLinear( c ) {

	return ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );

}

function LinearToSRGB( c ) {

	return ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;

}

let _canvas;

class ImageUtils {

	static getDataURL( image ) {

		if ( /^data:/i.test( image.src ) ) {

			return image.src;

		}

		if ( typeof HTMLCanvasElement === 'undefined' ) {

			return image.src;

		}

		let canvas;

		if ( image instanceof HTMLCanvasElement ) {

			canvas = image;

		} else {

			if ( _canvas === undefined ) _canvas = createElementNS( 'canvas' );

			_canvas.width = image.width;
			_canvas.height = image.height;

			const context = _canvas.getContext( '2d' );

			if ( image instanceof ImageData ) {

				context.putImageData( image, 0, 0 );

			} else {

				context.drawImage( image, 0, 0, image.width, image.height );

			}

			canvas = _canvas;

		}

		if ( canvas.width > 2048 || canvas.height > 2048 ) {

			console.warn( 'THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image );

			return canvas.toDataURL( 'image/jpeg', 0.6 );

		} else {

			return canvas.toDataURL( 'image/png' );

		}

	}

	static sRGBToLinear( image ) {

		if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
			( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
			( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

			const canvas = createElementNS( 'canvas' );

			canvas.width = image.width;
			canvas.height = image.height;

			const context = canvas.getContext( '2d' );
			context.drawImage( image, 0, 0, image.width, image.height );

			const imageData = context.getImageData( 0, 0, image.width, image.height );
			const data = imageData.data;

			for ( let i = 0; i < data.length; i ++ ) {

				data[ i ] = SRGBToLinear( data[ i ] / 255 ) * 255;

			}

			context.putImageData( imageData, 0, 0 );

			return canvas;

		} else if ( image.data ) {

			const data = image.data.slice( 0 );

			for ( let i = 0; i < data.length; i ++ ) {

				if ( data instanceof Uint8Array || data instanceof Uint8ClampedArray ) {

					data[ i ] = Math.floor( SRGBToLinear( data[ i ] / 255 ) * 255 );

				} else {

					// assuming float

					data[ i ] = SRGBToLinear( data[ i ] );

				}

			}

			return {
				data: data,
				width: image.width,
				height: image.height
			};

		} else {

			console.warn( 'THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.' );
			return image;

		}

	}

}

let _sourceId = 0;

class Source {

	constructor( data = null ) {

		this.isSource = true;

		Object.defineProperty( this, 'id', { value: _sourceId ++ } );

		this.uuid = generateUUID();

		this.data = data;
		this.dataReady = true;

		this.version = 0;

	}

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

	toJSON( meta ) {

		const isRootObject = ( meta === undefined || typeof meta === 'string' );

		if ( ! isRootObject && meta.images[ this.uuid ] !== undefined ) {

			return meta.images[ this.uuid ];

		}

		const output = {
			uuid: this.uuid,
			url: ''
		};

		const data = this.data;

		if ( data !== null ) {

			let url;

			if ( Array.isArray( data ) ) {

				// cube texture

				url = [];

				for ( let i = 0, l = data.length; i < l; i ++ ) {

					if ( data[ i ].isDataTexture ) {

						url.push( serializeImage( data[ i ].image ) );

					} else {

						url.push( serializeImage( data[ i ] ) );

					}

				}

			} else {

				// texture

				url = serializeImage( data );

			}

			output.url = url;

		}

		if ( ! isRootObject ) {

			meta.images[ this.uuid ] = output;

		}

		return output;

	}

}

function serializeImage( image ) {

	if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
		( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
		( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

		// default images

		return ImageUtils.getDataURL( image );

	} else {

		if ( image.data ) {

			// images of DataTexture

			return {
				data: Array.from( image.data ),
				width: image.width,
				height: image.height,
				type: image.data.constructor.name
			};

		} else {

			console.warn( 'THREE.Texture: Unable to serialize Texture.' );
			return {};

		}

	}

}

let _textureId = 0;

class Texture extends EventDispatcher {

	constructor( image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = Texture.DEFAULT_ANISOTROPY, colorSpace = NoColorSpace ) {

		super();

		this.isTexture = true;

		Object.defineProperty( this, 'id', { value: _textureId ++ } );

		this.uuid = generateUUID();

		this.name = '';

		this.source = new Source( image );
		this.mipmaps = [];

		this.mapping = mapping;
		this.channel = 0;

		this.wrapS = wrapS;
		this.wrapT = wrapT;

		this.magFilter = magFilter;
		this.minFilter = minFilter;

		this.anisotropy = anisotropy;

		this.format = format;
		this.internalFormat = null;
		this.type = type;

		this.offset = new Vector2( 0, 0 );
		this.repeat = new Vector2( 1, 1 );
		this.center = new Vector2( 0, 0 );
		this.rotation = 0;

		this.matrixAutoUpdate = true;
		this.matrix = new Matrix3();

		this.generateMipmaps = true;
		this.premultiplyAlpha = false;
		this.flipY = true;
		this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

		this.colorSpace = colorSpace;

		this.userData = {};

		this.version = 0;
		this.onUpdate = null;

		this.isRenderTargetTexture = false; // indicates whether a texture belongs to a render target or not
		this.pmremVersion = 0; // indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures)

	}

	get image() {

		return this.source.data;

	}

	set image( value = null ) {

		this.source.data = value;

	}

	updateMatrix() {

		this.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( source ) {

		this.name = source.name;

		this.source = source.source;
		this.mipmaps = source.mipmaps.slice( 0 );

		this.mapping = source.mapping;
		this.channel = source.channel;

		this.wrapS = source.wrapS;
		this.wrapT = source.wrapT;

		this.magFilter = source.magFilter;
		this.minFilter = source.minFilter;

		this.anisotropy = source.anisotropy;

		this.format = source.format;
		this.internalFormat = source.internalFormat;
		this.type = source.type;

		this.offset.copy( source.offset );
		this.repeat.copy( source.repeat );
		this.center.copy( source.center );
		this.rotation = source.rotation;

		this.matrixAutoUpdate = source.matrixAutoUpdate;
		this.matrix.copy( source.matrix );

		this.generateMipmaps = source.generateMipmaps;
		this.premultiplyAlpha = source.premultiplyAlpha;
		this.flipY = source.flipY;
		this.unpackAlignment = source.unpackAlignment;
		this.colorSpace = source.colorSpace;

		this.userData = JSON.parse( JSON.stringify( source.userData ) );

		this.needsUpdate = true;

		return this;

	}

	toJSON( meta ) {

		const isRootObject = ( meta === undefined || typeof meta === 'string' );

		if ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {

			return meta.textures[ this.uuid ];

		}

		const output = {

			metadata: {
				version: 4.6,
				type: 'Texture',
				generator: 'Texture.toJSON'
			},

			uuid: this.uuid,
			name: this.name,

			image: this.source.toJSON( meta ).uuid,

			mapping: this.mapping,
			channel: this.channel,

			repeat: [ this.repeat.x, this.repeat.y ],
			offset: [ this.offset.x, this.offset.y ],
			center: [ this.center.x, this.center.y ],
			rotation: this.rotation,

			wrap: [ this.wrapS, this.wrapT ],

			format: this.format,
			internalFormat: this.internalFormat,
			type: this.type,
			colorSpace: this.colorSpace,

			minFilter: this.minFilter,
			magFilter: this.magFilter,
			anisotropy: this.anisotropy,

			flipY: this.flipY,

			generateMipmaps: this.generateMipmaps,
			premultiplyAlpha: this.premultiplyAlpha,
			unpackAlignment: this.unpackAlignment

		};

		if ( Object.keys( this.userData ).length > 0 ) output.userData = this.userData;

		if ( ! isRootObject ) {

			meta.textures[ this.uuid ] = output;

		}

		return output;

	}

	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

	}

	transformUv( uv ) {

		if ( this.mapping !== UVMapping ) return uv;

		uv.applyMatrix3( this.matrix );

		if ( uv.x < 0 || uv.x > 1 ) {

			switch ( this.wrapS ) {

				case RepeatWrapping:

					uv.x = uv.x - Math.floor( uv.x );
					break;

				case ClampToEdgeWrapping:

					uv.x = uv.x < 0 ? 0 : 1;
					break;

				case MirroredRepeatWrapping:

					if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

						uv.x = Math.ceil( uv.x ) - uv.x;

					} else {

						uv.x = uv.x - Math.floor( uv.x );

					}

					break;

			}

		}

		if ( uv.y < 0 || uv.y > 1 ) {

			switch ( this.wrapT ) {

				case RepeatWrapping:

					uv.y = uv.y - Math.floor( uv.y );
					break;

				case ClampToEdgeWrapping:

					uv.y = uv.y < 0 ? 0 : 1;
					break;

				case MirroredRepeatWrapping:

					if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

						uv.y = Math.ceil( uv.y ) - uv.y;

					} else {

						uv.y = uv.y - Math.floor( uv.y );

					}

					break;

			}

		}

		if ( this.flipY ) {

			uv.y = 1 - uv.y;

		}

		return uv;

	}

	set needsUpdate( value ) {

		if ( value === true ) {

			this.version ++;
			this.source.needsUpdate = true;

		}

	}

	set needsPMREMUpdate( value ) {

		if ( value === true ) {

			this.pmremVersion ++;

		}

	}

}

Texture.DEFAULT_IMAGE = null;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.DEFAULT_ANISOTROPY = 1;

class Vector4 {

	constructor( x = 0, y = 0, z = 0, w = 1 ) {

		Vector4.prototype.isVector4 = true;

		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;

	}

	get width() {

		return this.z;

	}

	set width( value ) {

		this.z = value;

	}

	get height() {

		return this.w;

	}

	set height( value ) {

		this.w = value;

	}

	set( x, y, z, w ) {

		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;

		return this;

	}

	setScalar( scalar ) {

		this.x = scalar;
		this.y = scalar;
		this.z = scalar;
		this.w = scalar;

		return this;

	}

	setX( x ) {

		this.x = x;

		return this;

	}

	setY( y ) {

		this.y = y;

		return this;

	}

	setZ( z ) {

		this.z = z;

		return this;

	}

	setW( w ) {

		this.w = w;

		return this;

	}

	setComponent( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			case 3: this.w = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	}

	getComponent( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			case 3: return this.w;
			default: throw new Error( 'index is out of range: ' + index );

		}

	}

	clone() {

		return new this.constructor( this.x, this.y, this.z, this.w );

	}

	copy( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;
		this.w = ( v.w !== undefined ) ? v.w : 1;

		return this;

	}

	add( v ) {

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;
		this.w += v.w;

		return this;

	}

	addScalar( s ) {

		this.x += s;
		this.y += s;
		this.z += s;
		this.w += s;

		return this;

	}

	addVectors( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;
		this.w = a.w + b.w;

		return this;

	}

	addScaledVector( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;
		this.w += v.w * s;

		return this;

	}

	sub( v ) {

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;
		this.w -= v.w;

		return this;

	}

	subScalar( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;
		this.w -= s;

		return this;

	}

	subVectors( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;
		this.w = a.w - b.w;

		return this;

	}

	multiply( v ) {

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;
		this.w *= v.w;

		return this;

	}

	multiplyScalar( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;
		this.w *= scalar;

		return this;

	}

	applyMatrix4( m ) {

		const x = this.x, y = this.y, z = this.z, w = this.w;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
		this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

		return this;

	}

	divide( v ) {

		this.x /= v.x;
		this.y /= v.y;
		this.z /= v.z;
		this.w /= v.w;

		return this;

	}

	divideScalar( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	}

	setAxisAngleFromQuaternion( q ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

		// q is assumed to be normalized

		this.w = 2 * Math.acos( q.w );

		const s = Math.sqrt( 1 - q.w * q.w );

		if ( s < 0.0001 ) {

			this.x = 1;
			this.y = 0;
			this.z = 0;

		} else {

			this.x = q.x / s;
			this.y = q.y / s;
			this.z = q.z / s;

		}

		return this;

	}

	setAxisAngleFromRotationMatrix( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		let angle, x, y, z; // variables for result
		const epsilon = 0.01,		// margin to allow for rounding errors
			epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

			te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
		     ( Math.abs( m13 - m31 ) < epsilon ) &&
		     ( Math.abs( m23 - m32 ) < epsilon ) ) {

			// singularity found
			// first check for identity matrix which must have +1 for all terms
			// in leading diagonal and zero in other terms

			if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
			     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
			     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
			     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

				// this singularity is identity matrix so angle = 0

				this.set( 1, 0, 0, 0 );

				return this; // zero angle, arbitrary axis

			}

			// otherwise this singularity is angle = 180

			angle = Math.PI;

			const xx = ( m11 + 1 ) / 2;
			const yy = ( m22 + 1 ) / 2;
			const zz = ( m33 + 1 ) / 2;
			const xy = ( m12 + m21 ) / 4;
			const xz = ( m13 + m31 ) / 4;
			const yz = ( m23 + m32 ) / 4;

			if ( ( xx > yy ) && ( xx > zz ) ) {

				// m11 is the largest diagonal term

				if ( xx < epsilon ) {

					x = 0;
					y = 0.707106781;
					z = 0.707106781;

				} else {

					x = Math.sqrt( xx );
					y = xy / x;
					z = xz / x;

				}

			} else if ( yy > zz ) {

				// m22 is the largest diagonal term

				if ( yy < epsilon ) {

					x = 0.707106781;
					y = 0;
					z = 0.707106781;

				} else {

					y = Math.sqrt( yy );
					x = xy / y;
					z = yz / y;

				}

			} else {

				// m33 is the largest diagonal term so base result on this

				if ( zz < epsilon ) {

					x = 0.707106781;
					y = 0.707106781;
					z = 0;

				} else {

					z = Math.sqrt( zz );
					x = xz / z;
					y = yz / z;

				}

			}

			this.set( x, y, z, angle );

			return this; // return 180 deg rotation

		}

		// as we have reached here there are no singularities so we can handle normally

		let s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
			( m13 - m31 ) * ( m13 - m31 ) +
			( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

		if ( Math.abs( s ) < 0.001 ) s = 1;

		// prevent divide by zero, should not happen if matrix is orthogonal and should be
		// caught by singularity test above, but I've left it in just in case

		this.x = ( m32 - m23 ) / s;
		this.y = ( m13 - m31 ) / s;
		this.z = ( m21 - m12 ) / s;
		this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

		return this;

	}

	setFromMatrixPosition( m ) {

		const e = m.elements;

		this.x = e[ 12 ];
		this.y = e[ 13 ];
		this.z = e[ 14 ];
		this.w = e[ 15 ];

		return this;

	}

	min( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );
		this.w = Math.min( this.w, v.w );

		return this;

	}

	max( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );
		this.w = Math.max( this.w, v.w );

		return this;

	}

	clamp( min, max ) {

		// assumes min < max, componentwise

		this.x = clamp$1( this.x, min.x, max.x );
		this.y = clamp$1( this.y, min.y, max.y );
		this.z = clamp$1( this.z, min.z, max.z );
		this.w = clamp$1( this.w, min.w, max.w );

		return this;

	}

	clampScalar( minVal, maxVal ) {

		this.x = clamp$1( this.x, minVal, maxVal );
		this.y = clamp$1( this.y, minVal, maxVal );
		this.z = clamp$1( this.z, minVal, maxVal );
		this.w = clamp$1( this.w, minVal, maxVal );

		return this;

	}

	clampLength( min, max ) {

		const length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( clamp$1( length, min, max ) );

	}

	floor() {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );
		this.w = Math.floor( this.w );

		return this;

	}

	ceil() {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );
		this.w = Math.ceil( this.w );

		return this;

	}

	round() {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );
		this.w = Math.round( this.w );

		return this;

	}

	roundToZero() {

		this.x = Math.trunc( this.x );
		this.y = Math.trunc( this.y );
		this.z = Math.trunc( this.z );
		this.w = Math.trunc( this.w );

		return this;

	}

	negate() {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;
		this.w = - this.w;

		return this;

	}

	dot( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

	}

	lengthSq() {

		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

	}

	length() {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

	}

	manhattanLength() {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

	}

	normalize() {

		return this.divideScalar( this.length() || 1 );

	}

	setLength( length ) {

		return this.normalize().multiplyScalar( length );

	}

	lerp( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;
		this.w += ( v.w - this.w ) * alpha;

		return this;

	}

	lerpVectors( v1, v2, alpha ) {

		this.x = v1.x + ( v2.x - v1.x ) * alpha;
		this.y = v1.y + ( v2.y - v1.y ) * alpha;
		this.z = v1.z + ( v2.z - v1.z ) * alpha;
		this.w = v1.w + ( v2.w - v1.w ) * alpha;

		return this;

	}

	equals( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

	}

	fromArray( array, offset = 0 ) {

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];
		this.w = array[ offset + 3 ];

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;
		array[ offset + 3 ] = this.w;

		return array;

	}

	fromBufferAttribute( attribute, index ) {

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );
		this.z = attribute.getZ( index );
		this.w = attribute.getW( index );

		return this;

	}

	random() {

		this.x = Math.random();
		this.y = Math.random();
		this.z = Math.random();
		this.w = Math.random();

		return this;

	}

	*[ Symbol.iterator ]() {

		yield this.x;
		yield this.y;
		yield this.z;
		yield this.w;

	}

}

/*
 In options, we can specify:
 * Texture parameters for an auto-generated target texture
 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
*/
class RenderTarget extends EventDispatcher {

	constructor( width = 1, height = 1, options = {} ) {

		super();

		this.isRenderTarget = true;

		this.width = width;
		this.height = height;
		this.depth = 1;

		this.scissor = new Vector4( 0, 0, width, height );
		this.scissorTest = false;

		this.viewport = new Vector4( 0, 0, width, height );

		const image = { width: width, height: height, depth: 1 };

		options = Object.assign( {
			generateMipmaps: false,
			internalFormat: null,
			minFilter: LinearFilter,
			depthBuffer: true,
			stencilBuffer: false,
			resolveDepthBuffer: true,
			resolveStencilBuffer: true,
			depthTexture: null,
			samples: 0,
			count: 1
		}, options );

		const texture = new Texture( image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace );

		texture.flipY = false;
		texture.generateMipmaps = options.generateMipmaps;
		texture.internalFormat = options.internalFormat;

		this.textures = [];

		const count = options.count;
		for ( let i = 0; i < count; i ++ ) {

			this.textures[ i ] = texture.clone();
			this.textures[ i ].isRenderTargetTexture = true;

		}

		this.depthBuffer = options.depthBuffer;
		this.stencilBuffer = options.stencilBuffer;

		this.resolveDepthBuffer = options.resolveDepthBuffer;
		this.resolveStencilBuffer = options.resolveStencilBuffer;

		this.depthTexture = options.depthTexture;

		this.samples = options.samples;

	}

	get texture() {

		return this.textures[ 0 ];

	}

	set texture( value ) {

		this.textures[ 0 ] = value;

	}

	setSize( width, height, depth = 1 ) {

		if ( this.width !== width || this.height !== height || this.depth !== depth ) {

			this.width = width;
			this.height = height;
			this.depth = depth;

			for ( let i = 0, il = this.textures.length; i < il; i ++ ) {

				this.textures[ i ].image.width = width;
				this.textures[ i ].image.height = height;
				this.textures[ i ].image.depth = depth;

			}

			this.dispose();

		}

		this.viewport.set( 0, 0, width, height );
		this.scissor.set( 0, 0, width, height );

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( source ) {

		this.width = source.width;
		this.height = source.height;
		this.depth = source.depth;

		this.scissor.copy( source.scissor );
		this.scissorTest = source.scissorTest;

		this.viewport.copy( source.viewport );

		this.textures.length = 0;

		for ( let i = 0, il = source.textures.length; i < il; i ++ ) {

			this.textures[ i ] = source.textures[ i ].clone();
			this.textures[ i ].isRenderTargetTexture = true;

		}

		// ensure image object is not shared, see #20328

		const image = Object.assign( {}, source.texture.image );
		this.texture.source = new Source( image );

		this.depthBuffer = source.depthBuffer;
		this.stencilBuffer = source.stencilBuffer;

		this.resolveDepthBuffer = source.resolveDepthBuffer;
		this.resolveStencilBuffer = source.resolveStencilBuffer;

		if ( source.depthTexture !== null ) this.depthTexture = source.depthTexture.clone();

		this.samples = source.samples;

		return this;

	}

	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

	}

}

class WebGLRenderTarget extends RenderTarget {

	constructor( width = 1, height = 1, options = {} ) {

		super( width, height, options );

		this.isWebGLRenderTarget = true;

	}

}

class DataArrayTexture extends Texture {

	constructor( data = null, width = 1, height = 1, depth = 1 ) {

		super( null );

		this.isDataArrayTexture = true;

		this.image = { data, width, height, depth };

		this.magFilter = NearestFilter;
		this.minFilter = NearestFilter;

		this.wrapR = ClampToEdgeWrapping;

		this.generateMipmaps = false;
		this.flipY = false;
		this.unpackAlignment = 1;

		this.layerUpdates = new Set();

	}

	addLayerUpdate( layerIndex ) {

		this.layerUpdates.add( layerIndex );

	}

	clearLayerUpdates() {

		this.layerUpdates.clear();

	}

}

class Quaternion {

	constructor( x = 0, y = 0, z = 0, w = 1 ) {

		this.isQuaternion = true;

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

	}

	static slerpFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

		// fuzz-free, array-based Quaternion SLERP operation

		let x0 = src0[ srcOffset0 + 0 ],
			y0 = src0[ srcOffset0 + 1 ],
			z0 = src0[ srcOffset0 + 2 ],
			w0 = src0[ srcOffset0 + 3 ];

		const x1 = src1[ srcOffset1 + 0 ],
			y1 = src1[ srcOffset1 + 1 ],
			z1 = src1[ srcOffset1 + 2 ],
			w1 = src1[ srcOffset1 + 3 ];

		if ( t === 0 ) {

			dst[ dstOffset + 0 ] = x0;
			dst[ dstOffset + 1 ] = y0;
			dst[ dstOffset + 2 ] = z0;
			dst[ dstOffset + 3 ] = w0;
			return;

		}

		if ( t === 1 ) {

			dst[ dstOffset + 0 ] = x1;
			dst[ dstOffset + 1 ] = y1;
			dst[ dstOffset + 2 ] = z1;
			dst[ dstOffset + 3 ] = w1;
			return;

		}

		if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

			let s = 1 - t;
			const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
				dir = ( cos >= 0 ? 1 : -1 ),
				sqrSin = 1 - cos * cos;

			// Skip the Slerp for tiny steps to avoid numeric problems:
			if ( sqrSin > Number.EPSILON ) {

				const sin = Math.sqrt( sqrSin ),
					len = Math.atan2( sin, cos * dir );

				s = Math.sin( s * len ) / sin;
				t = Math.sin( t * len ) / sin;

			}

			const tDir = t * dir;

			x0 = x0 * s + x1 * tDir;
			y0 = y0 * s + y1 * tDir;
			z0 = z0 * s + z1 * tDir;
			w0 = w0 * s + w1 * tDir;

			// Normalize in case we just did a lerp:
			if ( s === 1 - t ) {

				const f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

				x0 *= f;
				y0 *= f;
				z0 *= f;
				w0 *= f;

			}

		}

		dst[ dstOffset ] = x0;
		dst[ dstOffset + 1 ] = y0;
		dst[ dstOffset + 2 ] = z0;
		dst[ dstOffset + 3 ] = w0;

	}

	static multiplyQuaternionsFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1 ) {

		const x0 = src0[ srcOffset0 ];
		const y0 = src0[ srcOffset0 + 1 ];
		const z0 = src0[ srcOffset0 + 2 ];
		const w0 = src0[ srcOffset0 + 3 ];

		const x1 = src1[ srcOffset1 ];
		const y1 = src1[ srcOffset1 + 1 ];
		const z1 = src1[ srcOffset1 + 2 ];
		const w1 = src1[ srcOffset1 + 3 ];

		dst[ dstOffset ] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
		dst[ dstOffset + 1 ] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
		dst[ dstOffset + 2 ] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
		dst[ dstOffset + 3 ] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;

		return dst;

	}

	get x() {

		return this._x;

	}

	set x( value ) {

		this._x = value;
		this._onChangeCallback();

	}

	get y() {

		return this._y;

	}

	set y( value ) {

		this._y = value;
		this._onChangeCallback();

	}

	get z() {

		return this._z;

	}

	set z( value ) {

		this._z = value;
		this._onChangeCallback();

	}

	get w() {

		return this._w;

	}

	set w( value ) {

		this._w = value;
		this._onChangeCallback();

	}

	set( x, y, z, w ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

		this._onChangeCallback();

		return this;

	}

	clone() {

		return new this.constructor( this._x, this._y, this._z, this._w );

	}

	copy( quaternion ) {

		this._x = quaternion.x;
		this._y = quaternion.y;
		this._z = quaternion.z;
		this._w = quaternion.w;

		this._onChangeCallback();

		return this;

	}

	setFromEuler( euler, update = true ) {

		const x = euler._x, y = euler._y, z = euler._z, order = euler._order;

		// http://www.mathworks.com/matlabcentral/fileexchange/
		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
		//	content/SpinCalc.m

		const cos = Math.cos;
		const sin = Math.sin;

		const c1 = cos( x / 2 );
		const c2 = cos( y / 2 );
		const c3 = cos( z / 2 );

		const s1 = sin( x / 2 );
		const s2 = sin( y / 2 );
		const s3 = sin( z / 2 );

		switch ( order ) {

			case 'XYZ':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'YXZ':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			case 'ZXY':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'ZYX':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			case 'YZX':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'XZY':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			default:
				console.warn( 'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order );

		}

		if ( update === true ) this._onChangeCallback();

		return this;

	}

	setFromAxisAngle( axis, angle ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

		// assumes axis is normalized

		const halfAngle = angle / 2, s = Math.sin( halfAngle );

		this._x = axis.x * s;
		this._y = axis.y * s;
		this._z = axis.z * s;
		this._w = Math.cos( halfAngle );

		this._onChangeCallback();

		return this;

	}

	setFromRotationMatrix( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		const te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

			trace = m11 + m22 + m33;

		if ( trace > 0 ) {

			const s = 0.5 / Math.sqrt( trace + 1.0 );

			this._w = 0.25 / s;
			this._x = ( m32 - m23 ) * s;
			this._y = ( m13 - m31 ) * s;
			this._z = ( m21 - m12 ) * s;

		} else if ( m11 > m22 && m11 > m33 ) {

			const s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

			this._w = ( m32 - m23 ) / s;
			this._x = 0.25 * s;
			this._y = ( m12 + m21 ) / s;
			this._z = ( m13 + m31 ) / s;

		} else if ( m22 > m33 ) {

			const s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

			this._w = ( m13 - m31 ) / s;
			this._x = ( m12 + m21 ) / s;
			this._y = 0.25 * s;
			this._z = ( m23 + m32 ) / s;

		} else {

			const s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

			this._w = ( m21 - m12 ) / s;
			this._x = ( m13 + m31 ) / s;
			this._y = ( m23 + m32 ) / s;
			this._z = 0.25 * s;

		}

		this._onChangeCallback();

		return this;

	}

	setFromUnitVectors( vFrom, vTo ) {

		// assumes direction vectors vFrom and vTo are normalized

		let r = vFrom.dot( vTo ) + 1;

		if ( r < Number.EPSILON ) {

			// vFrom and vTo point in opposite directions

			r = 0;

			if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

				this._x = - vFrom.y;
				this._y = vFrom.x;
				this._z = 0;
				this._w = r;

			} else {

				this._x = 0;
				this._y = - vFrom.z;
				this._z = vFrom.y;
				this._w = r;

			}

		} else {

			// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

			this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
			this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
			this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
			this._w = r;

		}

		return this.normalize();

	}

	angleTo( q ) {

		return 2 * Math.acos( Math.abs( clamp$1( this.dot( q ), -1, 1 ) ) );

	}

	rotateTowards( q, step ) {

		const angle = this.angleTo( q );

		if ( angle === 0 ) return this;

		const t = Math.min( 1, step / angle );

		this.slerp( q, t );

		return this;

	}

	identity() {

		return this.set( 0, 0, 0, 1 );

	}

	invert() {

		// quaternion is assumed to have unit length

		return this.conjugate();

	}

	conjugate() {

		this._x *= -1;
		this._y *= -1;
		this._z *= -1;

		this._onChangeCallback();

		return this;

	}

	dot( v ) {

		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

	}

	lengthSq() {

		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

	}

	length() {

		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

	}

	normalize() {

		let l = this.length();

		if ( l === 0 ) {

			this._x = 0;
			this._y = 0;
			this._z = 0;
			this._w = 1;

		} else {

			l = 1 / l;

			this._x = this._x * l;
			this._y = this._y * l;
			this._z = this._z * l;
			this._w = this._w * l;

		}

		this._onChangeCallback();

		return this;

	}

	multiply( q ) {

		return this.multiplyQuaternions( this, q );

	}

	premultiply( q ) {

		return this.multiplyQuaternions( q, this );

	}

	multiplyQuaternions( a, b ) {

		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

		const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
		const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

		this._onChangeCallback();

		return this;

	}

	slerp( qb, t ) {

		if ( t === 0 ) return this;
		if ( t === 1 ) return this.copy( qb );

		const x = this._x, y = this._y, z = this._z, w = this._w;

		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

		let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

		if ( cosHalfTheta < 0 ) {

			this._w = - qb._w;
			this._x = - qb._x;
			this._y = - qb._y;
			this._z = - qb._z;

			cosHalfTheta = - cosHalfTheta;

		} else {

			this.copy( qb );

		}

		if ( cosHalfTheta >= 1.0 ) {

			this._w = w;
			this._x = x;
			this._y = y;
			this._z = z;

			return this;

		}

		const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

		if ( sqrSinHalfTheta <= Number.EPSILON ) {

			const s = 1 - t;
			this._w = s * w + t * this._w;
			this._x = s * x + t * this._x;
			this._y = s * y + t * this._y;
			this._z = s * z + t * this._z;

			this.normalize(); // normalize calls _onChangeCallback()

			return this;

		}

		const sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
		const halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
		const ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
			ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

		this._w = ( w * ratioA + this._w * ratioB );
		this._x = ( x * ratioA + this._x * ratioB );
		this._y = ( y * ratioA + this._y * ratioB );
		this._z = ( z * ratioA + this._z * ratioB );

		this._onChangeCallback();

		return this;

	}

	slerpQuaternions( qa, qb, t ) {

		return this.copy( qa ).slerp( qb, t );

	}

	random() {

		// sets this quaternion to a uniform random unit quaternnion

		// Ken Shoemake
		// Uniform random rotations
		// D. Kirk, editor, Graphics Gems III, pages 124-132. Academic Press, New York, 1992.

		const theta1 = 2 * Math.PI * Math.random();
		const theta2 = 2 * Math.PI * Math.random();

		const x0 = Math.random();
		const r1 = Math.sqrt( 1 - x0 );
		const r2 = Math.sqrt( x0 );

		return this.set(
			r1 * Math.sin( theta1 ),
			r1 * Math.cos( theta1 ),
			r2 * Math.sin( theta2 ),
			r2 * Math.cos( theta2 ),
		);

	}

	equals( quaternion ) {

		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

	}

	fromArray( array, offset = 0 ) {

		this._x = array[ offset ];
		this._y = array[ offset + 1 ];
		this._z = array[ offset + 2 ];
		this._w = array[ offset + 3 ];

		this._onChangeCallback();

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._w;

		return array;

	}

	fromBufferAttribute( attribute, index ) {

		this._x = attribute.getX( index );
		this._y = attribute.getY( index );
		this._z = attribute.getZ( index );
		this._w = attribute.getW( index );

		this._onChangeCallback();

		return this;

	}

	toJSON() {

		return this.toArray();

	}

	_onChange( callback ) {

		this._onChangeCallback = callback;

		return this;

	}

	_onChangeCallback() {}

	*[ Symbol.iterator ]() {

		yield this._x;
		yield this._y;
		yield this._z;
		yield this._w;

	}

}

class Vector3 {

	constructor( x = 0, y = 0, z = 0 ) {

		Vector3.prototype.isVector3 = true;

		this.x = x;
		this.y = y;
		this.z = z;

	}

	set( x, y, z ) {

		if ( z === undefined ) z = this.z; // sprite.scale.set(x,y)

		this.x = x;
		this.y = y;
		this.z = z;

		return this;

	}

	setScalar( scalar ) {

		this.x = scalar;
		this.y = scalar;
		this.z = scalar;

		return this;

	}

	setX( x ) {

		this.x = x;

		return this;

	}

	setY( y ) {

		this.y = y;

		return this;

	}

	setZ( z ) {

		this.z = z;

		return this;

	}

	setComponent( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	}

	getComponent( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			default: throw new Error( 'index is out of range: ' + index );

		}

	}

	clone() {

		return new this.constructor( this.x, this.y, this.z );

	}

	copy( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;

		return this;

	}

	add( v ) {

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;

		return this;

	}

	addScalar( s ) {

		this.x += s;
		this.y += s;
		this.z += s;

		return this;

	}

	addVectors( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;

		return this;

	}

	addScaledVector( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;

		return this;

	}

	sub( v ) {

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;

		return this;

	}

	subScalar( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;

		return this;

	}

	subVectors( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;

		return this;

	}

	multiply( v ) {

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;

		return this;

	}

	multiplyScalar( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;

		return this;

	}

	multiplyVectors( a, b ) {

		this.x = a.x * b.x;
		this.y = a.y * b.y;
		this.z = a.z * b.z;

		return this;

	}

	applyEuler( euler ) {

		return this.applyQuaternion( _quaternion$4.setFromEuler( euler ) );

	}

	applyAxisAngle( axis, angle ) {

		return this.applyQuaternion( _quaternion$4.setFromAxisAngle( axis, angle ) );

	}

	applyMatrix3( m ) {

		const x = this.x, y = this.y, z = this.z;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

		return this;

	}

	applyNormalMatrix( m ) {

		return this.applyMatrix3( m ).normalize();

	}

	applyMatrix4( m ) {

		const x = this.x, y = this.y, z = this.z;
		const e = m.elements;

		const w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

		return this;

	}

	applyQuaternion( q ) {

		// quaternion q is assumed to have unit length

		const vx = this.x, vy = this.y, vz = this.z;
		const qx = q.x, qy = q.y, qz = q.z, qw = q.w;

		// t = 2 * cross( q.xyz, v );
		const tx = 2 * ( qy * vz - qz * vy );
		const ty = 2 * ( qz * vx - qx * vz );
		const tz = 2 * ( qx * vy - qy * vx );

		// v + q.w * t + cross( q.xyz, t );
		this.x = vx + qw * tx + qy * tz - qz * ty;
		this.y = vy + qw * ty + qz * tx - qx * tz;
		this.z = vz + qw * tz + qx * ty - qy * tx;

		return this;

	}

	project( camera ) {

		return this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );

	}

	unproject( camera ) {

		return this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );

	}

	transformDirection( m ) {

		// input: THREE.Matrix4 affine matrix
		// vector interpreted as a direction

		const x = this.x, y = this.y, z = this.z;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

		return this.normalize();

	}

	divide( v ) {

		this.x /= v.x;
		this.y /= v.y;
		this.z /= v.z;

		return this;

	}

	divideScalar( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	}

	min( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );

		return this;

	}

	max( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );

		return this;

	}

	clamp( min, max ) {

		// assumes min < max, componentwise

		this.x = clamp$1( this.x, min.x, max.x );
		this.y = clamp$1( this.y, min.y, max.y );
		this.z = clamp$1( this.z, min.z, max.z );

		return this;

	}

	clampScalar( minVal, maxVal ) {

		this.x = clamp$1( this.x, minVal, maxVal );
		this.y = clamp$1( this.y, minVal, maxVal );
		this.z = clamp$1( this.z, minVal, maxVal );

		return this;

	}

	clampLength( min, max ) {

		const length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( clamp$1( length, min, max ) );

	}

	floor() {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );

		return this;

	}

	ceil() {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );

		return this;

	}

	round() {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );

		return this;

	}

	roundToZero() {

		this.x = Math.trunc( this.x );
		this.y = Math.trunc( this.y );
		this.z = Math.trunc( this.z );

		return this;

	}

	negate() {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;

		return this;

	}

	dot( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z;

	}

	// TODO lengthSquared?

	lengthSq() {

		return this.x * this.x + this.y * this.y + this.z * this.z;

	}

	length() {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

	}

	manhattanLength() {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

	}

	normalize() {

		return this.divideScalar( this.length() || 1 );

	}

	setLength( length ) {

		return this.normalize().multiplyScalar( length );

	}

	lerp( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;

		return this;

	}

	lerpVectors( v1, v2, alpha ) {

		this.x = v1.x + ( v2.x - v1.x ) * alpha;
		this.y = v1.y + ( v2.y - v1.y ) * alpha;
		this.z = v1.z + ( v2.z - v1.z ) * alpha;

		return this;

	}

	cross( v ) {

		return this.crossVectors( this, v );

	}

	crossVectors( a, b ) {

		const ax = a.x, ay = a.y, az = a.z;
		const bx = b.x, by = b.y, bz = b.z;

		this.x = ay * bz - az * by;
		this.y = az * bx - ax * bz;
		this.z = ax * by - ay * bx;

		return this;

	}

	projectOnVector( v ) {

		const denominator = v.lengthSq();

		if ( denominator === 0 ) return this.set( 0, 0, 0 );

		const scalar = v.dot( this ) / denominator;

		return this.copy( v ).multiplyScalar( scalar );

	}

	projectOnPlane( planeNormal ) {

		_vector$c.copy( this ).projectOnVector( planeNormal );

		return this.sub( _vector$c );

	}

	reflect( normal ) {

		// reflect incident vector off plane orthogonal to normal
		// normal is assumed to have unit length

		return this.sub( _vector$c.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

	}

	angleTo( v ) {

		const denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );

		if ( denominator === 0 ) return Math.PI / 2;

		const theta = this.dot( v ) / denominator;

		// clamp, to handle numerical problems

		return Math.acos( clamp$1( theta, -1, 1 ) );

	}

	distanceTo( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	}

	distanceToSquared( v ) {

		const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

		return dx * dx + dy * dy + dz * dz;

	}

	manhattanDistanceTo( v ) {

		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

	}

	setFromSpherical( s ) {

		return this.setFromSphericalCoords( s.radius, s.phi, s.theta );

	}

	setFromSphericalCoords( radius, phi, theta ) {

		const sinPhiRadius = Math.sin( phi ) * radius;

		this.x = sinPhiRadius * Math.sin( theta );
		this.y = Math.cos( phi ) * radius;
		this.z = sinPhiRadius * Math.cos( theta );

		return this;

	}

	setFromCylindrical( c ) {

		return this.setFromCylindricalCoords( c.radius, c.theta, c.y );

	}

	setFromCylindricalCoords( radius, theta, y ) {

		this.x = radius * Math.sin( theta );
		this.y = y;
		this.z = radius * Math.cos( theta );

		return this;

	}

	setFromMatrixPosition( m ) {

		const e = m.elements;

		this.x = e[ 12 ];
		this.y = e[ 13 ];
		this.z = e[ 14 ];

		return this;

	}

	setFromMatrixScale( m ) {

		const sx = this.setFromMatrixColumn( m, 0 ).length();
		const sy = this.setFromMatrixColumn( m, 1 ).length();
		const sz = this.setFromMatrixColumn( m, 2 ).length();

		this.x = sx;
		this.y = sy;
		this.z = sz;

		return this;

	}

	setFromMatrixColumn( m, index ) {

		return this.fromArray( m.elements, index * 4 );

	}

	setFromMatrix3Column( m, index ) {

		return this.fromArray( m.elements, index * 3 );

	}

	setFromEuler( e ) {

		this.x = e._x;
		this.y = e._y;
		this.z = e._z;

		return this;

	}

	setFromColor( c ) {

		this.x = c.r;
		this.y = c.g;
		this.z = c.b;

		return this;

	}

	equals( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

	}

	fromArray( array, offset = 0 ) {

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;

		return array;

	}

	fromBufferAttribute( attribute, index ) {

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );
		this.z = attribute.getZ( index );

		return this;

	}

	random() {

		this.x = Math.random();
		this.y = Math.random();
		this.z = Math.random();

		return this;

	}

	randomDirection() {

		// https://mathworld.wolfram.com/SpherePointPicking.html

		const theta = Math.random() * Math.PI * 2;
		const u = Math.random() * 2 - 1;
		const c = Math.sqrt( 1 - u * u );

		this.x = c * Math.cos( theta );
		this.y = u;
		this.z = c * Math.sin( theta );

		return this;

	}

	*[ Symbol.iterator ]() {

		yield this.x;
		yield this.y;
		yield this.z;

	}

}

const _vector$c = /*@__PURE__*/ new Vector3();
const _quaternion$4 = /*@__PURE__*/ new Quaternion();

class Box3 {

	constructor( min = new Vector3( + Infinity, + Infinity, + Infinity ), max = new Vector3( - Infinity, - Infinity, - Infinity ) ) {

		this.isBox3 = true;

		this.min = min;
		this.max = max;

	}

	set( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	}

	setFromArray( array ) {

		this.makeEmpty();

		for ( let i = 0, il = array.length; i < il; i += 3 ) {

			this.expandByPoint( _vector$b.fromArray( array, i ) );

		}

		return this;

	}

	setFromBufferAttribute( attribute ) {

		this.makeEmpty();

		for ( let i = 0, il = attribute.count; i < il; i ++ ) {

			this.expandByPoint( _vector$b.fromBufferAttribute( attribute, i ) );

		}

		return this;

	}

	setFromPoints( points ) {

		this.makeEmpty();

		for ( let i = 0, il = points.length; i < il; i ++ ) {

			this.expandByPoint( points[ i ] );

		}

		return this;

	}

	setFromCenterAndSize( center, size ) {

		const halfSize = _vector$b.copy( size ).multiplyScalar( 0.5 );

		this.min.copy( center ).sub( halfSize );
		this.max.copy( center ).add( halfSize );

		return this;

	}

	setFromObject( object, precise = false ) {

		this.makeEmpty();

		return this.expandByObject( object, precise );

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	}

	makeEmpty() {

		this.min.x = this.min.y = this.min.z = + Infinity;
		this.max.x = this.max.y = this.max.z = - Infinity;

		return this;

	}

	isEmpty() {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

	}

	getCenter( target ) {

		return this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	}

	getSize( target ) {

		return this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );

	}

	expandByPoint( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;

	}

	expandByVector( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;

	}

	expandByScalar( scalar ) {

		this.min.addScalar( - scalar );
		this.max.addScalar( scalar );

		return this;

	}

	expandByObject( object, precise = false ) {

		// Computes the world-axis-aligned bounding box of an object (including its children),
		// accounting for both the object's, and children's, world transforms

		object.updateWorldMatrix( false, false );

		const geometry = object.geometry;

		if ( geometry !== undefined ) {

			const positionAttribute = geometry.getAttribute( 'position' );

			// precise AABB computation based on vertex data requires at least a position attribute.
			// instancing isn't supported so far and uses the normal (conservative) code path.

			if ( precise === true && positionAttribute !== undefined && object.isInstancedMesh !== true ) {

				for ( let i = 0, l = positionAttribute.count; i < l; i ++ ) {

					if ( object.isMesh === true ) {

						object.getVertexPosition( i, _vector$b );

					} else {

						_vector$b.fromBufferAttribute( positionAttribute, i );

					}

					_vector$b.applyMatrix4( object.matrixWorld );
					this.expandByPoint( _vector$b );

				}

			} else {

				if ( object.boundingBox !== undefined ) {

					// object-level bounding box

					if ( object.boundingBox === null ) {

						object.computeBoundingBox();

					}

					_box$4.copy( object.boundingBox );


				} else {

					// geometry-level bounding box

					if ( geometry.boundingBox === null ) {

						geometry.computeBoundingBox();

					}

					_box$4.copy( geometry.boundingBox );

				}

				_box$4.applyMatrix4( object.matrixWorld );

				this.union( _box$4 );

			}

		}

		const children = object.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			this.expandByObject( children[ i ], precise );

		}

		return this;

	}

	containsPoint( point ) {

		return point.x >= this.min.x && point.x <= this.max.x &&
			point.y >= this.min.y && point.y <= this.max.y &&
			point.z >= this.min.z && point.z <= this.max.z;

	}

	containsBox( box ) {

		return this.min.x <= box.min.x && box.max.x <= this.max.x &&
			this.min.y <= box.min.y && box.max.y <= this.max.y &&
			this.min.z <= box.min.z && box.max.z <= this.max.z;

	}

	getParameter( point, target ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		return target.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y ),
			( point.z - this.min.z ) / ( this.max.z - this.min.z )
		);

	}

	intersectsBox( box ) {

		// using 6 splitting planes to rule out intersections.
		return box.max.x >= this.min.x && box.min.x <= this.max.x &&
			box.max.y >= this.min.y && box.min.y <= this.max.y &&
			box.max.z >= this.min.z && box.min.z <= this.max.z;

	}

	intersectsSphere( sphere ) {

		// Find the point on the AABB closest to the sphere center.
		this.clampPoint( sphere.center, _vector$b );

		// If that point is inside the sphere, the AABB and sphere intersect.
		return _vector$b.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

	}

	intersectsPlane( plane ) {

		// We compute the minimum and maximum dot product values. If those values
		// are on the same side (back or front) of the plane, then there is no intersection.

		let min, max;

		if ( plane.normal.x > 0 ) {

			min = plane.normal.x * this.min.x;
			max = plane.normal.x * this.max.x;

		} else {

			min = plane.normal.x * this.max.x;
			max = plane.normal.x * this.min.x;

		}

		if ( plane.normal.y > 0 ) {

			min += plane.normal.y * this.min.y;
			max += plane.normal.y * this.max.y;

		} else {

			min += plane.normal.y * this.max.y;
			max += plane.normal.y * this.min.y;

		}

		if ( plane.normal.z > 0 ) {

			min += plane.normal.z * this.min.z;
			max += plane.normal.z * this.max.z;

		} else {

			min += plane.normal.z * this.max.z;
			max += plane.normal.z * this.min.z;

		}

		return ( min <= - plane.constant && max >= - plane.constant );

	}

	intersectsTriangle( triangle ) {

		if ( this.isEmpty() ) {

			return false;

		}

		// compute box center and extents
		this.getCenter( _center );
		_extents.subVectors( this.max, _center );

		// translate triangle to aabb origin
		_v0$2.subVectors( triangle.a, _center );
		_v1$7.subVectors( triangle.b, _center );
		_v2$4.subVectors( triangle.c, _center );

		// compute edge vectors for triangle
		_f0.subVectors( _v1$7, _v0$2 );
		_f1.subVectors( _v2$4, _v1$7 );
		_f2.subVectors( _v0$2, _v2$4 );

		// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
		// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
		// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
		let axes = [
			0, - _f0.z, _f0.y, 0, - _f1.z, _f1.y, 0, - _f2.z, _f2.y,
			_f0.z, 0, - _f0.x, _f1.z, 0, - _f1.x, _f2.z, 0, - _f2.x,
			- _f0.y, _f0.x, 0, - _f1.y, _f1.x, 0, - _f2.y, _f2.x, 0
		];
		if ( ! satForAxes( axes, _v0$2, _v1$7, _v2$4, _extents ) ) {

			return false;

		}

		// test 3 face normals from the aabb
		axes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];
		if ( ! satForAxes( axes, _v0$2, _v1$7, _v2$4, _extents ) ) {

			return false;

		}

		// finally testing the face normal of the triangle
		// use already existing triangle edge vectors here
		_triangleNormal.crossVectors( _f0, _f1 );
		axes = [ _triangleNormal.x, _triangleNormal.y, _triangleNormal.z ];

		return satForAxes( axes, _v0$2, _v1$7, _v2$4, _extents );

	}

	clampPoint( point, target ) {

		return target.copy( point ).clamp( this.min, this.max );

	}

	distanceToPoint( point ) {

		return this.clampPoint( point, _vector$b ).distanceTo( point );

	}

	getBoundingSphere( target ) {

		if ( this.isEmpty() ) {

			target.makeEmpty();

		} else {

			this.getCenter( target.center );

			target.radius = this.getSize( _vector$b ).length() * 0.5;

		}

		return target;

	}

	intersect( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
		if ( this.isEmpty() ) this.makeEmpty();

		return this;

	}

	union( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	}

	applyMatrix4( matrix ) {

		// transform of empty box is an empty box.
		if ( this.isEmpty() ) return this;

		// NOTE: I am using a binary pattern to specify all 2^3 combinations below
		_points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
		_points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
		_points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
		_points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
		_points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
		_points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
		_points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
		_points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111

		this.setFromPoints( _points );

		return this;

	}

	translate( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	}

	equals( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	}

}

const _points = [
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3()
];

const _vector$b = /*@__PURE__*/ new Vector3();

const _box$4 = /*@__PURE__*/ new Box3();

// triangle centered vertices

const _v0$2 = /*@__PURE__*/ new Vector3();
const _v1$7 = /*@__PURE__*/ new Vector3();
const _v2$4 = /*@__PURE__*/ new Vector3();

// triangle edge vectors

const _f0 = /*@__PURE__*/ new Vector3();
const _f1 = /*@__PURE__*/ new Vector3();
const _f2 = /*@__PURE__*/ new Vector3();

const _center = /*@__PURE__*/ new Vector3();
const _extents = /*@__PURE__*/ new Vector3();
const _triangleNormal = /*@__PURE__*/ new Vector3();
const _testAxis = /*@__PURE__*/ new Vector3();

function satForAxes( axes, v0, v1, v2, extents ) {

	for ( let i = 0, j = axes.length - 3; i <= j; i += 3 ) {

		_testAxis.fromArray( axes, i );
		// project the aabb onto the separating axis
		const r = extents.x * Math.abs( _testAxis.x ) + extents.y * Math.abs( _testAxis.y ) + extents.z * Math.abs( _testAxis.z );
		// project all 3 vertices of the triangle onto the separating axis
		const p0 = v0.dot( _testAxis );
		const p1 = v1.dot( _testAxis );
		const p2 = v2.dot( _testAxis );
		// actual test, basically see if either of the most extreme of the triangle points intersects r
		if ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {

			// points of the projected triangle are outside the projected half-length of the aabb
			// the axis is separating and we can exit
			return false;

		}

	}

	return true;

}

const _box$3 = /*@__PURE__*/ new Box3();
const _v1$6 = /*@__PURE__*/ new Vector3();
const _v2$3 = /*@__PURE__*/ new Vector3();

class Sphere {

	constructor( center = new Vector3(), radius = -1 ) {

		this.isSphere = true;

		this.center = center;
		this.radius = radius;

	}

	set( center, radius ) {

		this.center.copy( center );
		this.radius = radius;

		return this;

	}

	setFromPoints( points, optionalCenter ) {

		const center = this.center;

		if ( optionalCenter !== undefined ) {

			center.copy( optionalCenter );

		} else {

			_box$3.setFromPoints( points ).getCenter( center );

		}

		let maxRadiusSq = 0;

		for ( let i = 0, il = points.length; i < il; i ++ ) {

			maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

		}

		this.radius = Math.sqrt( maxRadiusSq );

		return this;

	}

	copy( sphere ) {

		this.center.copy( sphere.center );
		this.radius = sphere.radius;

		return this;

	}

	isEmpty() {

		return ( this.radius < 0 );

	}

	makeEmpty() {

		this.center.set( 0, 0, 0 );
		this.radius = -1;

		return this;

	}

	containsPoint( point ) {

		return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

	}

	distanceToPoint( point ) {

		return ( point.distanceTo( this.center ) - this.radius );

	}

	intersectsSphere( sphere ) {

		const radiusSum = this.radius + sphere.radius;

		return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

	}

	intersectsBox( box ) {

		return box.intersectsSphere( this );

	}

	intersectsPlane( plane ) {

		return Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;

	}

	clampPoint( point, target ) {

		const deltaLengthSq = this.center.distanceToSquared( point );

		target.copy( point );

		if ( deltaLengthSq > ( this.radius * this.radius ) ) {

			target.sub( this.center ).normalize();
			target.multiplyScalar( this.radius ).add( this.center );

		}

		return target;

	}

	getBoundingBox( target ) {

		if ( this.isEmpty() ) {

			// Empty sphere produces empty bounding box
			target.makeEmpty();
			return target;

		}

		target.set( this.center, this.center );
		target.expandByScalar( this.radius );

		return target;

	}

	applyMatrix4( matrix ) {

		this.center.applyMatrix4( matrix );
		this.radius = this.radius * matrix.getMaxScaleOnAxis();

		return this;

	}

	translate( offset ) {

		this.center.add( offset );

		return this;

	}

	expandByPoint( point ) {

		if ( this.isEmpty() ) {

			this.center.copy( point );

			this.radius = 0;

			return this;

		}

		_v1$6.subVectors( point, this.center );

		const lengthSq = _v1$6.lengthSq();

		if ( lengthSq > ( this.radius * this.radius ) ) {

			// calculate the minimal sphere

			const length = Math.sqrt( lengthSq );

			const delta = ( length - this.radius ) * 0.5;

			this.center.addScaledVector( _v1$6, delta / length );

			this.radius += delta;

		}

		return this;

	}

	union( sphere ) {

		if ( sphere.isEmpty() ) {

			return this;

		}

		if ( this.isEmpty() ) {

			this.copy( sphere );

			return this;

		}

		if ( this.center.equals( sphere.center ) === true ) {

			 this.radius = Math.max( this.radius, sphere.radius );

		} else {

			_v2$3.subVectors( sphere.center, this.center ).setLength( sphere.radius );

			this.expandByPoint( _v1$6.copy( sphere.center ).add( _v2$3 ) );

			this.expandByPoint( _v1$6.copy( sphere.center ).sub( _v2$3 ) );

		}

		return this;

	}

	equals( sphere ) {

		return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

const _vector$a = /*@__PURE__*/ new Vector3();
const _segCenter = /*@__PURE__*/ new Vector3();
const _segDir = /*@__PURE__*/ new Vector3();
const _diff = /*@__PURE__*/ new Vector3();

const _edge1 = /*@__PURE__*/ new Vector3();
const _edge2 = /*@__PURE__*/ new Vector3();
const _normal$1 = /*@__PURE__*/ new Vector3();

class Ray {

	constructor( origin = new Vector3(), direction = new Vector3( 0, 0, -1 ) ) {

		this.origin = origin;
		this.direction = direction;

	}

	set( origin, direction ) {

		this.origin.copy( origin );
		this.direction.copy( direction );

		return this;

	}

	copy( ray ) {

		this.origin.copy( ray.origin );
		this.direction.copy( ray.direction );

		return this;

	}

	at( t, target ) {

		return target.copy( this.origin ).addScaledVector( this.direction, t );

	}

	lookAt( v ) {

		this.direction.copy( v ).sub( this.origin ).normalize();

		return this;

	}

	recast( t ) {

		this.origin.copy( this.at( t, _vector$a ) );

		return this;

	}

	closestPointToPoint( point, target ) {

		target.subVectors( point, this.origin );

		const directionDistance = target.dot( this.direction );

		if ( directionDistance < 0 ) {

			return target.copy( this.origin );

		}

		return target.copy( this.origin ).addScaledVector( this.direction, directionDistance );

	}

	distanceToPoint( point ) {

		return Math.sqrt( this.distanceSqToPoint( point ) );

	}

	distanceSqToPoint( point ) {

		const directionDistance = _vector$a.subVectors( point, this.origin ).dot( this.direction );

		// point behind the ray

		if ( directionDistance < 0 ) {

			return this.origin.distanceToSquared( point );

		}

		_vector$a.copy( this.origin ).addScaledVector( this.direction, directionDistance );

		return _vector$a.distanceToSquared( point );

	}

	distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

		// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteDistRaySegment.h
		// It returns the min distance between the ray and the segment
		// defined by v0 and v1
		// It can also set two optional targets :
		// - The closest point on the ray
		// - The closest point on the segment

		_segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
		_segDir.copy( v1 ).sub( v0 ).normalize();
		_diff.copy( this.origin ).sub( _segCenter );

		const segExtent = v0.distanceTo( v1 ) * 0.5;
		const a01 = - this.direction.dot( _segDir );
		const b0 = _diff.dot( this.direction );
		const b1 = - _diff.dot( _segDir );
		const c = _diff.lengthSq();
		const det = Math.abs( 1 - a01 * a01 );
		let s0, s1, sqrDist, extDet;

		if ( det > 0 ) {

			// The ray and segment are not parallel.

			s0 = a01 * b1 - b0;
			s1 = a01 * b0 - b1;
			extDet = segExtent * det;

			if ( s0 >= 0 ) {

				if ( s1 >= - extDet ) {

					if ( s1 <= extDet ) {

						// region 0
						// Minimum at interior points of ray and segment.

						const invDet = 1 / det;
						s0 *= invDet;
						s1 *= invDet;
						sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

					} else {

						// region 1

						s1 = segExtent;
						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				} else {

					// region 5

					s1 = - segExtent;
					s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

			} else {

				if ( s1 <= - extDet ) {

					// region 4

					s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
					s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				} else if ( s1 <= extDet ) {

					// region 3

					s0 = 0;
					s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = s1 * ( s1 + 2 * b1 ) + c;

				} else {

					// region 2

					s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
					s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

			}

		} else {

			// Ray and segment are parallel.

			s1 = ( a01 > 0 ) ? - segExtent : segExtent;
			s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
			sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

		}

		if ( optionalPointOnRay ) {

			optionalPointOnRay.copy( this.origin ).addScaledVector( this.direction, s0 );

		}

		if ( optionalPointOnSegment ) {

			optionalPointOnSegment.copy( _segCenter ).addScaledVector( _segDir, s1 );

		}

		return sqrDist;

	}

	intersectSphere( sphere, target ) {

		_vector$a.subVectors( sphere.center, this.origin );
		const tca = _vector$a.dot( this.direction );
		const d2 = _vector$a.dot( _vector$a ) - tca * tca;
		const radius2 = sphere.radius * sphere.radius;

		if ( d2 > radius2 ) return null;

		const thc = Math.sqrt( radius2 - d2 );

		// t0 = first intersect point - entrance on front of sphere
		const t0 = tca - thc;

		// t1 = second intersect point - exit point on back of sphere
		const t1 = tca + thc;

		// test to see if t1 is behind the ray - if so, return null
		if ( t1 < 0 ) return null;

		// test to see if t0 is behind the ray:
		// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
		// in order to always return an intersect point that is in front of the ray.
		if ( t0 < 0 ) return this.at( t1, target );

		// else t0 is in front of the ray, so return the first collision point scaled by t0
		return this.at( t0, target );

	}

	intersectsSphere( sphere ) {

		return this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );

	}

	distanceToPlane( plane ) {

		const denominator = plane.normal.dot( this.direction );

		if ( denominator === 0 ) {

			// line is coplanar, return origin
			if ( plane.distanceToPoint( this.origin ) === 0 ) {

				return 0;

			}

			// Null is preferable to undefined since undefined means.... it is undefined

			return null;

		}

		const t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

		// Return if the ray never intersects the plane

		return t >= 0 ? t : null;

	}

	intersectPlane( plane, target ) {

		const t = this.distanceToPlane( plane );

		if ( t === null ) {

			return null;

		}

		return this.at( t, target );

	}

	intersectsPlane( plane ) {

		// check if the ray lies on the plane first

		const distToPoint = plane.distanceToPoint( this.origin );

		if ( distToPoint === 0 ) {

			return true;

		}

		const denominator = plane.normal.dot( this.direction );

		if ( denominator * distToPoint < 0 ) {

			return true;

		}

		// ray origin is behind the plane (and is pointing behind it)

		return false;

	}

	intersectBox( box, target ) {

		let tmin, tmax, tymin, tymax, tzmin, tzmax;

		const invdirx = 1 / this.direction.x,
			invdiry = 1 / this.direction.y,
			invdirz = 1 / this.direction.z;

		const origin = this.origin;

		if ( invdirx >= 0 ) {

			tmin = ( box.min.x - origin.x ) * invdirx;
			tmax = ( box.max.x - origin.x ) * invdirx;

		} else {

			tmin = ( box.max.x - origin.x ) * invdirx;
			tmax = ( box.min.x - origin.x ) * invdirx;

		}

		if ( invdiry >= 0 ) {

			tymin = ( box.min.y - origin.y ) * invdiry;
			tymax = ( box.max.y - origin.y ) * invdiry;

		} else {

			tymin = ( box.max.y - origin.y ) * invdiry;
			tymax = ( box.min.y - origin.y ) * invdiry;

		}

		if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

		if ( tymin > tmin || isNaN( tmin ) ) tmin = tymin;

		if ( tymax < tmax || isNaN( tmax ) ) tmax = tymax;

		if ( invdirz >= 0 ) {

			tzmin = ( box.min.z - origin.z ) * invdirz;
			tzmax = ( box.max.z - origin.z ) * invdirz;

		} else {

			tzmin = ( box.max.z - origin.z ) * invdirz;
			tzmax = ( box.min.z - origin.z ) * invdirz;

		}

		if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

		if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

		if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

		//return point closest to the ray (positive side)

		if ( tmax < 0 ) return null;

		return this.at( tmin >= 0 ? tmin : tmax, target );

	}

	intersectsBox( box ) {

		return this.intersectBox( box, _vector$a ) !== null;

	}

	intersectTriangle( a, b, c, backfaceCulling, target ) {

		// Compute the offset origin, edges, and normal.

		// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

		_edge1.subVectors( b, a );
		_edge2.subVectors( c, a );
		_normal$1.crossVectors( _edge1, _edge2 );

		// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
		// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
		//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
		//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
		//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
		let DdN = this.direction.dot( _normal$1 );
		let sign;

		if ( DdN > 0 ) {

			if ( backfaceCulling ) return null;
			sign = 1;

		} else if ( DdN < 0 ) {

			sign = -1;
			DdN = - DdN;

		} else {

			return null;

		}

		_diff.subVectors( this.origin, a );
		const DdQxE2 = sign * this.direction.dot( _edge2.crossVectors( _diff, _edge2 ) );

		// b1 < 0, no intersection
		if ( DdQxE2 < 0 ) {

			return null;

		}

		const DdE1xQ = sign * this.direction.dot( _edge1.cross( _diff ) );

		// b2 < 0, no intersection
		if ( DdE1xQ < 0 ) {

			return null;

		}

		// b1+b2 > 1, no intersection
		if ( DdQxE2 + DdE1xQ > DdN ) {

			return null;

		}

		// Line intersects triangle, check if ray does.
		const QdN = - sign * _diff.dot( _normal$1 );

		// t < 0, no intersection
		if ( QdN < 0 ) {

			return null;

		}

		// Ray intersects triangle.
		return this.at( QdN / DdN, target );

	}

	applyMatrix4( matrix4 ) {

		this.origin.applyMatrix4( matrix4 );
		this.direction.transformDirection( matrix4 );

		return this;

	}

	equals( ray ) {

		return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

class Matrix4 {

	constructor( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

		Matrix4.prototype.isMatrix4 = true;

		this.elements = [

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		];

		if ( n11 !== undefined ) {

			this.set( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 );

		}

	}

	set( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

		const te = this.elements;

		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

		return this;

	}

	identity() {

		this.set(

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	}

	clone() {

		return new Matrix4().fromArray( this.elements );

	}

	copy( m ) {

		const te = this.elements;
		const me = m.elements;

		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
		te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
		te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
		te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

		return this;

	}

	copyPosition( m ) {

		const te = this.elements, me = m.elements;

		te[ 12 ] = me[ 12 ];
		te[ 13 ] = me[ 13 ];
		te[ 14 ] = me[ 14 ];

		return this;

	}

	setFromMatrix3( m ) {

		const me = m.elements;

		this.set(

			me[ 0 ], me[ 3 ], me[ 6 ], 0,
			me[ 1 ], me[ 4 ], me[ 7 ], 0,
			me[ 2 ], me[ 5 ], me[ 8 ], 0,
			0, 0, 0, 1

		);

		return this;

	}

	extractBasis( xAxis, yAxis, zAxis ) {

		xAxis.setFromMatrixColumn( this, 0 );
		yAxis.setFromMatrixColumn( this, 1 );
		zAxis.setFromMatrixColumn( this, 2 );

		return this;

	}

	makeBasis( xAxis, yAxis, zAxis ) {

		this.set(
			xAxis.x, yAxis.x, zAxis.x, 0,
			xAxis.y, yAxis.y, zAxis.y, 0,
			xAxis.z, yAxis.z, zAxis.z, 0,
			0, 0, 0, 1
		);

		return this;

	}

	extractRotation( m ) {

		// this method does not support reflection matrices

		const te = this.elements;
		const me = m.elements;

		const scaleX = 1 / _v1$5.setFromMatrixColumn( m, 0 ).length();
		const scaleY = 1 / _v1$5.setFromMatrixColumn( m, 1 ).length();
		const scaleZ = 1 / _v1$5.setFromMatrixColumn( m, 2 ).length();

		te[ 0 ] = me[ 0 ] * scaleX;
		te[ 1 ] = me[ 1 ] * scaleX;
		te[ 2 ] = me[ 2 ] * scaleX;
		te[ 3 ] = 0;

		te[ 4 ] = me[ 4 ] * scaleY;
		te[ 5 ] = me[ 5 ] * scaleY;
		te[ 6 ] = me[ 6 ] * scaleY;
		te[ 7 ] = 0;

		te[ 8 ] = me[ 8 ] * scaleZ;
		te[ 9 ] = me[ 9 ] * scaleZ;
		te[ 10 ] = me[ 10 ] * scaleZ;
		te[ 11 ] = 0;

		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	}

	makeRotationFromEuler( euler ) {

		const te = this.elements;

		const x = euler.x, y = euler.y, z = euler.z;
		const a = Math.cos( x ), b = Math.sin( x );
		const c = Math.cos( y ), d = Math.sin( y );
		const e = Math.cos( z ), f = Math.sin( z );

		if ( euler.order === 'XYZ' ) {

			const ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = - c * f;
			te[ 8 ] = d;

			te[ 1 ] = af + be * d;
			te[ 5 ] = ae - bf * d;
			te[ 9 ] = - b * c;

			te[ 2 ] = bf - ae * d;
			te[ 6 ] = be + af * d;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YXZ' ) {

			const ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce + df * b;
			te[ 4 ] = de * b - cf;
			te[ 8 ] = a * d;

			te[ 1 ] = a * f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b;

			te[ 2 ] = cf * b - de;
			te[ 6 ] = df + ce * b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZXY' ) {

			const ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce - df * b;
			te[ 4 ] = - a * f;
			te[ 8 ] = de + cf * b;

			te[ 1 ] = cf + de * b;
			te[ 5 ] = a * e;
			te[ 9 ] = df - ce * b;

			te[ 2 ] = - a * d;
			te[ 6 ] = b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZYX' ) {

			const ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = be * d - af;
			te[ 8 ] = ae * d + bf;

			te[ 1 ] = c * f;
			te[ 5 ] = bf * d + ae;
			te[ 9 ] = af * d - be;

			te[ 2 ] = - d;
			te[ 6 ] = b * c;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YZX' ) {

			const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = bd - ac * f;
			te[ 8 ] = bc * f + ad;

			te[ 1 ] = f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b * e;

			te[ 2 ] = - d * e;
			te[ 6 ] = ad * f + bc;
			te[ 10 ] = ac - bd * f;

		} else if ( euler.order === 'XZY' ) {

			const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = - f;
			te[ 8 ] = d * e;

			te[ 1 ] = ac * f + bd;
			te[ 5 ] = a * e;
			te[ 9 ] = ad * f - bc;

			te[ 2 ] = bc * f - ad;
			te[ 6 ] = b * e;
			te[ 10 ] = bd * f + ac;

		}

		// bottom row
		te[ 3 ] = 0;
		te[ 7 ] = 0;
		te[ 11 ] = 0;

		// last column
		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	}

	makeRotationFromQuaternion( q ) {

		return this.compose( _zero, q, _one );

	}

	lookAt( eye, target, up ) {

		const te = this.elements;

		_z.subVectors( eye, target );

		if ( _z.lengthSq() === 0 ) {

			// eye and target are in the same position

			_z.z = 1;

		}

		_z.normalize();
		_x.crossVectors( up, _z );

		if ( _x.lengthSq() === 0 ) {

			// up and z are parallel

			if ( Math.abs( up.z ) === 1 ) {

				_z.x += 0.0001;

			} else {

				_z.z += 0.0001;

			}

			_z.normalize();
			_x.crossVectors( up, _z );

		}

		_x.normalize();
		_y.crossVectors( _z, _x );

		te[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;
		te[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;
		te[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;

		return this;

	}

	multiply( m ) {

		return this.multiplyMatrices( this, m );

	}

	premultiply( m ) {

		return this.multiplyMatrices( m, this );

	}

	multiplyMatrices( a, b ) {

		const ae = a.elements;
		const be = b.elements;
		const te = this.elements;

		const a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
		const a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
		const a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
		const a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

		const b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
		const b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
		const b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
		const b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

		return this;

	}

	multiplyScalar( s ) {

		const te = this.elements;

		te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
		te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
		te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
		te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

		return this;

	}

	determinant() {

		const te = this.elements;

		const n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
		const n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
		const n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
		const n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

		//TODO: make this more efficient
		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

		return (
			n41 * (
				+ n14 * n23 * n32
				 - n13 * n24 * n32
				 - n14 * n22 * n33
				 + n12 * n24 * n33
				 + n13 * n22 * n34
				 - n12 * n23 * n34
			) +
			n42 * (
				+ n11 * n23 * n34
				 - n11 * n24 * n33
				 + n14 * n21 * n33
				 - n13 * n21 * n34
				 + n13 * n24 * n31
				 - n14 * n23 * n31
			) +
			n43 * (
				+ n11 * n24 * n32
				 - n11 * n22 * n34
				 - n14 * n21 * n32
				 + n12 * n21 * n34
				 + n14 * n22 * n31
				 - n12 * n24 * n31
			) +
			n44 * (
				- n13 * n22 * n31
				 - n11 * n23 * n32
				 + n11 * n22 * n33
				 + n13 * n21 * n32
				 - n12 * n21 * n33
				 + n12 * n23 * n31
			)

		);

	}

	transpose() {

		const te = this.elements;
		let tmp;

		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

		return this;

	}

	setPosition( x, y, z ) {

		const te = this.elements;

		if ( x.isVector3 ) {

			te[ 12 ] = x.x;
			te[ 13 ] = x.y;
			te[ 14 ] = x.z;

		} else {

			te[ 12 ] = x;
			te[ 13 ] = y;
			te[ 14 ] = z;

		}

		return this;

	}

	invert() {

		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
		const te = this.elements,

			n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ], n41 = te[ 3 ],
			n12 = te[ 4 ], n22 = te[ 5 ], n32 = te[ 6 ], n42 = te[ 7 ],
			n13 = te[ 8 ], n23 = te[ 9 ], n33 = te[ 10 ], n43 = te[ 11 ],
			n14 = te[ 12 ], n24 = te[ 13 ], n34 = te[ 14 ], n44 = te[ 15 ],

			t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
			t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
			t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
			t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

		const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

		if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );

		const detInv = 1 / det;

		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
		te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
		te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

		te[ 4 ] = t12 * detInv;
		te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
		te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
		te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

		te[ 8 ] = t13 * detInv;
		te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
		te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
		te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

		te[ 12 ] = t14 * detInv;
		te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
		te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
		te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

		return this;

	}

	scale( v ) {

		const te = this.elements;
		const x = v.x, y = v.y, z = v.z;

		te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
		te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
		te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
		te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

		return this;

	}

	getMaxScaleOnAxis() {

		const te = this.elements;

		const scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
		const scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
		const scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

		return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

	}

	makeTranslation( x, y, z ) {

		if ( x.isVector3 ) {

			this.set(

				1, 0, 0, x.x,
				0, 1, 0, x.y,
				0, 0, 1, x.z,
				0, 0, 0, 1

			);

		} else {

			this.set(

				1, 0, 0, x,
				0, 1, 0, y,
				0, 0, 1, z,
				0, 0, 0, 1

			);

		}

		return this;

	}

	makeRotationX( theta ) {

		const c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			1, 0, 0, 0,
			0, c, - s, 0,
			0, s, c, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeRotationY( theta ) {

		const c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			 c, 0, s, 0,
			 0, 1, 0, 0,
			- s, 0, c, 0,
			 0, 0, 0, 1

		);

		return this;

	}

	makeRotationZ( theta ) {

		const c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			c, - s, 0, 0,
			s, c, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeRotationAxis( axis, angle ) {

		// Based on http://www.gamedev.net/reference/articles/article1199.asp

		const c = Math.cos( angle );
		const s = Math.sin( angle );
		const t = 1 - c;
		const x = axis.x, y = axis.y, z = axis.z;
		const tx = t * x, ty = t * y;

		this.set(

			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeScale( x, y, z ) {

		this.set(

			x, 0, 0, 0,
			0, y, 0, 0,
			0, 0, z, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeShear( xy, xz, yx, yz, zx, zy ) {

		this.set(

			1, yx, zx, 0,
			xy, 1, zy, 0,
			xz, yz, 1, 0,
			0, 0, 0, 1

		);

		return this;

	}

	compose( position, quaternion, scale ) {

		const te = this.elements;

		const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
		const x2 = x + x,	y2 = y + y, z2 = z + z;
		const xx = x * x2, xy = x * y2, xz = x * z2;
		const yy = y * y2, yz = y * z2, zz = z * z2;
		const wx = w * x2, wy = w * y2, wz = w * z2;

		const sx = scale.x, sy = scale.y, sz = scale.z;

		te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;
		te[ 1 ] = ( xy + wz ) * sx;
		te[ 2 ] = ( xz - wy ) * sx;
		te[ 3 ] = 0;

		te[ 4 ] = ( xy - wz ) * sy;
		te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;
		te[ 6 ] = ( yz + wx ) * sy;
		te[ 7 ] = 0;

		te[ 8 ] = ( xz + wy ) * sz;
		te[ 9 ] = ( yz - wx ) * sz;
		te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;
		te[ 11 ] = 0;

		te[ 12 ] = position.x;
		te[ 13 ] = position.y;
		te[ 14 ] = position.z;
		te[ 15 ] = 1;

		return this;

	}

	decompose( position, quaternion, scale ) {

		const te = this.elements;

		let sx = _v1$5.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
		const sy = _v1$5.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
		const sz = _v1$5.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

		// if determine is negative, we need to invert one scale
		const det = this.determinant();
		if ( det < 0 ) sx = - sx;

		position.x = te[ 12 ];
		position.y = te[ 13 ];
		position.z = te[ 14 ];

		// scale the rotation part
		_m1$2.copy( this );

		const invSX = 1 / sx;
		const invSY = 1 / sy;
		const invSZ = 1 / sz;

		_m1$2.elements[ 0 ] *= invSX;
		_m1$2.elements[ 1 ] *= invSX;
		_m1$2.elements[ 2 ] *= invSX;

		_m1$2.elements[ 4 ] *= invSY;
		_m1$2.elements[ 5 ] *= invSY;
		_m1$2.elements[ 6 ] *= invSY;

		_m1$2.elements[ 8 ] *= invSZ;
		_m1$2.elements[ 9 ] *= invSZ;
		_m1$2.elements[ 10 ] *= invSZ;

		quaternion.setFromRotationMatrix( _m1$2 );

		scale.x = sx;
		scale.y = sy;
		scale.z = sz;

		return this;

	}

	makePerspective( left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem ) {

		const te = this.elements;
		const x = 2 * near / ( right - left );
		const y = 2 * near / ( top - bottom );

		const a = ( right + left ) / ( right - left );
		const b = ( top + bottom ) / ( top - bottom );

		let c, d;

		if ( coordinateSystem === WebGLCoordinateSystem ) {

			c = - ( far + near ) / ( far - near );
			d = ( -2 * far * near ) / ( far - near );

		} else if ( coordinateSystem === WebGPUCoordinateSystem ) {

			c = - far / ( far - near );
			d = ( - far * near ) / ( far - near );

		} else {

			throw new Error( 'THREE.Matrix4.makePerspective(): Invalid coordinate system: ' + coordinateSystem );

		}

		te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a; 	te[ 12 ] = 0;
		te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b; 	te[ 13 ] = 0;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c; 	te[ 14 ] = d;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = -1;	te[ 15 ] = 0;

		return this;

	}

	makeOrthographic( left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem ) {

		const te = this.elements;
		const w = 1.0 / ( right - left );
		const h = 1.0 / ( top - bottom );
		const p = 1.0 / ( far - near );

		const x = ( right + left ) * w;
		const y = ( top + bottom ) * h;

		let z, zInv;

		if ( coordinateSystem === WebGLCoordinateSystem ) {

			z = ( far + near ) * p;
			zInv = -2 * p;

		} else if ( coordinateSystem === WebGPUCoordinateSystem ) {

			z = near * p;
			zInv = -1 * p;

		} else {

			throw new Error( 'THREE.Matrix4.makeOrthographic(): Invalid coordinate system: ' + coordinateSystem );

		}

		te[ 0 ] = 2 * w;	te[ 4 ] = 0;		te[ 8 ] = 0; 		te[ 12 ] = - x;
		te[ 1 ] = 0; 		te[ 5 ] = 2 * h;	te[ 9 ] = 0; 		te[ 13 ] = - y;
		te[ 2 ] = 0; 		te[ 6 ] = 0;		te[ 10 ] = zInv;	te[ 14 ] = - z;
		te[ 3 ] = 0; 		te[ 7 ] = 0;		te[ 11 ] = 0;		te[ 15 ] = 1;

		return this;

	}

	equals( matrix ) {

		const te = this.elements;
		const me = matrix.elements;

		for ( let i = 0; i < 16; i ++ ) {

			if ( te[ i ] !== me[ i ] ) return false;

		}

		return true;

	}

	fromArray( array, offset = 0 ) {

		for ( let i = 0; i < 16; i ++ ) {

			this.elements[ i ] = array[ i + offset ];

		}

		return this;

	}

	toArray( array = [], offset = 0 ) {

		const te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];
		array[ offset + 3 ] = te[ 3 ];

		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];
		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];

		array[ offset + 8 ] = te[ 8 ];
		array[ offset + 9 ] = te[ 9 ];
		array[ offset + 10 ] = te[ 10 ];
		array[ offset + 11 ] = te[ 11 ];

		array[ offset + 12 ] = te[ 12 ];
		array[ offset + 13 ] = te[ 13 ];
		array[ offset + 14 ] = te[ 14 ];
		array[ offset + 15 ] = te[ 15 ];

		return array;

	}

}

const _v1$5 = /*@__PURE__*/ new Vector3();
const _m1$2 = /*@__PURE__*/ new Matrix4();
const _zero = /*@__PURE__*/ new Vector3( 0, 0, 0 );
const _one = /*@__PURE__*/ new Vector3( 1, 1, 1 );
const _x = /*@__PURE__*/ new Vector3();
const _y = /*@__PURE__*/ new Vector3();
const _z = /*@__PURE__*/ new Vector3();

const _matrix$2 = /*@__PURE__*/ new Matrix4();
const _quaternion$3 = /*@__PURE__*/ new Quaternion();

class Euler {

	constructor( x = 0, y = 0, z = 0, order = Euler.DEFAULT_ORDER ) {

		this.isEuler = true;

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order;

	}

	get x() {

		return this._x;

	}

	set x( value ) {

		this._x = value;
		this._onChangeCallback();

	}

	get y() {

		return this._y;

	}

	set y( value ) {

		this._y = value;
		this._onChangeCallback();

	}

	get z() {

		return this._z;

	}

	set z( value ) {

		this._z = value;
		this._onChangeCallback();

	}

	get order() {

		return this._order;

	}

	set order( value ) {

		this._order = value;
		this._onChangeCallback();

	}

	set( x, y, z, order = this._order ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order;

		this._onChangeCallback();

		return this;

	}

	clone() {

		return new this.constructor( this._x, this._y, this._z, this._order );

	}

	copy( euler ) {

		this._x = euler._x;
		this._y = euler._y;
		this._z = euler._z;
		this._order = euler._order;

		this._onChangeCallback();

		return this;

	}

	setFromRotationMatrix( m, order = this._order, update = true ) {

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		const te = m.elements;
		const m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
		const m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
		const m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		switch ( order ) {

			case 'XYZ':

				this._y = Math.asin( clamp$1( m13, -1, 1 ) );

				if ( Math.abs( m13 ) < 0.9999999 ) {

					this._x = Math.atan2( - m23, m33 );
					this._z = Math.atan2( - m12, m11 );

				} else {

					this._x = Math.atan2( m32, m22 );
					this._z = 0;

				}

				break;

			case 'YXZ':

				this._x = Math.asin( - clamp$1( m23, -1, 1 ) );

				if ( Math.abs( m23 ) < 0.9999999 ) {

					this._y = Math.atan2( m13, m33 );
					this._z = Math.atan2( m21, m22 );

				} else {

					this._y = Math.atan2( - m31, m11 );
					this._z = 0;

				}

				break;

			case 'ZXY':

				this._x = Math.asin( clamp$1( m32, -1, 1 ) );

				if ( Math.abs( m32 ) < 0.9999999 ) {

					this._y = Math.atan2( - m31, m33 );
					this._z = Math.atan2( - m12, m22 );

				} else {

					this._y = 0;
					this._z = Math.atan2( m21, m11 );

				}

				break;

			case 'ZYX':

				this._y = Math.asin( - clamp$1( m31, -1, 1 ) );

				if ( Math.abs( m31 ) < 0.9999999 ) {

					this._x = Math.atan2( m32, m33 );
					this._z = Math.atan2( m21, m11 );

				} else {

					this._x = 0;
					this._z = Math.atan2( - m12, m22 );

				}

				break;

			case 'YZX':

				this._z = Math.asin( clamp$1( m21, -1, 1 ) );

				if ( Math.abs( m21 ) < 0.9999999 ) {

					this._x = Math.atan2( - m23, m22 );
					this._y = Math.atan2( - m31, m11 );

				} else {

					this._x = 0;
					this._y = Math.atan2( m13, m33 );

				}

				break;

			case 'XZY':

				this._z = Math.asin( - clamp$1( m12, -1, 1 ) );

				if ( Math.abs( m12 ) < 0.9999999 ) {

					this._x = Math.atan2( m32, m22 );
					this._y = Math.atan2( m13, m11 );

				} else {

					this._x = Math.atan2( - m23, m33 );
					this._y = 0;

				}

				break;

			default:

				console.warn( 'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order );

		}

		this._order = order;

		if ( update === true ) this._onChangeCallback();

		return this;

	}

	setFromQuaternion( q, order, update ) {

		_matrix$2.makeRotationFromQuaternion( q );

		return this.setFromRotationMatrix( _matrix$2, order, update );

	}

	setFromVector3( v, order = this._order ) {

		return this.set( v.x, v.y, v.z, order );

	}

	reorder( newOrder ) {

		// WARNING: this discards revolution information -bhouston

		_quaternion$3.setFromEuler( this );

		return this.setFromQuaternion( _quaternion$3, newOrder );

	}

	equals( euler ) {

		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

	}

	fromArray( array ) {

		this._x = array[ 0 ];
		this._y = array[ 1 ];
		this._z = array[ 2 ];
		if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

		this._onChangeCallback();

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._order;

		return array;

	}

	_onChange( callback ) {

		this._onChangeCallback = callback;

		return this;

	}

	_onChangeCallback() {}

	*[ Symbol.iterator ]() {

		yield this._x;
		yield this._y;
		yield this._z;
		yield this._order;

	}

}

Euler.DEFAULT_ORDER = 'XYZ';

class Layers {

	constructor() {

		this.mask = 1 | 0;

	}

	set( channel ) {

		this.mask = ( 1 << channel | 0 ) >>> 0;

	}

	enable( channel ) {

		this.mask |= 1 << channel | 0;

	}

	enableAll() {

		this.mask = 0xffffffff | 0;

	}

	toggle( channel ) {

		this.mask ^= 1 << channel | 0;

	}

	disable( channel ) {

		this.mask &= ~ ( 1 << channel | 0 );

	}

	disableAll() {

		this.mask = 0;

	}

	test( layers ) {

		return ( this.mask & layers.mask ) !== 0;

	}

	isEnabled( channel ) {

		return ( this.mask & ( 1 << channel | 0 ) ) !== 0;

	}

}

let _object3DId = 0;

const _v1$4 = /*@__PURE__*/ new Vector3();
const _q1 = /*@__PURE__*/ new Quaternion();
const _m1$1 = /*@__PURE__*/ new Matrix4();
const _target$1 = /*@__PURE__*/ new Vector3();

const _position$3 = /*@__PURE__*/ new Vector3();
const _scale$2 = /*@__PURE__*/ new Vector3();
const _quaternion$2 = /*@__PURE__*/ new Quaternion();

const _xAxis = /*@__PURE__*/ new Vector3( 1, 0, 0 );
const _yAxis = /*@__PURE__*/ new Vector3( 0, 1, 0 );
const _zAxis = /*@__PURE__*/ new Vector3( 0, 0, 1 );

const _addedEvent = { type: 'added' };
const _removedEvent = { type: 'removed' };

const _childaddedEvent = { type: 'childadded', child: null };
const _childremovedEvent = { type: 'childremoved', child: null };

class Object3D extends EventDispatcher {

	constructor() {

		super();

		this.isObject3D = true;

		Object.defineProperty( this, 'id', { value: _object3DId ++ } );

		this.uuid = generateUUID();

		this.name = '';
		this.type = 'Object3D';

		this.parent = null;
		this.children = [];

		this.up = Object3D.DEFAULT_UP.clone();

		const position = new Vector3();
		const rotation = new Euler();
		const quaternion = new Quaternion();
		const scale = new Vector3( 1, 1, 1 );

		function onRotationChange() {

			quaternion.setFromEuler( rotation, false );

		}

		function onQuaternionChange() {

			rotation.setFromQuaternion( quaternion, undefined, false );

		}

		rotation._onChange( onRotationChange );
		quaternion._onChange( onQuaternionChange );

		Object.defineProperties( this, {
			position: {
				configurable: true,
				enumerable: true,
				value: position
			},
			rotation: {
				configurable: true,
				enumerable: true,
				value: rotation
			},
			quaternion: {
				configurable: true,
				enumerable: true,
				value: quaternion
			},
			scale: {
				configurable: true,
				enumerable: true,
				value: scale
			},
			modelViewMatrix: {
				value: new Matrix4()
			},
			normalMatrix: {
				value: new Matrix3()
			}
		} );

		this.matrix = new Matrix4();
		this.matrixWorld = new Matrix4();

		this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;

		this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE; // checked by the renderer
		this.matrixWorldNeedsUpdate = false;

		this.layers = new Layers();
		this.visible = true;

		this.castShadow = false;
		this.receiveShadow = false;

		this.frustumCulled = true;
		this.renderOrder = 0;

		this.animations = [];

		this.userData = {};

	}

	onBeforeShadow( /* renderer, object, camera, shadowCamera, geometry, depthMaterial, group */ ) {}

	onAfterShadow( /* renderer, object, camera, shadowCamera, geometry, depthMaterial, group */ ) {}

	onBeforeRender( /* renderer, scene, camera, geometry, material, group */ ) {}

	onAfterRender( /* renderer, scene, camera, geometry, material, group */ ) {}

	applyMatrix4( matrix ) {

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		this.matrix.premultiply( matrix );

		this.matrix.decompose( this.position, this.quaternion, this.scale );

	}

	applyQuaternion( q ) {

		this.quaternion.premultiply( q );

		return this;

	}

	setRotationFromAxisAngle( axis, angle ) {

		// assumes axis is normalized

		this.quaternion.setFromAxisAngle( axis, angle );

	}

	setRotationFromEuler( euler ) {

		this.quaternion.setFromEuler( euler, true );

	}

	setRotationFromMatrix( m ) {

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		this.quaternion.setFromRotationMatrix( m );

	}

	setRotationFromQuaternion( q ) {

		// assumes q is normalized

		this.quaternion.copy( q );

	}

	rotateOnAxis( axis, angle ) {

		// rotate object on axis in object space
		// axis is assumed to be normalized

		_q1.setFromAxisAngle( axis, angle );

		this.quaternion.multiply( _q1 );

		return this;

	}

	rotateOnWorldAxis( axis, angle ) {

		// rotate object on axis in world space
		// axis is assumed to be normalized
		// method assumes no rotated parent

		_q1.setFromAxisAngle( axis, angle );

		this.quaternion.premultiply( _q1 );

		return this;

	}

	rotateX( angle ) {

		return this.rotateOnAxis( _xAxis, angle );

	}

	rotateY( angle ) {

		return this.rotateOnAxis( _yAxis, angle );

	}

	rotateZ( angle ) {

		return this.rotateOnAxis( _zAxis, angle );

	}

	translateOnAxis( axis, distance ) {

		// translate object by distance along axis in object space
		// axis is assumed to be normalized

		_v1$4.copy( axis ).applyQuaternion( this.quaternion );

		this.position.add( _v1$4.multiplyScalar( distance ) );

		return this;

	}

	translateX( distance ) {

		return this.translateOnAxis( _xAxis, distance );

	}

	translateY( distance ) {

		return this.translateOnAxis( _yAxis, distance );

	}

	translateZ( distance ) {

		return this.translateOnAxis( _zAxis, distance );

	}

	localToWorld( vector ) {

		this.updateWorldMatrix( true, false );

		return vector.applyMatrix4( this.matrixWorld );

	}

	worldToLocal( vector ) {

		this.updateWorldMatrix( true, false );

		return vector.applyMatrix4( _m1$1.copy( this.matrixWorld ).invert() );

	}

	lookAt( x, y, z ) {

		// This method does not support objects having non-uniformly-scaled parent(s)

		if ( x.isVector3 ) {

			_target$1.copy( x );

		} else {

			_target$1.set( x, y, z );

		}

		const parent = this.parent;

		this.updateWorldMatrix( true, false );

		_position$3.setFromMatrixPosition( this.matrixWorld );

		if ( this.isCamera || this.isLight ) {

			_m1$1.lookAt( _position$3, _target$1, this.up );

		} else {

			_m1$1.lookAt( _target$1, _position$3, this.up );

		}

		this.quaternion.setFromRotationMatrix( _m1$1 );

		if ( parent ) {

			_m1$1.extractRotation( parent.matrixWorld );
			_q1.setFromRotationMatrix( _m1$1 );
			this.quaternion.premultiply( _q1.invert() );

		}

	}

	add( object ) {

		if ( arguments.length > 1 ) {

			for ( let i = 0; i < arguments.length; i ++ ) {

				this.add( arguments[ i ] );

			}

			return this;

		}

		if ( object === this ) {

			console.error( 'THREE.Object3D.add: object can\'t be added as a child of itself.', object );
			return this;

		}

		if ( object && object.isObject3D ) {

			object.removeFromParent();
			object.parent = this;
			this.children.push( object );

			object.dispatchEvent( _addedEvent );

			_childaddedEvent.child = object;
			this.dispatchEvent( _childaddedEvent );
			_childaddedEvent.child = null;

		} else {

			console.error( 'THREE.Object3D.add: object not an instance of THREE.Object3D.', object );

		}

		return this;

	}

	remove( object ) {

		if ( arguments.length > 1 ) {

			for ( let i = 0; i < arguments.length; i ++ ) {

				this.remove( arguments[ i ] );

			}

			return this;

		}

		const index = this.children.indexOf( object );

		if ( index !== -1 ) {

			object.parent = null;
			this.children.splice( index, 1 );

			object.dispatchEvent( _removedEvent );

			_childremovedEvent.child = object;
			this.dispatchEvent( _childremovedEvent );
			_childremovedEvent.child = null;

		}

		return this;

	}

	removeFromParent() {

		const parent = this.parent;

		if ( parent !== null ) {

			parent.remove( this );

		}

		return this;

	}

	clear() {

		return this.remove( ... this.children );

	}

	attach( object ) {

		// adds object as a child of this, while maintaining the object's world transform

		// Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)

		this.updateWorldMatrix( true, false );

		_m1$1.copy( this.matrixWorld ).invert();

		if ( object.parent !== null ) {

			object.parent.updateWorldMatrix( true, false );

			_m1$1.multiply( object.parent.matrixWorld );

		}

		object.applyMatrix4( _m1$1 );

		object.removeFromParent();
		object.parent = this;
		this.children.push( object );

		object.updateWorldMatrix( false, true );

		object.dispatchEvent( _addedEvent );

		_childaddedEvent.child = object;
		this.dispatchEvent( _childaddedEvent );
		_childaddedEvent.child = null;

		return this;

	}

	getObjectById( id ) {

		return this.getObjectByProperty( 'id', id );

	}

	getObjectByName( name ) {

		return this.getObjectByProperty( 'name', name );

	}

	getObjectByProperty( name, value ) {

		if ( this[ name ] === value ) return this;

		for ( let i = 0, l = this.children.length; i < l; i ++ ) {

			const child = this.children[ i ];
			const object = child.getObjectByProperty( name, value );

			if ( object !== undefined ) {

				return object;

			}

		}

		return undefined;

	}

	getObjectsByProperty( name, value, result = [] ) {

		if ( this[ name ] === value ) result.push( this );

		const children = this.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].getObjectsByProperty( name, value, result );

		}

		return result;

	}

	getWorldPosition( target ) {

		this.updateWorldMatrix( true, false );

		return target.setFromMatrixPosition( this.matrixWorld );

	}

	getWorldQuaternion( target ) {

		this.updateWorldMatrix( true, false );

		this.matrixWorld.decompose( _position$3, target, _scale$2 );

		return target;

	}

	getWorldScale( target ) {

		this.updateWorldMatrix( true, false );

		this.matrixWorld.decompose( _position$3, _quaternion$2, target );

		return target;

	}

	getWorldDirection( target ) {

		this.updateWorldMatrix( true, false );

		const e = this.matrixWorld.elements;

		return target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();

	}

	raycast( /* raycaster, intersects */ ) {}

	traverse( callback ) {

		callback( this );

		const children = this.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].traverse( callback );

		}

	}

	traverseVisible( callback ) {

		if ( this.visible === false ) return;

		callback( this );

		const children = this.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].traverseVisible( callback );

		}

	}

	traverseAncestors( callback ) {

		const parent = this.parent;

		if ( parent !== null ) {

			callback( parent );

			parent.traverseAncestors( callback );

		}

	}

	updateMatrix() {

		this.matrix.compose( this.position, this.quaternion, this.scale );

		this.matrixWorldNeedsUpdate = true;

	}

	updateMatrixWorld( force ) {

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		if ( this.matrixWorldNeedsUpdate || force ) {

			if ( this.matrixWorldAutoUpdate === true ) {

				if ( this.parent === null ) {

					this.matrixWorld.copy( this.matrix );

				} else {

					this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

				}

			}

			this.matrixWorldNeedsUpdate = false;

			force = true;

		}

		// make sure descendants are updated if required

		const children = this.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			const child = children[ i ];

			child.updateMatrixWorld( force );

		}

	}

	updateWorldMatrix( updateParents, updateChildren ) {

		const parent = this.parent;

		if ( updateParents === true && parent !== null ) {

			parent.updateWorldMatrix( true, false );

		}

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		if ( this.matrixWorldAutoUpdate === true ) {

			if ( this.parent === null ) {

				this.matrixWorld.copy( this.matrix );

			} else {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			}

		}

		// make sure descendants are updated

		if ( updateChildren === true ) {

			const children = this.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				const child = children[ i ];

				child.updateWorldMatrix( false, true );

			}

		}

	}

	toJSON( meta ) {

		// meta is a string when called from JSON.stringify
		const isRootObject = ( meta === undefined || typeof meta === 'string' );

		const output = {};

		// meta is a hash used to collect geometries, materials.
		// not providing it implies that this is the root object
		// being serialized.
		if ( isRootObject ) {

			// initialize meta obj
			meta = {
				geometries: {},
				materials: {},
				textures: {},
				images: {},
				shapes: {},
				skeletons: {},
				animations: {},
				nodes: {}
			};

			output.metadata = {
				version: 4.6,
				type: 'Object',
				generator: 'Object3D.toJSON'
			};

		}

		// standard Object3D serialization

		const object = {};

		object.uuid = this.uuid;
		object.type = this.type;

		if ( this.name !== '' ) object.name = this.name;
		if ( this.castShadow === true ) object.castShadow = true;
		if ( this.receiveShadow === true ) object.receiveShadow = true;
		if ( this.visible === false ) object.visible = false;
		if ( this.frustumCulled === false ) object.frustumCulled = false;
		if ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;
		if ( Object.keys( this.userData ).length > 0 ) object.userData = this.userData;

		object.layers = this.layers.mask;
		object.matrix = this.matrix.toArray();
		object.up = this.up.toArray();

		if ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;

		// object specific properties

		if ( this.isInstancedMesh ) {

			object.type = 'InstancedMesh';
			object.count = this.count;
			object.instanceMatrix = this.instanceMatrix.toJSON();
			if ( this.instanceColor !== null ) object.instanceColor = this.instanceColor.toJSON();

		}

		if ( this.isBatchedMesh ) {

			object.type = 'BatchedMesh';
			object.perObjectFrustumCulled = this.perObjectFrustumCulled;
			object.sortObjects = this.sortObjects;

			object.drawRanges = this._drawRanges;
			object.reservedRanges = this._reservedRanges;

			object.visibility = this._visibility;
			object.active = this._active;
			object.bounds = this._bounds.map( bound => ( {
				boxInitialized: bound.boxInitialized,
				boxMin: bound.box.min.toArray(),
				boxMax: bound.box.max.toArray(),

				sphereInitialized: bound.sphereInitialized,
				sphereRadius: bound.sphere.radius,
				sphereCenter: bound.sphere.center.toArray()
			} ) );

			object.maxInstanceCount = this._maxInstanceCount;
			object.maxVertexCount = this._maxVertexCount;
			object.maxIndexCount = this._maxIndexCount;

			object.geometryInitialized = this._geometryInitialized;
			object.geometryCount = this._geometryCount;

			object.matricesTexture = this._matricesTexture.toJSON( meta );

			if ( this._colorsTexture !== null ) object.colorsTexture = this._colorsTexture.toJSON( meta );

			if ( this.boundingSphere !== null ) {

				object.boundingSphere = {
					center: object.boundingSphere.center.toArray(),
					radius: object.boundingSphere.radius
				};

			}

			if ( this.boundingBox !== null ) {

				object.boundingBox = {
					min: object.boundingBox.min.toArray(),
					max: object.boundingBox.max.toArray()
				};

			}

		}

		//

		function serialize( library, element ) {

			if ( library[ element.uuid ] === undefined ) {

				library[ element.uuid ] = element.toJSON( meta );

			}

			return element.uuid;

		}

		if ( this.isScene ) {

			if ( this.background ) {

				if ( this.background.isColor ) {

					object.background = this.background.toJSON();

				} else if ( this.background.isTexture ) {

					object.background = this.background.toJSON( meta ).uuid;

				}

			}

			if ( this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true ) {

				object.environment = this.environment.toJSON( meta ).uuid;

			}

		} else if ( this.isMesh || this.isLine || this.isPoints ) {

			object.geometry = serialize( meta.geometries, this.geometry );

			const parameters = this.geometry.parameters;

			if ( parameters !== undefined && parameters.shapes !== undefined ) {

				const shapes = parameters.shapes;

				if ( Array.isArray( shapes ) ) {

					for ( let i = 0, l = shapes.length; i < l; i ++ ) {

						const shape = shapes[ i ];

						serialize( meta.shapes, shape );

					}

				} else {

					serialize( meta.shapes, shapes );

				}

			}

		}

		if ( this.isSkinnedMesh ) {

			object.bindMode = this.bindMode;
			object.bindMatrix = this.bindMatrix.toArray();

			if ( this.skeleton !== undefined ) {

				serialize( meta.skeletons, this.skeleton );

				object.skeleton = this.skeleton.uuid;

			}

		}

		if ( this.material !== undefined ) {

			if ( Array.isArray( this.material ) ) {

				const uuids = [];

				for ( let i = 0, l = this.material.length; i < l; i ++ ) {

					uuids.push( serialize( meta.materials, this.material[ i ] ) );

				}

				object.material = uuids;

			} else {

				object.material = serialize( meta.materials, this.material );

			}

		}

		//

		if ( this.children.length > 0 ) {

			object.children = [];

			for ( let i = 0; i < this.children.length; i ++ ) {

				object.children.push( this.children[ i ].toJSON( meta ).object );

			}

		}

		//

		if ( this.animations.length > 0 ) {

			object.animations = [];

			for ( let i = 0; i < this.animations.length; i ++ ) {

				const animation = this.animations[ i ];

				object.animations.push( serialize( meta.animations, animation ) );

			}

		}

		if ( isRootObject ) {

			const geometries = extractFromCache( meta.geometries );
			const materials = extractFromCache( meta.materials );
			const textures = extractFromCache( meta.textures );
			const images = extractFromCache( meta.images );
			const shapes = extractFromCache( meta.shapes );
			const skeletons = extractFromCache( meta.skeletons );
			const animations = extractFromCache( meta.animations );
			const nodes = extractFromCache( meta.nodes );

			if ( geometries.length > 0 ) output.geometries = geometries;
			if ( materials.length > 0 ) output.materials = materials;
			if ( textures.length > 0 ) output.textures = textures;
			if ( images.length > 0 ) output.images = images;
			if ( shapes.length > 0 ) output.shapes = shapes;
			if ( skeletons.length > 0 ) output.skeletons = skeletons;
			if ( animations.length > 0 ) output.animations = animations;
			if ( nodes.length > 0 ) output.nodes = nodes;

		}

		output.object = object;

		return output;

		// extract data from the cache hash
		// remove metadata on each item
		// and return as array
		function extractFromCache( cache ) {

			const values = [];
			for ( const key in cache ) {

				const data = cache[ key ];
				delete data.metadata;
				values.push( data );

			}

			return values;

		}

	}

	clone( recursive ) {

		return new this.constructor().copy( this, recursive );

	}

	copy( source, recursive = true ) {

		this.name = source.name;

		this.up.copy( source.up );

		this.position.copy( source.position );
		this.rotation.order = source.rotation.order;
		this.quaternion.copy( source.quaternion );
		this.scale.copy( source.scale );

		this.matrix.copy( source.matrix );
		this.matrixWorld.copy( source.matrixWorld );

		this.matrixAutoUpdate = source.matrixAutoUpdate;

		this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;
		this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

		this.layers.mask = source.layers.mask;
		this.visible = source.visible;

		this.castShadow = source.castShadow;
		this.receiveShadow = source.receiveShadow;

		this.frustumCulled = source.frustumCulled;
		this.renderOrder = source.renderOrder;

		this.animations = source.animations.slice();

		this.userData = JSON.parse( JSON.stringify( source.userData ) );

		if ( recursive === true ) {

			for ( let i = 0; i < source.children.length; i ++ ) {

				const child = source.children[ i ];
				this.add( child.clone() );

			}

		}

		return this;

	}

}

Object3D.DEFAULT_UP = /*@__PURE__*/ new Vector3( 0, 1, 0 );
Object3D.DEFAULT_MATRIX_AUTO_UPDATE = true;
Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;

const _v0$1 = /*@__PURE__*/ new Vector3();
const _v1$3 = /*@__PURE__*/ new Vector3();
const _v2$2 = /*@__PURE__*/ new Vector3();
const _v3$2 = /*@__PURE__*/ new Vector3();

const _vab = /*@__PURE__*/ new Vector3();
const _vac = /*@__PURE__*/ new Vector3();
const _vbc = /*@__PURE__*/ new Vector3();
const _vap = /*@__PURE__*/ new Vector3();
const _vbp = /*@__PURE__*/ new Vector3();
const _vcp = /*@__PURE__*/ new Vector3();

const _v40 = /*@__PURE__*/ new Vector4();
const _v41 = /*@__PURE__*/ new Vector4();
const _v42 = /*@__PURE__*/ new Vector4();

class Triangle {

	constructor( a = new Vector3(), b = new Vector3(), c = new Vector3() ) {

		this.a = a;
		this.b = b;
		this.c = c;

	}

	static getNormal( a, b, c, target ) {

		target.subVectors( c, b );
		_v0$1.subVectors( a, b );
		target.cross( _v0$1 );

		const targetLengthSq = target.lengthSq();
		if ( targetLengthSq > 0 ) {

			return target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );

		}

		return target.set( 0, 0, 0 );

	}

	// static/instance method to calculate barycentric coordinates
	// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
	static getBarycoord( point, a, b, c, target ) {

		_v0$1.subVectors( c, a );
		_v1$3.subVectors( b, a );
		_v2$2.subVectors( point, a );

		const dot00 = _v0$1.dot( _v0$1 );
		const dot01 = _v0$1.dot( _v1$3 );
		const dot02 = _v0$1.dot( _v2$2 );
		const dot11 = _v1$3.dot( _v1$3 );
		const dot12 = _v1$3.dot( _v2$2 );

		const denom = ( dot00 * dot11 - dot01 * dot01 );

		// collinear or singular triangle
		if ( denom === 0 ) {

			target.set( 0, 0, 0 );
			return null;

		}

		const invDenom = 1 / denom;
		const u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
		const v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

		// barycentric coordinates must always sum to 1
		return target.set( 1 - u - v, v, u );

	}

	static containsPoint( point, a, b, c ) {

		// if the triangle is degenerate then we can't contain a point
		if ( this.getBarycoord( point, a, b, c, _v3$2 ) === null ) {

			return false;

		}

		return ( _v3$2.x >= 0 ) && ( _v3$2.y >= 0 ) && ( ( _v3$2.x + _v3$2.y ) <= 1 );

	}

	static getInterpolation( point, p1, p2, p3, v1, v2, v3, target ) {

		if ( this.getBarycoord( point, p1, p2, p3, _v3$2 ) === null ) {

			target.x = 0;
			target.y = 0;
			if ( 'z' in target ) target.z = 0;
			if ( 'w' in target ) target.w = 0;
			return null;

		}

		target.setScalar( 0 );
		target.addScaledVector( v1, _v3$2.x );
		target.addScaledVector( v2, _v3$2.y );
		target.addScaledVector( v3, _v3$2.z );

		return target;

	}

	static getInterpolatedAttribute( attr, i1, i2, i3, barycoord, target ) {

		_v40.setScalar( 0 );
		_v41.setScalar( 0 );
		_v42.setScalar( 0 );

		_v40.fromBufferAttribute( attr, i1 );
		_v41.fromBufferAttribute( attr, i2 );
		_v42.fromBufferAttribute( attr, i3 );

		target.setScalar( 0 );
		target.addScaledVector( _v40, barycoord.x );
		target.addScaledVector( _v41, barycoord.y );
		target.addScaledVector( _v42, barycoord.z );

		return target;

	}

	static isFrontFacing( a, b, c, direction ) {

		_v0$1.subVectors( c, b );
		_v1$3.subVectors( a, b );

		// strictly front facing
		return ( _v0$1.cross( _v1$3 ).dot( direction ) < 0 ) ? true : false;

	}

	set( a, b, c ) {

		this.a.copy( a );
		this.b.copy( b );
		this.c.copy( c );

		return this;

	}

	setFromPointsAndIndices( points, i0, i1, i2 ) {

		this.a.copy( points[ i0 ] );
		this.b.copy( points[ i1 ] );
		this.c.copy( points[ i2 ] );

		return this;

	}

	setFromAttributeAndIndices( attribute, i0, i1, i2 ) {

		this.a.fromBufferAttribute( attribute, i0 );
		this.b.fromBufferAttribute( attribute, i1 );
		this.c.fromBufferAttribute( attribute, i2 );

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( triangle ) {

		this.a.copy( triangle.a );
		this.b.copy( triangle.b );
		this.c.copy( triangle.c );

		return this;

	}

	getArea() {

		_v0$1.subVectors( this.c, this.b );
		_v1$3.subVectors( this.a, this.b );

		return _v0$1.cross( _v1$3 ).length() * 0.5;

	}

	getMidpoint( target ) {

		return target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

	}

	getNormal( target ) {

		return Triangle.getNormal( this.a, this.b, this.c, target );

	}

	getPlane( target ) {

		return target.setFromCoplanarPoints( this.a, this.b, this.c );

	}

	getBarycoord( point, target ) {

		return Triangle.getBarycoord( point, this.a, this.b, this.c, target );

	}

	getInterpolation( point, v1, v2, v3, target ) {

		return Triangle.getInterpolation( point, this.a, this.b, this.c, v1, v2, v3, target );

	}

	containsPoint( point ) {

		return Triangle.containsPoint( point, this.a, this.b, this.c );

	}

	isFrontFacing( direction ) {

		return Triangle.isFrontFacing( this.a, this.b, this.c, direction );

	}

	intersectsBox( box ) {

		return box.intersectsTriangle( this );

	}

	closestPointToPoint( p, target ) {

		const a = this.a, b = this.b, c = this.c;
		let v, w;

		// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
		// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
		// under the accompanying license; see chapter 5.1.5 for detailed explanation.
		// basically, we're distinguishing which of the voronoi regions of the triangle
		// the point lies in with the minimum amount of redundant computation.

		_vab.subVectors( b, a );
		_vac.subVectors( c, a );
		_vap.subVectors( p, a );
		const d1 = _vab.dot( _vap );
		const d2 = _vac.dot( _vap );
		if ( d1 <= 0 && d2 <= 0 ) {

			// vertex region of A; barycentric coords (1, 0, 0)
			return target.copy( a );

		}

		_vbp.subVectors( p, b );
		const d3 = _vab.dot( _vbp );
		const d4 = _vac.dot( _vbp );
		if ( d3 >= 0 && d4 <= d3 ) {

			// vertex region of B; barycentric coords (0, 1, 0)
			return target.copy( b );

		}

		const vc = d1 * d4 - d3 * d2;
		if ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {

			v = d1 / ( d1 - d3 );
			// edge region of AB; barycentric coords (1-v, v, 0)
			return target.copy( a ).addScaledVector( _vab, v );

		}

		_vcp.subVectors( p, c );
		const d5 = _vab.dot( _vcp );
		const d6 = _vac.dot( _vcp );
		if ( d6 >= 0 && d5 <= d6 ) {

			// vertex region of C; barycentric coords (0, 0, 1)
			return target.copy( c );

		}

		const vb = d5 * d2 - d1 * d6;
		if ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {

			w = d2 / ( d2 - d6 );
			// edge region of AC; barycentric coords (1-w, 0, w)
			return target.copy( a ).addScaledVector( _vac, w );

		}

		const va = d3 * d6 - d5 * d4;
		if ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {

			_vbc.subVectors( c, b );
			w = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );
			// edge region of BC; barycentric coords (0, 1-w, w)
			return target.copy( b ).addScaledVector( _vbc, w ); // edge region of BC

		}

		// face region
		const denom = 1 / ( va + vb + vc );
		// u = va * denom
		v = vb * denom;
		w = vc * denom;

		return target.copy( a ).addScaledVector( _vab, v ).addScaledVector( _vac, w );

	}

	equals( triangle ) {

		return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

	}

}

const _colorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
	'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
	'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
	'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
	'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
	'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
	'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
	'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
	'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
	'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
	'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
	'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
	'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
	'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
	'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
	'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
	'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
	'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
	'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
	'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
	'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
	'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
	'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
	'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

const _hslA = { h: 0, s: 0, l: 0 };
const _hslB = { h: 0, s: 0, l: 0 };

function hue2rgb( p, q, t ) {

	if ( t < 0 ) t += 1;
	if ( t > 1 ) t -= 1;
	if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
	if ( t < 1 / 2 ) return q;
	if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
	return p;

}

class Color {

	constructor( r, g, b ) {

		this.isColor = true;

		this.r = 1;
		this.g = 1;
		this.b = 1;

		return this.set( r, g, b );

	}

	set( r, g, b ) {

		if ( g === undefined && b === undefined ) {

			// r is THREE.Color, hex or string

			const value = r;

			if ( value && value.isColor ) {

				this.copy( value );

			} else if ( typeof value === 'number' ) {

				this.setHex( value );

			} else if ( typeof value === 'string' ) {

				this.setStyle( value );

			}

		} else {

			this.setRGB( r, g, b );

		}

		return this;

	}

	setScalar( scalar ) {

		this.r = scalar;
		this.g = scalar;
		this.b = scalar;

		return this;

	}

	setHex( hex, colorSpace = SRGBColorSpace ) {

		hex = Math.floor( hex );

		this.r = ( hex >> 16 & 255 ) / 255;
		this.g = ( hex >> 8 & 255 ) / 255;
		this.b = ( hex & 255 ) / 255;

		ColorManagement.toWorkingColorSpace( this, colorSpace );

		return this;

	}

	setRGB( r, g, b, colorSpace = ColorManagement.workingColorSpace ) {

		this.r = r;
		this.g = g;
		this.b = b;

		ColorManagement.toWorkingColorSpace( this, colorSpace );

		return this;

	}

	setHSL( h, s, l, colorSpace = ColorManagement.workingColorSpace ) {

		// h,s,l ranges are in 0.0 - 1.0
		h = euclideanModulo( h, 1 );
		s = clamp$1( s, 0, 1 );
		l = clamp$1( l, 0, 1 );

		if ( s === 0 ) {

			this.r = this.g = this.b = l;

		} else {

			const p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
			const q = ( 2 * l ) - p;

			this.r = hue2rgb( q, p, h + 1 / 3 );
			this.g = hue2rgb( q, p, h );
			this.b = hue2rgb( q, p, h - 1 / 3 );

		}

		ColorManagement.toWorkingColorSpace( this, colorSpace );

		return this;

	}

	setStyle( style, colorSpace = SRGBColorSpace ) {

		function handleAlpha( string ) {

			if ( string === undefined ) return;

			if ( parseFloat( string ) < 1 ) {

				console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

			}

		}


		let m;

		if ( m = /^(\w+)\(([^\)]*)\)/.exec( style ) ) {

			// rgb / hsl

			let color;
			const name = m[ 1 ];
			const components = m[ 2 ];

			switch ( name ) {

				case 'rgb':
				case 'rgba':

					if ( color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

						// rgb(255,0,0) rgba(255,0,0,0.5)

						handleAlpha( color[ 4 ] );

						return this.setRGB(
							Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255,
							Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255,
							Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255,
							colorSpace
						);

					}

					if ( color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

						// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)

						handleAlpha( color[ 4 ] );

						return this.setRGB(
							Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100,
							Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100,
							Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100,
							colorSpace
						);

					}

					break;

				case 'hsl':
				case 'hsla':

					if ( color = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

						// hsl(120,50%,50%) hsla(120,50%,50%,0.5)

						handleAlpha( color[ 4 ] );

						return this.setHSL(
							parseFloat( color[ 1 ] ) / 360,
							parseFloat( color[ 2 ] ) / 100,
							parseFloat( color[ 3 ] ) / 100,
							colorSpace
						);

					}

					break;

				default:

					console.warn( 'THREE.Color: Unknown color model ' + style );

			}

		} else if ( m = /^\#([A-Fa-f\d]+)$/.exec( style ) ) {

			// hex color

			const hex = m[ 1 ];
			const size = hex.length;

			if ( size === 3 ) {

				// #ff0
				return this.setRGB(
					parseInt( hex.charAt( 0 ), 16 ) / 15,
					parseInt( hex.charAt( 1 ), 16 ) / 15,
					parseInt( hex.charAt( 2 ), 16 ) / 15,
					colorSpace
				);

			} else if ( size === 6 ) {

				// #ff0000
				return this.setHex( parseInt( hex, 16 ), colorSpace );

			} else {

				console.warn( 'THREE.Color: Invalid hex color ' + style );

			}

		} else if ( style && style.length > 0 ) {

			return this.setColorName( style, colorSpace );

		}

		return this;

	}

	setColorName( style, colorSpace = SRGBColorSpace ) {

		// color keywords
		const hex = _colorKeywords[ style.toLowerCase() ];

		if ( hex !== undefined ) {

			// red
			this.setHex( hex, colorSpace );

		} else {

			// unknown color
			console.warn( 'THREE.Color: Unknown color ' + style );

		}

		return this;

	}

	clone() {

		return new this.constructor( this.r, this.g, this.b );

	}

	copy( color ) {

		this.r = color.r;
		this.g = color.g;
		this.b = color.b;

		return this;

	}

	copySRGBToLinear( color ) {

		this.r = SRGBToLinear( color.r );
		this.g = SRGBToLinear( color.g );
		this.b = SRGBToLinear( color.b );

		return this;

	}

	copyLinearToSRGB( color ) {

		this.r = LinearToSRGB( color.r );
		this.g = LinearToSRGB( color.g );
		this.b = LinearToSRGB( color.b );

		return this;

	}

	convertSRGBToLinear() {

		this.copySRGBToLinear( this );

		return this;

	}

	convertLinearToSRGB() {

		this.copyLinearToSRGB( this );

		return this;

	}

	getHex( colorSpace = SRGBColorSpace ) {

		ColorManagement.fromWorkingColorSpace( _color.copy( this ), colorSpace );

		return Math.round( clamp$1( _color.r * 255, 0, 255 ) ) * 65536 + Math.round( clamp$1( _color.g * 255, 0, 255 ) ) * 256 + Math.round( clamp$1( _color.b * 255, 0, 255 ) );

	}

	getHexString( colorSpace = SRGBColorSpace ) {

		return ( '000000' + this.getHex( colorSpace ).toString( 16 ) ).slice( -6 );

	}

	getHSL( target, colorSpace = ColorManagement.workingColorSpace ) {

		// h,s,l ranges are in 0.0 - 1.0

		ColorManagement.fromWorkingColorSpace( _color.copy( this ), colorSpace );

		const r = _color.r, g = _color.g, b = _color.b;

		const max = Math.max( r, g, b );
		const min = Math.min( r, g, b );

		let hue, saturation;
		const lightness = ( min + max ) / 2.0;

		if ( min === max ) {

			hue = 0;
			saturation = 0;

		} else {

			const delta = max - min;

			saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

			switch ( max ) {

				case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
				case g: hue = ( b - r ) / delta + 2; break;
				case b: hue = ( r - g ) / delta + 4; break;

			}

			hue /= 6;

		}

		target.h = hue;
		target.s = saturation;
		target.l = lightness;

		return target;

	}

	getRGB( target, colorSpace = ColorManagement.workingColorSpace ) {

		ColorManagement.fromWorkingColorSpace( _color.copy( this ), colorSpace );

		target.r = _color.r;
		target.g = _color.g;
		target.b = _color.b;

		return target;

	}

	getStyle( colorSpace = SRGBColorSpace ) {

		ColorManagement.fromWorkingColorSpace( _color.copy( this ), colorSpace );

		const r = _color.r, g = _color.g, b = _color.b;

		if ( colorSpace !== SRGBColorSpace ) {

			// Requires CSS Color Module Level 4 (https://www.w3.org/TR/css-color-4/).
			return `color(${ colorSpace } ${ r.toFixed( 3 ) } ${ g.toFixed( 3 ) } ${ b.toFixed( 3 ) })`;

		}

		return `rgb(${ Math.round( r * 255 ) },${ Math.round( g * 255 ) },${ Math.round( b * 255 ) })`;

	}

	offsetHSL( h, s, l ) {

		this.getHSL( _hslA );

		return this.setHSL( _hslA.h + h, _hslA.s + s, _hslA.l + l );

	}

	add( color ) {

		this.r += color.r;
		this.g += color.g;
		this.b += color.b;

		return this;

	}

	addColors( color1, color2 ) {

		this.r = color1.r + color2.r;
		this.g = color1.g + color2.g;
		this.b = color1.b + color2.b;

		return this;

	}

	addScalar( s ) {

		this.r += s;
		this.g += s;
		this.b += s;

		return this;

	}

	sub( color ) {

		this.r = Math.max( 0, this.r - color.r );
		this.g = Math.max( 0, this.g - color.g );
		this.b = Math.max( 0, this.b - color.b );

		return this;

	}

	multiply( color ) {

		this.r *= color.r;
		this.g *= color.g;
		this.b *= color.b;

		return this;

	}

	multiplyScalar( s ) {

		this.r *= s;
		this.g *= s;
		this.b *= s;

		return this;

	}

	lerp( color, alpha ) {

		this.r += ( color.r - this.r ) * alpha;
		this.g += ( color.g - this.g ) * alpha;
		this.b += ( color.b - this.b ) * alpha;

		return this;

	}

	lerpColors( color1, color2, alpha ) {

		this.r = color1.r + ( color2.r - color1.r ) * alpha;
		this.g = color1.g + ( color2.g - color1.g ) * alpha;
		this.b = color1.b + ( color2.b - color1.b ) * alpha;

		return this;

	}

	lerpHSL( color, alpha ) {

		this.getHSL( _hslA );
		color.getHSL( _hslB );

		const h = lerp$1( _hslA.h, _hslB.h, alpha );
		const s = lerp$1( _hslA.s, _hslB.s, alpha );
		const l = lerp$1( _hslA.l, _hslB.l, alpha );

		this.setHSL( h, s, l );

		return this;

	}

	setFromVector3( v ) {

		this.r = v.x;
		this.g = v.y;
		this.b = v.z;

		return this;

	}

	applyMatrix3( m ) {

		const r = this.r, g = this.g, b = this.b;
		const e = m.elements;

		this.r = e[ 0 ] * r + e[ 3 ] * g + e[ 6 ] * b;
		this.g = e[ 1 ] * r + e[ 4 ] * g + e[ 7 ] * b;
		this.b = e[ 2 ] * r + e[ 5 ] * g + e[ 8 ] * b;

		return this;

	}

	equals( c ) {

		return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

	}

	fromArray( array, offset = 0 ) {

		this.r = array[ offset ];
		this.g = array[ offset + 1 ];
		this.b = array[ offset + 2 ];

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.r;
		array[ offset + 1 ] = this.g;
		array[ offset + 2 ] = this.b;

		return array;

	}

	fromBufferAttribute( attribute, index ) {

		this.r = attribute.getX( index );
		this.g = attribute.getY( index );
		this.b = attribute.getZ( index );

		return this;

	}

	toJSON() {

		return this.getHex();

	}

	*[ Symbol.iterator ]() {

		yield this.r;
		yield this.g;
		yield this.b;

	}

}

const _color = /*@__PURE__*/ new Color();

Color.NAMES = _colorKeywords;

let _materialId = 0;

class Material extends EventDispatcher {

	constructor() {

		super();

		this.isMaterial = true;

		Object.defineProperty( this, 'id', { value: _materialId ++ } );

		this.uuid = generateUUID();

		this.name = '';
		this.type = 'Material';

		this.blending = NormalBlending;
		this.side = FrontSide;
		this.vertexColors = false;

		this.opacity = 1;
		this.transparent = false;
		this.alphaHash = false;

		this.blendSrc = SrcAlphaFactor;
		this.blendDst = OneMinusSrcAlphaFactor;
		this.blendEquation = AddEquation;
		this.blendSrcAlpha = null;
		this.blendDstAlpha = null;
		this.blendEquationAlpha = null;
		this.blendColor = new Color( 0, 0, 0 );
		this.blendAlpha = 0;

		this.depthFunc = LessEqualDepth;
		this.depthTest = true;
		this.depthWrite = true;

		this.stencilWriteMask = 0xff;
		this.stencilFunc = AlwaysStencilFunc;
		this.stencilRef = 0;
		this.stencilFuncMask = 0xff;
		this.stencilFail = KeepStencilOp;
		this.stencilZFail = KeepStencilOp;
		this.stencilZPass = KeepStencilOp;
		this.stencilWrite = false;

		this.clippingPlanes = null;
		this.clipIntersection = false;
		this.clipShadows = false;

		this.shadowSide = null;

		this.colorWrite = true;

		this.precision = null; // override the renderer's default precision for this material

		this.polygonOffset = false;
		this.polygonOffsetFactor = 0;
		this.polygonOffsetUnits = 0;

		this.dithering = false;

		this.alphaToCoverage = false;
		this.premultipliedAlpha = false;
		this.forceSinglePass = false;

		this.visible = true;

		this.toneMapped = true;

		this.userData = {};

		this.version = 0;

		this._alphaTest = 0;

	}

	get alphaTest() {

		return this._alphaTest;

	}

	set alphaTest( value ) {

		if ( this._alphaTest > 0 !== value > 0 ) {

			this.version ++;

		}

		this._alphaTest = value;

	}

	// onBeforeRender and onBeforeCompile only supported in WebGLRenderer

	onBeforeRender( /* renderer, scene, camera, geometry, object, group */ ) {}

	onBeforeCompile( /* shaderobject, renderer */ ) {}

	customProgramCacheKey() {

		return this.onBeforeCompile.toString();

	}

	setValues( values ) {

		if ( values === undefined ) return;

		for ( const key in values ) {

			const newValue = values[ key ];

			if ( newValue === undefined ) {

				console.warn( `THREE.Material: parameter '${ key }' has value of undefined.` );
				continue;

			}

			const currentValue = this[ key ];

			if ( currentValue === undefined ) {

				console.warn( `THREE.Material: '${ key }' is not a property of THREE.${ this.type }.` );
				continue;

			}

			if ( currentValue && currentValue.isColor ) {

				currentValue.set( newValue );

			} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {

				currentValue.copy( newValue );

			} else {

				this[ key ] = newValue;

			}

		}

	}

	toJSON( meta ) {

		const isRootObject = ( meta === undefined || typeof meta === 'string' );

		if ( isRootObject ) {

			meta = {
				textures: {},
				images: {}
			};

		}

		const data = {
			metadata: {
				version: 4.6,
				type: 'Material',
				generator: 'Material.toJSON'
			}
		};

		// standard Material serialization
		data.uuid = this.uuid;
		data.type = this.type;

		if ( this.name !== '' ) data.name = this.name;

		if ( this.color && this.color.isColor ) data.color = this.color.getHex();

		if ( this.roughness !== undefined ) data.roughness = this.roughness;
		if ( this.metalness !== undefined ) data.metalness = this.metalness;

		if ( this.sheen !== undefined ) data.sheen = this.sheen;
		if ( this.sheenColor && this.sheenColor.isColor ) data.sheenColor = this.sheenColor.getHex();
		if ( this.sheenRoughness !== undefined ) data.sheenRoughness = this.sheenRoughness;
		if ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();
		if ( this.emissiveIntensity !== undefined && this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;

		if ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();
		if ( this.specularIntensity !== undefined ) data.specularIntensity = this.specularIntensity;
		if ( this.specularColor && this.specularColor.isColor ) data.specularColor = this.specularColor.getHex();
		if ( this.shininess !== undefined ) data.shininess = this.shininess;
		if ( this.clearcoat !== undefined ) data.clearcoat = this.clearcoat;
		if ( this.clearcoatRoughness !== undefined ) data.clearcoatRoughness = this.clearcoatRoughness;

		if ( this.clearcoatMap && this.clearcoatMap.isTexture ) {

			data.clearcoatMap = this.clearcoatMap.toJSON( meta ).uuid;

		}

		if ( this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture ) {

			data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON( meta ).uuid;

		}

		if ( this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture ) {

			data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON( meta ).uuid;
			data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();

		}

		if ( this.dispersion !== undefined ) data.dispersion = this.dispersion;

		if ( this.iridescence !== undefined ) data.iridescence = this.iridescence;
		if ( this.iridescenceIOR !== undefined ) data.iridescenceIOR = this.iridescenceIOR;
		if ( this.iridescenceThicknessRange !== undefined ) data.iridescenceThicknessRange = this.iridescenceThicknessRange;

		if ( this.iridescenceMap && this.iridescenceMap.isTexture ) {

			data.iridescenceMap = this.iridescenceMap.toJSON( meta ).uuid;

		}

		if ( this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture ) {

			data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON( meta ).uuid;

		}

		if ( this.anisotropy !== undefined ) data.anisotropy = this.anisotropy;
		if ( this.anisotropyRotation !== undefined ) data.anisotropyRotation = this.anisotropyRotation;

		if ( this.anisotropyMap && this.anisotropyMap.isTexture ) {

			data.anisotropyMap = this.anisotropyMap.toJSON( meta ).uuid;

		}

		if ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;
		if ( this.matcap && this.matcap.isTexture ) data.matcap = this.matcap.toJSON( meta ).uuid;
		if ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;

		if ( this.lightMap && this.lightMap.isTexture ) {

			data.lightMap = this.lightMap.toJSON( meta ).uuid;
			data.lightMapIntensity = this.lightMapIntensity;

		}

		if ( this.aoMap && this.aoMap.isTexture ) {

			data.aoMap = this.aoMap.toJSON( meta ).uuid;
			data.aoMapIntensity = this.aoMapIntensity;

		}

		if ( this.bumpMap && this.bumpMap.isTexture ) {

			data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
			data.bumpScale = this.bumpScale;

		}

		if ( this.normalMap && this.normalMap.isTexture ) {

			data.normalMap = this.normalMap.toJSON( meta ).uuid;
			data.normalMapType = this.normalMapType;
			data.normalScale = this.normalScale.toArray();

		}

		if ( this.displacementMap && this.displacementMap.isTexture ) {

			data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
			data.displacementScale = this.displacementScale;
			data.displacementBias = this.displacementBias;

		}

		if ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
		if ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;

		if ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
		if ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;
		if ( this.specularIntensityMap && this.specularIntensityMap.isTexture ) data.specularIntensityMap = this.specularIntensityMap.toJSON( meta ).uuid;
		if ( this.specularColorMap && this.specularColorMap.isTexture ) data.specularColorMap = this.specularColorMap.toJSON( meta ).uuid;

		if ( this.envMap && this.envMap.isTexture ) {

			data.envMap = this.envMap.toJSON( meta ).uuid;

			if ( this.combine !== undefined ) data.combine = this.combine;

		}

		if ( this.envMapRotation !== undefined ) data.envMapRotation = this.envMapRotation.toArray();
		if ( this.envMapIntensity !== undefined ) data.envMapIntensity = this.envMapIntensity;
		if ( this.reflectivity !== undefined ) data.reflectivity = this.reflectivity;
		if ( this.refractionRatio !== undefined ) data.refractionRatio = this.refractionRatio;

		if ( this.gradientMap && this.gradientMap.isTexture ) {

			data.gradientMap = this.gradientMap.toJSON( meta ).uuid;

		}

		if ( this.transmission !== undefined ) data.transmission = this.transmission;
		if ( this.transmissionMap && this.transmissionMap.isTexture ) data.transmissionMap = this.transmissionMap.toJSON( meta ).uuid;
		if ( this.thickness !== undefined ) data.thickness = this.thickness;
		if ( this.thicknessMap && this.thicknessMap.isTexture ) data.thicknessMap = this.thicknessMap.toJSON( meta ).uuid;
		if ( this.attenuationDistance !== undefined && this.attenuationDistance !== Infinity ) data.attenuationDistance = this.attenuationDistance;
		if ( this.attenuationColor !== undefined ) data.attenuationColor = this.attenuationColor.getHex();

		if ( this.size !== undefined ) data.size = this.size;
		if ( this.shadowSide !== null ) data.shadowSide = this.shadowSide;
		if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

		if ( this.blending !== NormalBlending ) data.blending = this.blending;
		if ( this.side !== FrontSide ) data.side = this.side;
		if ( this.vertexColors === true ) data.vertexColors = true;

		if ( this.opacity < 1 ) data.opacity = this.opacity;
		if ( this.transparent === true ) data.transparent = true;

		if ( this.blendSrc !== SrcAlphaFactor ) data.blendSrc = this.blendSrc;
		if ( this.blendDst !== OneMinusSrcAlphaFactor ) data.blendDst = this.blendDst;
		if ( this.blendEquation !== AddEquation ) data.blendEquation = this.blendEquation;
		if ( this.blendSrcAlpha !== null ) data.blendSrcAlpha = this.blendSrcAlpha;
		if ( this.blendDstAlpha !== null ) data.blendDstAlpha = this.blendDstAlpha;
		if ( this.blendEquationAlpha !== null ) data.blendEquationAlpha = this.blendEquationAlpha;
		if ( this.blendColor && this.blendColor.isColor ) data.blendColor = this.blendColor.getHex();
		if ( this.blendAlpha !== 0 ) data.blendAlpha = this.blendAlpha;

		if ( this.depthFunc !== LessEqualDepth ) data.depthFunc = this.depthFunc;
		if ( this.depthTest === false ) data.depthTest = this.depthTest;
		if ( this.depthWrite === false ) data.depthWrite = this.depthWrite;
		if ( this.colorWrite === false ) data.colorWrite = this.colorWrite;

		if ( this.stencilWriteMask !== 0xff ) data.stencilWriteMask = this.stencilWriteMask;
		if ( this.stencilFunc !== AlwaysStencilFunc ) data.stencilFunc = this.stencilFunc;
		if ( this.stencilRef !== 0 ) data.stencilRef = this.stencilRef;
		if ( this.stencilFuncMask !== 0xff ) data.stencilFuncMask = this.stencilFuncMask;
		if ( this.stencilFail !== KeepStencilOp ) data.stencilFail = this.stencilFail;
		if ( this.stencilZFail !== KeepStencilOp ) data.stencilZFail = this.stencilZFail;
		if ( this.stencilZPass !== KeepStencilOp ) data.stencilZPass = this.stencilZPass;
		if ( this.stencilWrite === true ) data.stencilWrite = this.stencilWrite;

		// rotation (SpriteMaterial)
		if ( this.rotation !== undefined && this.rotation !== 0 ) data.rotation = this.rotation;

		if ( this.polygonOffset === true ) data.polygonOffset = true;
		if ( this.polygonOffsetFactor !== 0 ) data.polygonOffsetFactor = this.polygonOffsetFactor;
		if ( this.polygonOffsetUnits !== 0 ) data.polygonOffsetUnits = this.polygonOffsetUnits;

		if ( this.linewidth !== undefined && this.linewidth !== 1 ) data.linewidth = this.linewidth;
		if ( this.dashSize !== undefined ) data.dashSize = this.dashSize;
		if ( this.gapSize !== undefined ) data.gapSize = this.gapSize;
		if ( this.scale !== undefined ) data.scale = this.scale;

		if ( this.dithering === true ) data.dithering = true;

		if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
		if ( this.alphaHash === true ) data.alphaHash = true;
		if ( this.alphaToCoverage === true ) data.alphaToCoverage = true;
		if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = true;
		if ( this.forceSinglePass === true ) data.forceSinglePass = true;

		if ( this.wireframe === true ) data.wireframe = true;
		if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
		if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
		if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;

		if ( this.flatShading === true ) data.flatShading = true;

		if ( this.visible === false ) data.visible = false;

		if ( this.toneMapped === false ) data.toneMapped = false;

		if ( this.fog === false ) data.fog = false;

		if ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;

		// TODO: Copied from Object3D.toJSON

		function extractFromCache( cache ) {

			const values = [];

			for ( const key in cache ) {

				const data = cache[ key ];
				delete data.metadata;
				values.push( data );

			}

			return values;

		}

		if ( isRootObject ) {

			const textures = extractFromCache( meta.textures );
			const images = extractFromCache( meta.images );

			if ( textures.length > 0 ) data.textures = textures;
			if ( images.length > 0 ) data.images = images;

		}

		return data;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( source ) {

		this.name = source.name;

		this.blending = source.blending;
		this.side = source.side;
		this.vertexColors = source.vertexColors;

		this.opacity = source.opacity;
		this.transparent = source.transparent;

		this.blendSrc = source.blendSrc;
		this.blendDst = source.blendDst;
		this.blendEquation = source.blendEquation;
		this.blendSrcAlpha = source.blendSrcAlpha;
		this.blendDstAlpha = source.blendDstAlpha;
		this.blendEquationAlpha = source.blendEquationAlpha;
		this.blendColor.copy( source.blendColor );
		this.blendAlpha = source.blendAlpha;

		this.depthFunc = source.depthFunc;
		this.depthTest = source.depthTest;
		this.depthWrite = source.depthWrite;

		this.stencilWriteMask = source.stencilWriteMask;
		this.stencilFunc = source.stencilFunc;
		this.stencilRef = source.stencilRef;
		this.stencilFuncMask = source.stencilFuncMask;
		this.stencilFail = source.stencilFail;
		this.stencilZFail = source.stencilZFail;
		this.stencilZPass = source.stencilZPass;
		this.stencilWrite = source.stencilWrite;

		const srcPlanes = source.clippingPlanes;
		let dstPlanes = null;

		if ( srcPlanes !== null ) {

			const n = srcPlanes.length;
			dstPlanes = new Array( n );

			for ( let i = 0; i !== n; ++ i ) {

				dstPlanes[ i ] = srcPlanes[ i ].clone();

			}

		}

		this.clippingPlanes = dstPlanes;
		this.clipIntersection = source.clipIntersection;
		this.clipShadows = source.clipShadows;

		this.shadowSide = source.shadowSide;

		this.colorWrite = source.colorWrite;

		this.precision = source.precision;

		this.polygonOffset = source.polygonOffset;
		this.polygonOffsetFactor = source.polygonOffsetFactor;
		this.polygonOffsetUnits = source.polygonOffsetUnits;

		this.dithering = source.dithering;

		this.alphaTest = source.alphaTest;
		this.alphaHash = source.alphaHash;
		this.alphaToCoverage = source.alphaToCoverage;
		this.premultipliedAlpha = source.premultipliedAlpha;
		this.forceSinglePass = source.forceSinglePass;

		this.visible = source.visible;

		this.toneMapped = source.toneMapped;

		this.userData = JSON.parse( JSON.stringify( source.userData ) );

		return this;

	}

	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

	}

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

	onBuild( /* shaderobject, renderer */ ) {

		console.warn( 'Material: onBuild() has been removed.' ); // @deprecated, r166

	}

}

class MeshBasicMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isMeshBasicMaterial = true;

		this.type = 'MeshBasicMaterial';

		this.color = new Color( 0xffffff ); // emissive

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.envMapRotation = new Euler();
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.envMapRotation.copy( source.envMapRotation );
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.fog = source.fog;

		return this;

	}

}

// Fast Half Float Conversions, http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf

const _tables = /*@__PURE__*/ _generateTables();

function _generateTables() {

	// float32 to float16 helpers

	const buffer = new ArrayBuffer( 4 );
	const floatView = new Float32Array( buffer );
	const uint32View = new Uint32Array( buffer );

	const baseTable = new Uint32Array( 512 );
	const shiftTable = new Uint32Array( 512 );

	for ( let i = 0; i < 256; ++ i ) {

		const e = i - 127;

		// very small number (0, -0)

		if ( e < -27 ) {

			baseTable[ i ] = 0x0000;
			baseTable[ i | 0x100 ] = 0x8000;
			shiftTable[ i ] = 24;
			shiftTable[ i | 0x100 ] = 24;

			// small number (denorm)

		} else if ( e < -14 ) {

			baseTable[ i ] = 0x0400 >> ( - e - 14 );
			baseTable[ i | 0x100 ] = ( 0x0400 >> ( - e - 14 ) ) | 0x8000;
			shiftTable[ i ] = - e - 1;
			shiftTable[ i | 0x100 ] = - e - 1;

			// normal number

		} else if ( e <= 15 ) {

			baseTable[ i ] = ( e + 15 ) << 10;
			baseTable[ i | 0x100 ] = ( ( e + 15 ) << 10 ) | 0x8000;
			shiftTable[ i ] = 13;
			shiftTable[ i | 0x100 ] = 13;

			// large number (Infinity, -Infinity)

		} else if ( e < 128 ) {

			baseTable[ i ] = 0x7c00;
			baseTable[ i | 0x100 ] = 0xfc00;
			shiftTable[ i ] = 24;
			shiftTable[ i | 0x100 ] = 24;

			// stay (NaN, Infinity, -Infinity)

		} else {

			baseTable[ i ] = 0x7c00;
			baseTable[ i | 0x100 ] = 0xfc00;
			shiftTable[ i ] = 13;
			shiftTable[ i | 0x100 ] = 13;

		}

	}

	// float16 to float32 helpers

	const mantissaTable = new Uint32Array( 2048 );
	const exponentTable = new Uint32Array( 64 );
	const offsetTable = new Uint32Array( 64 );

	for ( let i = 1; i < 1024; ++ i ) {

		let m = i << 13; // zero pad mantissa bits
		let e = 0; // zero exponent

		// normalized
		while ( ( m & 0x00800000 ) === 0 ) {

			m <<= 1;
			e -= 0x00800000; // decrement exponent

		}

		m &= -8388609; // clear leading 1 bit
		e += 0x38800000; // adjust bias

		mantissaTable[ i ] = m | e;

	}

	for ( let i = 1024; i < 2048; ++ i ) {

		mantissaTable[ i ] = 0x38000000 + ( ( i - 1024 ) << 13 );

	}

	for ( let i = 1; i < 31; ++ i ) {

		exponentTable[ i ] = i << 23;

	}

	exponentTable[ 31 ] = 0x47800000;
	exponentTable[ 32 ] = 0x80000000;

	for ( let i = 33; i < 63; ++ i ) {

		exponentTable[ i ] = 0x80000000 + ( ( i - 32 ) << 23 );

	}

	exponentTable[ 63 ] = 0xc7800000;

	for ( let i = 1; i < 64; ++ i ) {

		if ( i !== 32 ) {

			offsetTable[ i ] = 1024;

		}

	}

	return {
		floatView: floatView,
		uint32View: uint32View,
		baseTable: baseTable,
		shiftTable: shiftTable,
		mantissaTable: mantissaTable,
		exponentTable: exponentTable,
		offsetTable: offsetTable
	};

}

// float32 to float16

function toHalfFloat( val ) {

	if ( Math.abs( val ) > 65504 ) console.warn( 'THREE.DataUtils.toHalfFloat(): Value out of range.' );

	val = clamp$1( val, -65504, 65504 );

	_tables.floatView[ 0 ] = val;
	const f = _tables.uint32View[ 0 ];
	const e = ( f >> 23 ) & 0x1ff;
	return _tables.baseTable[ e ] + ( ( f & 0x007fffff ) >> _tables.shiftTable[ e ] );

}

// float16 to float32

function fromHalfFloat( val ) {

	const m = val >> 10;
	_tables.uint32View[ 0 ] = _tables.mantissaTable[ _tables.offsetTable[ m ] + ( val & 0x3ff ) ] + _tables.exponentTable[ m ];
	return _tables.floatView[ 0 ];

}

const _vector$9 = /*@__PURE__*/ new Vector3();
const _vector2$1 = /*@__PURE__*/ new Vector2();

class BufferAttribute {

	constructor( array, itemSize, normalized = false ) {

		if ( Array.isArray( array ) ) {

			throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

		}

		this.isBufferAttribute = true;

		this.name = '';

		this.array = array;
		this.itemSize = itemSize;
		this.count = array !== undefined ? array.length / itemSize : 0;
		this.normalized = normalized;

		this.usage = StaticDrawUsage;
		this.updateRanges = [];
		this.gpuType = FloatType;

		this.version = 0;

	}

	onUploadCallback() {}

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

	setUsage( value ) {

		this.usage = value;

		return this;

	}

	addUpdateRange( start, count ) {

		this.updateRanges.push( { start, count } );

	}

	clearUpdateRanges() {

		this.updateRanges.length = 0;

	}

	copy( source ) {

		this.name = source.name;
		this.array = new source.array.constructor( source.array );
		this.itemSize = source.itemSize;
		this.count = source.count;
		this.normalized = source.normalized;

		this.usage = source.usage;
		this.gpuType = source.gpuType;

		return this;

	}

	copyAt( index1, attribute, index2 ) {

		index1 *= this.itemSize;
		index2 *= attribute.itemSize;

		for ( let i = 0, l = this.itemSize; i < l; i ++ ) {

			this.array[ index1 + i ] = attribute.array[ index2 + i ];

		}

		return this;

	}

	copyArray( array ) {

		this.array.set( array );

		return this;

	}

	applyMatrix3( m ) {

		if ( this.itemSize === 2 ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector2$1.fromBufferAttribute( this, i );
				_vector2$1.applyMatrix3( m );

				this.setXY( i, _vector2$1.x, _vector2$1.y );

			}

		} else if ( this.itemSize === 3 ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector$9.fromBufferAttribute( this, i );
				_vector$9.applyMatrix3( m );

				this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

			}

		}

		return this;

	}

	applyMatrix4( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$9.fromBufferAttribute( this, i );

			_vector$9.applyMatrix4( m );

			this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

		}

		return this;

	}

	applyNormalMatrix( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$9.fromBufferAttribute( this, i );

			_vector$9.applyNormalMatrix( m );

			this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

		}

		return this;

	}

	transformDirection( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$9.fromBufferAttribute( this, i );

			_vector$9.transformDirection( m );

			this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

		}

		return this;

	}

	set( value, offset = 0 ) {

		// Matching BufferAttribute constructor, do not normalize the array.
		this.array.set( value, offset );

		return this;

	}

	getComponent( index, component ) {

		let value = this.array[ index * this.itemSize + component ];

		if ( this.normalized ) value = denormalize( value, this.array );

		return value;

	}

	setComponent( index, component, value ) {

		if ( this.normalized ) value = normalize$2( value, this.array );

		this.array[ index * this.itemSize + component ] = value;

		return this;

	}

	getX( index ) {

		let x = this.array[ index * this.itemSize ];

		if ( this.normalized ) x = denormalize( x, this.array );

		return x;

	}

	setX( index, x ) {

		if ( this.normalized ) x = normalize$2( x, this.array );

		this.array[ index * this.itemSize ] = x;

		return this;

	}

	getY( index ) {

		let y = this.array[ index * this.itemSize + 1 ];

		if ( this.normalized ) y = denormalize( y, this.array );

		return y;

	}

	setY( index, y ) {

		if ( this.normalized ) y = normalize$2( y, this.array );

		this.array[ index * this.itemSize + 1 ] = y;

		return this;

	}

	getZ( index ) {

		let z = this.array[ index * this.itemSize + 2 ];

		if ( this.normalized ) z = denormalize( z, this.array );

		return z;

	}

	setZ( index, z ) {

		if ( this.normalized ) z = normalize$2( z, this.array );

		this.array[ index * this.itemSize + 2 ] = z;

		return this;

	}

	getW( index ) {

		let w = this.array[ index * this.itemSize + 3 ];

		if ( this.normalized ) w = denormalize( w, this.array );

		return w;

	}

	setW( index, w ) {

		if ( this.normalized ) w = normalize$2( w, this.array );

		this.array[ index * this.itemSize + 3 ] = w;

		return this;

	}

	setXY( index, x, y ) {

		index *= this.itemSize;

		if ( this.normalized ) {

			x = normalize$2( x, this.array );
			y = normalize$2( y, this.array );

		}

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;

		return this;

	}

	setXYZ( index, x, y, z ) {

		index *= this.itemSize;

		if ( this.normalized ) {

			x = normalize$2( x, this.array );
			y = normalize$2( y, this.array );
			z = normalize$2( z, this.array );

		}

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;

		return this;

	}

	setXYZW( index, x, y, z, w ) {

		index *= this.itemSize;

		if ( this.normalized ) {

			x = normalize$2( x, this.array );
			y = normalize$2( y, this.array );
			z = normalize$2( z, this.array );
			w = normalize$2( w, this.array );

		}

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;
		this.array[ index + 3 ] = w;

		return this;

	}

	onUpload( callback ) {

		this.onUploadCallback = callback;

		return this;

	}

	clone() {

		return new this.constructor( this.array, this.itemSize ).copy( this );

	}

	toJSON() {

		const data = {
			itemSize: this.itemSize,
			type: this.array.constructor.name,
			array: Array.from( this.array ),
			normalized: this.normalized
		};

		if ( this.name !== '' ) data.name = this.name;
		if ( this.usage !== StaticDrawUsage ) data.usage = this.usage;

		return data;

	}

}

class Uint16BufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Uint16Array( array ), itemSize, normalized );

	}

}

class Uint32BufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Uint32Array( array ), itemSize, normalized );

	}

}

class Float16BufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Uint16Array( array ), itemSize, normalized );

		this.isFloat16BufferAttribute = true;

	}

	getX( index ) {

		let x = fromHalfFloat( this.array[ index * this.itemSize ] );

		if ( this.normalized ) x = denormalize( x, this.array );

		return x;

	}

	setX( index, x ) {

		if ( this.normalized ) x = normalize$2( x, this.array );

		this.array[ index * this.itemSize ] = toHalfFloat( x );

		return this;

	}

	getY( index ) {

		let y = fromHalfFloat( this.array[ index * this.itemSize + 1 ] );

		if ( this.normalized ) y = denormalize( y, this.array );

		return y;

	}

	setY( index, y ) {

		if ( this.normalized ) y = normalize$2( y, this.array );

		this.array[ index * this.itemSize + 1 ] = toHalfFloat( y );

		return this;

	}

	getZ( index ) {

		let z = fromHalfFloat( this.array[ index * this.itemSize + 2 ] );

		if ( this.normalized ) z = denormalize( z, this.array );

		return z;

	}

	setZ( index, z ) {

		if ( this.normalized ) z = normalize$2( z, this.array );

		this.array[ index * this.itemSize + 2 ] = toHalfFloat( z );

		return this;

	}

	getW( index ) {

		let w = fromHalfFloat( this.array[ index * this.itemSize + 3 ] );

		if ( this.normalized ) w = denormalize( w, this.array );

		return w;

	}

	setW( index, w ) {

		if ( this.normalized ) w = normalize$2( w, this.array );

		this.array[ index * this.itemSize + 3 ] = toHalfFloat( w );

		return this;

	}

	setXY( index, x, y ) {

		index *= this.itemSize;

		if ( this.normalized ) {

			x = normalize$2( x, this.array );
			y = normalize$2( y, this.array );

		}

		this.array[ index + 0 ] = toHalfFloat( x );
		this.array[ index + 1 ] = toHalfFloat( y );

		return this;

	}

	setXYZ( index, x, y, z ) {

		index *= this.itemSize;

		if ( this.normalized ) {

			x = normalize$2( x, this.array );
			y = normalize$2( y, this.array );
			z = normalize$2( z, this.array );

		}

		this.array[ index + 0 ] = toHalfFloat( x );
		this.array[ index + 1 ] = toHalfFloat( y );
		this.array[ index + 2 ] = toHalfFloat( z );

		return this;

	}

	setXYZW( index, x, y, z, w ) {

		index *= this.itemSize;

		if ( this.normalized ) {

			x = normalize$2( x, this.array );
			y = normalize$2( y, this.array );
			z = normalize$2( z, this.array );
			w = normalize$2( w, this.array );

		}

		this.array[ index + 0 ] = toHalfFloat( x );
		this.array[ index + 1 ] = toHalfFloat( y );
		this.array[ index + 2 ] = toHalfFloat( z );
		this.array[ index + 3 ] = toHalfFloat( w );

		return this;

	}

}


class Float32BufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Float32Array( array ), itemSize, normalized );

	}

}

let _id$1$1 = 0;

const _m1$3 = /*@__PURE__*/ new Matrix4();
const _obj = /*@__PURE__*/ new Object3D();
const _offset = /*@__PURE__*/ new Vector3();
const _box$2 = /*@__PURE__*/ new Box3();
const _boxMorphTargets = /*@__PURE__*/ new Box3();
const _vector$8 = /*@__PURE__*/ new Vector3();

class BufferGeometry extends EventDispatcher {

	constructor() {

		super();

		this.isBufferGeometry = true;

		Object.defineProperty( this, 'id', { value: _id$1$1 ++ } );

		this.uuid = generateUUID();

		this.name = '';
		this.type = 'BufferGeometry';

		this.index = null;
		this.indirect = null;
		this.attributes = {};

		this.morphAttributes = {};
		this.morphTargetsRelative = false;

		this.groups = [];

		this.boundingBox = null;
		this.boundingSphere = null;

		this.drawRange = { start: 0, count: Infinity };

		this.userData = {};

	}

	getIndex() {

		return this.index;

	}

	setIndex( index ) {

		if ( Array.isArray( index ) ) {

			this.index = new ( arrayNeedsUint32$1( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );

		} else {

			this.index = index;

		}

		return this;

	}

	setIndirect( indirect ) {

		this.indirect = indirect;

		return this;

	}

	getIndirect() {

		return this.indirect;

	}

	getAttribute( name ) {

		return this.attributes[ name ];

	}

	setAttribute( name, attribute ) {

		this.attributes[ name ] = attribute;

		return this;

	}

	deleteAttribute( name ) {

		delete this.attributes[ name ];

		return this;

	}

	hasAttribute( name ) {

		return this.attributes[ name ] !== undefined;

	}

	addGroup( start, count, materialIndex = 0 ) {

		this.groups.push( {

			start: start,
			count: count,
			materialIndex: materialIndex

		} );

	}

	clearGroups() {

		this.groups = [];

	}

	setDrawRange( start, count ) {

		this.drawRange.start = start;
		this.drawRange.count = count;

	}

	applyMatrix4( matrix ) {

		const position = this.attributes.position;

		if ( position !== undefined ) {

			position.applyMatrix4( matrix );

			position.needsUpdate = true;

		}

		const normal = this.attributes.normal;

		if ( normal !== undefined ) {

			const normalMatrix = new Matrix3().getNormalMatrix( matrix );

			normal.applyNormalMatrix( normalMatrix );

			normal.needsUpdate = true;

		}

		const tangent = this.attributes.tangent;

		if ( tangent !== undefined ) {

			tangent.transformDirection( matrix );

			tangent.needsUpdate = true;

		}

		if ( this.boundingBox !== null ) {

			this.computeBoundingBox();

		}

		if ( this.boundingSphere !== null ) {

			this.computeBoundingSphere();

		}

		return this;

	}

	applyQuaternion( q ) {

		_m1$3.makeRotationFromQuaternion( q );

		this.applyMatrix4( _m1$3 );

		return this;

	}

	rotateX( angle ) {

		// rotate geometry around world x-axis

		_m1$3.makeRotationX( angle );

		this.applyMatrix4( _m1$3 );

		return this;

	}

	rotateY( angle ) {

		// rotate geometry around world y-axis

		_m1$3.makeRotationY( angle );

		this.applyMatrix4( _m1$3 );

		return this;

	}

	rotateZ( angle ) {

		// rotate geometry around world z-axis

		_m1$3.makeRotationZ( angle );

		this.applyMatrix4( _m1$3 );

		return this;

	}

	translate( x, y, z ) {

		// translate geometry

		_m1$3.makeTranslation( x, y, z );

		this.applyMatrix4( _m1$3 );

		return this;

	}

	scale( x, y, z ) {

		// scale geometry

		_m1$3.makeScale( x, y, z );

		this.applyMatrix4( _m1$3 );

		return this;

	}

	lookAt( vector ) {

		_obj.lookAt( vector );

		_obj.updateMatrix();

		this.applyMatrix4( _obj.matrix );

		return this;

	}

	center() {

		this.computeBoundingBox();

		this.boundingBox.getCenter( _offset ).negate();

		this.translate( _offset.x, _offset.y, _offset.z );

		return this;

	}

	setFromPoints( points ) {

		const positionAttribute = this.getAttribute( 'position' );

		if ( positionAttribute === undefined ) {

			const position = [];

			for ( let i = 0, l = points.length; i < l; i ++ ) {

				const point = points[ i ];
				position.push( point.x, point.y, point.z || 0 );

			}

			this.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );

		} else {

			const l = Math.min( points.length, positionAttribute.count ); // make sure data do not exceed buffer size

			for ( let i = 0; i < l; i ++ ) {

				const point = points[ i ];
				positionAttribute.setXYZ( i, point.x, point.y, point.z || 0 );

			}

			if ( points.length > positionAttribute.count ) {

				console.warn( 'THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.' );

			}

			positionAttribute.needsUpdate = true;

		}

		return this;

	}

	computeBoundingBox() {

		if ( this.boundingBox === null ) {

			this.boundingBox = new Box3();

		}

		const position = this.attributes.position;
		const morphAttributesPosition = this.morphAttributes.position;

		if ( position && position.isGLBufferAttribute ) {

			console.error( 'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.', this );

			this.boundingBox.set(
				new Vector3( - Infinity, - Infinity, - Infinity ),
				new Vector3( + Infinity, + Infinity, + Infinity )
			);

			return;

		}

		if ( position !== undefined ) {

			this.boundingBox.setFromBufferAttribute( position );

			// process morph attributes if present

			if ( morphAttributesPosition ) {

				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

					const morphAttribute = morphAttributesPosition[ i ];
					_box$2.setFromBufferAttribute( morphAttribute );

					if ( this.morphTargetsRelative ) {

						_vector$8.addVectors( this.boundingBox.min, _box$2.min );
						this.boundingBox.expandByPoint( _vector$8 );

						_vector$8.addVectors( this.boundingBox.max, _box$2.max );
						this.boundingBox.expandByPoint( _vector$8 );

					} else {

						this.boundingBox.expandByPoint( _box$2.min );
						this.boundingBox.expandByPoint( _box$2.max );

					}

				}

			}

		} else {

			this.boundingBox.makeEmpty();

		}

		if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

			console.error( 'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

		}

	}

	computeBoundingSphere() {

		if ( this.boundingSphere === null ) {

			this.boundingSphere = new Sphere();

		}

		const position = this.attributes.position;
		const morphAttributesPosition = this.morphAttributes.position;

		if ( position && position.isGLBufferAttribute ) {

			console.error( 'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.', this );

			this.boundingSphere.set( new Vector3(), Infinity );

			return;

		}

		if ( position ) {

			// first, find the center of the bounding sphere

			const center = this.boundingSphere.center;

			_box$2.setFromBufferAttribute( position );

			// process morph attributes if present

			if ( morphAttributesPosition ) {

				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

					const morphAttribute = morphAttributesPosition[ i ];
					_boxMorphTargets.setFromBufferAttribute( morphAttribute );

					if ( this.morphTargetsRelative ) {

						_vector$8.addVectors( _box$2.min, _boxMorphTargets.min );
						_box$2.expandByPoint( _vector$8 );

						_vector$8.addVectors( _box$2.max, _boxMorphTargets.max );
						_box$2.expandByPoint( _vector$8 );

					} else {

						_box$2.expandByPoint( _boxMorphTargets.min );
						_box$2.expandByPoint( _boxMorphTargets.max );

					}

				}

			}

			_box$2.getCenter( center );

			// second, try to find a boundingSphere with a radius smaller than the
			// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

			let maxRadiusSq = 0;

			for ( let i = 0, il = position.count; i < il; i ++ ) {

				_vector$8.fromBufferAttribute( position, i );

				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );

			}

			// process morph attributes if present

			if ( morphAttributesPosition ) {

				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

					const morphAttribute = morphAttributesPosition[ i ];
					const morphTargetsRelative = this.morphTargetsRelative;

					for ( let j = 0, jl = morphAttribute.count; j < jl; j ++ ) {

						_vector$8.fromBufferAttribute( morphAttribute, j );

						if ( morphTargetsRelative ) {

							_offset.fromBufferAttribute( position, j );
							_vector$8.add( _offset );

						}

						maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );

					}

				}

			}

			this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

			if ( isNaN( this.boundingSphere.radius ) ) {

				console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

			}

		}

	}

	computeTangents() {

		const index = this.index;
		const attributes = this.attributes;

		// based on http://www.terathon.com/code/tangent.html
		// (per vertex tangents)

		if ( index === null ||
			 attributes.position === undefined ||
			 attributes.normal === undefined ||
			 attributes.uv === undefined ) {

			console.error( 'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)' );
			return;

		}

		const positionAttribute = attributes.position;
		const normalAttribute = attributes.normal;
		const uvAttribute = attributes.uv;

		if ( this.hasAttribute( 'tangent' ) === false ) {

			this.setAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * positionAttribute.count ), 4 ) );

		}

		const tangentAttribute = this.getAttribute( 'tangent' );

		const tan1 = [], tan2 = [];

		for ( let i = 0; i < positionAttribute.count; i ++ ) {

			tan1[ i ] = new Vector3();
			tan2[ i ] = new Vector3();

		}

		const vA = new Vector3(),
			vB = new Vector3(),
			vC = new Vector3(),

			uvA = new Vector2(),
			uvB = new Vector2(),
			uvC = new Vector2(),

			sdir = new Vector3(),
			tdir = new Vector3();

		function handleTriangle( a, b, c ) {

			vA.fromBufferAttribute( positionAttribute, a );
			vB.fromBufferAttribute( positionAttribute, b );
			vC.fromBufferAttribute( positionAttribute, c );

			uvA.fromBufferAttribute( uvAttribute, a );
			uvB.fromBufferAttribute( uvAttribute, b );
			uvC.fromBufferAttribute( uvAttribute, c );

			vB.sub( vA );
			vC.sub( vA );

			uvB.sub( uvA );
			uvC.sub( uvA );

			const r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );

			// silently ignore degenerate uv triangles having coincident or colinear vertices

			if ( ! isFinite( r ) ) return;

			sdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );
			tdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );

			tan1[ a ].add( sdir );
			tan1[ b ].add( sdir );
			tan1[ c ].add( sdir );

			tan2[ a ].add( tdir );
			tan2[ b ].add( tdir );
			tan2[ c ].add( tdir );

		}

		let groups = this.groups;

		if ( groups.length === 0 ) {

			groups = [ {
				start: 0,
				count: index.count
			} ];

		}

		for ( let i = 0, il = groups.length; i < il; ++ i ) {

			const group = groups[ i ];

			const start = group.start;
			const count = group.count;

			for ( let j = start, jl = start + count; j < jl; j += 3 ) {

				handleTriangle(
					index.getX( j + 0 ),
					index.getX( j + 1 ),
					index.getX( j + 2 )
				);

			}

		}

		const tmp = new Vector3(), tmp2 = new Vector3();
		const n = new Vector3(), n2 = new Vector3();

		function handleVertex( v ) {

			n.fromBufferAttribute( normalAttribute, v );
			n2.copy( n );

			const t = tan1[ v ];

			// Gram-Schmidt orthogonalize

			tmp.copy( t );
			tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

			// Calculate handedness

			tmp2.crossVectors( n2, t );
			const test = tmp2.dot( tan2[ v ] );
			const w = ( test < 0.0 ) ? -1 : 1.0;

			tangentAttribute.setXYZW( v, tmp.x, tmp.y, tmp.z, w );

		}

		for ( let i = 0, il = groups.length; i < il; ++ i ) {

			const group = groups[ i ];

			const start = group.start;
			const count = group.count;

			for ( let j = start, jl = start + count; j < jl; j += 3 ) {

				handleVertex( index.getX( j + 0 ) );
				handleVertex( index.getX( j + 1 ) );
				handleVertex( index.getX( j + 2 ) );

			}

		}

	}

	computeVertexNormals() {

		const index = this.index;
		const positionAttribute = this.getAttribute( 'position' );

		if ( positionAttribute !== undefined ) {

			let normalAttribute = this.getAttribute( 'normal' );

			if ( normalAttribute === undefined ) {

				normalAttribute = new BufferAttribute( new Float32Array( positionAttribute.count * 3 ), 3 );
				this.setAttribute( 'normal', normalAttribute );

			} else {

				// reset existing normals to zero

				for ( let i = 0, il = normalAttribute.count; i < il; i ++ ) {

					normalAttribute.setXYZ( i, 0, 0, 0 );

				}

			}

			const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
			const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
			const cb = new Vector3(), ab = new Vector3();

			// indexed elements

			if ( index ) {

				for ( let i = 0, il = index.count; i < il; i += 3 ) {

					const vA = index.getX( i + 0 );
					const vB = index.getX( i + 1 );
					const vC = index.getX( i + 2 );

					pA.fromBufferAttribute( positionAttribute, vA );
					pB.fromBufferAttribute( positionAttribute, vB );
					pC.fromBufferAttribute( positionAttribute, vC );

					cb.subVectors( pC, pB );
					ab.subVectors( pA, pB );
					cb.cross( ab );

					nA.fromBufferAttribute( normalAttribute, vA );
					nB.fromBufferAttribute( normalAttribute, vB );
					nC.fromBufferAttribute( normalAttribute, vC );

					nA.add( cb );
					nB.add( cb );
					nC.add( cb );

					normalAttribute.setXYZ( vA, nA.x, nA.y, nA.z );
					normalAttribute.setXYZ( vB, nB.x, nB.y, nB.z );
					normalAttribute.setXYZ( vC, nC.x, nC.y, nC.z );

				}

			} else {

				// non-indexed elements (unconnected triangle soup)

				for ( let i = 0, il = positionAttribute.count; i < il; i += 3 ) {

					pA.fromBufferAttribute( positionAttribute, i + 0 );
					pB.fromBufferAttribute( positionAttribute, i + 1 );
					pC.fromBufferAttribute( positionAttribute, i + 2 );

					cb.subVectors( pC, pB );
					ab.subVectors( pA, pB );
					cb.cross( ab );

					normalAttribute.setXYZ( i + 0, cb.x, cb.y, cb.z );
					normalAttribute.setXYZ( i + 1, cb.x, cb.y, cb.z );
					normalAttribute.setXYZ( i + 2, cb.x, cb.y, cb.z );

				}

			}

			this.normalizeNormals();

			normalAttribute.needsUpdate = true;

		}

	}

	normalizeNormals() {

		const normals = this.attributes.normal;

		for ( let i = 0, il = normals.count; i < il; i ++ ) {

			_vector$8.fromBufferAttribute( normals, i );

			_vector$8.normalize();

			normals.setXYZ( i, _vector$8.x, _vector$8.y, _vector$8.z );

		}

	}

	toNonIndexed() {

		function convertBufferAttribute( attribute, indices ) {

			const array = attribute.array;
			const itemSize = attribute.itemSize;
			const normalized = attribute.normalized;

			const array2 = new array.constructor( indices.length * itemSize );

			let index = 0, index2 = 0;

			for ( let i = 0, l = indices.length; i < l; i ++ ) {

				if ( attribute.isInterleavedBufferAttribute ) {

					index = indices[ i ] * attribute.data.stride + attribute.offset;

				} else {

					index = indices[ i ] * itemSize;

				}

				for ( let j = 0; j < itemSize; j ++ ) {

					array2[ index2 ++ ] = array[ index ++ ];

				}

			}

			return new BufferAttribute( array2, itemSize, normalized );

		}

		//

		if ( this.index === null ) {

			console.warn( 'THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.' );
			return this;

		}

		const geometry2 = new BufferGeometry();

		const indices = this.index.array;
		const attributes = this.attributes;

		// attributes

		for ( const name in attributes ) {

			const attribute = attributes[ name ];

			const newAttribute = convertBufferAttribute( attribute, indices );

			geometry2.setAttribute( name, newAttribute );

		}

		// morph attributes

		const morphAttributes = this.morphAttributes;

		for ( const name in morphAttributes ) {

			const morphArray = [];
			const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

			for ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {

				const attribute = morphAttribute[ i ];

				const newAttribute = convertBufferAttribute( attribute, indices );

				morphArray.push( newAttribute );

			}

			geometry2.morphAttributes[ name ] = morphArray;

		}

		geometry2.morphTargetsRelative = this.morphTargetsRelative;

		// groups

		const groups = this.groups;

		for ( let i = 0, l = groups.length; i < l; i ++ ) {

			const group = groups[ i ];
			geometry2.addGroup( group.start, group.count, group.materialIndex );

		}

		return geometry2;

	}

	toJSON() {

		const data = {
			metadata: {
				version: 4.6,
				type: 'BufferGeometry',
				generator: 'BufferGeometry.toJSON'
			}
		};

		// standard BufferGeometry serialization

		data.uuid = this.uuid;
		data.type = this.type;
		if ( this.name !== '' ) data.name = this.name;
		if ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;

		if ( this.parameters !== undefined ) {

			const parameters = this.parameters;

			for ( const key in parameters ) {

				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

			}

			return data;

		}

		// for simplicity the code assumes attributes are not shared across geometries, see #15811

		data.data = { attributes: {} };

		const index = this.index;

		if ( index !== null ) {

			data.data.index = {
				type: index.array.constructor.name,
				array: Array.prototype.slice.call( index.array )
			};

		}

		const attributes = this.attributes;

		for ( const key in attributes ) {

			const attribute = attributes[ key ];

			data.data.attributes[ key ] = attribute.toJSON( data.data );

		}

		const morphAttributes = {};
		let hasMorphAttributes = false;

		for ( const key in this.morphAttributes ) {

			const attributeArray = this.morphAttributes[ key ];

			const array = [];

			for ( let i = 0, il = attributeArray.length; i < il; i ++ ) {

				const attribute = attributeArray[ i ];

				array.push( attribute.toJSON( data.data ) );

			}

			if ( array.length > 0 ) {

				morphAttributes[ key ] = array;

				hasMorphAttributes = true;

			}

		}

		if ( hasMorphAttributes ) {

			data.data.morphAttributes = morphAttributes;
			data.data.morphTargetsRelative = this.morphTargetsRelative;

		}

		const groups = this.groups;

		if ( groups.length > 0 ) {

			data.data.groups = JSON.parse( JSON.stringify( groups ) );

		}

		const boundingSphere = this.boundingSphere;

		if ( boundingSphere !== null ) {

			data.data.boundingSphere = {
				center: boundingSphere.center.toArray(),
				radius: boundingSphere.radius
			};

		}

		return data;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( source ) {

		// reset

		this.index = null;
		this.attributes = {};
		this.morphAttributes = {};
		this.groups = [];
		this.boundingBox = null;
		this.boundingSphere = null;

		// used for storing cloned, shared data

		const data = {};

		// name

		this.name = source.name;

		// index

		const index = source.index;

		if ( index !== null ) {

			this.setIndex( index.clone( data ) );

		}

		// attributes

		const attributes = source.attributes;

		for ( const name in attributes ) {

			const attribute = attributes[ name ];
			this.setAttribute( name, attribute.clone( data ) );

		}

		// morph attributes

		const morphAttributes = source.morphAttributes;

		for ( const name in morphAttributes ) {

			const array = [];
			const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

			for ( let i = 0, l = morphAttribute.length; i < l; i ++ ) {

				array.push( morphAttribute[ i ].clone( data ) );

			}

			this.morphAttributes[ name ] = array;

		}

		this.morphTargetsRelative = source.morphTargetsRelative;

		// groups

		const groups = source.groups;

		for ( let i = 0, l = groups.length; i < l; i ++ ) {

			const group = groups[ i ];
			this.addGroup( group.start, group.count, group.materialIndex );

		}

		// bounding box

		const boundingBox = source.boundingBox;

		if ( boundingBox !== null ) {

			this.boundingBox = boundingBox.clone();

		}

		// bounding sphere

		const boundingSphere = source.boundingSphere;

		if ( boundingSphere !== null ) {

			this.boundingSphere = boundingSphere.clone();

		}

		// draw range

		this.drawRange.start = source.drawRange.start;
		this.drawRange.count = source.drawRange.count;

		// user data

		this.userData = source.userData;

		return this;

	}

	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

	}

}

const _inverseMatrix$3 = /*@__PURE__*/ new Matrix4();
const _ray$3 = /*@__PURE__*/ new Ray();
const _sphere$6 = /*@__PURE__*/ new Sphere();
const _sphereHitAt = /*@__PURE__*/ new Vector3();

const _vA$1 = /*@__PURE__*/ new Vector3();
const _vB$1 = /*@__PURE__*/ new Vector3();
const _vC$1 = /*@__PURE__*/ new Vector3();

const _tempA = /*@__PURE__*/ new Vector3();
const _morphA = /*@__PURE__*/ new Vector3();

const _intersectionPoint = /*@__PURE__*/ new Vector3();
const _intersectionPointWorld = /*@__PURE__*/ new Vector3();

class Mesh extends Object3D {

	constructor( geometry = new BufferGeometry(), material = new MeshBasicMaterial() ) {

		super();

		this.isMesh = true;

		this.type = 'Mesh';

		this.geometry = geometry;
		this.material = material;

		this.updateMorphTargets();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		if ( source.morphTargetInfluences !== undefined ) {

			this.morphTargetInfluences = source.morphTargetInfluences.slice();

		}

		if ( source.morphTargetDictionary !== undefined ) {

			this.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );

		}

		this.material = Array.isArray( source.material ) ? source.material.slice() : source.material;
		this.geometry = source.geometry;

		return this;

	}

	updateMorphTargets() {

		const geometry = this.geometry;

		const morphAttributes = geometry.morphAttributes;
		const keys = Object.keys( morphAttributes );

		if ( keys.length > 0 ) {

			const morphAttribute = morphAttributes[ keys[ 0 ] ];

			if ( morphAttribute !== undefined ) {

				this.morphTargetInfluences = [];
				this.morphTargetDictionary = {};

				for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

					const name = morphAttribute[ m ].name || String( m );

					this.morphTargetInfluences.push( 0 );
					this.morphTargetDictionary[ name ] = m;

				}

			}

		}

	}

	getVertexPosition( index, target ) {

		const geometry = this.geometry;
		const position = geometry.attributes.position;
		const morphPosition = geometry.morphAttributes.position;
		const morphTargetsRelative = geometry.morphTargetsRelative;

		target.fromBufferAttribute( position, index );

		const morphInfluences = this.morphTargetInfluences;

		if ( morphPosition && morphInfluences ) {

			_morphA.set( 0, 0, 0 );

			for ( let i = 0, il = morphPosition.length; i < il; i ++ ) {

				const influence = morphInfluences[ i ];
				const morphAttribute = morphPosition[ i ];

				if ( influence === 0 ) continue;

				_tempA.fromBufferAttribute( morphAttribute, index );

				if ( morphTargetsRelative ) {

					_morphA.addScaledVector( _tempA, influence );

				} else {

					_morphA.addScaledVector( _tempA.sub( target ), influence );

				}

			}

			target.add( _morphA );

		}

		return target;

	}

	raycast( raycaster, intersects ) {

		const geometry = this.geometry;
		const material = this.material;
		const matrixWorld = this.matrixWorld;

		if ( material === undefined ) return;

		// test with bounding sphere in world space

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere$6.copy( geometry.boundingSphere );
		_sphere$6.applyMatrix4( matrixWorld );

		// check distance from ray origin to bounding sphere

		_ray$3.copy( raycaster.ray ).recast( raycaster.near );

		if ( _sphere$6.containsPoint( _ray$3.origin ) === false ) {

			if ( _ray$3.intersectSphere( _sphere$6, _sphereHitAt ) === null ) return;

			if ( _ray$3.origin.distanceToSquared( _sphereHitAt ) > ( raycaster.far - raycaster.near ) ** 2 ) return;

		}

		// convert ray to local space of mesh

		_inverseMatrix$3.copy( matrixWorld ).invert();
		_ray$3.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$3 );

		// test with bounding box in local space

		if ( geometry.boundingBox !== null ) {

			if ( _ray$3.intersectsBox( geometry.boundingBox ) === false ) return;

		}

		// test for intersections with geometry

		this._computeIntersections( raycaster, intersects, _ray$3 );

	}

	_computeIntersections( raycaster, intersects, rayLocalSpace ) {

		let intersection;

		const geometry = this.geometry;
		const material = this.material;

		const index = geometry.index;
		const position = geometry.attributes.position;
		const uv = geometry.attributes.uv;
		const uv1 = geometry.attributes.uv1;
		const normal = geometry.attributes.normal;
		const groups = geometry.groups;
		const drawRange = geometry.drawRange;

		if ( index !== null ) {

			// indexed buffer geometry

			if ( Array.isArray( material ) ) {

				for ( let i = 0, il = groups.length; i < il; i ++ ) {

					const group = groups[ i ];
					const groupMaterial = material[ group.materialIndex ];

					const start = Math.max( group.start, drawRange.start );
					const end = Math.min( index.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );

					for ( let j = start, jl = end; j < jl; j += 3 ) {

						const a = index.getX( j );
						const b = index.getX( j + 1 );
						const c = index.getX( j + 2 );

						intersection = checkGeometryIntersection( this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );

						if ( intersection ) {

							intersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics
							intersection.face.materialIndex = group.materialIndex;
							intersects.push( intersection );

						}

					}

				}

			} else {

				const start = Math.max( 0, drawRange.start );
				const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

				for ( let i = start, il = end; i < il; i += 3 ) {

					const a = index.getX( i );
					const b = index.getX( i + 1 );
					const c = index.getX( i + 2 );

					intersection = checkGeometryIntersection( this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );

					if ( intersection ) {

						intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics
						intersects.push( intersection );

					}

				}

			}

		} else if ( position !== undefined ) {

			// non-indexed buffer geometry

			if ( Array.isArray( material ) ) {

				for ( let i = 0, il = groups.length; i < il; i ++ ) {

					const group = groups[ i ];
					const groupMaterial = material[ group.materialIndex ];

					const start = Math.max( group.start, drawRange.start );
					const end = Math.min( position.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );

					for ( let j = start, jl = end; j < jl; j += 3 ) {

						const a = j;
						const b = j + 1;
						const c = j + 2;

						intersection = checkGeometryIntersection( this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );

						if ( intersection ) {

							intersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics
							intersection.face.materialIndex = group.materialIndex;
							intersects.push( intersection );

						}

					}

				}

			} else {

				const start = Math.max( 0, drawRange.start );
				const end = Math.min( position.count, ( drawRange.start + drawRange.count ) );

				for ( let i = start, il = end; i < il; i += 3 ) {

					const a = i;
					const b = i + 1;
					const c = i + 2;

					intersection = checkGeometryIntersection( this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );

					if ( intersection ) {

						intersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics
						intersects.push( intersection );

					}

				}

			}

		}

	}

}

function checkIntersection$1( object, material, raycaster, ray, pA, pB, pC, point ) {

	let intersect;

	if ( material.side === BackSide ) {

		intersect = ray.intersectTriangle( pC, pB, pA, true, point );

	} else {

		intersect = ray.intersectTriangle( pA, pB, pC, ( material.side === FrontSide ), point );

	}

	if ( intersect === null ) return null;

	_intersectionPointWorld.copy( point );
	_intersectionPointWorld.applyMatrix4( object.matrixWorld );

	const distance = raycaster.ray.origin.distanceTo( _intersectionPointWorld );

	if ( distance < raycaster.near || distance > raycaster.far ) return null;

	return {
		distance: distance,
		point: _intersectionPointWorld.clone(),
		object: object
	};

}

function checkGeometryIntersection( object, material, raycaster, ray, uv, uv1, normal, a, b, c ) {

	object.getVertexPosition( a, _vA$1 );
	object.getVertexPosition( b, _vB$1 );
	object.getVertexPosition( c, _vC$1 );

	const intersection = checkIntersection$1( object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint );

	if ( intersection ) {

		const barycoord = new Vector3();
		Triangle.getBarycoord( _intersectionPoint, _vA$1, _vB$1, _vC$1, barycoord );

		if ( uv ) {

			intersection.uv = Triangle.getInterpolatedAttribute( uv, a, b, c, barycoord, new Vector2() );

		}

		if ( uv1 ) {

			intersection.uv1 = Triangle.getInterpolatedAttribute( uv1, a, b, c, barycoord, new Vector2() );

		}

		if ( normal ) {

			intersection.normal = Triangle.getInterpolatedAttribute( normal, a, b, c, barycoord, new Vector3() );

			if ( intersection.normal.dot( ray.direction ) > 0 ) {

				intersection.normal.multiplyScalar( -1 );

			}

		}

		const face = {
			a: a,
			b: b,
			c: c,
			normal: new Vector3(),
			materialIndex: 0
		};

		Triangle.getNormal( _vA$1, _vB$1, _vC$1, face.normal );

		intersection.face = face;
		intersection.barycoord = barycoord;

	}

	return intersection;

}

class BoxGeometry extends BufferGeometry {

	constructor( width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1 ) {

		super();

		this.type = 'BoxGeometry';

		this.parameters = {
			width: width,
			height: height,
			depth: depth,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			depthSegments: depthSegments
		};

		const scope = this;

		// segments

		widthSegments = Math.floor( widthSegments );
		heightSegments = Math.floor( heightSegments );
		depthSegments = Math.floor( depthSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		let numberOfVertices = 0;
		let groupStart = 0;

		// build each side of the box geometry

		buildPlane( 'z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0 ); // px
		buildPlane( 'z', 'y', 'x', 1, -1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx
		buildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py
		buildPlane( 'x', 'z', 'y', 1, -1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny
		buildPlane( 'x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4 ); // pz
		buildPlane( 'x', 'y', 'z', -1, -1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

			const segmentWidth = width / gridX;
			const segmentHeight = height / gridY;

			const widthHalf = width / 2;
			const heightHalf = height / 2;
			const depthHalf = depth / 2;

			const gridX1 = gridX + 1;
			const gridY1 = gridY + 1;

			let vertexCounter = 0;
			let groupCount = 0;

			const vector = new Vector3();

			// generate vertices, normals and uvs

			for ( let iy = 0; iy < gridY1; iy ++ ) {

				const y = iy * segmentHeight - heightHalf;

				for ( let ix = 0; ix < gridX1; ix ++ ) {

					const x = ix * segmentWidth - widthHalf;

					// set values to correct vector component

					vector[ u ] = x * udir;
					vector[ v ] = y * vdir;
					vector[ w ] = depthHalf;

					// now apply vector to vertex buffer

					vertices.push( vector.x, vector.y, vector.z );

					// set values to correct vector component

					vector[ u ] = 0;
					vector[ v ] = 0;
					vector[ w ] = depth > 0 ? 1 : -1;

					// now apply vector to normal buffer

					normals.push( vector.x, vector.y, vector.z );

					// uvs

					uvs.push( ix / gridX );
					uvs.push( 1 - ( iy / gridY ) );

					// counters

					vertexCounter += 1;

				}

			}

			// indices

			// 1. you need three indices to draw a single face
			// 2. a single segment consists of two faces
			// 3. so we need to generate six (2*3) indices per segment

			for ( let iy = 0; iy < gridY; iy ++ ) {

				for ( let ix = 0; ix < gridX; ix ++ ) {

					const a = numberOfVertices + ix + gridX1 * iy;
					const b = numberOfVertices + ix + gridX1 * ( iy + 1 );
					const c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
					const d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

					// increase counter

					groupCount += 6;

				}

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, materialIndex );

			// calculate new start value for groups

			groupStart += groupCount;

			// update total number of vertices

			numberOfVertices += vertexCounter;

		}

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	static fromJSON( data ) {

		return new BoxGeometry( data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments );

	}

}

/**
 * Uniform Utilities
 */

function cloneUniforms( src ) {

	const dst = {};

	for ( const u in src ) {

		dst[ u ] = {};

		for ( const p in src[ u ] ) {

			const property = src[ u ][ p ];

			if ( property && ( property.isColor ||
				property.isMatrix3 || property.isMatrix4 ||
				property.isVector2 || property.isVector3 || property.isVector4 ||
				property.isTexture || property.isQuaternion ) ) {

				if ( property.isRenderTargetTexture ) {

					console.warn( 'UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().' );
					dst[ u ][ p ] = null;

				} else {

					dst[ u ][ p ] = property.clone();

				}

			} else if ( Array.isArray( property ) ) {

				dst[ u ][ p ] = property.slice();

			} else {

				dst[ u ][ p ] = property;

			}

		}

	}

	return dst;

}

function cloneUniformsGroups( src ) {

	const dst = [];

	for ( let u = 0; u < src.length; u ++ ) {

		dst.push( src[ u ].clone() );

	}

	return dst;

}

var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";

var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

class ShaderMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isShaderMaterial = true;

		this.type = 'ShaderMaterial';

		this.defines = {};
		this.uniforms = {};
		this.uniformsGroups = [];

		this.vertexShader = default_vertex;
		this.fragmentShader = default_fragment;

		this.linewidth = 1;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.fog = false; // set to use scene fog
		this.lights = false; // set to use scene lights
		this.clipping = false; // set to use user-defined clipping planes

		this.forceSinglePass = true;

		this.extensions = {
			clipCullDistance: false, // set to use vertex shader clipping
			multiDraw: false // set to use vertex shader multi_draw / enable gl_DrawID
		};

		// When rendered geometry doesn't include these attributes but the material does,
		// use these default values in WebGL. This avoids errors when buffer data is missing.
		this.defaultAttributeValues = {
			'color': [ 1, 1, 1 ],
			'uv': [ 0, 0 ],
			'uv1': [ 0, 0 ]
		};

		this.index0AttributeName = undefined;
		this.uniformsNeedUpdate = false;

		this.glslVersion = null;

		if ( parameters !== undefined ) {

			this.setValues( parameters );

		}

	}

	copy( source ) {

		super.copy( source );

		this.fragmentShader = source.fragmentShader;
		this.vertexShader = source.vertexShader;

		this.uniforms = cloneUniforms( source.uniforms );
		this.uniformsGroups = cloneUniformsGroups( source.uniformsGroups );

		this.defines = Object.assign( {}, source.defines );

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		this.fog = source.fog;
		this.lights = source.lights;
		this.clipping = source.clipping;

		this.extensions = Object.assign( {}, source.extensions );

		this.glslVersion = source.glslVersion;

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.glslVersion = this.glslVersion;
		data.uniforms = {};

		for ( const name in this.uniforms ) {

			const uniform = this.uniforms[ name ];
			const value = uniform.value;

			if ( value && value.isTexture ) {

				data.uniforms[ name ] = {
					type: 't',
					value: value.toJSON( meta ).uuid
				};

			} else if ( value && value.isColor ) {

				data.uniforms[ name ] = {
					type: 'c',
					value: value.getHex()
				};

			} else if ( value && value.isVector2 ) {

				data.uniforms[ name ] = {
					type: 'v2',
					value: value.toArray()
				};

			} else if ( value && value.isVector3 ) {

				data.uniforms[ name ] = {
					type: 'v3',
					value: value.toArray()
				};

			} else if ( value && value.isVector4 ) {

				data.uniforms[ name ] = {
					type: 'v4',
					value: value.toArray()
				};

			} else if ( value && value.isMatrix3 ) {

				data.uniforms[ name ] = {
					type: 'm3',
					value: value.toArray()
				};

			} else if ( value && value.isMatrix4 ) {

				data.uniforms[ name ] = {
					type: 'm4',
					value: value.toArray()
				};

			} else {

				data.uniforms[ name ] = {
					value: value
				};

				// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far

			}

		}

		if ( Object.keys( this.defines ).length > 0 ) data.defines = this.defines;

		data.vertexShader = this.vertexShader;
		data.fragmentShader = this.fragmentShader;

		data.lights = this.lights;
		data.clipping = this.clipping;

		const extensions = {};

		for ( const key in this.extensions ) {

			if ( this.extensions[ key ] === true ) extensions[ key ] = true;

		}

		if ( Object.keys( extensions ).length > 0 ) data.extensions = extensions;

		return data;

	}

}

class Camera extends Object3D {

	constructor() {

		super();

		this.isCamera = true;

		this.type = 'Camera';

		this.matrixWorldInverse = new Matrix4();

		this.projectionMatrix = new Matrix4();
		this.projectionMatrixInverse = new Matrix4();

		this.coordinateSystem = WebGLCoordinateSystem;

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.matrixWorldInverse.copy( source.matrixWorldInverse );

		this.projectionMatrix.copy( source.projectionMatrix );
		this.projectionMatrixInverse.copy( source.projectionMatrixInverse );

		this.coordinateSystem = source.coordinateSystem;

		return this;

	}

	getWorldDirection( target ) {

		return super.getWorldDirection( target ).negate();

	}

	updateMatrixWorld( force ) {

		super.updateMatrixWorld( force );

		this.matrixWorldInverse.copy( this.matrixWorld ).invert();

	}

	updateWorldMatrix( updateParents, updateChildren ) {

		super.updateWorldMatrix( updateParents, updateChildren );

		this.matrixWorldInverse.copy( this.matrixWorld ).invert();

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

const _v3$1 = /*@__PURE__*/ new Vector3();
const _minTarget = /*@__PURE__*/ new Vector2();
const _maxTarget = /*@__PURE__*/ new Vector2();


class PerspectiveCamera extends Camera {

	constructor( fov = 50, aspect = 1, near = 0.1, far = 2000 ) {

		super();

		this.isPerspectiveCamera = true;

		this.type = 'PerspectiveCamera';

		this.fov = fov;
		this.zoom = 1;

		this.near = near;
		this.far = far;
		this.focus = 10;

		this.aspect = aspect;
		this.view = null;

		this.filmGauge = 35;	// width of the film (default in millimeters)
		this.filmOffset = 0;	// horizontal film offset (same unit as gauge)

		this.updateProjectionMatrix();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.fov = source.fov;
		this.zoom = source.zoom;

		this.near = source.near;
		this.far = source.far;
		this.focus = source.focus;

		this.aspect = source.aspect;
		this.view = source.view === null ? null : Object.assign( {}, source.view );

		this.filmGauge = source.filmGauge;
		this.filmOffset = source.filmOffset;

		return this;

	}

	/**
	 * Sets the FOV by focal length in respect to the current .filmGauge.
	 *
	 * The default film gauge is 35, so that the focal length can be specified for
	 * a 35mm (full frame) camera.
	 *
	 * Values for focal length and film gauge must have the same unit.
	 */
	setFocalLength( focalLength ) {

		/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */
		const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

		this.fov = RAD2DEG * 2 * Math.atan( vExtentSlope );
		this.updateProjectionMatrix();

	}

	/**
	 * Calculates the focal length from the current .fov and .filmGauge.
	 */
	getFocalLength() {

		const vExtentSlope = Math.tan( DEG2RAD * 0.5 * this.fov );

		return 0.5 * this.getFilmHeight() / vExtentSlope;

	}

	getEffectiveFOV() {

		return RAD2DEG * 2 * Math.atan(
			Math.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom );

	}

	getFilmWidth() {

		// film not completely covered in portrait format (aspect < 1)
		return this.filmGauge * Math.min( this.aspect, 1 );

	}

	getFilmHeight() {

		// film not completely covered in landscape format (aspect > 1)
		return this.filmGauge / Math.max( this.aspect, 1 );

	}

	/**
	 * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
	 * Sets minTarget and maxTarget to the coordinates of the lower-left and upper-right corners of the view rectangle.
	 */
	getViewBounds( distance, minTarget, maxTarget ) {

		_v3$1.set( -1, -1, 0.5 ).applyMatrix4( this.projectionMatrixInverse );

		minTarget.set( _v3$1.x, _v3$1.y ).multiplyScalar( - distance / _v3$1.z );

		_v3$1.set( 1, 1, 0.5 ).applyMatrix4( this.projectionMatrixInverse );

		maxTarget.set( _v3$1.x, _v3$1.y ).multiplyScalar( - distance / _v3$1.z );

	}

	/**
	 * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
	 * Copies the result into the target Vector2, where x is width and y is height.
	 */
	getViewSize( distance, target ) {

		this.getViewBounds( distance, _minTarget, _maxTarget );

		return target.subVectors( _maxTarget, _minTarget );

	}

	/**
	 * Sets an offset in a larger frustum. This is useful for multi-window or
	 * multi-monitor/multi-machine setups.
	 *
	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
	 * the monitors are in grid like this
	 *
	 *   +---+---+---+
	 *   | A | B | C |
	 *   +---+---+---+
	 *   | D | E | F |
	 *   +---+---+---+
	 *
	 * then for each monitor you would call it like this
	 *
	 *   const w = 1920;
	 *   const h = 1080;
	 *   const fullWidth = w * 3;
	 *   const fullHeight = h * 2;
	 *
	 *   --A--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
	 *   --B--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
	 *   --C--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
	 *   --D--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
	 *   --E--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
	 *   --F--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
	 *
	 *   Note there is no reason monitors have to be the same size or in a grid.
	 */
	setViewOffset( fullWidth, fullHeight, x, y, width, height ) {

		this.aspect = fullWidth / fullHeight;

		if ( this.view === null ) {

			this.view = {
				enabled: true,
				fullWidth: 1,
				fullHeight: 1,
				offsetX: 0,
				offsetY: 0,
				width: 1,
				height: 1
			};

		}

		this.view.enabled = true;
		this.view.fullWidth = fullWidth;
		this.view.fullHeight = fullHeight;
		this.view.offsetX = x;
		this.view.offsetY = y;
		this.view.width = width;
		this.view.height = height;

		this.updateProjectionMatrix();

	}

	clearViewOffset() {

		if ( this.view !== null ) {

			this.view.enabled = false;

		}

		this.updateProjectionMatrix();

	}

	updateProjectionMatrix() {

		const near = this.near;
		let top = near * Math.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom;
		let height = 2 * top;
		let width = this.aspect * height;
		let left = -0.5 * width;
		const view = this.view;

		if ( this.view !== null && this.view.enabled ) {

			const fullWidth = view.fullWidth,
				fullHeight = view.fullHeight;

			left += view.offsetX * width / fullWidth;
			top -= view.offsetY * height / fullHeight;
			width *= view.width / fullWidth;
			height *= view.height / fullHeight;

		}

		const skew = this.filmOffset;
		if ( skew !== 0 ) left += near * skew / this.getFilmWidth();

		this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far, this.coordinateSystem );

		this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.object.fov = this.fov;
		data.object.zoom = this.zoom;

		data.object.near = this.near;
		data.object.far = this.far;
		data.object.focus = this.focus;

		data.object.aspect = this.aspect;

		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

		data.object.filmGauge = this.filmGauge;
		data.object.filmOffset = this.filmOffset;

		return data;

	}

}

const fov = -90; // negative fov is not an error
const aspect = 1;

class CubeCamera extends Object3D {

	constructor( near, far, renderTarget ) {

		super();

		this.type = 'CubeCamera';

		this.renderTarget = renderTarget;
		this.coordinateSystem = null;
		this.activeMipmapLevel = 0;

		const cameraPX = new PerspectiveCamera( fov, aspect, near, far );
		cameraPX.layers = this.layers;
		this.add( cameraPX );

		const cameraNX = new PerspectiveCamera( fov, aspect, near, far );
		cameraNX.layers = this.layers;
		this.add( cameraNX );

		const cameraPY = new PerspectiveCamera( fov, aspect, near, far );
		cameraPY.layers = this.layers;
		this.add( cameraPY );

		const cameraNY = new PerspectiveCamera( fov, aspect, near, far );
		cameraNY.layers = this.layers;
		this.add( cameraNY );

		const cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
		cameraPZ.layers = this.layers;
		this.add( cameraPZ );

		const cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
		cameraNZ.layers = this.layers;
		this.add( cameraNZ );

	}

	updateCoordinateSystem() {

		const coordinateSystem = this.coordinateSystem;

		const cameras = this.children.concat();

		const [ cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ ] = cameras;

		for ( const camera of cameras ) this.remove( camera );

		if ( coordinateSystem === WebGLCoordinateSystem ) {

			cameraPX.up.set( 0, 1, 0 );
			cameraPX.lookAt( 1, 0, 0 );

			cameraNX.up.set( 0, 1, 0 );
			cameraNX.lookAt( -1, 0, 0 );

			cameraPY.up.set( 0, 0, -1 );
			cameraPY.lookAt( 0, 1, 0 );

			cameraNY.up.set( 0, 0, 1 );
			cameraNY.lookAt( 0, -1, 0 );

			cameraPZ.up.set( 0, 1, 0 );
			cameraPZ.lookAt( 0, 0, 1 );

			cameraNZ.up.set( 0, 1, 0 );
			cameraNZ.lookAt( 0, 0, -1 );

		} else if ( coordinateSystem === WebGPUCoordinateSystem ) {

			cameraPX.up.set( 0, -1, 0 );
			cameraPX.lookAt( -1, 0, 0 );

			cameraNX.up.set( 0, -1, 0 );
			cameraNX.lookAt( 1, 0, 0 );

			cameraPY.up.set( 0, 0, 1 );
			cameraPY.lookAt( 0, 1, 0 );

			cameraNY.up.set( 0, 0, -1 );
			cameraNY.lookAt( 0, -1, 0 );

			cameraPZ.up.set( 0, -1, 0 );
			cameraPZ.lookAt( 0, 0, 1 );

			cameraNZ.up.set( 0, -1, 0 );
			cameraNZ.lookAt( 0, 0, -1 );

		} else {

			throw new Error( 'THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: ' + coordinateSystem );

		}

		for ( const camera of cameras ) {

			this.add( camera );

			camera.updateMatrixWorld();

		}

	}

	update( renderer, scene ) {

		if ( this.parent === null ) this.updateMatrixWorld();

		const { renderTarget, activeMipmapLevel } = this;

		if ( this.coordinateSystem !== renderer.coordinateSystem ) {

			this.coordinateSystem = renderer.coordinateSystem;

			this.updateCoordinateSystem();

		}

		const [ cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ ] = this.children;

		const currentRenderTarget = renderer.getRenderTarget();
		const currentActiveCubeFace = renderer.getActiveCubeFace();
		const currentActiveMipmapLevel = renderer.getActiveMipmapLevel();

		const currentXrEnabled = renderer.xr.enabled;

		renderer.xr.enabled = false;

		const generateMipmaps = renderTarget.texture.generateMipmaps;

		renderTarget.texture.generateMipmaps = false;

		renderer.setRenderTarget( renderTarget, 0, activeMipmapLevel );
		renderer.render( scene, cameraPX );

		renderer.setRenderTarget( renderTarget, 1, activeMipmapLevel );
		renderer.render( scene, cameraNX );

		renderer.setRenderTarget( renderTarget, 2, activeMipmapLevel );
		renderer.render( scene, cameraPY );

		renderer.setRenderTarget( renderTarget, 3, activeMipmapLevel );
		renderer.render( scene, cameraNY );

		renderer.setRenderTarget( renderTarget, 4, activeMipmapLevel );
		renderer.render( scene, cameraPZ );

		// mipmaps are generated during the last call of render()
		// at this point, all sides of the cube render target are defined

		renderTarget.texture.generateMipmaps = generateMipmaps;

		renderer.setRenderTarget( renderTarget, 5, activeMipmapLevel );
		renderer.render( scene, cameraNZ );

		renderer.setRenderTarget( currentRenderTarget, currentActiveCubeFace, currentActiveMipmapLevel );

		renderer.xr.enabled = currentXrEnabled;

		renderTarget.texture.needsPMREMUpdate = true;

	}

}

class CubeTexture extends Texture {

	constructor( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace ) {

		images = images !== undefined ? images : [];
		mapping = mapping !== undefined ? mapping : CubeReflectionMapping;

		super( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace );

		this.isCubeTexture = true;

		this.flipY = false;

	}

	get images() {

		return this.image;

	}

	set images( value ) {

		this.image = value;

	}

}

class WebGLCubeRenderTarget extends WebGLRenderTarget {

	constructor( size = 1, options = {} ) {

		super( size, size, options );

		this.isWebGLCubeRenderTarget = true;

		const image = { width: size, height: size, depth: 1 };
		const images = [ image, image, image, image, image, image ];

		this.texture = new CubeTexture( images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace );

		// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
		// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
		// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.

		// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
		// and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture
		// as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).

		this.texture.isRenderTargetTexture = true;

		this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
		this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;

	}

	fromEquirectangularTexture( renderer, texture ) {

		this.texture.type = texture.type;
		this.texture.colorSpace = texture.colorSpace;

		this.texture.generateMipmaps = texture.generateMipmaps;
		this.texture.minFilter = texture.minFilter;
		this.texture.magFilter = texture.magFilter;

		const shader = {

			uniforms: {
				tEquirect: { value: null },
			},

			vertexShader: /* glsl */`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,

			fragmentShader: /* glsl */`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
		};

		const geometry = new BoxGeometry( 5, 5, 5 );

		const material = new ShaderMaterial( {

			name: 'CubemapFromEquirect',

			uniforms: cloneUniforms( shader.uniforms ),
			vertexShader: shader.vertexShader,
			fragmentShader: shader.fragmentShader,
			side: BackSide,
			blending: NoBlending

		} );

		material.uniforms.tEquirect.value = texture;

		const mesh = new Mesh( geometry, material );

		const currentMinFilter = texture.minFilter;

		// Avoid blurred poles
		if ( texture.minFilter === LinearMipmapLinearFilter ) texture.minFilter = LinearFilter;

		const camera = new CubeCamera( 1, 10, this );
		camera.update( renderer, mesh );

		texture.minFilter = currentMinFilter;

		mesh.geometry.dispose();
		mesh.material.dispose();

		return this;

	}

	clear( renderer, color, depth, stencil ) {

		const currentRenderTarget = renderer.getRenderTarget();

		for ( let i = 0; i < 6; i ++ ) {

			renderer.setRenderTarget( this, i );

			renderer.clear( color, depth, stencil );

		}

		renderer.setRenderTarget( currentRenderTarget );

	}

}

class FogExp2 {

	constructor( color, density = 0.00025 ) {

		this.isFogExp2 = true;

		this.name = '';

		this.color = new Color( color );
		this.density = density;

	}

	clone() {

		return new FogExp2( this.color, this.density );

	}

	toJSON( /* meta */ ) {

		return {
			type: 'FogExp2',
			name: this.name,
			color: this.color.getHex(),
			density: this.density
		};

	}

}

class Fog {

	constructor( color, near = 1, far = 1000 ) {

		this.isFog = true;

		this.name = '';

		this.color = new Color( color );

		this.near = near;
		this.far = far;

	}

	clone() {

		return new Fog( this.color, this.near, this.far );

	}

	toJSON( /* meta */ ) {

		return {
			type: 'Fog',
			name: this.name,
			color: this.color.getHex(),
			near: this.near,
			far: this.far
		};

	}

}

class Scene extends Object3D {

	constructor() {

		super();

		this.isScene = true;

		this.type = 'Scene';

		this.background = null;
		this.environment = null;
		this.fog = null;

		this.backgroundBlurriness = 0;
		this.backgroundIntensity = 1;
		this.backgroundRotation = new Euler();

		this.environmentIntensity = 1;
		this.environmentRotation = new Euler();

		this.overrideMaterial = null;

		if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

			__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) );

		}

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		if ( source.background !== null ) this.background = source.background.clone();
		if ( source.environment !== null ) this.environment = source.environment.clone();
		if ( source.fog !== null ) this.fog = source.fog.clone();

		this.backgroundBlurriness = source.backgroundBlurriness;
		this.backgroundIntensity = source.backgroundIntensity;
		this.backgroundRotation.copy( source.backgroundRotation );

		this.environmentIntensity = source.environmentIntensity;
		this.environmentRotation.copy( source.environmentRotation );

		if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

		this.matrixAutoUpdate = source.matrixAutoUpdate;

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		if ( this.fog !== null ) data.object.fog = this.fog.toJSON();

		if ( this.backgroundBlurriness > 0 ) data.object.backgroundBlurriness = this.backgroundBlurriness;
		if ( this.backgroundIntensity !== 1 ) data.object.backgroundIntensity = this.backgroundIntensity;
		data.object.backgroundRotation = this.backgroundRotation.toArray();

		if ( this.environmentIntensity !== 1 ) data.object.environmentIntensity = this.environmentIntensity;
		data.object.environmentRotation = this.environmentRotation.toArray();

		return data;

	}

}

class InterleavedBuffer {

	constructor( array, stride ) {

		this.isInterleavedBuffer = true;

		this.array = array;
		this.stride = stride;
		this.count = array !== undefined ? array.length / stride : 0;

		this.usage = StaticDrawUsage;
		this.updateRanges = [];

		this.version = 0;

		this.uuid = generateUUID();

	}

	onUploadCallback() {}

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

	setUsage( value ) {

		this.usage = value;

		return this;

	}

	addUpdateRange( start, count ) {

		this.updateRanges.push( { start, count } );

	}

	clearUpdateRanges() {

		this.updateRanges.length = 0;

	}

	copy( source ) {

		this.array = new source.array.constructor( source.array );
		this.count = source.count;
		this.stride = source.stride;
		this.usage = source.usage;

		return this;

	}

	copyAt( index1, attribute, index2 ) {

		index1 *= this.stride;
		index2 *= attribute.stride;

		for ( let i = 0, l = this.stride; i < l; i ++ ) {

			this.array[ index1 + i ] = attribute.array[ index2 + i ];

		}

		return this;

	}

	set( value, offset = 0 ) {

		this.array.set( value, offset );

		return this;

	}

	clone( data ) {

		if ( data.arrayBuffers === undefined ) {

			data.arrayBuffers = {};

		}

		if ( this.array.buffer._uuid === undefined ) {

			this.array.buffer._uuid = generateUUID();

		}

		if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

			data.arrayBuffers[ this.array.buffer._uuid ] = this.array.slice( 0 ).buffer;

		}

		const array = new this.array.constructor( data.arrayBuffers[ this.array.buffer._uuid ] );

		const ib = new this.constructor( array, this.stride );
		ib.setUsage( this.usage );

		return ib;

	}

	onUpload( callback ) {

		this.onUploadCallback = callback;

		return this;

	}

	toJSON( data ) {

		if ( data.arrayBuffers === undefined ) {

			data.arrayBuffers = {};

		}

		// generate UUID for array buffer if necessary

		if ( this.array.buffer._uuid === undefined ) {

			this.array.buffer._uuid = generateUUID();

		}

		if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

			data.arrayBuffers[ this.array.buffer._uuid ] = Array.from( new Uint32Array( this.array.buffer ) );

		}

		//

		return {
			uuid: this.uuid,
			buffer: this.array.buffer._uuid,
			type: this.array.constructor.name,
			stride: this.stride
		};

	}

}

const _vector$7 = /*@__PURE__*/ new Vector3();

class InterleavedBufferAttribute {

	constructor( interleavedBuffer, itemSize, offset, normalized = false ) {

		this.isInterleavedBufferAttribute = true;

		this.name = '';

		this.data = interleavedBuffer;
		this.itemSize = itemSize;
		this.offset = offset;

		this.normalized = normalized;

	}

	get count() {

		return this.data.count;

	}

	get array() {

		return this.data.array;

	}

	set needsUpdate( value ) {

		this.data.needsUpdate = value;

	}

	applyMatrix4( m ) {

		for ( let i = 0, l = this.data.count; i < l; i ++ ) {

			_vector$7.fromBufferAttribute( this, i );

			_vector$7.applyMatrix4( m );

			this.setXYZ( i, _vector$7.x, _vector$7.y, _vector$7.z );

		}

		return this;

	}

	applyNormalMatrix( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$7.fromBufferAttribute( this, i );

			_vector$7.applyNormalMatrix( m );

			this.setXYZ( i, _vector$7.x, _vector$7.y, _vector$7.z );

		}

		return this;

	}

	transformDirection( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$7.fromBufferAttribute( this, i );

			_vector$7.transformDirection( m );

			this.setXYZ( i, _vector$7.x, _vector$7.y, _vector$7.z );

		}

		return this;

	}

	getComponent( index, component ) {

		let value = this.array[ index * this.data.stride + this.offset + component ];

		if ( this.normalized ) value = denormalize( value, this.array );

		return value;

	}

	setComponent( index, component, value ) {

		if ( this.normalized ) value = normalize$2( value, this.array );

		this.data.array[ index * this.data.stride + this.offset + component ] = value;

		return this;

	}

	setX( index, x ) {

		if ( this.normalized ) x = normalize$2( x, this.array );

		this.data.array[ index * this.data.stride + this.offset ] = x;

		return this;

	}

	setY( index, y ) {

		if ( this.normalized ) y = normalize$2( y, this.array );

		this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

		return this;

	}

	setZ( index, z ) {

		if ( this.normalized ) z = normalize$2( z, this.array );

		this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

		return this;

	}

	setW( index, w ) {

		if ( this.normalized ) w = normalize$2( w, this.array );

		this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

		return this;

	}

	getX( index ) {

		let x = this.data.array[ index * this.data.stride + this.offset ];

		if ( this.normalized ) x = denormalize( x, this.array );

		return x;

	}

	getY( index ) {

		let y = this.data.array[ index * this.data.stride + this.offset + 1 ];

		if ( this.normalized ) y = denormalize( y, this.array );

		return y;

	}

	getZ( index ) {

		let z = this.data.array[ index * this.data.stride + this.offset + 2 ];

		if ( this.normalized ) z = denormalize( z, this.array );

		return z;

	}

	getW( index ) {

		let w = this.data.array[ index * this.data.stride + this.offset + 3 ];

		if ( this.normalized ) w = denormalize( w, this.array );

		return w;

	}

	setXY( index, x, y ) {

		index = index * this.data.stride + this.offset;

		if ( this.normalized ) {

			x = normalize$2( x, this.array );
			y = normalize$2( y, this.array );

		}

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;

		return this;

	}

	setXYZ( index, x, y, z ) {

		index = index * this.data.stride + this.offset;

		if ( this.normalized ) {

			x = normalize$2( x, this.array );
			y = normalize$2( y, this.array );
			z = normalize$2( z, this.array );

		}

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;
		this.data.array[ index + 2 ] = z;

		return this;

	}

	setXYZW( index, x, y, z, w ) {

		index = index * this.data.stride + this.offset;

		if ( this.normalized ) {

			x = normalize$2( x, this.array );
			y = normalize$2( y, this.array );
			z = normalize$2( z, this.array );
			w = normalize$2( w, this.array );

		}

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;
		this.data.array[ index + 2 ] = z;
		this.data.array[ index + 3 ] = w;

		return this;

	}

	clone( data ) {

		if ( data === undefined ) {

			console.log( 'THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.' );

			const array = [];

			for ( let i = 0; i < this.count; i ++ ) {

				const index = i * this.data.stride + this.offset;

				for ( let j = 0; j < this.itemSize; j ++ ) {

					array.push( this.data.array[ index + j ] );

				}

			}

			return new BufferAttribute( new this.array.constructor( array ), this.itemSize, this.normalized );

		} else {

			if ( data.interleavedBuffers === undefined ) {

				data.interleavedBuffers = {};

			}

			if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

				data.interleavedBuffers[ this.data.uuid ] = this.data.clone( data );

			}

			return new InterleavedBufferAttribute( data.interleavedBuffers[ this.data.uuid ], this.itemSize, this.offset, this.normalized );

		}

	}

	toJSON( data ) {

		if ( data === undefined ) {

			console.log( 'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.' );

			const array = [];

			for ( let i = 0; i < this.count; i ++ ) {

				const index = i * this.data.stride + this.offset;

				for ( let j = 0; j < this.itemSize; j ++ ) {

					array.push( this.data.array[ index + j ] );

				}

			}

			// de-interleave data and save it as an ordinary buffer attribute for now

			return {
				itemSize: this.itemSize,
				type: this.array.constructor.name,
				array: array,
				normalized: this.normalized
			};

		} else {

			// save as true interleaved attribute

			if ( data.interleavedBuffers === undefined ) {

				data.interleavedBuffers = {};

			}

			if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

				data.interleavedBuffers[ this.data.uuid ] = this.data.toJSON( data );

			}

			return {
				isInterleavedBufferAttribute: true,
				itemSize: this.itemSize,
				data: this.data.uuid,
				offset: this.offset,
				normalized: this.normalized
			};

		}

	}

}

class SpriteMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isSpriteMaterial = true;

		this.type = 'SpriteMaterial';

		this.color = new Color( 0xffffff );

		this.map = null;

		this.alphaMap = null;

		this.rotation = 0;

		this.sizeAttenuation = true;

		this.transparent = true;

		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.rotation = source.rotation;

		this.sizeAttenuation = source.sizeAttenuation;

		this.fog = source.fog;

		return this;

	}

}

class DataTexture extends Texture {

	constructor( data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, colorSpace ) {

		super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace );

		this.isDataTexture = true;

		this.image = { data: data, width: width, height: height };

		this.generateMipmaps = false;
		this.flipY = false;
		this.unpackAlignment = 1;

	}

}

class InstancedBufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized, meshPerAttribute = 1 ) {

		super( array, itemSize, normalized );

		this.isInstancedBufferAttribute = true;

		this.meshPerAttribute = meshPerAttribute;

	}

	copy( source ) {

		super.copy( source );

		this.meshPerAttribute = source.meshPerAttribute;

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.meshPerAttribute = this.meshPerAttribute;

		data.isInstancedBufferAttribute = true;

		return data;

	}

}

const _instanceLocalMatrix = /*@__PURE__*/ new Matrix4();
const _instanceWorldMatrix = /*@__PURE__*/ new Matrix4();

const _instanceIntersects = [];

const _box3 = /*@__PURE__*/ new Box3();
const _identity = /*@__PURE__*/ new Matrix4();
const _mesh$1 = /*@__PURE__*/ new Mesh();
const _sphere$4 = /*@__PURE__*/ new Sphere();

class InstancedMesh extends Mesh {

	constructor( geometry, material, count ) {

		super( geometry, material );

		this.isInstancedMesh = true;

		this.instanceMatrix = new InstancedBufferAttribute( new Float32Array( count * 16 ), 16 );
		this.instanceColor = null;
		this.morphTexture = null;

		this.count = count;

		this.boundingBox = null;
		this.boundingSphere = null;

		for ( let i = 0; i < count; i ++ ) {

			this.setMatrixAt( i, _identity );

		}

	}

	computeBoundingBox() {

		const geometry = this.geometry;
		const count = this.count;

		if ( this.boundingBox === null ) {

			this.boundingBox = new Box3();

		}

		if ( geometry.boundingBox === null ) {

			geometry.computeBoundingBox();

		}

		this.boundingBox.makeEmpty();

		for ( let i = 0; i < count; i ++ ) {

			this.getMatrixAt( i, _instanceLocalMatrix );

			_box3.copy( geometry.boundingBox ).applyMatrix4( _instanceLocalMatrix );

			this.boundingBox.union( _box3 );

		}

	}

	computeBoundingSphere() {

		const geometry = this.geometry;
		const count = this.count;

		if ( this.boundingSphere === null ) {

			this.boundingSphere = new Sphere();

		}

		if ( geometry.boundingSphere === null ) {

			geometry.computeBoundingSphere();

		}

		this.boundingSphere.makeEmpty();

		for ( let i = 0; i < count; i ++ ) {

			this.getMatrixAt( i, _instanceLocalMatrix );

			_sphere$4.copy( geometry.boundingSphere ).applyMatrix4( _instanceLocalMatrix );

			this.boundingSphere.union( _sphere$4 );

		}

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.instanceMatrix.copy( source.instanceMatrix );

		if ( source.morphTexture !== null ) this.morphTexture = source.morphTexture.clone();
		if ( source.instanceColor !== null ) this.instanceColor = source.instanceColor.clone();

		this.count = source.count;

		if ( source.boundingBox !== null ) this.boundingBox = source.boundingBox.clone();
		if ( source.boundingSphere !== null ) this.boundingSphere = source.boundingSphere.clone();

		return this;

	}

	getColorAt( index, color ) {

		color.fromArray( this.instanceColor.array, index * 3 );

	}

	getMatrixAt( index, matrix ) {

		matrix.fromArray( this.instanceMatrix.array, index * 16 );

	}

	getMorphAt( index, object ) {

		const objectInfluences = object.morphTargetInfluences;

		const array = this.morphTexture.source.data.data;

		const len = objectInfluences.length + 1; // All influences + the baseInfluenceSum

		const dataIndex = index * len + 1; // Skip the baseInfluenceSum at the beginning

		for ( let i = 0; i < objectInfluences.length; i ++ ) {

			objectInfluences[ i ] = array[ dataIndex + i ];

		}

	}

	raycast( raycaster, intersects ) {

		const matrixWorld = this.matrixWorld;
		const raycastTimes = this.count;

		_mesh$1.geometry = this.geometry;
		_mesh$1.material = this.material;

		if ( _mesh$1.material === undefined ) return;

		// test with bounding sphere first

		if ( this.boundingSphere === null ) this.computeBoundingSphere();

		_sphere$4.copy( this.boundingSphere );
		_sphere$4.applyMatrix4( matrixWorld );

		if ( raycaster.ray.intersectsSphere( _sphere$4 ) === false ) return;

		// now test each instance

		for ( let instanceId = 0; instanceId < raycastTimes; instanceId ++ ) {

			// calculate the world matrix for each instance

			this.getMatrixAt( instanceId, _instanceLocalMatrix );

			_instanceWorldMatrix.multiplyMatrices( matrixWorld, _instanceLocalMatrix );

			// the mesh represents this single instance

			_mesh$1.matrixWorld = _instanceWorldMatrix;

			_mesh$1.raycast( raycaster, _instanceIntersects );

			// process the result of raycast

			for ( let i = 0, l = _instanceIntersects.length; i < l; i ++ ) {

				const intersect = _instanceIntersects[ i ];
				intersect.instanceId = instanceId;
				intersect.object = this;
				intersects.push( intersect );

			}

			_instanceIntersects.length = 0;

		}

	}

	setColorAt( index, color ) {

		if ( this.instanceColor === null ) {

			this.instanceColor = new InstancedBufferAttribute( new Float32Array( this.instanceMatrix.count * 3 ).fill( 1 ), 3 );

		}

		color.toArray( this.instanceColor.array, index * 3 );

	}

	setMatrixAt( index, matrix ) {

		matrix.toArray( this.instanceMatrix.array, index * 16 );

	}

	setMorphAt( index, object ) {

		const objectInfluences = object.morphTargetInfluences;

		const len = objectInfluences.length + 1; // morphBaseInfluence + all influences

		if ( this.morphTexture === null ) {

			this.morphTexture = new DataTexture( new Float32Array( len * this.count ), len, this.count, RedFormat, FloatType );

		}

		const array = this.morphTexture.source.data.data;

		let morphInfluencesSum = 0;

		for ( let i = 0; i < objectInfluences.length; i ++ ) {

			morphInfluencesSum += objectInfluences[ i ];

		}

		const morphBaseInfluence = this.geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;

		const dataIndex = len * index;

		array[ dataIndex ] = morphBaseInfluence;

		array.set( objectInfluences, dataIndex + 1 );

	}

	updateMorphTargets() {

	}

	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

		if ( this.morphTexture !== null ) {

			this.morphTexture.dispose();
			this.morphTexture = null;

		}

		return this;

	}

}

const _vector1 = /*@__PURE__*/ new Vector3();
const _vector2 = /*@__PURE__*/ new Vector3();
const _normalMatrix = /*@__PURE__*/ new Matrix3();

class Plane {

	constructor( normal = new Vector3( 1, 0, 0 ), constant = 0 ) {

		this.isPlane = true;

		// normal is assumed to be normalized

		this.normal = normal;
		this.constant = constant;

	}

	set( normal, constant ) {

		this.normal.copy( normal );
		this.constant = constant;

		return this;

	}

	setComponents( x, y, z, w ) {

		this.normal.set( x, y, z );
		this.constant = w;

		return this;

	}

	setFromNormalAndCoplanarPoint( normal, point ) {

		this.normal.copy( normal );
		this.constant = - point.dot( this.normal );

		return this;

	}

	setFromCoplanarPoints( a, b, c ) {

		const normal = _vector1.subVectors( c, b ).cross( _vector2.subVectors( a, b ) ).normalize();

		// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

		this.setFromNormalAndCoplanarPoint( normal, a );

		return this;

	}

	copy( plane ) {

		this.normal.copy( plane.normal );
		this.constant = plane.constant;

		return this;

	}

	normalize() {

		// Note: will lead to a divide by zero if the plane is invalid.

		const inverseNormalLength = 1.0 / this.normal.length();
		this.normal.multiplyScalar( inverseNormalLength );
		this.constant *= inverseNormalLength;

		return this;

	}

	negate() {

		this.constant *= -1;
		this.normal.negate();

		return this;

	}

	distanceToPoint( point ) {

		return this.normal.dot( point ) + this.constant;

	}

	distanceToSphere( sphere ) {

		return this.distanceToPoint( sphere.center ) - sphere.radius;

	}

	projectPoint( point, target ) {

		return target.copy( point ).addScaledVector( this.normal, - this.distanceToPoint( point ) );

	}

	intersectLine( line, target ) {

		const direction = line.delta( _vector1 );

		const denominator = this.normal.dot( direction );

		if ( denominator === 0 ) {

			// line is coplanar, return origin
			if ( this.distanceToPoint( line.start ) === 0 ) {

				return target.copy( line.start );

			}

			// Unsure if this is the correct method to handle this case.
			return null;

		}

		const t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

		if ( t < 0 || t > 1 ) {

			return null;

		}

		return target.copy( line.start ).addScaledVector( direction, t );

	}

	intersectsLine( line ) {

		// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

		const startSign = this.distanceToPoint( line.start );
		const endSign = this.distanceToPoint( line.end );

		return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

	}

	intersectsBox( box ) {

		return box.intersectsPlane( this );

	}

	intersectsSphere( sphere ) {

		return sphere.intersectsPlane( this );

	}

	coplanarPoint( target ) {

		return target.copy( this.normal ).multiplyScalar( - this.constant );

	}

	applyMatrix4( matrix, optionalNormalMatrix ) {

		const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );

		const referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );

		const normal = this.normal.applyMatrix3( normalMatrix ).normalize();

		this.constant = - referencePoint.dot( normal );

		return this;

	}

	translate( offset ) {

		this.constant -= offset.dot( this.normal );

		return this;

	}

	equals( plane ) {

		return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

const _sphere$3 = /*@__PURE__*/ new Sphere();
const _vector$6 = /*@__PURE__*/ new Vector3();

class Frustum {

	constructor( p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane() ) {

		this.planes = [ p0, p1, p2, p3, p4, p5 ];

	}

	set( p0, p1, p2, p3, p4, p5 ) {

		const planes = this.planes;

		planes[ 0 ].copy( p0 );
		planes[ 1 ].copy( p1 );
		planes[ 2 ].copy( p2 );
		planes[ 3 ].copy( p3 );
		planes[ 4 ].copy( p4 );
		planes[ 5 ].copy( p5 );

		return this;

	}

	copy( frustum ) {

		const planes = this.planes;

		for ( let i = 0; i < 6; i ++ ) {

			planes[ i ].copy( frustum.planes[ i ] );

		}

		return this;

	}

	setFromProjectionMatrix( m, coordinateSystem = WebGLCoordinateSystem ) {

		const planes = this.planes;
		const me = m.elements;
		const me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
		const me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
		const me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
		const me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

		planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
		planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
		planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
		planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
		planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();

		if ( coordinateSystem === WebGLCoordinateSystem ) {

			planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

		} else if ( coordinateSystem === WebGPUCoordinateSystem ) {

			planes[ 5 ].setComponents( me2, me6, me10, me14 ).normalize();

		} else {

			throw new Error( 'THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: ' + coordinateSystem );

		}

		return this;

	}

	intersectsObject( object ) {

		if ( object.boundingSphere !== undefined ) {

			if ( object.boundingSphere === null ) object.computeBoundingSphere();

			_sphere$3.copy( object.boundingSphere ).applyMatrix4( object.matrixWorld );

		} else {

			const geometry = object.geometry;

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			_sphere$3.copy( geometry.boundingSphere ).applyMatrix4( object.matrixWorld );

		}

		return this.intersectsSphere( _sphere$3 );

	}

	intersectsSprite( sprite ) {

		_sphere$3.center.set( 0, 0, 0 );
		_sphere$3.radius = 0.7071067811865476;
		_sphere$3.applyMatrix4( sprite.matrixWorld );

		return this.intersectsSphere( _sphere$3 );

	}

	intersectsSphere( sphere ) {

		const planes = this.planes;
		const center = sphere.center;
		const negRadius = - sphere.radius;

		for ( let i = 0; i < 6; i ++ ) {

			const distance = planes[ i ].distanceToPoint( center );

			if ( distance < negRadius ) {

				return false;

			}

		}

		return true;

	}

	intersectsBox( box ) {

		const planes = this.planes;

		for ( let i = 0; i < 6; i ++ ) {

			const plane = planes[ i ];

			// corner at max distance

			_vector$6.x = plane.normal.x > 0 ? box.max.x : box.min.x;
			_vector$6.y = plane.normal.y > 0 ? box.max.y : box.min.y;
			_vector$6.z = plane.normal.z > 0 ? box.max.z : box.min.z;

			if ( plane.distanceToPoint( _vector$6 ) < 0 ) {

				return false;

			}

		}

		return true;

	}

	containsPoint( point ) {

		const planes = this.planes;

		for ( let i = 0; i < 6; i ++ ) {

			if ( planes[ i ].distanceToPoint( point ) < 0 ) {

				return false;

			}

		}

		return true;

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

class LineBasicMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isLineBasicMaterial = true;

		this.type = 'LineBasicMaterial';

		this.color = new Color( 0xffffff );

		this.map = null;

		this.linewidth = 1;
		this.linecap = 'round';
		this.linejoin = 'round';

		this.fog = true;

		this.setValues( parameters );

	}


	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;

		this.linewidth = source.linewidth;
		this.linecap = source.linecap;
		this.linejoin = source.linejoin;

		this.fog = source.fog;

		return this;

	}

}

class PointsMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isPointsMaterial = true;

		this.type = 'PointsMaterial';

		this.color = new Color( 0xffffff );

		this.map = null;

		this.alphaMap = null;

		this.size = 1;
		this.sizeAttenuation = true;

		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.size = source.size;
		this.sizeAttenuation = source.sizeAttenuation;

		this.fog = source.fog;

		return this;

	}

}

const _inverseMatrix = /*@__PURE__*/ new Matrix4();
const _ray = /*@__PURE__*/ new Ray();
const _sphere = /*@__PURE__*/ new Sphere();
const _position$2 = /*@__PURE__*/ new Vector3();

class Points extends Object3D {

	constructor( geometry = new BufferGeometry(), material = new PointsMaterial() ) {

		super();

		this.isPoints = true;

		this.type = 'Points';

		this.geometry = geometry;
		this.material = material;

		this.updateMorphTargets();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.material = Array.isArray( source.material ) ? source.material.slice() : source.material;
		this.geometry = source.geometry;

		return this;

	}

	raycast( raycaster, intersects ) {

		const geometry = this.geometry;
		const matrixWorld = this.matrixWorld;
		const threshold = raycaster.params.Points.threshold;
		const drawRange = geometry.drawRange;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere.copy( geometry.boundingSphere );
		_sphere.applyMatrix4( matrixWorld );
		_sphere.radius += threshold;

		if ( raycaster.ray.intersectsSphere( _sphere ) === false ) return;

		//

		_inverseMatrix.copy( matrixWorld ).invert();
		_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );

		const localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
		const localThresholdSq = localThreshold * localThreshold;

		const index = geometry.index;
		const attributes = geometry.attributes;
		const positionAttribute = attributes.position;

		if ( index !== null ) {

			const start = Math.max( 0, drawRange.start );
			const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

			for ( let i = start, il = end; i < il; i ++ ) {

				const a = index.getX( i );

				_position$2.fromBufferAttribute( positionAttribute, a );

				testPoint( _position$2, a, localThresholdSq, matrixWorld, raycaster, intersects, this );

			}

		} else {

			const start = Math.max( 0, drawRange.start );
			const end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );

			for ( let i = start, l = end; i < l; i ++ ) {

				_position$2.fromBufferAttribute( positionAttribute, i );

				testPoint( _position$2, i, localThresholdSq, matrixWorld, raycaster, intersects, this );

			}

		}

	}

	updateMorphTargets() {

		const geometry = this.geometry;

		const morphAttributes = geometry.morphAttributes;
		const keys = Object.keys( morphAttributes );

		if ( keys.length > 0 ) {

			const morphAttribute = morphAttributes[ keys[ 0 ] ];

			if ( morphAttribute !== undefined ) {

				this.morphTargetInfluences = [];
				this.morphTargetDictionary = {};

				for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

					const name = morphAttribute[ m ].name || String( m );

					this.morphTargetInfluences.push( 0 );
					this.morphTargetDictionary[ name ] = m;

				}

			}

		}

	}

}

function testPoint( point, index, localThresholdSq, matrixWorld, raycaster, intersects, object ) {

	const rayPointDistanceSq = _ray.distanceSqToPoint( point );

	if ( rayPointDistanceSq < localThresholdSq ) {

		const intersectPoint = new Vector3();

		_ray.closestPointToPoint( point, intersectPoint );
		intersectPoint.applyMatrix4( matrixWorld );

		const distance = raycaster.ray.origin.distanceTo( intersectPoint );

		if ( distance < raycaster.near || distance > raycaster.far ) return;

		intersects.push( {

			distance: distance,
			distanceToRay: Math.sqrt( rayPointDistanceSq ),
			point: intersectPoint,
			index: index,
			face: null,
			faceIndex: null,
			barycoord: null,
			object: object

		} );

	}

}

class Group extends Object3D {

	constructor() {

		super();

		this.isGroup = true;

		this.type = 'Group';

	}

}

class FramebufferTexture extends Texture {

	constructor( width, height ) {

		super( { width, height } );

		this.isFramebufferTexture = true;

		this.magFilter = NearestFilter;
		this.minFilter = NearestFilter;

		this.generateMipmaps = false;

		this.needsUpdate = true;

	}

}

class DepthTexture extends Texture {

	constructor( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format = DepthFormat ) {

		if ( format !== DepthFormat && format !== DepthStencilFormat ) {

			throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );

		}

		if ( type === undefined && format === DepthFormat ) type = UnsignedIntType;
		if ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;

		super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.isDepthTexture = true;

		this.image = { width: width, height: height };

		this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
		this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

		this.flipY = false;
		this.generateMipmaps = false;

		this.compareFunction = null;

	}


	copy( source ) {

		super.copy( source );

		this.compareFunction = source.compareFunction;

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		if ( this.compareFunction !== null ) data.compareFunction = this.compareFunction;

		return data;

	}

}

/**
 * Extensible curve object.
 *
 * Some common of curve methods:
 * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
 * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following curves inherit from THREE.Curve:
 *
 * -- 2D curves --
 * THREE.ArcCurve
 * THREE.CubicBezierCurve
 * THREE.EllipseCurve
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.SplineCurve
 *
 * -- 3D curves --
 * THREE.CatmullRomCurve3
 * THREE.CubicBezierCurve3
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath.
 *
 **/

class Curve {

	constructor() {

		this.type = 'Curve';

		this.arcLengthDivisions = 200;

	}

	// Virtual base class method to overwrite and implement in subclasses
	//	- t [0 .. 1]

	getPoint( /* t, optionalTarget */ ) {

		console.warn( 'THREE.Curve: .getPoint() not implemented.' );
		return null;

	}

	// Get point at relative position in curve according to arc length
	// - u [0 .. 1]

	getPointAt( u, optionalTarget ) {

		const t = this.getUtoTmapping( u );
		return this.getPoint( t, optionalTarget );

	}

	// Get sequence of points using getPoint( t )

	getPoints( divisions = 5 ) {

		const points = [];

		for ( let d = 0; d <= divisions; d ++ ) {

			points.push( this.getPoint( d / divisions ) );

		}

		return points;

	}

	// Get sequence of points using getPointAt( u )

	getSpacedPoints( divisions = 5 ) {

		const points = [];

		for ( let d = 0; d <= divisions; d ++ ) {

			points.push( this.getPointAt( d / divisions ) );

		}

		return points;

	}

	// Get total curve arc length

	getLength() {

		const lengths = this.getLengths();
		return lengths[ lengths.length - 1 ];

	}

	// Get list of cumulative segment lengths

	getLengths( divisions = this.arcLengthDivisions ) {

		if ( this.cacheArcLengths &&
			( this.cacheArcLengths.length === divisions + 1 ) &&
			! this.needsUpdate ) {

			return this.cacheArcLengths;

		}

		this.needsUpdate = false;

		const cache = [];
		let current, last = this.getPoint( 0 );
		let sum = 0;

		cache.push( 0 );

		for ( let p = 1; p <= divisions; p ++ ) {

			current = this.getPoint( p / divisions );
			sum += current.distanceTo( last );
			cache.push( sum );
			last = current;

		}

		this.cacheArcLengths = cache;

		return cache; // { sums: cache, sum: sum }; Sum is in the last element.

	}

	updateArcLengths() {

		this.needsUpdate = true;
		this.getLengths();

	}

	// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

	getUtoTmapping( u, distance ) {

		const arcLengths = this.getLengths();

		let i = 0;
		const il = arcLengths.length;

		let targetArcLength; // The targeted u distance value to get

		if ( distance ) {

			targetArcLength = distance;

		} else {

			targetArcLength = u * arcLengths[ il - 1 ];

		}

		// binary search for the index with largest value smaller than target u distance

		let low = 0, high = il - 1, comparison;

		while ( low <= high ) {

			i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

			comparison = arcLengths[ i ] - targetArcLength;

			if ( comparison < 0 ) {

				low = i + 1;

			} else if ( comparison > 0 ) {

				high = i - 1;

			} else {

				high = i;
				break;

				// DONE

			}

		}

		i = high;

		if ( arcLengths[ i ] === targetArcLength ) {

			return i / ( il - 1 );

		}

		// we could get finer grain at lengths, or use simple interpolation between two points

		const lengthBefore = arcLengths[ i ];
		const lengthAfter = arcLengths[ i + 1 ];

		const segmentLength = lengthAfter - lengthBefore;

		// determine where we are between the 'before' and 'after' points

		const segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

		// add that fractional amount to t

		const t = ( i + segmentFraction ) / ( il - 1 );

		return t;

	}

	// Returns a unit vector tangent at t
	// In case any sub curve does not implement its tangent derivation,
	// 2 points a small delta apart will be used to find its gradient
	// which seems to give a reasonable approximation

	getTangent( t, optionalTarget ) {

		const delta = 0.0001;
		let t1 = t - delta;
		let t2 = t + delta;

		// Capping in case of danger

		if ( t1 < 0 ) t1 = 0;
		if ( t2 > 1 ) t2 = 1;

		const pt1 = this.getPoint( t1 );
		const pt2 = this.getPoint( t2 );

		const tangent = optionalTarget || ( ( pt1.isVector2 ) ? new Vector2() : new Vector3() );

		tangent.copy( pt2 ).sub( pt1 ).normalize();

		return tangent;

	}

	getTangentAt( u, optionalTarget ) {

		const t = this.getUtoTmapping( u );
		return this.getTangent( t, optionalTarget );

	}

	computeFrenetFrames( segments, closed ) {

		// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf

		const normal = new Vector3();

		const tangents = [];
		const normals = [];
		const binormals = [];

		const vec = new Vector3();
		const mat = new Matrix4();

		// compute the tangent vectors for each segment on the curve

		for ( let i = 0; i <= segments; i ++ ) {

			const u = i / segments;

			tangents[ i ] = this.getTangentAt( u, new Vector3() );

		}

		// select an initial normal vector perpendicular to the first tangent vector,
		// and in the direction of the minimum tangent xyz component

		normals[ 0 ] = new Vector3();
		binormals[ 0 ] = new Vector3();
		let min = Number.MAX_VALUE;
		const tx = Math.abs( tangents[ 0 ].x );
		const ty = Math.abs( tangents[ 0 ].y );
		const tz = Math.abs( tangents[ 0 ].z );

		if ( tx <= min ) {

			min = tx;
			normal.set( 1, 0, 0 );

		}

		if ( ty <= min ) {

			min = ty;
			normal.set( 0, 1, 0 );

		}

		if ( tz <= min ) {

			normal.set( 0, 0, 1 );

		}

		vec.crossVectors( tangents[ 0 ], normal ).normalize();

		normals[ 0 ].crossVectors( tangents[ 0 ], vec );
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );


		// compute the slowly-varying normal and binormal vectors for each segment on the curve

		for ( let i = 1; i <= segments; i ++ ) {

			normals[ i ] = normals[ i - 1 ].clone();

			binormals[ i ] = binormals[ i - 1 ].clone();

			vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

			if ( vec.length() > Number.EPSILON ) {

				vec.normalize();

				const theta = Math.acos( clamp$1( tangents[ i - 1 ].dot( tangents[ i ] ), -1, 1 ) ); // clamp for floating pt errors

				normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

			}

			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

		}

		// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

		if ( closed === true ) {

			let theta = Math.acos( clamp$1( normals[ 0 ].dot( normals[ segments ] ), -1, 1 ) );
			theta /= segments;

			if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {

				theta = - theta;

			}

			for ( let i = 1; i <= segments; i ++ ) {

				// twist a little...
				normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
				binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

			}

		}

		return {
			tangents: tangents,
			normals: normals,
			binormals: binormals
		};

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( source ) {

		this.arcLengthDivisions = source.arcLengthDivisions;

		return this;

	}

	toJSON() {

		const data = {
			metadata: {
				version: 4.6,
				type: 'Curve',
				generator: 'Curve.toJSON'
			}
		};

		data.arcLengthDivisions = this.arcLengthDivisions;
		data.type = this.type;

		return data;

	}

	fromJSON( json ) {

		this.arcLengthDivisions = json.arcLengthDivisions;

		return this;

	}

}

class EllipseCurve extends Curve {

	constructor( aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0 ) {

		super();

		this.isEllipseCurve = true;

		this.type = 'EllipseCurve';

		this.aX = aX;
		this.aY = aY;

		this.xRadius = xRadius;
		this.yRadius = yRadius;

		this.aStartAngle = aStartAngle;
		this.aEndAngle = aEndAngle;

		this.aClockwise = aClockwise;

		this.aRotation = aRotation;

	}

	getPoint( t, optionalTarget = new Vector2() ) {

		const point = optionalTarget;

		const twoPi = Math.PI * 2;
		let deltaAngle = this.aEndAngle - this.aStartAngle;
		const samePoints = Math.abs( deltaAngle ) < Number.EPSILON;

		// ensures that deltaAngle is 0 .. 2 PI
		while ( deltaAngle < 0 ) deltaAngle += twoPi;
		while ( deltaAngle > twoPi ) deltaAngle -= twoPi;

		if ( deltaAngle < Number.EPSILON ) {

			if ( samePoints ) {

				deltaAngle = 0;

			} else {

				deltaAngle = twoPi;

			}

		}

		if ( this.aClockwise === true && ! samePoints ) {

			if ( deltaAngle === twoPi ) {

				deltaAngle = - twoPi;

			} else {

				deltaAngle = deltaAngle - twoPi;

			}

		}

		const angle = this.aStartAngle + t * deltaAngle;
		let x = this.aX + this.xRadius * Math.cos( angle );
		let y = this.aY + this.yRadius * Math.sin( angle );

		if ( this.aRotation !== 0 ) {

			const cos = Math.cos( this.aRotation );
			const sin = Math.sin( this.aRotation );

			const tx = x - this.aX;
			const ty = y - this.aY;

			// Rotate the point about the center of the ellipse.
			x = tx * cos - ty * sin + this.aX;
			y = tx * sin + ty * cos + this.aY;

		}

		return point.set( x, y );

	}

	copy( source ) {

		super.copy( source );

		this.aX = source.aX;
		this.aY = source.aY;

		this.xRadius = source.xRadius;
		this.yRadius = source.yRadius;

		this.aStartAngle = source.aStartAngle;
		this.aEndAngle = source.aEndAngle;

		this.aClockwise = source.aClockwise;

		this.aRotation = source.aRotation;

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.aX = this.aX;
		data.aY = this.aY;

		data.xRadius = this.xRadius;
		data.yRadius = this.yRadius;

		data.aStartAngle = this.aStartAngle;
		data.aEndAngle = this.aEndAngle;

		data.aClockwise = this.aClockwise;

		data.aRotation = this.aRotation;

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.aX = json.aX;
		this.aY = json.aY;

		this.xRadius = json.xRadius;
		this.yRadius = json.yRadius;

		this.aStartAngle = json.aStartAngle;
		this.aEndAngle = json.aEndAngle;

		this.aClockwise = json.aClockwise;

		this.aRotation = json.aRotation;

		return this;

	}

}

class ArcCurve extends EllipseCurve {

	constructor( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		super( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

		this.isArcCurve = true;

		this.type = 'ArcCurve';

	}

}

/**
 * Centripetal CatmullRom Curve - which is useful for avoiding
 * cusps and self-intersections in non-uniform catmull rom curves.
 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
 *
 * curve.type accepts centripetal(default), chordal and catmullrom
 * curve.tension is used for catmullrom which defaults to 0.5
 */


/*
Based on an optimized c++ solution in
 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
 - http://ideone.com/NoEbVM

This CubicPoly class could be used for reusing some variables and calculations,
but for three.js curve use, it could be possible inlined and flatten into a single function call
which can be placed in CurveUtils.
*/

function CubicPoly() {

	let c0 = 0, c1 = 0, c2 = 0, c3 = 0;

	/*
	 * Compute coefficients for a cubic polynomial
	 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
	 * such that
	 *   p(0) = x0, p(1) = x1
	 *  and
	 *   p'(0) = t0, p'(1) = t1.
	 */
	function init( x0, x1, t0, t1 ) {

		c0 = x0;
		c1 = t0;
		c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
		c3 = 2 * x0 - 2 * x1 + t0 + t1;

	}

	return {

		initCatmullRom: function ( x0, x1, x2, x3, tension ) {

			init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

		},

		initNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {

			// compute tangents when parameterized in [t1,t2]
			let t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
			let t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

			// rescale tangents for parametrization in [0,1]
			t1 *= dt1;
			t2 *= dt1;

			init( x1, x2, t1, t2 );

		},

		calc: function ( t ) {

			const t2 = t * t;
			const t3 = t2 * t;
			return c0 + c1 * t + c2 * t2 + c3 * t3;

		}

	};

}

//

const tmp = /*@__PURE__*/ new Vector3();
const px = /*@__PURE__*/ new CubicPoly();
const py = /*@__PURE__*/ new CubicPoly();
const pz = /*@__PURE__*/ new CubicPoly();

class CatmullRomCurve3 extends Curve {

	constructor( points = [], closed = false, curveType = 'centripetal', tension = 0.5 ) {

		super();

		this.isCatmullRomCurve3 = true;

		this.type = 'CatmullRomCurve3';

		this.points = points;
		this.closed = closed;
		this.curveType = curveType;
		this.tension = tension;

	}

	getPoint( t, optionalTarget = new Vector3() ) {

		const point = optionalTarget;

		const points = this.points;
		const l = points.length;

		const p = ( l - ( this.closed ? 0 : 1 ) ) * t;
		let intPoint = Math.floor( p );
		let weight = p - intPoint;

		if ( this.closed ) {

			intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / l ) + 1 ) * l;

		} else if ( weight === 0 && intPoint === l - 1 ) {

			intPoint = l - 2;
			weight = 1;

		}

		let p0, p3; // 4 points (p1 & p2 defined below)

		if ( this.closed || intPoint > 0 ) {

			p0 = points[ ( intPoint - 1 ) % l ];

		} else {

			// extrapolate first point
			tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
			p0 = tmp;

		}

		const p1 = points[ intPoint % l ];
		const p2 = points[ ( intPoint + 1 ) % l ];

		if ( this.closed || intPoint + 2 < l ) {

			p3 = points[ ( intPoint + 2 ) % l ];

		} else {

			// extrapolate last point
			tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
			p3 = tmp;

		}

		if ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) {

			// init Centripetal / Chordal Catmull-Rom
			const pow = this.curveType === 'chordal' ? 0.5 : 0.25;
			let dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
			let dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
			let dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

			// safety check for repeated points
			if ( dt1 < 1e-4 ) dt1 = 1.0;
			if ( dt0 < 1e-4 ) dt0 = dt1;
			if ( dt2 < 1e-4 ) dt2 = dt1;

			px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
			py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
			pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

		} else if ( this.curveType === 'catmullrom' ) {

			px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension );
			py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension );
			pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension );

		}

		point.set(
			px.calc( weight ),
			py.calc( weight ),
			pz.calc( weight )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.points = [];

		for ( let i = 0, l = source.points.length; i < l; i ++ ) {

			const point = source.points[ i ];

			this.points.push( point.clone() );

		}

		this.closed = source.closed;
		this.curveType = source.curveType;
		this.tension = source.tension;

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.points = [];

		for ( let i = 0, l = this.points.length; i < l; i ++ ) {

			const point = this.points[ i ];
			data.points.push( point.toArray() );

		}

		data.closed = this.closed;
		data.curveType = this.curveType;
		data.tension = this.tension;

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.points = [];

		for ( let i = 0, l = json.points.length; i < l; i ++ ) {

			const point = json.points[ i ];
			this.points.push( new Vector3().fromArray( point ) );

		}

		this.closed = json.closed;
		this.curveType = json.curveType;
		this.tension = json.tension;

		return this;

	}

}

/**
 * Bezier Curves formulas obtained from
 * https://en.wikipedia.org/wiki/B%C3%A9zier_curve
 */

function CatmullRom( t, p0, p1, p2, p3 ) {

	const v0 = ( p2 - p0 ) * 0.5;
	const v1 = ( p3 - p1 ) * 0.5;
	const t2 = t * t;
	const t3 = t * t2;
	return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( -3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

}

//

function QuadraticBezierP0( t, p ) {

	const k = 1 - t;
	return k * k * p;

}

function QuadraticBezierP1( t, p ) {

	return 2 * ( 1 - t ) * t * p;

}

function QuadraticBezierP2( t, p ) {

	return t * t * p;

}

function QuadraticBezier( t, p0, p1, p2 ) {

	return QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +
		QuadraticBezierP2( t, p2 );

}

//

function CubicBezierP0( t, p ) {

	const k = 1 - t;
	return k * k * k * p;

}

function CubicBezierP1( t, p ) {

	const k = 1 - t;
	return 3 * k * k * t * p;

}

function CubicBezierP2( t, p ) {

	return 3 * ( 1 - t ) * t * t * p;

}

function CubicBezierP3( t, p ) {

	return t * t * t * p;

}

function CubicBezier( t, p0, p1, p2, p3 ) {

	return CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +
		CubicBezierP3( t, p3 );

}

class CubicBezierCurve extends Curve {

	constructor( v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2() ) {

		super();

		this.isCubicBezierCurve = true;

		this.type = 'CubicBezierCurve';

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
		this.v3 = v3;

	}

	getPoint( t, optionalTarget = new Vector2() ) {

		const point = optionalTarget;

		const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

		point.set(
			CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
			CubicBezier( t, v0.y, v1.y, v2.y, v3.y )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );
		this.v3.copy( source.v3 );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		data.v3 = this.v3.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );
		this.v3.fromArray( json.v3 );

		return this;

	}

}

class CubicBezierCurve3 extends Curve {

	constructor( v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3() ) {

		super();

		this.isCubicBezierCurve3 = true;

		this.type = 'CubicBezierCurve3';

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
		this.v3 = v3;

	}

	getPoint( t, optionalTarget = new Vector3() ) {

		const point = optionalTarget;

		const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

		point.set(
			CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
			CubicBezier( t, v0.y, v1.y, v2.y, v3.y ),
			CubicBezier( t, v0.z, v1.z, v2.z, v3.z )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );
		this.v3.copy( source.v3 );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		data.v3 = this.v3.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );
		this.v3.fromArray( json.v3 );

		return this;

	}

}

class LineCurve extends Curve {

	constructor( v1 = new Vector2(), v2 = new Vector2() ) {

		super();

		this.isLineCurve = true;

		this.type = 'LineCurve';

		this.v1 = v1;
		this.v2 = v2;

	}

	getPoint( t, optionalTarget = new Vector2() ) {

		const point = optionalTarget;

		if ( t === 1 ) {

			point.copy( this.v2 );

		} else {

			point.copy( this.v2 ).sub( this.v1 );
			point.multiplyScalar( t ).add( this.v1 );

		}

		return point;

	}

	// Line curve is linear, so we can overwrite default getPointAt
	getPointAt( u, optionalTarget ) {

		return this.getPoint( u, optionalTarget );

	}

	getTangent( t, optionalTarget = new Vector2() ) {

		return optionalTarget.subVectors( this.v2, this.v1 ).normalize();

	}

	getTangentAt( u, optionalTarget ) {

		return this.getTangent( u, optionalTarget );

	}

	copy( source ) {

		super.copy( source );

		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	}

}

class LineCurve3 extends Curve {

	constructor( v1 = new Vector3(), v2 = new Vector3() ) {

		super();

		this.isLineCurve3 = true;

		this.type = 'LineCurve3';

		this.v1 = v1;
		this.v2 = v2;

	}

	getPoint( t, optionalTarget = new Vector3() ) {

		const point = optionalTarget;

		if ( t === 1 ) {

			point.copy( this.v2 );

		} else {

			point.copy( this.v2 ).sub( this.v1 );
			point.multiplyScalar( t ).add( this.v1 );

		}

		return point;

	}

	// Line curve is linear, so we can overwrite default getPointAt
	getPointAt( u, optionalTarget ) {

		return this.getPoint( u, optionalTarget );

	}

	getTangent( t, optionalTarget = new Vector3() ) {

		return optionalTarget.subVectors( this.v2, this.v1 ).normalize();

	}

	getTangentAt( u, optionalTarget ) {

		return this.getTangent( u, optionalTarget );

	}

	copy( source ) {

		super.copy( source );

		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	}

}

class QuadraticBezierCurve extends Curve {

	constructor( v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2() ) {

		super();

		this.isQuadraticBezierCurve = true;

		this.type = 'QuadraticBezierCurve';

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;

	}

	getPoint( t, optionalTarget = new Vector2() ) {

		const point = optionalTarget;

		const v0 = this.v0, v1 = this.v1, v2 = this.v2;

		point.set(
			QuadraticBezier( t, v0.x, v1.x, v2.x ),
			QuadraticBezier( t, v0.y, v1.y, v2.y )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	}

}

class QuadraticBezierCurve3 extends Curve {

	constructor( v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3() ) {

		super();

		this.isQuadraticBezierCurve3 = true;

		this.type = 'QuadraticBezierCurve3';

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;

	}

	getPoint( t, optionalTarget = new Vector3() ) {

		const point = optionalTarget;

		const v0 = this.v0, v1 = this.v1, v2 = this.v2;

		point.set(
			QuadraticBezier( t, v0.x, v1.x, v2.x ),
			QuadraticBezier( t, v0.y, v1.y, v2.y ),
			QuadraticBezier( t, v0.z, v1.z, v2.z )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	}

}

class SplineCurve extends Curve {

	constructor( points = [] ) {

		super();

		this.isSplineCurve = true;

		this.type = 'SplineCurve';

		this.points = points;

	}

	getPoint( t, optionalTarget = new Vector2() ) {

		const point = optionalTarget;

		const points = this.points;
		const p = ( points.length - 1 ) * t;

		const intPoint = Math.floor( p );
		const weight = p - intPoint;

		const p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
		const p1 = points[ intPoint ];
		const p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
		const p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

		point.set(
			CatmullRom( weight, p0.x, p1.x, p2.x, p3.x ),
			CatmullRom( weight, p0.y, p1.y, p2.y, p3.y )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.points = [];

		for ( let i = 0, l = source.points.length; i < l; i ++ ) {

			const point = source.points[ i ];

			this.points.push( point.clone() );

		}

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.points = [];

		for ( let i = 0, l = this.points.length; i < l; i ++ ) {

			const point = this.points[ i ];
			data.points.push( point.toArray() );

		}

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.points = [];

		for ( let i = 0, l = json.points.length; i < l; i ++ ) {

			const point = json.points[ i ];
			this.points.push( new Vector2().fromArray( point ) );

		}

		return this;

	}

}

var Curves = /*#__PURE__*/Object.freeze({
	__proto__: null,
	ArcCurve: ArcCurve,
	CatmullRomCurve3: CatmullRomCurve3,
	CubicBezierCurve: CubicBezierCurve,
	CubicBezierCurve3: CubicBezierCurve3,
	EllipseCurve: EllipseCurve,
	LineCurve: LineCurve,
	LineCurve3: LineCurve3,
	QuadraticBezierCurve: QuadraticBezierCurve,
	QuadraticBezierCurve3: QuadraticBezierCurve3,
	SplineCurve: SplineCurve
});

/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/

class CurvePath extends Curve {

	constructor() {

		super();

		this.type = 'CurvePath';

		this.curves = [];
		this.autoClose = false; // Automatically closes the path

	}

	add( curve ) {

		this.curves.push( curve );

	}

	closePath() {

		// Add a line curve if start and end of lines are not connected
		const startPoint = this.curves[ 0 ].getPoint( 0 );
		const endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

		if ( ! startPoint.equals( endPoint ) ) {

			const lineType = ( startPoint.isVector2 === true ) ? 'LineCurve' : 'LineCurve3';
			this.curves.push( new Curves[ lineType ]( endPoint, startPoint ) );

		}

		return this;

	}

	// To get accurate point with reference to
	// entire path distance at time t,
	// following has to be done:

	// 1. Length of each sub path have to be known
	// 2. Locate and identify type of curve
	// 3. Get t for the curve
	// 4. Return curve.getPointAt(t')

	getPoint( t, optionalTarget ) {

		const d = t * this.getLength();
		const curveLengths = this.getCurveLengths();
		let i = 0;

		// To think about boundaries points.

		while ( i < curveLengths.length ) {

			if ( curveLengths[ i ] >= d ) {

				const diff = curveLengths[ i ] - d;
				const curve = this.curves[ i ];

				const segmentLength = curve.getLength();
				const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;

				return curve.getPointAt( u, optionalTarget );

			}

			i ++;

		}

		return null;

		// loop where sum != 0, sum > d , sum+1 <d

	}

	// We cannot use the default THREE.Curve getPoint() with getLength() because in
	// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
	// getPoint() depends on getLength

	getLength() {

		const lens = this.getCurveLengths();
		return lens[ lens.length - 1 ];

	}

	// cacheLengths must be recalculated.
	updateArcLengths() {

		this.needsUpdate = true;
		this.cacheLengths = null;
		this.getCurveLengths();

	}

	// Compute lengths and cache them
	// We cannot overwrite getLengths() because UtoT mapping uses it.

	getCurveLengths() {

		// We use cache values if curves and cache array are same length

		if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

			return this.cacheLengths;

		}

		// Get length of sub-curve
		// Push sums into cached array

		const lengths = [];
		let sums = 0;

		for ( let i = 0, l = this.curves.length; i < l; i ++ ) {

			sums += this.curves[ i ].getLength();
			lengths.push( sums );

		}

		this.cacheLengths = lengths;

		return lengths;

	}

	getSpacedPoints( divisions = 40 ) {

		const points = [];

		for ( let i = 0; i <= divisions; i ++ ) {

			points.push( this.getPoint( i / divisions ) );

		}

		if ( this.autoClose ) {

			points.push( points[ 0 ] );

		}

		return points;

	}

	getPoints( divisions = 12 ) {

		const points = [];
		let last;

		for ( let i = 0, curves = this.curves; i < curves.length; i ++ ) {

			const curve = curves[ i ];
			const resolution = curve.isEllipseCurve ? divisions * 2
				: ( curve.isLineCurve || curve.isLineCurve3 ) ? 1
					: curve.isSplineCurve ? divisions * curve.points.length
						: divisions;

			const pts = curve.getPoints( resolution );

			for ( let j = 0; j < pts.length; j ++ ) {

				const point = pts[ j ];

				if ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates

				points.push( point );
				last = point;

			}

		}

		if ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {

			points.push( points[ 0 ] );

		}

		return points;

	}

	copy( source ) {

		super.copy( source );

		this.curves = [];

		for ( let i = 0, l = source.curves.length; i < l; i ++ ) {

			const curve = source.curves[ i ];

			this.curves.push( curve.clone() );

		}

		this.autoClose = source.autoClose;

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.autoClose = this.autoClose;
		data.curves = [];

		for ( let i = 0, l = this.curves.length; i < l; i ++ ) {

			const curve = this.curves[ i ];
			data.curves.push( curve.toJSON() );

		}

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.autoClose = json.autoClose;
		this.curves = [];

		for ( let i = 0, l = json.curves.length; i < l; i ++ ) {

			const curve = json.curves[ i ];
			this.curves.push( new Curves[ curve.type ]().fromJSON( curve ) );

		}

		return this;

	}

}

class Path extends CurvePath {

	constructor( points ) {

		super();

		this.type = 'Path';

		this.currentPoint = new Vector2();

		if ( points ) {

			this.setFromPoints( points );

		}

	}

	setFromPoints( points ) {

		this.moveTo( points[ 0 ].x, points[ 0 ].y );

		for ( let i = 1, l = points.length; i < l; i ++ ) {

			this.lineTo( points[ i ].x, points[ i ].y );

		}

		return this;

	}

	moveTo( x, y ) {

		this.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?

		return this;

	}

	lineTo( x, y ) {

		const curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );
		this.curves.push( curve );

		this.currentPoint.set( x, y );

		return this;

	}

	quadraticCurveTo( aCPx, aCPy, aX, aY ) {

		const curve = new QuadraticBezierCurve(
			this.currentPoint.clone(),
			new Vector2( aCPx, aCPy ),
			new Vector2( aX, aY )
		);

		this.curves.push( curve );

		this.currentPoint.set( aX, aY );

		return this;

	}

	bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

		const curve = new CubicBezierCurve(
			this.currentPoint.clone(),
			new Vector2( aCP1x, aCP1y ),
			new Vector2( aCP2x, aCP2y ),
			new Vector2( aX, aY )
		);

		this.curves.push( curve );

		this.currentPoint.set( aX, aY );

		return this;

	}

	splineThru( pts /*Array of Vector*/ ) {

		const npts = [ this.currentPoint.clone() ].concat( pts );

		const curve = new SplineCurve( npts );
		this.curves.push( curve );

		this.currentPoint.copy( pts[ pts.length - 1 ] );

		return this;

	}

	arc( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		const x0 = this.currentPoint.x;
		const y0 = this.currentPoint.y;

		this.absarc( aX + x0, aY + y0, aRadius,
			aStartAngle, aEndAngle, aClockwise );

		return this;

	}

	absarc( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

		return this;

	}

	ellipse( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

		const x0 = this.currentPoint.x;
		const y0 = this.currentPoint.y;

		this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

		return this;

	}

	absellipse( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

		const curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

		if ( this.curves.length > 0 ) {

			// if a previous curve is present, attempt to join
			const firstPoint = curve.getPoint( 0 );

			if ( ! firstPoint.equals( this.currentPoint ) ) {

				this.lineTo( firstPoint.x, firstPoint.y );

			}

		}

		this.curves.push( curve );

		const lastPoint = curve.getPoint( 1 );
		this.currentPoint.copy( lastPoint );

		return this;

	}

	copy( source ) {

		super.copy( source );

		this.currentPoint.copy( source.currentPoint );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.currentPoint = this.currentPoint.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.currentPoint.fromArray( json.currentPoint );

		return this;

	}

}

class LatheGeometry extends BufferGeometry {

	constructor( points = [ new Vector2( 0, -0.5 ), new Vector2( 0.5, 0 ), new Vector2( 0, 0.5 ) ], segments = 12, phiStart = 0, phiLength = Math.PI * 2 ) {

		super();

		this.type = 'LatheGeometry';

		this.parameters = {
			points: points,
			segments: segments,
			phiStart: phiStart,
			phiLength: phiLength
		};

		segments = Math.floor( segments );

		// clamp phiLength so it's in range of [ 0, 2PI ]

		phiLength = clamp$1( phiLength, 0, Math.PI * 2 );

		// buffers

		const indices = [];
		const vertices = [];
		const uvs = [];
		const initNormals = [];
		const normals = [];

		// helper variables

		const inverseSegments = 1.0 / segments;
		const vertex = new Vector3();
		const uv = new Vector2();
		const normal = new Vector3();
		const curNormal = new Vector3();
		const prevNormal = new Vector3();
		let dx = 0;
		let dy = 0;

		// pre-compute normals for initial "meridian"

		for ( let j = 0; j <= ( points.length - 1 ); j ++ ) {

			switch ( j ) {

				case 0:				// special handling for 1st vertex on path

					dx = points[ j + 1 ].x - points[ j ].x;
					dy = points[ j + 1 ].y - points[ j ].y;

					normal.x = dy * 1.0;
					normal.y = - dx;
					normal.z = dy * 0.0;

					prevNormal.copy( normal );

					normal.normalize();

					initNormals.push( normal.x, normal.y, normal.z );

					break;

				case ( points.length - 1 ):	// special handling for last Vertex on path

					initNormals.push( prevNormal.x, prevNormal.y, prevNormal.z );

					break;

				default:			// default handling for all vertices in between

					dx = points[ j + 1 ].x - points[ j ].x;
					dy = points[ j + 1 ].y - points[ j ].y;

					normal.x = dy * 1.0;
					normal.y = - dx;
					normal.z = dy * 0.0;

					curNormal.copy( normal );

					normal.x += prevNormal.x;
					normal.y += prevNormal.y;
					normal.z += prevNormal.z;

					normal.normalize();

					initNormals.push( normal.x, normal.y, normal.z );

					prevNormal.copy( curNormal );

			}

		}

		// generate vertices, uvs and normals

		for ( let i = 0; i <= segments; i ++ ) {

			const phi = phiStart + i * inverseSegments * phiLength;

			const sin = Math.sin( phi );
			const cos = Math.cos( phi );

			for ( let j = 0; j <= ( points.length - 1 ); j ++ ) {

				// vertex

				vertex.x = points[ j ].x * sin;
				vertex.y = points[ j ].y;
				vertex.z = points[ j ].x * cos;

				vertices.push( vertex.x, vertex.y, vertex.z );

				// uv

				uv.x = i / segments;
				uv.y = j / ( points.length - 1 );

				uvs.push( uv.x, uv.y );

				// normal

				const x = initNormals[ 3 * j + 0 ] * sin;
				const y = initNormals[ 3 * j + 1 ];
				const z = initNormals[ 3 * j + 0 ] * cos;

				normals.push( x, y, z );

			}

		}

		// indices

		for ( let i = 0; i < segments; i ++ ) {

			for ( let j = 0; j < ( points.length - 1 ); j ++ ) {

				const base = j + i * points.length;

				const a = base;
				const b = base + points.length;
				const c = base + points.length + 1;
				const d = base + 1;

				// faces

				indices.push( a, b, d );
				indices.push( c, d, b );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	static fromJSON( data ) {

		return new LatheGeometry( data.points, data.segments, data.phiStart, data.phiLength );

	}

}

class CapsuleGeometry extends LatheGeometry {

	constructor( radius = 1, length = 1, capSegments = 4, radialSegments = 8 ) {

		const path = new Path();
		path.absarc( 0, - length / 2, radius, Math.PI * 1.5, 0 );
		path.absarc( 0, length / 2, radius, 0, Math.PI * 0.5 );

		super( path.getPoints( capSegments ), radialSegments );

		this.type = 'CapsuleGeometry';

		this.parameters = {
			radius: radius,
			length: length,
			capSegments: capSegments,
			radialSegments: radialSegments,
		};

	}

	static fromJSON( data ) {

		return new CapsuleGeometry( data.radius, data.length, data.capSegments, data.radialSegments );

	}

}

class CircleGeometry extends BufferGeometry {

	constructor( radius = 1, segments = 32, thetaStart = 0, thetaLength = Math.PI * 2 ) {

		super();

		this.type = 'CircleGeometry';

		this.parameters = {
			radius: radius,
			segments: segments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		segments = Math.max( 3, segments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		const vertex = new Vector3();
		const uv = new Vector2();

		// center point

		vertices.push( 0, 0, 0 );
		normals.push( 0, 0, 1 );
		uvs.push( 0.5, 0.5 );

		for ( let s = 0, i = 3; s <= segments; s ++, i += 3 ) {

			const segment = thetaStart + s / segments * thetaLength;

			// vertex

			vertex.x = radius * Math.cos( segment );
			vertex.y = radius * Math.sin( segment );

			vertices.push( vertex.x, vertex.y, vertex.z );

			// normal

			normals.push( 0, 0, 1 );

			// uvs

			uv.x = ( vertices[ i ] / radius + 1 ) / 2;
			uv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;

			uvs.push( uv.x, uv.y );

		}

		// indices

		for ( let i = 1; i <= segments; i ++ ) {

			indices.push( i, i + 1, 0 );

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	static fromJSON( data ) {

		return new CircleGeometry( data.radius, data.segments, data.thetaStart, data.thetaLength );

	}

}

class CylinderGeometry extends BufferGeometry {

	constructor( radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2 ) {

		super();

		this.type = 'CylinderGeometry';

		this.parameters = {
			radiusTop: radiusTop,
			radiusBottom: radiusBottom,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		const scope = this;

		radialSegments = Math.floor( radialSegments );
		heightSegments = Math.floor( heightSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		let index = 0;
		const indexArray = [];
		const halfHeight = height / 2;
		let groupStart = 0;

		// generate geometry

		generateTorso();

		if ( openEnded === false ) {

			if ( radiusTop > 0 ) generateCap( true );
			if ( radiusBottom > 0 ) generateCap( false );

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		function generateTorso() {

			const normal = new Vector3();
			const vertex = new Vector3();

			let groupCount = 0;

			// this will be used to calculate the normal
			const slope = ( radiusBottom - radiusTop ) / height;

			// generate vertices, normals and uvs

			for ( let y = 0; y <= heightSegments; y ++ ) {

				const indexRow = [];

				const v = y / heightSegments;

				// calculate the radius of the current row

				const radius = v * ( radiusBottom - radiusTop ) + radiusTop;

				for ( let x = 0; x <= radialSegments; x ++ ) {

					const u = x / radialSegments;

					const theta = u * thetaLength + thetaStart;

					const sinTheta = Math.sin( theta );
					const cosTheta = Math.cos( theta );

					// vertex

					vertex.x = radius * sinTheta;
					vertex.y = - v * height + halfHeight;
					vertex.z = radius * cosTheta;
					vertices.push( vertex.x, vertex.y, vertex.z );

					// normal

					normal.set( sinTheta, slope, cosTheta ).normalize();
					normals.push( normal.x, normal.y, normal.z );

					// uv

					uvs.push( u, 1 - v );

					// save index of vertex in respective row

					indexRow.push( index ++ );

				}

				// now save vertices of the row in our index array

				indexArray.push( indexRow );

			}

			// generate indices

			for ( let x = 0; x < radialSegments; x ++ ) {

				for ( let y = 0; y < heightSegments; y ++ ) {

					// we use the index array to access the correct indices

					const a = indexArray[ y ][ x ];
					const b = indexArray[ y + 1 ][ x ];
					const c = indexArray[ y + 1 ][ x + 1 ];
					const d = indexArray[ y ][ x + 1 ];

					// faces

					if ( radiusTop > 0 || y !== 0 ) {

						indices.push( a, b, d );
						groupCount += 3;

					}

					if ( radiusBottom > 0 || y !== heightSegments - 1 ) {

						indices.push( b, c, d );
						groupCount += 3;

					}

				}

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, 0 );

			// calculate new start value for groups

			groupStart += groupCount;

		}

		function generateCap( top ) {

			// save the index of the first center vertex
			const centerIndexStart = index;

			const uv = new Vector2();
			const vertex = new Vector3();

			let groupCount = 0;

			const radius = ( top === true ) ? radiusTop : radiusBottom;
			const sign = ( top === true ) ? 1 : -1;

			// first we generate the center vertex data of the cap.
			// because the geometry needs one set of uvs per face,
			// we must generate a center vertex per face/segment

			for ( let x = 1; x <= radialSegments; x ++ ) {

				// vertex

				vertices.push( 0, halfHeight * sign, 0 );

				// normal

				normals.push( 0, sign, 0 );

				// uv

				uvs.push( 0.5, 0.5 );

				// increase index

				index ++;

			}

			// save the index of the last center vertex
			const centerIndexEnd = index;

			// now we generate the surrounding vertices, normals and uvs

			for ( let x = 0; x <= radialSegments; x ++ ) {

				const u = x / radialSegments;
				const theta = u * thetaLength + thetaStart;

				const cosTheta = Math.cos( theta );
				const sinTheta = Math.sin( theta );

				// vertex

				vertex.x = radius * sinTheta;
				vertex.y = halfHeight * sign;
				vertex.z = radius * cosTheta;
				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normals.push( 0, sign, 0 );

				// uv

				uv.x = ( cosTheta * 0.5 ) + 0.5;
				uv.y = ( sinTheta * 0.5 * sign ) + 0.5;
				uvs.push( uv.x, uv.y );

				// increase index

				index ++;

			}

			// generate indices

			for ( let x = 0; x < radialSegments; x ++ ) {

				const c = centerIndexStart + x;
				const i = centerIndexEnd + x;

				if ( top === true ) {

					// face top

					indices.push( i, i + 1, c );

				} else {

					// face bottom

					indices.push( i + 1, i, c );

				}

				groupCount += 3;

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );

			// calculate new start value for groups

			groupStart += groupCount;

		}

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	static fromJSON( data ) {

		return new CylinderGeometry( data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength );

	}

}

class ConeGeometry extends CylinderGeometry {

	constructor( radius = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2 ) {

		super( 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

		this.type = 'ConeGeometry';

		this.parameters = {
			radius: radius,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

	}

	static fromJSON( data ) {

		return new ConeGeometry( data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength );

	}

}

class PolyhedronGeometry extends BufferGeometry {

	constructor( vertices = [], indices = [], radius = 1, detail = 0 ) {

		super();

		this.type = 'PolyhedronGeometry';

		this.parameters = {
			vertices: vertices,
			indices: indices,
			radius: radius,
			detail: detail
		};

		// default buffer data

		const vertexBuffer = [];
		const uvBuffer = [];

		// the subdivision creates the vertex buffer data

		subdivide( detail );

		// all vertices should lie on a conceptual sphere with a given radius

		applyRadius( radius );

		// finally, create the uv data

		generateUVs();

		// build non-indexed geometry

		this.setAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );

		if ( detail === 0 ) {

			this.computeVertexNormals(); // flat normals

		} else {

			this.normalizeNormals(); // smooth normals

		}

		// helper functions

		function subdivide( detail ) {

			const a = new Vector3();
			const b = new Vector3();
			const c = new Vector3();

			// iterate over all faces and apply a subdivision with the given detail value

			for ( let i = 0; i < indices.length; i += 3 ) {

				// get the vertices of the face

				getVertexByIndex( indices[ i + 0 ], a );
				getVertexByIndex( indices[ i + 1 ], b );
				getVertexByIndex( indices[ i + 2 ], c );

				// perform subdivision

				subdivideFace( a, b, c, detail );

			}

		}

		function subdivideFace( a, b, c, detail ) {

			const cols = detail + 1;

			// we use this multidimensional array as a data structure for creating the subdivision

			const v = [];

			// construct all of the vertices for this subdivision

			for ( let i = 0; i <= cols; i ++ ) {

				v[ i ] = [];

				const aj = a.clone().lerp( c, i / cols );
				const bj = b.clone().lerp( c, i / cols );

				const rows = cols - i;

				for ( let j = 0; j <= rows; j ++ ) {

					if ( j === 0 && i === cols ) {

						v[ i ][ j ] = aj;

					} else {

						v[ i ][ j ] = aj.clone().lerp( bj, j / rows );

					}

				}

			}

			// construct all of the faces

			for ( let i = 0; i < cols; i ++ ) {

				for ( let j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {

					const k = Math.floor( j / 2 );

					if ( j % 2 === 0 ) {

						pushVertex( v[ i ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k ] );
						pushVertex( v[ i ][ k ] );

					} else {

						pushVertex( v[ i ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k ] );

					}

				}

			}

		}

		function applyRadius( radius ) {

			const vertex = new Vector3();

			// iterate over the entire buffer and apply the radius to each vertex

			for ( let i = 0; i < vertexBuffer.length; i += 3 ) {

				vertex.x = vertexBuffer[ i + 0 ];
				vertex.y = vertexBuffer[ i + 1 ];
				vertex.z = vertexBuffer[ i + 2 ];

				vertex.normalize().multiplyScalar( radius );

				vertexBuffer[ i + 0 ] = vertex.x;
				vertexBuffer[ i + 1 ] = vertex.y;
				vertexBuffer[ i + 2 ] = vertex.z;

			}

		}

		function generateUVs() {

			const vertex = new Vector3();

			for ( let i = 0; i < vertexBuffer.length; i += 3 ) {

				vertex.x = vertexBuffer[ i + 0 ];
				vertex.y = vertexBuffer[ i + 1 ];
				vertex.z = vertexBuffer[ i + 2 ];

				const u = azimuth( vertex ) / 2 / Math.PI + 0.5;
				const v = inclination( vertex ) / Math.PI + 0.5;
				uvBuffer.push( u, 1 - v );

			}

			correctUVs();

			correctSeam();

		}

		function correctSeam() {

			// handle case when face straddles the seam, see #3269

			for ( let i = 0; i < uvBuffer.length; i += 6 ) {

				// uv data of a single face

				const x0 = uvBuffer[ i + 0 ];
				const x1 = uvBuffer[ i + 2 ];
				const x2 = uvBuffer[ i + 4 ];

				const max = Math.max( x0, x1, x2 );
				const min = Math.min( x0, x1, x2 );

				// 0.9 is somewhat arbitrary

				if ( max > 0.9 && min < 0.1 ) {

					if ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;
					if ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;
					if ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;

				}

			}

		}

		function pushVertex( vertex ) {

			vertexBuffer.push( vertex.x, vertex.y, vertex.z );

		}

		function getVertexByIndex( index, vertex ) {

			const stride = index * 3;

			vertex.x = vertices[ stride + 0 ];
			vertex.y = vertices[ stride + 1 ];
			vertex.z = vertices[ stride + 2 ];

		}

		function correctUVs() {

			const a = new Vector3();
			const b = new Vector3();
			const c = new Vector3();

			const centroid = new Vector3();

			const uvA = new Vector2();
			const uvB = new Vector2();
			const uvC = new Vector2();

			for ( let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {

				a.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );
				b.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );
				c.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );

				uvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );
				uvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );
				uvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );

				centroid.copy( a ).add( b ).add( c ).divideScalar( 3 );

				const azi = azimuth( centroid );

				correctUV( uvA, j + 0, a, azi );
				correctUV( uvB, j + 2, b, azi );
				correctUV( uvC, j + 4, c, azi );

			}

		}

		function correctUV( uv, stride, vector, azimuth ) {

			if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {

				uvBuffer[ stride ] = uv.x - 1;

			}

			if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {

				uvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;

			}

		}

		// Angle around the Y axis, counter-clockwise when looking from above.

		function azimuth( vector ) {

			return Math.atan2( vector.z, - vector.x );

		}


		// Angle above the XZ plane.

		function inclination( vector ) {

			return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

		}

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	static fromJSON( data ) {

		return new PolyhedronGeometry( data.vertices, data.indices, data.radius, data.details );

	}

}

class Shape extends Path {

	constructor( points ) {

		super( points );

		this.uuid = generateUUID();

		this.type = 'Shape';

		this.holes = [];

	}

	getPointsHoles( divisions ) {

		const holesPts = [];

		for ( let i = 0, l = this.holes.length; i < l; i ++ ) {

			holesPts[ i ] = this.holes[ i ].getPoints( divisions );

		}

		return holesPts;

	}

	// get points of shape and holes (keypoints based on segments parameter)

	extractPoints( divisions ) {

		return {

			shape: this.getPoints( divisions ),
			holes: this.getPointsHoles( divisions )

		};

	}

	copy( source ) {

		super.copy( source );

		this.holes = [];

		for ( let i = 0, l = source.holes.length; i < l; i ++ ) {

			const hole = source.holes[ i ];

			this.holes.push( hole.clone() );

		}

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.uuid = this.uuid;
		data.holes = [];

		for ( let i = 0, l = this.holes.length; i < l; i ++ ) {

			const hole = this.holes[ i ];
			data.holes.push( hole.toJSON() );

		}

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.uuid = json.uuid;
		this.holes = [];

		for ( let i = 0, l = json.holes.length; i < l; i ++ ) {

			const hole = json.holes[ i ];
			this.holes.push( new Path().fromJSON( hole ) );

		}

		return this;

	}

}

/**
 * Port from https://github.com/mapbox/earcut (v2.2.4)
 */

const Earcut = {

	triangulate: function ( data, holeIndices, dim = 2 ) {

		const hasHoles = holeIndices && holeIndices.length;
		const outerLen = hasHoles ? holeIndices[ 0 ] * dim : data.length;
		let outerNode = linkedList( data, 0, outerLen, dim, true );
		const triangles = [];

		if ( ! outerNode || outerNode.next === outerNode.prev ) return triangles;

		let minX, minY, maxX, maxY, x, y, invSize;

		if ( hasHoles ) outerNode = eliminateHoles( data, holeIndices, outerNode, dim );

		// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
		if ( data.length > 80 * dim ) {

			minX = maxX = data[ 0 ];
			minY = maxY = data[ 1 ];

			for ( let i = dim; i < outerLen; i += dim ) {

				x = data[ i ];
				y = data[ i + 1 ];
				if ( x < minX ) minX = x;
				if ( y < minY ) minY = y;
				if ( x > maxX ) maxX = x;
				if ( y > maxY ) maxY = y;

			}

			// minX, minY and invSize are later used to transform coords into integers for z-order calculation
			invSize = Math.max( maxX - minX, maxY - minY );
			invSize = invSize !== 0 ? 32767 / invSize : 0;

		}

		earcutLinked( outerNode, triangles, dim, minX, minY, invSize, 0 );

		return triangles;

	}

};

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList( data, start, end, dim, clockwise ) {

	let i, last;

	if ( clockwise === ( signedArea( data, start, end, dim ) > 0 ) ) {

		for ( i = start; i < end; i += dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );

	} else {

		for ( i = end - dim; i >= start; i -= dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );

	}

	if ( last && equals$1( last, last.next ) ) {

		removeNode( last );
		last = last.next;

	}

	return last;

}

// eliminate colinear or duplicate points
function filterPoints( start, end ) {

	if ( ! start ) return start;
	if ( ! end ) end = start;

	let p = start,
		again;
	do {

		again = false;

		if ( ! p.steiner && ( equals$1( p, p.next ) || area( p.prev, p, p.next ) === 0 ) ) {

			removeNode( p );
			p = end = p.prev;
			if ( p === p.next ) break;
			again = true;

		} else {

			p = p.next;

		}

	} while ( again || p !== end );

	return end;

}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked( ear, triangles, dim, minX, minY, invSize, pass ) {

	if ( ! ear ) return;

	// interlink polygon nodes in z-order
	if ( ! pass && invSize ) indexCurve( ear, minX, minY, invSize );

	let stop = ear,
		prev, next;

	// iterate through ears, slicing them one by one
	while ( ear.prev !== ear.next ) {

		prev = ear.prev;
		next = ear.next;

		if ( invSize ? isEarHashed( ear, minX, minY, invSize ) : isEar( ear ) ) {

			// cut off the triangle
			triangles.push( prev.i / dim | 0 );
			triangles.push( ear.i / dim | 0 );
			triangles.push( next.i / dim | 0 );

			removeNode( ear );

			// skipping the next vertex leads to less sliver triangles
			ear = next.next;
			stop = next.next;

			continue;

		}

		ear = next;

		// if we looped through the whole remaining polygon and can't find any more ears
		if ( ear === stop ) {

			// try filtering points and slicing again
			if ( ! pass ) {

				earcutLinked( filterPoints( ear ), triangles, dim, minX, minY, invSize, 1 );

				// if this didn't work, try curing all small self-intersections locally

			} else if ( pass === 1 ) {

				ear = cureLocalIntersections( filterPoints( ear ), triangles, dim );
				earcutLinked( ear, triangles, dim, minX, minY, invSize, 2 );

				// as a last resort, try splitting the remaining polygon into two

			} else if ( pass === 2 ) {

				splitEarcut( ear, triangles, dim, minX, minY, invSize );

			}

			break;

		}

	}

}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar( ear ) {

	const a = ear.prev,
		b = ear,
		c = ear.next;

	if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear

	// now make sure we don't have other points inside the potential ear
	const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;

	// triangle bbox; min & max are calculated like this for speed
	const x0 = ax < bx ? ( ax < cx ? ax : cx ) : ( bx < cx ? bx : cx ),
		y0 = ay < by ? ( ay < cy ? ay : cy ) : ( by < cy ? by : cy ),
		x1 = ax > bx ? ( ax > cx ? ax : cx ) : ( bx > cx ? bx : cx ),
		y1 = ay > by ? ( ay > cy ? ay : cy ) : ( by > cy ? by : cy );

	let p = c.next;
	while ( p !== a ) {

		if ( p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&
			pointInTriangle( ax, ay, bx, by, cx, cy, p.x, p.y ) &&
			area( p.prev, p, p.next ) >= 0 ) return false;
		p = p.next;

	}

	return true;

}

function isEarHashed( ear, minX, minY, invSize ) {

	const a = ear.prev,
		b = ear,
		c = ear.next;

	if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear

	const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;

	// triangle bbox; min & max are calculated like this for speed
	const x0 = ax < bx ? ( ax < cx ? ax : cx ) : ( bx < cx ? bx : cx ),
		y0 = ay < by ? ( ay < cy ? ay : cy ) : ( by < cy ? by : cy ),
		x1 = ax > bx ? ( ax > cx ? ax : cx ) : ( bx > cx ? bx : cx ),
		y1 = ay > by ? ( ay > cy ? ay : cy ) : ( by > cy ? by : cy );

	// z-order range for the current triangle bbox;
	const minZ = zOrder( x0, y0, minX, minY, invSize ),
		maxZ = zOrder( x1, y1, minX, minY, invSize );

	let p = ear.prevZ,
		n = ear.nextZ;

	// look for points inside the triangle in both directions
	while ( p && p.z >= minZ && n && n.z <= maxZ ) {

		if ( p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
			pointInTriangle( ax, ay, bx, by, cx, cy, p.x, p.y ) && area( p.prev, p, p.next ) >= 0 ) return false;
		p = p.prevZ;

		if ( n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
			pointInTriangle( ax, ay, bx, by, cx, cy, n.x, n.y ) && area( n.prev, n, n.next ) >= 0 ) return false;
		n = n.nextZ;

	}

	// look for remaining points in decreasing z-order
	while ( p && p.z >= minZ ) {

		if ( p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
			pointInTriangle( ax, ay, bx, by, cx, cy, p.x, p.y ) && area( p.prev, p, p.next ) >= 0 ) return false;
		p = p.prevZ;

	}

	// look for remaining points in increasing z-order
	while ( n && n.z <= maxZ ) {

		if ( n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
			pointInTriangle( ax, ay, bx, by, cx, cy, n.x, n.y ) && area( n.prev, n, n.next ) >= 0 ) return false;
		n = n.nextZ;

	}

	return true;

}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections( start, triangles, dim ) {

	let p = start;
	do {

		const a = p.prev,
			b = p.next.next;

		if ( ! equals$1( a, b ) && intersects( a, p, p.next, b ) && locallyInside( a, b ) && locallyInside( b, a ) ) {

			triangles.push( a.i / dim | 0 );
			triangles.push( p.i / dim | 0 );
			triangles.push( b.i / dim | 0 );

			// remove two nodes involved
			removeNode( p );
			removeNode( p.next );

			p = start = b;

		}

		p = p.next;

	} while ( p !== start );

	return filterPoints( p );

}

// try splitting polygon into two and triangulate them independently
function splitEarcut( start, triangles, dim, minX, minY, invSize ) {

	// look for a valid diagonal that divides the polygon into two
	let a = start;
	do {

		let b = a.next.next;
		while ( b !== a.prev ) {

			if ( a.i !== b.i && isValidDiagonal( a, b ) ) {

				// split the polygon in two by the diagonal
				let c = splitPolygon( a, b );

				// filter colinear points around the cuts
				a = filterPoints( a, a.next );
				c = filterPoints( c, c.next );

				// run earcut on each half
				earcutLinked( a, triangles, dim, minX, minY, invSize, 0 );
				earcutLinked( c, triangles, dim, minX, minY, invSize, 0 );
				return;

			}

			b = b.next;

		}

		a = a.next;

	} while ( a !== start );

}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles( data, holeIndices, outerNode, dim ) {

	const queue = [];
	let i, len, start, end, list;

	for ( i = 0, len = holeIndices.length; i < len; i ++ ) {

		start = holeIndices[ i ] * dim;
		end = i < len - 1 ? holeIndices[ i + 1 ] * dim : data.length;
		list = linkedList( data, start, end, dim, false );
		if ( list === list.next ) list.steiner = true;
		queue.push( getLeftmost( list ) );

	}

	queue.sort( compareX );

	// process holes from left to right
	for ( i = 0; i < queue.length; i ++ ) {

		outerNode = eliminateHole( queue[ i ], outerNode );

	}

	return outerNode;

}

function compareX( a, b ) {

	return a.x - b.x;

}

// find a bridge between vertices that connects hole with an outer ring and link it
function eliminateHole( hole, outerNode ) {

	const bridge = findHoleBridge( hole, outerNode );
	if ( ! bridge ) {

		return outerNode;

	}

	const bridgeReverse = splitPolygon( bridge, hole );

	// filter collinear points around the cuts
	filterPoints( bridgeReverse, bridgeReverse.next );
	return filterPoints( bridge, bridge.next );

}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge( hole, outerNode ) {

	let p = outerNode,
		qx = - Infinity,
		m;

	const hx = hole.x, hy = hole.y;

	// find a segment intersected by a ray from the hole's leftmost point to the left;
	// segment's endpoint with lesser x will be potential connection point
	do {

		if ( hy <= p.y && hy >= p.next.y && p.next.y !== p.y ) {

			const x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y );
			if ( x <= hx && x > qx ) {

				qx = x;
				m = p.x < p.next.x ? p : p.next;
				if ( x === hx ) return m; // hole touches outer segment; pick leftmost endpoint

			}

		}

		p = p.next;

	} while ( p !== outerNode );

	if ( ! m ) return null;

	// look for points inside the triangle of hole point, segment intersection and endpoint;
	// if there are no points found, we have a valid connection;
	// otherwise choose the point of the minimum angle with the ray as connection point

	const stop = m,
		mx = m.x,
		my = m.y;
	let tanMin = Infinity, tan;

	p = m;

	do {

		if ( hx >= p.x && p.x >= mx && hx !== p.x &&
				pointInTriangle( hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y ) ) {

			tan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential

			if ( locallyInside( p, hole ) && ( tan < tanMin || ( tan === tanMin && ( p.x > m.x || ( p.x === m.x && sectorContainsSector( m, p ) ) ) ) ) ) {

				m = p;
				tanMin = tan;

			}

		}

		p = p.next;

	} while ( p !== stop );

	return m;

}

// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector( m, p ) {

	return area( m.prev, m, p.prev ) < 0 && area( p.next, m, m.next ) < 0;

}

// interlink polygon nodes in z-order
function indexCurve( start, minX, minY, invSize ) {

	let p = start;
	do {

		if ( p.z === 0 ) p.z = zOrder( p.x, p.y, minX, minY, invSize );
		p.prevZ = p.prev;
		p.nextZ = p.next;
		p = p.next;

	} while ( p !== start );

	p.prevZ.nextZ = null;
	p.prevZ = null;

	sortLinked( p );

}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked( list ) {

	let i, p, q, e, tail, numMerges, pSize, qSize,
		inSize = 1;

	do {

		p = list;
		list = null;
		tail = null;
		numMerges = 0;

		while ( p ) {

			numMerges ++;
			q = p;
			pSize = 0;
			for ( i = 0; i < inSize; i ++ ) {

				pSize ++;
				q = q.nextZ;
				if ( ! q ) break;

			}

			qSize = inSize;

			while ( pSize > 0 || ( qSize > 0 && q ) ) {

				if ( pSize !== 0 && ( qSize === 0 || ! q || p.z <= q.z ) ) {

					e = p;
					p = p.nextZ;
					pSize --;

				} else {

					e = q;
					q = q.nextZ;
					qSize --;

				}

				if ( tail ) tail.nextZ = e;
				else list = e;

				e.prevZ = tail;
				tail = e;

			}

			p = q;

		}

		tail.nextZ = null;
		inSize *= 2;

	} while ( numMerges > 1 );

	return list;

}

// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder( x, y, minX, minY, invSize ) {

	// coords are transformed into non-negative 15-bit integer range
	x = ( x - minX ) * invSize | 0;
	y = ( y - minY ) * invSize | 0;

	x = ( x | ( x << 8 ) ) & 0x00FF00FF;
	x = ( x | ( x << 4 ) ) & 0x0F0F0F0F;
	x = ( x | ( x << 2 ) ) & 0x33333333;
	x = ( x | ( x << 1 ) ) & 0x55555555;

	y = ( y | ( y << 8 ) ) & 0x00FF00FF;
	y = ( y | ( y << 4 ) ) & 0x0F0F0F0F;
	y = ( y | ( y << 2 ) ) & 0x33333333;
	y = ( y | ( y << 1 ) ) & 0x55555555;

	return x | ( y << 1 );

}

// find the leftmost node of a polygon ring
function getLeftmost( start ) {

	let p = start,
		leftmost = start;
	do {

		if ( p.x < leftmost.x || ( p.x === leftmost.x && p.y < leftmost.y ) ) leftmost = p;
		p = p.next;

	} while ( p !== start );

	return leftmost;

}

// check if a point lies within a convex triangle
function pointInTriangle( ax, ay, bx, by, cx, cy, px, py ) {

	return ( cx - px ) * ( ay - py ) >= ( ax - px ) * ( cy - py ) &&
           ( ax - px ) * ( by - py ) >= ( bx - px ) * ( ay - py ) &&
           ( bx - px ) * ( cy - py ) >= ( cx - px ) * ( by - py );

}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal( a, b ) {

	return a.next.i !== b.i && a.prev.i !== b.i && ! intersectsPolygon( a, b ) && // dones't intersect other edges
           ( locallyInside( a, b ) && locallyInside( b, a ) && middleInside( a, b ) && // locally visible
            ( area( a.prev, a, b.prev ) || area( a, b.prev, b ) ) || // does not create opposite-facing sectors
            equals$1( a, b ) && area( a.prev, a, a.next ) > 0 && area( b.prev, b, b.next ) > 0 ); // special zero-length case

}

// signed area of a triangle
function area( p, q, r ) {

	return ( q.y - p.y ) * ( r.x - q.x ) - ( q.x - p.x ) * ( r.y - q.y );

}

// check if two points are equal
function equals$1( p1, p2 ) {

	return p1.x === p2.x && p1.y === p2.y;

}

// check if two segments intersect
function intersects( p1, q1, p2, q2 ) {

	const o1 = sign$1( area( p1, q1, p2 ) );
	const o2 = sign$1( area( p1, q1, q2 ) );
	const o3 = sign$1( area( p2, q2, p1 ) );
	const o4 = sign$1( area( p2, q2, q1 ) );

	if ( o1 !== o2 && o3 !== o4 ) return true; // general case

	if ( o1 === 0 && onSegment( p1, p2, q1 ) ) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
	if ( o2 === 0 && onSegment( p1, q2, q1 ) ) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
	if ( o3 === 0 && onSegment( p2, p1, q2 ) ) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
	if ( o4 === 0 && onSegment( p2, q1, q2 ) ) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

	return false;

}

// for collinear points p, q, r, check if point q lies on segment pr
function onSegment( p, q, r ) {

	return q.x <= Math.max( p.x, r.x ) && q.x >= Math.min( p.x, r.x ) && q.y <= Math.max( p.y, r.y ) && q.y >= Math.min( p.y, r.y );

}

function sign$1( num ) {

	return num > 0 ? 1 : num < 0 ? -1 : 0;

}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon( a, b ) {

	let p = a;
	do {

		if ( p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
			intersects( p, p.next, a, b ) ) return true;
		p = p.next;

	} while ( p !== a );

	return false;

}

// check if a polygon diagonal is locally inside the polygon
function locallyInside( a, b ) {

	return area( a.prev, a, a.next ) < 0 ?
		area( a, b, a.next ) >= 0 && area( a, a.prev, b ) >= 0 :
		area( a, b, a.prev ) < 0 || area( a, a.next, b ) < 0;

}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside( a, b ) {

	let p = a,
		inside = false;
	const px = ( a.x + b.x ) / 2,
		py = ( a.y + b.y ) / 2;
	do {

		if ( ( ( p.y > py ) !== ( p.next.y > py ) ) && p.next.y !== p.y &&
			( px < ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) )
			inside = ! inside;
		p = p.next;

	} while ( p !== a );

	return inside;

}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon( a, b ) {

	const a2 = new Node$1( a.i, a.x, a.y ),
		b2 = new Node$1( b.i, b.x, b.y ),
		an = a.next,
		bp = b.prev;

	a.next = b;
	b.prev = a;

	a2.next = an;
	an.prev = a2;

	b2.next = a2;
	a2.prev = b2;

	bp.next = b2;
	b2.prev = bp;

	return b2;

}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode( i, x, y, last ) {

	const p = new Node$1( i, x, y );

	if ( ! last ) {

		p.prev = p;
		p.next = p;

	} else {

		p.next = last.next;
		p.prev = last;
		last.next.prev = p;
		last.next = p;

	}

	return p;

}

function removeNode( p ) {

	p.next.prev = p.prev;
	p.prev.next = p.next;

	if ( p.prevZ ) p.prevZ.nextZ = p.nextZ;
	if ( p.nextZ ) p.nextZ.prevZ = p.prevZ;

}

function Node$1( i, x, y ) {

	// vertex index in coordinates array
	this.i = i;

	// vertex coordinates
	this.x = x;
	this.y = y;

	// previous and next vertex nodes in a polygon ring
	this.prev = null;
	this.next = null;

	// z-order curve value
	this.z = 0;

	// previous and next nodes in z-order
	this.prevZ = null;
	this.nextZ = null;

	// indicates whether this is a steiner point
	this.steiner = false;

}

function signedArea( data, start, end, dim ) {

	let sum = 0;
	for ( let i = start, j = end - dim; i < end; i += dim ) {

		sum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] );
		j = i;

	}

	return sum;

}

class ShapeUtils {

	// calculate area of the contour polygon

	static area( contour ) {

		const n = contour.length;
		let a = 0.0;

		for ( let p = n - 1, q = 0; q < n; p = q ++ ) {

			a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

		}

		return a * 0.5;

	}

	static isClockWise( pts ) {

		return ShapeUtils.area( pts ) < 0;

	}

	static triangulateShape( contour, holes ) {

		const vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
		const holeIndices = []; // array of hole indices
		const faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

		removeDupEndPts( contour );
		addContour( vertices, contour );

		//

		let holeIndex = contour.length;

		holes.forEach( removeDupEndPts );

		for ( let i = 0; i < holes.length; i ++ ) {

			holeIndices.push( holeIndex );
			holeIndex += holes[ i ].length;
			addContour( vertices, holes[ i ] );

		}

		//

		const triangles = Earcut.triangulate( vertices, holeIndices );

		//

		for ( let i = 0; i < triangles.length; i += 3 ) {

			faces.push( triangles.slice( i, i + 3 ) );

		}

		return faces;

	}

}

function removeDupEndPts( points ) {

	const l = points.length;

	if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {

		points.pop();

	}

}

function addContour( vertices, contour ) {

	for ( let i = 0; i < contour.length; i ++ ) {

		vertices.push( contour[ i ].x );
		vertices.push( contour[ i ].y );

	}

}

class IcosahedronGeometry extends PolyhedronGeometry {

	constructor( radius = 1, detail = 0 ) {

		const t = ( 1 + Math.sqrt( 5 ) ) / 2;

		const vertices = [
			-1, t, 0, 	1, t, 0, 	-1, - t, 0, 	1, - t, 0,
			0, -1, t, 	0, 1, t,	0, -1, - t, 	0, 1, - t,
			t, 0, -1, 	t, 0, 1, 	- t, 0, -1, 	- t, 0, 1
		];

		const indices = [
			0, 11, 5, 	0, 5, 1, 	0, 1, 7, 	0, 7, 10, 	0, 10, 11,
			1, 5, 9, 	5, 11, 4,	11, 10, 2,	10, 7, 6,	7, 1, 8,
			3, 9, 4, 	3, 4, 2,	3, 2, 6,	3, 6, 8,	3, 8, 9,
			4, 9, 5, 	2, 4, 11,	6, 2, 10,	8, 6, 7,	9, 8, 1
		];

		super( vertices, indices, radius, detail );

		this.type = 'IcosahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

	static fromJSON( data ) {

		return new IcosahedronGeometry( data.radius, data.detail );

	}

}

class PlaneGeometry extends BufferGeometry {

	constructor( width = 1, height = 1, widthSegments = 1, heightSegments = 1 ) {

		super();

		this.type = 'PlaneGeometry';

		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};

		const width_half = width / 2;
		const height_half = height / 2;

		const gridX = Math.floor( widthSegments );
		const gridY = Math.floor( heightSegments );

		const gridX1 = gridX + 1;
		const gridY1 = gridY + 1;

		const segment_width = width / gridX;
		const segment_height = height / gridY;

		//

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		for ( let iy = 0; iy < gridY1; iy ++ ) {

			const y = iy * segment_height - height_half;

			for ( let ix = 0; ix < gridX1; ix ++ ) {

				const x = ix * segment_width - width_half;

				vertices.push( x, - y, 0 );

				normals.push( 0, 0, 1 );

				uvs.push( ix / gridX );
				uvs.push( 1 - ( iy / gridY ) );

			}

		}

		for ( let iy = 0; iy < gridY; iy ++ ) {

			for ( let ix = 0; ix < gridX; ix ++ ) {

				const a = ix + gridX1 * iy;
				const b = ix + gridX1 * ( iy + 1 );
				const c = ( ix + 1 ) + gridX1 * ( iy + 1 );
				const d = ( ix + 1 ) + gridX1 * iy;

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	static fromJSON( data ) {

		return new PlaneGeometry( data.width, data.height, data.widthSegments, data.heightSegments );

	}

}

class RingGeometry extends BufferGeometry {

	constructor( innerRadius = 0.5, outerRadius = 1, thetaSegments = 32, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2 ) {

		super();

		this.type = 'RingGeometry';

		this.parameters = {
			innerRadius: innerRadius,
			outerRadius: outerRadius,
			thetaSegments: thetaSegments,
			phiSegments: phiSegments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		thetaSegments = Math.max( 3, thetaSegments );
		phiSegments = Math.max( 1, phiSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// some helper variables

		let radius = innerRadius;
		const radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
		const vertex = new Vector3();
		const uv = new Vector2();

		// generate vertices, normals and uvs

		for ( let j = 0; j <= phiSegments; j ++ ) {

			for ( let i = 0; i <= thetaSegments; i ++ ) {

				// values are generate from the inside of the ring to the outside

				const segment = thetaStart + i / thetaSegments * thetaLength;

				// vertex

				vertex.x = radius * Math.cos( segment );
				vertex.y = radius * Math.sin( segment );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normals.push( 0, 0, 1 );

				// uv

				uv.x = ( vertex.x / outerRadius + 1 ) / 2;
				uv.y = ( vertex.y / outerRadius + 1 ) / 2;

				uvs.push( uv.x, uv.y );

			}

			// increase the radius for next row of vertices

			radius += radiusStep;

		}

		// indices

		for ( let j = 0; j < phiSegments; j ++ ) {

			const thetaSegmentLevel = j * ( thetaSegments + 1 );

			for ( let i = 0; i < thetaSegments; i ++ ) {

				const segment = i + thetaSegmentLevel;

				const a = segment;
				const b = segment + thetaSegments + 1;
				const c = segment + thetaSegments + 2;
				const d = segment + 1;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	static fromJSON( data ) {

		return new RingGeometry( data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength );

	}

}

class ShapeGeometry extends BufferGeometry {

	constructor( shapes = new Shape( [ new Vector2( 0, 0.5 ), new Vector2( -0.5, -0.5 ), new Vector2( 0.5, -0.5 ) ] ), curveSegments = 12 ) {

		super();

		this.type = 'ShapeGeometry';

		this.parameters = {
			shapes: shapes,
			curveSegments: curveSegments
		};

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		let groupStart = 0;
		let groupCount = 0;

		// allow single and array values for "shapes" parameter

		if ( Array.isArray( shapes ) === false ) {

			addShape( shapes );

		} else {

			for ( let i = 0; i < shapes.length; i ++ ) {

				addShape( shapes[ i ] );

				this.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support

				groupStart += groupCount;
				groupCount = 0;

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );


		// helper functions

		function addShape( shape ) {

			const indexOffset = vertices.length / 3;
			const points = shape.extractPoints( curveSegments );

			let shapeVertices = points.shape;
			const shapeHoles = points.holes;

			// check direction of vertices

			if ( ShapeUtils.isClockWise( shapeVertices ) === false ) {

				shapeVertices = shapeVertices.reverse();

			}

			for ( let i = 0, l = shapeHoles.length; i < l; i ++ ) {

				const shapeHole = shapeHoles[ i ];

				if ( ShapeUtils.isClockWise( shapeHole ) === true ) {

					shapeHoles[ i ] = shapeHole.reverse();

				}

			}

			const faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );

			// join vertices of inner and outer paths to a single array

			for ( let i = 0, l = shapeHoles.length; i < l; i ++ ) {

				const shapeHole = shapeHoles[ i ];
				shapeVertices = shapeVertices.concat( shapeHole );

			}

			// vertices, normals, uvs

			for ( let i = 0, l = shapeVertices.length; i < l; i ++ ) {

				const vertex = shapeVertices[ i ];

				vertices.push( vertex.x, vertex.y, 0 );
				normals.push( 0, 0, 1 );
				uvs.push( vertex.x, vertex.y ); // world uvs

			}

			// indices

			for ( let i = 0, l = faces.length; i < l; i ++ ) {

				const face = faces[ i ];

				const a = face[ 0 ] + indexOffset;
				const b = face[ 1 ] + indexOffset;
				const c = face[ 2 ] + indexOffset;

				indices.push( a, b, c );
				groupCount += 3;

			}

		}

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		const shapes = this.parameters.shapes;

		return toJSON( shapes, data );

	}

	static fromJSON( data, shapes ) {

		const geometryShapes = [];

		for ( let j = 0, jl = data.shapes.length; j < jl; j ++ ) {

			const shape = shapes[ data.shapes[ j ] ];

			geometryShapes.push( shape );

		}

		return new ShapeGeometry( geometryShapes, data.curveSegments );

	}

}

function toJSON( shapes, data ) {

	data.shapes = [];

	if ( Array.isArray( shapes ) ) {

		for ( let i = 0, l = shapes.length; i < l; i ++ ) {

			const shape = shapes[ i ];

			data.shapes.push( shape.uuid );

		}

	} else {

		data.shapes.push( shapes.uuid );

	}

	return data;

}

class SphereGeometry extends BufferGeometry {

	constructor( radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI ) {

		super();

		this.type = 'SphereGeometry';

		this.parameters = {
			radius: radius,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			phiStart: phiStart,
			phiLength: phiLength,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		widthSegments = Math.max( 3, Math.floor( widthSegments ) );
		heightSegments = Math.max( 2, Math.floor( heightSegments ) );

		const thetaEnd = Math.min( thetaStart + thetaLength, Math.PI );

		let index = 0;
		const grid = [];

		const vertex = new Vector3();
		const normal = new Vector3();

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// generate vertices, normals and uvs

		for ( let iy = 0; iy <= heightSegments; iy ++ ) {

			const verticesRow = [];

			const v = iy / heightSegments;

			// special case for the poles

			let uOffset = 0;

			if ( iy === 0 && thetaStart === 0 ) {

				uOffset = 0.5 / widthSegments;

			} else if ( iy === heightSegments && thetaEnd === Math.PI ) {

				uOffset = -0.5 / widthSegments;

			}

			for ( let ix = 0; ix <= widthSegments; ix ++ ) {

				const u = ix / widthSegments;

				// vertex

				vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
				vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
				vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normal.copy( vertex ).normalize();
				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( u + uOffset, 1 - v );

				verticesRow.push( index ++ );

			}

			grid.push( verticesRow );

		}

		// indices

		for ( let iy = 0; iy < heightSegments; iy ++ ) {

			for ( let ix = 0; ix < widthSegments; ix ++ ) {

				const a = grid[ iy ][ ix + 1 ];
				const b = grid[ iy ][ ix ];
				const c = grid[ iy + 1 ][ ix ];
				const d = grid[ iy + 1 ][ ix + 1 ];

				if ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );
				if ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	static fromJSON( data ) {

		return new SphereGeometry( data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength );

	}

}

class TorusGeometry extends BufferGeometry {

	constructor( radius = 1, tube = 0.4, radialSegments = 12, tubularSegments = 48, arc = Math.PI * 2 ) {

		super();

		this.type = 'TorusGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			radialSegments: radialSegments,
			tubularSegments: tubularSegments,
			arc: arc
		};

		radialSegments = Math.floor( radialSegments );
		tubularSegments = Math.floor( tubularSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		const center = new Vector3();
		const vertex = new Vector3();
		const normal = new Vector3();

		// generate vertices, normals and uvs

		for ( let j = 0; j <= radialSegments; j ++ ) {

			for ( let i = 0; i <= tubularSegments; i ++ ) {

				const u = i / tubularSegments * arc;
				const v = j / radialSegments * Math.PI * 2;

				// vertex

				vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
				vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
				vertex.z = tube * Math.sin( v );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				center.x = radius * Math.cos( u );
				center.y = radius * Math.sin( u );
				normal.subVectors( vertex, center ).normalize();

				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( i / tubularSegments );
				uvs.push( j / radialSegments );

			}

		}

		// generate indices

		for ( let j = 1; j <= radialSegments; j ++ ) {

			for ( let i = 1; i <= tubularSegments; i ++ ) {

				// indices

				const a = ( tubularSegments + 1 ) * j + i - 1;
				const b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
				const c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
				const d = ( tubularSegments + 1 ) * j + i;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	static fromJSON( data ) {

		return new TorusGeometry( data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc );

	}

}

class TorusKnotGeometry extends BufferGeometry {

	constructor( radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3 ) {

		super();

		this.type = 'TorusKnotGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			tubularSegments: tubularSegments,
			radialSegments: radialSegments,
			p: p,
			q: q
		};

		tubularSegments = Math.floor( tubularSegments );
		radialSegments = Math.floor( radialSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		const vertex = new Vector3();
		const normal = new Vector3();

		const P1 = new Vector3();
		const P2 = new Vector3();

		const B = new Vector3();
		const T = new Vector3();
		const N = new Vector3();

		// generate vertices, normals and uvs

		for ( let i = 0; i <= tubularSegments; ++ i ) {

			// the radian "u" is used to calculate the position on the torus curve of the current tubular segment

			const u = i / tubularSegments * p * Math.PI * 2;

			// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
			// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

			calculatePositionOnCurve( u, p, q, radius, P1 );
			calculatePositionOnCurve( u + 0.01, p, q, radius, P2 );

			// calculate orthonormal basis

			T.subVectors( P2, P1 );
			N.addVectors( P2, P1 );
			B.crossVectors( T, N );
			N.crossVectors( B, T );

			// normalize B, N. T can be ignored, we don't use it

			B.normalize();
			N.normalize();

			for ( let j = 0; j <= radialSegments; ++ j ) {

				// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
				// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.

				const v = j / radialSegments * Math.PI * 2;
				const cx = - tube * Math.cos( v );
				const cy = tube * Math.sin( v );

				// now calculate the final vertex position.
				// first we orient the extrusion with our basis vectors, then we add it to the current position on the curve

				vertex.x = P1.x + ( cx * N.x + cy * B.x );
				vertex.y = P1.y + ( cx * N.y + cy * B.y );
				vertex.z = P1.z + ( cx * N.z + cy * B.z );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)

				normal.subVectors( vertex, P1 ).normalize();

				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( i / tubularSegments );
				uvs.push( j / radialSegments );

			}

		}

		// generate indices

		for ( let j = 1; j <= tubularSegments; j ++ ) {

			for ( let i = 1; i <= radialSegments; i ++ ) {

				// indices

				const a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
				const b = ( radialSegments + 1 ) * j + ( i - 1 );
				const c = ( radialSegments + 1 ) * j + i;
				const d = ( radialSegments + 1 ) * ( j - 1 ) + i;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		// this function calculates the current position on the torus curve

		function calculatePositionOnCurve( u, p, q, radius, position ) {

			const cu = Math.cos( u );
			const su = Math.sin( u );
			const quOverP = q / p * u;
			const cs = Math.cos( quOverP );

			position.x = radius * ( 2 + cs ) * 0.5 * cu;
			position.y = radius * ( 2 + cs ) * su * 0.5;
			position.z = radius * Math.sin( quOverP ) * 0.5;

		}

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	static fromJSON( data ) {

		return new TorusKnotGeometry( data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q );

	}

}

class TubeGeometry extends BufferGeometry {

	constructor( path = new QuadraticBezierCurve3( new Vector3( -1, -1, 0 ), new Vector3( -1, 1, 0 ), new Vector3( 1, 1, 0 ) ), tubularSegments = 64, radius = 1, radialSegments = 8, closed = false ) {

		super();

		this.type = 'TubeGeometry';

		this.parameters = {
			path: path,
			tubularSegments: tubularSegments,
			radius: radius,
			radialSegments: radialSegments,
			closed: closed
		};

		const frames = path.computeFrenetFrames( tubularSegments, closed );

		// expose internals

		this.tangents = frames.tangents;
		this.normals = frames.normals;
		this.binormals = frames.binormals;

		// helper variables

		const vertex = new Vector3();
		const normal = new Vector3();
		const uv = new Vector2();
		let P = new Vector3();

		// buffer

		const vertices = [];
		const normals = [];
		const uvs = [];
		const indices = [];

		// create buffer data

		generateBufferData();

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		// functions

		function generateBufferData() {

			for ( let i = 0; i < tubularSegments; i ++ ) {

				generateSegment( i );

			}

			// if the geometry is not closed, generate the last row of vertices and normals
			// at the regular position on the given path
			//
			// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)

			generateSegment( ( closed === false ) ? tubularSegments : 0 );

			// uvs are generated in a separate function.
			// this makes it easy compute correct values for closed geometries

			generateUVs();

			// finally create faces

			generateIndices();

		}

		function generateSegment( i ) {

			// we use getPointAt to sample evenly distributed points from the given path

			P = path.getPointAt( i / tubularSegments, P );

			// retrieve corresponding normal and binormal

			const N = frames.normals[ i ];
			const B = frames.binormals[ i ];

			// generate normals and vertices for the current segment

			for ( let j = 0; j <= radialSegments; j ++ ) {

				const v = j / radialSegments * Math.PI * 2;

				const sin = Math.sin( v );
				const cos = - Math.cos( v );

				// normal

				normal.x = ( cos * N.x + sin * B.x );
				normal.y = ( cos * N.y + sin * B.y );
				normal.z = ( cos * N.z + sin * B.z );
				normal.normalize();

				normals.push( normal.x, normal.y, normal.z );

				// vertex

				vertex.x = P.x + radius * normal.x;
				vertex.y = P.y + radius * normal.y;
				vertex.z = P.z + radius * normal.z;

				vertices.push( vertex.x, vertex.y, vertex.z );

			}

		}

		function generateIndices() {

			for ( let j = 1; j <= tubularSegments; j ++ ) {

				for ( let i = 1; i <= radialSegments; i ++ ) {

					const a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
					const b = ( radialSegments + 1 ) * j + ( i - 1 );
					const c = ( radialSegments + 1 ) * j + i;
					const d = ( radialSegments + 1 ) * ( j - 1 ) + i;

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

				}

			}

		}

		function generateUVs() {

			for ( let i = 0; i <= tubularSegments; i ++ ) {

				for ( let j = 0; j <= radialSegments; j ++ ) {

					uv.x = i / tubularSegments;
					uv.y = j / radialSegments;

					uvs.push( uv.x, uv.y );

				}

			}

		}

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.path = this.parameters.path.toJSON();

		return data;

	}

	static fromJSON( data ) {

		// This only works for built-in curves (e.g. CatmullRomCurve3).
		// User defined curves or instances of CurvePath will not be deserialized.
		return new TubeGeometry(
			new Curves[ data.path.type ]().fromJSON( data.path ),
			data.tubularSegments,
			data.radius,
			data.radialSegments,
			data.closed
		);

	}

}

class ShadowMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isShadowMaterial = true;

		this.type = 'ShadowMaterial';

		this.color = new Color( 0x000000 );
		this.transparent = true;

		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.fog = source.fog;

		return this;

	}

}

class MeshStandardMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isMeshStandardMaterial = true;

		this.type = 'MeshStandardMaterial';

		this.defines = { 'STANDARD': '' };

		this.color = new Color( 0xffffff ); // diffuse
		this.roughness = 1.0;
		this.metalness = 0.0;

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.roughnessMap = null;

		this.metalnessMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.envMapRotation = new Euler();
		this.envMapIntensity = 1.0;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.flatShading = false;

		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.defines = { 'STANDARD': '' };

		this.color.copy( source.color );
		this.roughness = source.roughness;
		this.metalness = source.metalness;

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.roughnessMap = source.roughnessMap;

		this.metalnessMap = source.metalnessMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.envMapRotation.copy( source.envMapRotation );
		this.envMapIntensity = source.envMapIntensity;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.flatShading = source.flatShading;

		this.fog = source.fog;

		return this;

	}

}

class MeshPhysicalMaterial extends MeshStandardMaterial {

	constructor( parameters ) {

		super();

		this.isMeshPhysicalMaterial = true;

		this.defines = {

			'STANDARD': '',
			'PHYSICAL': ''

		};

		this.type = 'MeshPhysicalMaterial';

		this.anisotropyRotation = 0;
		this.anisotropyMap = null;

		this.clearcoatMap = null;
		this.clearcoatRoughness = 0.0;
		this.clearcoatRoughnessMap = null;
		this.clearcoatNormalScale = new Vector2( 1, 1 );
		this.clearcoatNormalMap = null;

		this.ior = 1.5;

		Object.defineProperty( this, 'reflectivity', {
			get: function () {

				return ( clamp$1( 2.5 * ( this.ior - 1 ) / ( this.ior + 1 ), 0, 1 ) );

			},
			set: function ( reflectivity ) {

				this.ior = ( 1 + 0.4 * reflectivity ) / ( 1 - 0.4 * reflectivity );

			}
		} );

		this.iridescenceMap = null;
		this.iridescenceIOR = 1.3;
		this.iridescenceThicknessRange = [ 100, 400 ];
		this.iridescenceThicknessMap = null;

		this.sheenColor = new Color( 0x000000 );
		this.sheenColorMap = null;
		this.sheenRoughness = 1.0;
		this.sheenRoughnessMap = null;

		this.transmissionMap = null;

		this.thickness = 0;
		this.thicknessMap = null;
		this.attenuationDistance = Infinity;
		this.attenuationColor = new Color( 1, 1, 1 );

		this.specularIntensity = 1.0;
		this.specularIntensityMap = null;
		this.specularColor = new Color( 1, 1, 1 );
		this.specularColorMap = null;

		this._anisotropy = 0;
		this._clearcoat = 0;
		this._dispersion = 0;
		this._iridescence = 0;
		this._sheen = 0.0;
		this._transmission = 0;

		this.setValues( parameters );

	}

	get anisotropy() {

		return this._anisotropy;

	}

	set anisotropy( value ) {

		if ( this._anisotropy > 0 !== value > 0 ) {

			this.version ++;

		}

		this._anisotropy = value;

	}

	get clearcoat() {

		return this._clearcoat;

	}

	set clearcoat( value ) {

		if ( this._clearcoat > 0 !== value > 0 ) {

			this.version ++;

		}

		this._clearcoat = value;

	}

	get iridescence() {

		return this._iridescence;

	}

	set iridescence( value ) {

		if ( this._iridescence > 0 !== value > 0 ) {

			this.version ++;

		}

		this._iridescence = value;

	}

	get dispersion() {

		return this._dispersion;

	}

	set dispersion( value ) {

		if ( this._dispersion > 0 !== value > 0 ) {

			this.version ++;

		}

		this._dispersion = value;

	}

	get sheen() {

		return this._sheen;

	}

	set sheen( value ) {

		if ( this._sheen > 0 !== value > 0 ) {

			this.version ++;

		}

		this._sheen = value;

	}

	get transmission() {

		return this._transmission;

	}

	set transmission( value ) {

		if ( this._transmission > 0 !== value > 0 ) {

			this.version ++;

		}

		this._transmission = value;

	}

	copy( source ) {

		super.copy( source );

		this.defines = {

			'STANDARD': '',
			'PHYSICAL': ''

		};

		this.anisotropy = source.anisotropy;
		this.anisotropyRotation = source.anisotropyRotation;
		this.anisotropyMap = source.anisotropyMap;

		this.clearcoat = source.clearcoat;
		this.clearcoatMap = source.clearcoatMap;
		this.clearcoatRoughness = source.clearcoatRoughness;
		this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
		this.clearcoatNormalMap = source.clearcoatNormalMap;
		this.clearcoatNormalScale.copy( source.clearcoatNormalScale );

		this.dispersion = source.dispersion;
		this.ior = source.ior;

		this.iridescence = source.iridescence;
		this.iridescenceMap = source.iridescenceMap;
		this.iridescenceIOR = source.iridescenceIOR;
		this.iridescenceThicknessRange = [ ...source.iridescenceThicknessRange ];
		this.iridescenceThicknessMap = source.iridescenceThicknessMap;

		this.sheen = source.sheen;
		this.sheenColor.copy( source.sheenColor );
		this.sheenColorMap = source.sheenColorMap;
		this.sheenRoughness = source.sheenRoughness;
		this.sheenRoughnessMap = source.sheenRoughnessMap;

		this.transmission = source.transmission;
		this.transmissionMap = source.transmissionMap;

		this.thickness = source.thickness;
		this.thicknessMap = source.thicknessMap;
		this.attenuationDistance = source.attenuationDistance;
		this.attenuationColor.copy( source.attenuationColor );

		this.specularIntensity = source.specularIntensity;
		this.specularIntensityMap = source.specularIntensityMap;
		this.specularColor.copy( source.specularColor );
		this.specularColorMap = source.specularColorMap;

		return this;

	}

}

class MeshPhongMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isMeshPhongMaterial = true;

		this.type = 'MeshPhongMaterial';

		this.color = new Color( 0xffffff ); // diffuse
		this.specular = new Color( 0x111111 );
		this.shininess = 30;

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.envMapRotation = new Euler();

		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.flatShading = false;

		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );
		this.specular.copy( source.specular );
		this.shininess = source.shininess;

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.envMapRotation.copy( source.envMapRotation );
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.flatShading = source.flatShading;

		this.fog = source.fog;

		return this;

	}

}

class MeshToonMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isMeshToonMaterial = true;

		this.defines = { 'TOON': '' };

		this.type = 'MeshToonMaterial';

		this.color = new Color( 0xffffff );

		this.map = null;
		this.gradientMap = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.alphaMap = null;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;
		this.gradientMap = source.gradientMap;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.alphaMap = source.alphaMap;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.fog = source.fog;

		return this;

	}

}

class MeshNormalMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isMeshNormalMaterial = true;

		this.type = 'MeshNormalMaterial';

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.flatShading = false;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		this.flatShading = source.flatShading;

		return this;

	}

}

class MeshLambertMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isMeshLambertMaterial = true;

		this.type = 'MeshLambertMaterial';

		this.color = new Color( 0xffffff ); // diffuse

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.envMapRotation = new Euler();
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.flatShading = false;

		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.envMapRotation.copy( source.envMapRotation );
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.flatShading = source.flatShading;

		this.fog = source.fog;

		return this;

	}

}

class MeshMatcapMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isMeshMatcapMaterial = true;

		this.defines = { 'MATCAP': '' };

		this.type = 'MeshMatcapMaterial';

		this.color = new Color( 0xffffff ); // diffuse

		this.matcap = null;

		this.map = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.alphaMap = null;

		this.flatShading = false;

		this.fog = true;

		this.setValues( parameters );

	}


	copy( source ) {

		super.copy( source );

		this.defines = { 'MATCAP': '' };

		this.color.copy( source.color );

		this.matcap = source.matcap;

		this.map = source.map;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.alphaMap = source.alphaMap;

		this.flatShading = source.flatShading;

		this.fog = source.fog;

		return this;

	}

}

class LineDashedMaterial extends LineBasicMaterial {

	constructor( parameters ) {

		super();

		this.isLineDashedMaterial = true;
		this.type = 'LineDashedMaterial';

		this.scale = 1;
		this.dashSize = 3;
		this.gapSize = 1;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.scale = source.scale;
		this.dashSize = source.dashSize;
		this.gapSize = source.gapSize;

		return this;

	}

}

class Light extends Object3D {

	constructor( color, intensity = 1 ) {

		super();

		this.isLight = true;

		this.type = 'Light';

		this.color = new Color( color );
		this.intensity = intensity;

	}

	dispose() {

		// Empty here in base class; some subclasses override.

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.color.copy( source.color );
		this.intensity = source.intensity;

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.object.color = this.color.getHex();
		data.object.intensity = this.intensity;

		if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

		if ( this.distance !== undefined ) data.object.distance = this.distance;
		if ( this.angle !== undefined ) data.object.angle = this.angle;
		if ( this.decay !== undefined ) data.object.decay = this.decay;
		if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;

		if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();
		if ( this.target !== undefined ) data.object.target = this.target.uuid;

		return data;

	}

}

class HemisphereLight extends Light {

	constructor( skyColor, groundColor, intensity ) {

		super( skyColor, intensity );

		this.isHemisphereLight = true;

		this.type = 'HemisphereLight';

		this.position.copy( Object3D.DEFAULT_UP );
		this.updateMatrix();

		this.groundColor = new Color( groundColor );

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.groundColor.copy( source.groundColor );

		return this;

	}

}

const _projScreenMatrix$1$1 = /*@__PURE__*/ new Matrix4();
const _lightPositionWorld$1 = /*@__PURE__*/ new Vector3();
const _lookTarget$1 = /*@__PURE__*/ new Vector3();

class LightShadow {

	constructor( camera ) {

		this.camera = camera;

		this.intensity = 1;

		this.bias = 0;
		this.normalBias = 0;
		this.radius = 1;
		this.blurSamples = 8;

		this.mapSize = new Vector2( 512, 512 );

		this.map = null;
		this.mapPass = null;
		this.matrix = new Matrix4();

		this.autoUpdate = true;
		this.needsUpdate = false;

		this._frustum = new Frustum();
		this._frameExtents = new Vector2( 1, 1 );

		this._viewportCount = 1;

		this._viewports = [

			new Vector4( 0, 0, 1, 1 )

		];

	}

	getViewportCount() {

		return this._viewportCount;

	}

	getFrustum() {

		return this._frustum;

	}

	updateMatrices( light ) {

		const shadowCamera = this.camera;
		const shadowMatrix = this.matrix;

		_lightPositionWorld$1.setFromMatrixPosition( light.matrixWorld );
		shadowCamera.position.copy( _lightPositionWorld$1 );

		_lookTarget$1.setFromMatrixPosition( light.target.matrixWorld );
		shadowCamera.lookAt( _lookTarget$1 );
		shadowCamera.updateMatrixWorld();

		_projScreenMatrix$1$1.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
		this._frustum.setFromProjectionMatrix( _projScreenMatrix$1$1 );

		shadowMatrix.set(
			0.5, 0.0, 0.0, 0.5,
			0.0, 0.5, 0.0, 0.5,
			0.0, 0.0, 0.5, 0.5,
			0.0, 0.0, 0.0, 1.0
		);

		shadowMatrix.multiply( _projScreenMatrix$1$1 );

	}

	getViewport( viewportIndex ) {

		return this._viewports[ viewportIndex ];

	}

	getFrameExtents() {

		return this._frameExtents;

	}

	dispose() {

		if ( this.map ) {

			this.map.dispose();

		}

		if ( this.mapPass ) {

			this.mapPass.dispose();

		}

	}

	copy( source ) {

		this.camera = source.camera.clone();

		this.intensity = source.intensity;

		this.bias = source.bias;
		this.radius = source.radius;

		this.mapSize.copy( source.mapSize );

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	toJSON() {

		const object = {};

		if ( this.intensity !== 1 ) object.intensity = this.intensity;
		if ( this.bias !== 0 ) object.bias = this.bias;
		if ( this.normalBias !== 0 ) object.normalBias = this.normalBias;
		if ( this.radius !== 1 ) object.radius = this.radius;
		if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();

		object.camera = this.camera.toJSON( false ).object;
		delete object.camera.matrix;

		return object;

	}

}

class SpotLightShadow extends LightShadow {

	constructor() {

		super( new PerspectiveCamera( 50, 1, 0.5, 500 ) );

		this.isSpotLightShadow = true;

		this.focus = 1;

	}

	updateMatrices( light ) {

		const camera = this.camera;

		const fov = RAD2DEG * 2 * light.angle * this.focus;
		const aspect = this.mapSize.width / this.mapSize.height;
		const far = light.distance || camera.far;

		if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {

			camera.fov = fov;
			camera.aspect = aspect;
			camera.far = far;
			camera.updateProjectionMatrix();

		}

		super.updateMatrices( light );

	}

	copy( source ) {

		super.copy( source );

		this.focus = source.focus;

		return this;

	}

}

class SpotLight extends Light {

	constructor( color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 2 ) {

		super( color, intensity );

		this.isSpotLight = true;

		this.type = 'SpotLight';

		this.position.copy( Object3D.DEFAULT_UP );
		this.updateMatrix();

		this.target = new Object3D();

		this.distance = distance;
		this.angle = angle;
		this.penumbra = penumbra;
		this.decay = decay;

		this.map = null;

		this.shadow = new SpotLightShadow();

	}

	get power() {

		// compute the light's luminous power (in lumens) from its intensity (in candela)
		// by convention for a spotlight, luminous power (lm) =  * luminous intensity (cd)
		return this.intensity * Math.PI;

	}

	set power( power ) {

		// set the light's intensity (in candela) from the desired luminous power (in lumens)
		this.intensity = power / Math.PI;

	}

	dispose() {

		this.shadow.dispose();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.distance = source.distance;
		this.angle = source.angle;
		this.penumbra = source.penumbra;
		this.decay = source.decay;

		this.target = source.target.clone();

		this.shadow = source.shadow.clone();

		return this;

	}

}

const _projScreenMatrix$2 = /*@__PURE__*/ new Matrix4();
const _lightPositionWorld = /*@__PURE__*/ new Vector3();
const _lookTarget = /*@__PURE__*/ new Vector3();

class PointLightShadow extends LightShadow {

	constructor() {

		super( new PerspectiveCamera( 90, 1, 0.5, 500 ) );

		this.isPointLightShadow = true;

		this._frameExtents = new Vector2( 4, 2 );

		this._viewportCount = 6;

		this._viewports = [
			// These viewports map a cube-map onto a 2D texture with the
			// following orientation:
			//
			//  xzXZ
			//   y Y
			//
			// X - Positive x direction
			// x - Negative x direction
			// Y - Positive y direction
			// y - Negative y direction
			// Z - Positive z direction
			// z - Negative z direction

			// positive X
			new Vector4( 2, 1, 1, 1 ),
			// negative X
			new Vector4( 0, 1, 1, 1 ),
			// positive Z
			new Vector4( 3, 1, 1, 1 ),
			// negative Z
			new Vector4( 1, 1, 1, 1 ),
			// positive Y
			new Vector4( 3, 0, 1, 1 ),
			// negative Y
			new Vector4( 1, 0, 1, 1 )
		];

		this._cubeDirections = [
			new Vector3( 1, 0, 0 ), new Vector3( -1, 0, 0 ), new Vector3( 0, 0, 1 ),
			new Vector3( 0, 0, -1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, -1, 0 )
		];

		this._cubeUps = [
			new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),
			new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),	new Vector3( 0, 0, -1 )
		];

	}

	updateMatrices( light, viewportIndex = 0 ) {

		const camera = this.camera;
		const shadowMatrix = this.matrix;

		const far = light.distance || camera.far;

		if ( far !== camera.far ) {

			camera.far = far;
			camera.updateProjectionMatrix();

		}

		_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
		camera.position.copy( _lightPositionWorld );

		_lookTarget.copy( camera.position );
		_lookTarget.add( this._cubeDirections[ viewportIndex ] );
		camera.up.copy( this._cubeUps[ viewportIndex ] );
		camera.lookAt( _lookTarget );
		camera.updateMatrixWorld();

		shadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );

		_projScreenMatrix$2.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		this._frustum.setFromProjectionMatrix( _projScreenMatrix$2 );

	}

}

class PointLight extends Light {

	constructor( color, intensity, distance = 0, decay = 2 ) {

		super( color, intensity );

		this.isPointLight = true;

		this.type = 'PointLight';

		this.distance = distance;
		this.decay = decay;

		this.shadow = new PointLightShadow();

	}

	get power() {

		// compute the light's luminous power (in lumens) from its intensity (in candela)
		// for an isotropic light source, luminous power (lm) = 4  luminous intensity (cd)
		return this.intensity * 4 * Math.PI;

	}

	set power( power ) {

		// set the light's intensity (in candela) from the desired luminous power (in lumens)
		this.intensity = power / ( 4 * Math.PI );

	}

	dispose() {

		this.shadow.dispose();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.distance = source.distance;
		this.decay = source.decay;

		this.shadow = source.shadow.clone();

		return this;

	}

}

class OrthographicCamera extends Camera {

	constructor( left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2000 ) {

		super();

		this.isOrthographicCamera = true;

		this.type = 'OrthographicCamera';

		this.zoom = 1;
		this.view = null;

		this.left = left;
		this.right = right;
		this.top = top;
		this.bottom = bottom;

		this.near = near;
		this.far = far;

		this.updateProjectionMatrix();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.left = source.left;
		this.right = source.right;
		this.top = source.top;
		this.bottom = source.bottom;
		this.near = source.near;
		this.far = source.far;

		this.zoom = source.zoom;
		this.view = source.view === null ? null : Object.assign( {}, source.view );

		return this;

	}

	setViewOffset( fullWidth, fullHeight, x, y, width, height ) {

		if ( this.view === null ) {

			this.view = {
				enabled: true,
				fullWidth: 1,
				fullHeight: 1,
				offsetX: 0,
				offsetY: 0,
				width: 1,
				height: 1
			};

		}

		this.view.enabled = true;
		this.view.fullWidth = fullWidth;
		this.view.fullHeight = fullHeight;
		this.view.offsetX = x;
		this.view.offsetY = y;
		this.view.width = width;
		this.view.height = height;

		this.updateProjectionMatrix();

	}

	clearViewOffset() {

		if ( this.view !== null ) {

			this.view.enabled = false;

		}

		this.updateProjectionMatrix();

	}

	updateProjectionMatrix() {

		const dx = ( this.right - this.left ) / ( 2 * this.zoom );
		const dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
		const cx = ( this.right + this.left ) / 2;
		const cy = ( this.top + this.bottom ) / 2;

		let left = cx - dx;
		let right = cx + dx;
		let top = cy + dy;
		let bottom = cy - dy;

		if ( this.view !== null && this.view.enabled ) {

			const scaleW = ( this.right - this.left ) / this.view.fullWidth / this.zoom;
			const scaleH = ( this.top - this.bottom ) / this.view.fullHeight / this.zoom;

			left += scaleW * this.view.offsetX;
			right = left + scaleW * this.view.width;
			top -= scaleH * this.view.offsetY;
			bottom = top - scaleH * this.view.height;

		}

		this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far, this.coordinateSystem );

		this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.object.zoom = this.zoom;
		data.object.left = this.left;
		data.object.right = this.right;
		data.object.top = this.top;
		data.object.bottom = this.bottom;
		data.object.near = this.near;
		data.object.far = this.far;

		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

		return data;

	}

}

class DirectionalLightShadow extends LightShadow {

	constructor() {

		super( new OrthographicCamera( -5, 5, 5, -5, 0.5, 500 ) );

		this.isDirectionalLightShadow = true;

	}

}

class DirectionalLight extends Light {

	constructor( color, intensity ) {

		super( color, intensity );

		this.isDirectionalLight = true;

		this.type = 'DirectionalLight';

		this.position.copy( Object3D.DEFAULT_UP );
		this.updateMatrix();

		this.target = new Object3D();

		this.shadow = new DirectionalLightShadow();

	}

	dispose() {

		this.shadow.dispose();

	}

	copy( source ) {

		super.copy( source );

		this.target = source.target.clone();
		this.shadow = source.shadow.clone();

		return this;

	}

}

class AmbientLight extends Light {

	constructor( color, intensity ) {

		super( color, intensity );

		this.isAmbientLight = true;

		this.type = 'AmbientLight';

	}

}

class RectAreaLight extends Light {

	constructor( color, intensity, width = 10, height = 10 ) {

		super( color, intensity );

		this.isRectAreaLight = true;

		this.type = 'RectAreaLight';

		this.width = width;
		this.height = height;

	}

	get power() {

		// compute the light's luminous power (in lumens) from its intensity (in nits)
		return this.intensity * this.width * this.height * Math.PI;

	}

	set power( power ) {

		// set the light's intensity (in nits) from the desired luminous power (in lumens)
		this.intensity = power / ( this.width * this.height * Math.PI );

	}

	copy( source ) {

		super.copy( source );

		this.width = source.width;
		this.height = source.height;

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.object.width = this.width;
		data.object.height = this.height;

		return data;

	}

}

/**
 * Primary reference:
 *   https://graphics.stanford.edu/papers/envmap/envmap.pdf
 *
 * Secondary reference:
 *   https://www.ppsloan.org/publications/StupidSH36.pdf
 */

// 3-band SH defined by 9 coefficients

class SphericalHarmonics3 {

	constructor() {

		this.isSphericalHarmonics3 = true;

		this.coefficients = [];

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients.push( new Vector3() );

		}

	}

	set( coefficients ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].copy( coefficients[ i ] );

		}

		return this;

	}

	zero() {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].set( 0, 0, 0 );

		}

		return this;

	}

	// get the radiance in the direction of the normal
	// target is a Vector3
	getAt( normal, target ) {

		// normal is assumed to be unit length

		const x = normal.x, y = normal.y, z = normal.z;

		const coeff = this.coefficients;

		// band 0
		target.copy( coeff[ 0 ] ).multiplyScalar( 0.282095 );

		// band 1
		target.addScaledVector( coeff[ 1 ], 0.488603 * y );
		target.addScaledVector( coeff[ 2 ], 0.488603 * z );
		target.addScaledVector( coeff[ 3 ], 0.488603 * x );

		// band 2
		target.addScaledVector( coeff[ 4 ], 1.092548 * ( x * y ) );
		target.addScaledVector( coeff[ 5 ], 1.092548 * ( y * z ) );
		target.addScaledVector( coeff[ 6 ], 0.315392 * ( 3.0 * z * z - 1.0 ) );
		target.addScaledVector( coeff[ 7 ], 1.092548 * ( x * z ) );
		target.addScaledVector( coeff[ 8 ], 0.546274 * ( x * x - y * y ) );

		return target;

	}

	// get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
	// target is a Vector3
	// https://graphics.stanford.edu/papers/envmap/envmap.pdf
	getIrradianceAt( normal, target ) {

		// normal is assumed to be unit length

		const x = normal.x, y = normal.y, z = normal.z;

		const coeff = this.coefficients;

		// band 0
		target.copy( coeff[ 0 ] ).multiplyScalar( 0.886227 ); //  * 0.282095

		// band 1
		target.addScaledVector( coeff[ 1 ], 2.0 * 0.511664 * y ); // ( 2 *  / 3 ) * 0.488603
		target.addScaledVector( coeff[ 2 ], 2.0 * 0.511664 * z );
		target.addScaledVector( coeff[ 3 ], 2.0 * 0.511664 * x );

		// band 2
		target.addScaledVector( coeff[ 4 ], 2.0 * 0.429043 * x * y ); // (  / 4 ) * 1.092548
		target.addScaledVector( coeff[ 5 ], 2.0 * 0.429043 * y * z );
		target.addScaledVector( coeff[ 6 ], 0.743125 * z * z - 0.247708 ); // (  / 4 ) * 0.315392 * 3
		target.addScaledVector( coeff[ 7 ], 2.0 * 0.429043 * x * z );
		target.addScaledVector( coeff[ 8 ], 0.429043 * ( x * x - y * y ) ); // (  / 4 ) * 0.546274

		return target;

	}

	add( sh ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].add( sh.coefficients[ i ] );

		}

		return this;

	}

	addScaledSH( sh, s ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].addScaledVector( sh.coefficients[ i ], s );

		}

		return this;

	}

	scale( s ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].multiplyScalar( s );

		}

		return this;

	}

	lerp( sh, alpha ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].lerp( sh.coefficients[ i ], alpha );

		}

		return this;

	}

	equals( sh ) {

		for ( let i = 0; i < 9; i ++ ) {

			if ( ! this.coefficients[ i ].equals( sh.coefficients[ i ] ) ) {

				return false;

			}

		}

		return true;

	}

	copy( sh ) {

		return this.set( sh.coefficients );

	}

	clone() {

		return new this.constructor().copy( this );

	}

	fromArray( array, offset = 0 ) {

		const coefficients = this.coefficients;

		for ( let i = 0; i < 9; i ++ ) {

			coefficients[ i ].fromArray( array, offset + ( i * 3 ) );

		}

		return this;

	}

	toArray( array = [], offset = 0 ) {

		const coefficients = this.coefficients;

		for ( let i = 0; i < 9; i ++ ) {

			coefficients[ i ].toArray( array, offset + ( i * 3 ) );

		}

		return array;

	}

	// evaluate the basis functions
	// shBasis is an Array[ 9 ]
	static getBasisAt( normal, shBasis ) {

		// normal is assumed to be unit length

		const x = normal.x, y = normal.y, z = normal.z;

		// band 0
		shBasis[ 0 ] = 0.282095;

		// band 1
		shBasis[ 1 ] = 0.488603 * y;
		shBasis[ 2 ] = 0.488603 * z;
		shBasis[ 3 ] = 0.488603 * x;

		// band 2
		shBasis[ 4 ] = 1.092548 * x * y;
		shBasis[ 5 ] = 1.092548 * y * z;
		shBasis[ 6 ] = 0.315392 * ( 3 * z * z - 1 );
		shBasis[ 7 ] = 1.092548 * x * z;
		shBasis[ 8 ] = 0.546274 * ( x * x - y * y );

	}

}

class LightProbe extends Light {

	constructor( sh = new SphericalHarmonics3(), intensity = 1 ) {

		super( undefined, intensity );

		this.isLightProbe = true;

		this.sh = sh;

	}

	copy( source ) {

		super.copy( source );

		this.sh.copy( source.sh );

		return this;

	}

	fromJSON( json ) {

		this.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();
		this.sh.fromArray( json.sh );

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.object.sh = this.sh.toArray();

		return data;

	}

}

class Clock {

	constructor( autoStart = true ) {

		this.autoStart = autoStart;

		this.startTime = 0;
		this.oldTime = 0;
		this.elapsedTime = 0;

		this.running = false;

	}

	start() {

		this.startTime = now();

		this.oldTime = this.startTime;
		this.elapsedTime = 0;
		this.running = true;

	}

	stop() {

		this.getElapsedTime();
		this.running = false;
		this.autoStart = false;

	}

	getElapsedTime() {

		this.getDelta();
		return this.elapsedTime;

	}

	getDelta() {

		let diff = 0;

		if ( this.autoStart && ! this.running ) {

			this.start();
			return 0;

		}

		if ( this.running ) {

			const newTime = now();

			diff = ( newTime - this.oldTime ) / 1000;
			this.oldTime = newTime;

			this.elapsedTime += diff;

		}

		return diff;

	}

}

function now() {

	return performance.now();

}

class InstancedInterleavedBuffer extends InterleavedBuffer {

	constructor( array, stride, meshPerAttribute = 1 ) {

		super( array, stride );

		this.isInstancedInterleavedBuffer = true;

		this.meshPerAttribute = meshPerAttribute;

	}

	copy( source ) {

		super.copy( source );

		this.meshPerAttribute = source.meshPerAttribute;

		return this;

	}

	clone( data ) {

		const ib = super.clone( data );

		ib.meshPerAttribute = this.meshPerAttribute;

		return ib;

	}

	toJSON( data ) {

		const json = super.toJSON( data );

		json.isInstancedInterleavedBuffer = true;
		json.meshPerAttribute = this.meshPerAttribute;

		return json;

	}

}

class Controls extends EventDispatcher {

	constructor( object, domElement = null ) {

		super();

		this.object = object;
		this.domElement = domElement;

		this.enabled = true;

		this.state = -1;

		this.keys = {};
		this.mouseButtons = { LEFT: null, MIDDLE: null, RIGHT: null };
		this.touches = { ONE: null, TWO: null };

	}

	connect() {}

	disconnect() {}

	dispose() {}

	update( /* delta */ ) {}

}

if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

	__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'register', { detail: {
		revision: REVISION,
	} } ) );

}

if ( typeof window !== 'undefined' ) {

	if ( window.__THREE__ ) {

		console.warn( 'WARNING: Multiple instances of Three.js being imported.' );

	} else {

		window.__THREE__ = REVISION;

	}

}

// Helper to check if something is a valid TSL Node
function isNode(val) {
    return val && (val.isNode === true || typeof val.build === 'function');
}

// Helper to check if value is a THREE.js object that shouldn't be wrapped
function isThreeObject(val) {
    return val && (val.isVector2 || val.isVector3 || val.isVector4 || val.isColor || val.isMatrix3 || val.isMatrix4);
}

// Recursively checks a Node tree for raw numbers mixed with Nodes
function validateNodeTree(node, path, visited = new Set()) {
    if (!node || typeof node !== 'object') return [];
    if (visited.has(node)) return [];
    visited.add(node);

    const errors = [];

    // CRITICAL CHECK: Math/Operator nodes (add, mul, sub) fail if inputs are raw numbers
    if (node.isMathNode || node.isOperatorNode) {
        if (node.a !== undefined && !isNode(node.a) && typeof node.a === 'number') {
             errors.push(`${path}.a is a NUMBER (${node.a}). Wrap in float(${node.a}).`);
        }
        if (node.b !== undefined && !isNode(node.b) && typeof node.b === 'number') {
             errors.push(`${path}.b is a NUMBER (${node.b}). Wrap in float(${node.b}).`);
        }
    }

    // CHECK: Detect improperly nested uniform nodes (e.g., vec3(uniformNode) where uniformNode already wraps a THREE.Color)
    if (node.isVectorNode || node.isColorNode) {
        const val = node.value || node.x; // Check first param
        if (val && isNode(val) && val.isUniformNode) {
            // Check if uniform contains a THREE.js object
            if (val.value && isThreeObject(val.value)) {
                errors.push(`${path} wraps a uniform containing a THREE object. Uniform nodes don't need vec3()/color() wrappers.`);
            }
        }
    }

    // CHECK: Verify getNodeType exists for nodes that should have it
    if (isNode(node) && !node.getNodeType && !node.isUniformNode) {
        errors.push(`${path} is marked as a node but missing getNodeType() method. Type: ${node.type || node.constructor?.name}`);
    }

    // Traverse children
    const checkKeys = ['a', 'b', 'c', 'value', 'node', 'nodes', 'params', 'x', 'y', 'z', 'w'];
    checkKeys.forEach(key => {
        const val = node[key];
        if (Array.isArray(val)) {
            val.forEach((child, i) => errors.push(...validateNodeTree(child, `${path}.${key}[${i}]`, visited)));
        } else if (isNode(val)) {
            errors.push(...validateNodeTree(val, `${path}.${key}`, visited));
        }
    });

    return errors;
}

function diagnoseMaterial(material, objName) {
    if (!material || !material.isNodeMaterial) return [];
    
    const errors = [];
    // Properties that MUST be Nodes in TSL
    const slots = ['colorNode', 'positionNode', 'normalNode', 'emissiveNode', 'roughnessNode', 'metalnessNode', 'opacityNode', 'sizeNode'];

    slots.forEach(slot => {
        if (material[slot]) {
            // 1. Top-level check: Is the slot itself a number? (Allowed for roughness/metalness, bad for vec3 types)
            if (typeof material[slot] === 'number') {
                if (slot.includes('color') || slot.includes('position') || slot.includes('normal')) {
                    errors.push(`[${objName}] material.${slot} is a raw number (${material[slot]}). Must be a Node.`);
                }
            }
            // 2. Check if it's a THREE.js object being used directly
            else if (isThreeObject(material[slot])) {
                errors.push(`[${objName}] material.${slot} is a THREE.js object (${material[slot].constructor.name}). Wrap in appropriate TSL node or use uniform().`);
            }
            // 3. Deep check
            else {
                const treeErrors = validateNodeTree(material[slot], slot);
                if (treeErrors.length > 0) {
                    errors.push(...treeErrors.map(e => `[${objName}] ${e}`));
                }
            }
        }
    });
    return errors;
}

function installDiagnostics(scene) {
    window.scanForTSLErrors = () => {
        console.group(" TSL Deep Scan...");
        let issues = 0;
        let totalMaterials = 0;
        const errorsByType = {};
        
        scene.traverse(obj => {
            if (obj.material) {
                const mats = Array.isArray(obj.material) ? obj.material : [obj.material];
                mats.forEach(m => {
                    if (m.isNodeMaterial) {
                        totalMaterials++;
                        const errs = diagnoseMaterial(m, obj.name || obj.type);
                        if (errs.length > 0) {
                            issues++;
                            const matType = m.type || m.constructor.name;
                            errorsByType[matType] = (errorsByType[matType] || 0) + 1;
                            
                            console.error(` ${obj.name || obj.type} (${matType}):`);
                            console.error(`   UUID: ${obj.uuid}, Position: (${obj.position.x.toFixed(1)}, ${obj.position.y.toFixed(1)}, ${obj.position.z.toFixed(1)})`);
                            errs.forEach(e => console.warn("     " + e));
                        }
                    }
                });
            }
        });
        
        if (issues === 0) {
            console.log(` No TSL type-mixing errors found in ${totalMaterials} node materials.`);
        } else {
            console.error(` Found ${issues} materials with errors out of ${totalMaterials} total:`);
            Object.entries(errorsByType).forEach(([type, count]) => {
                console.error(`   - ${type}: ${count} error(s)`);
            });
        }
        console.groupEnd();
        return issues;
    };
    
    // Auto-run scan after a short delay to catch initialization issues
    console.log(" [TSL Diagnostics] Auto-scanning in 2 seconds...");
    setTimeout(() => {
        const errorCount = window.scanForTSLErrors();
        if (errorCount > 0) {
            console.warn(" [TSL Diagnostics] Errors detected during initialization. Fix these to prevent runtime shader errors.");
        }
    }, 2000);
}

/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */

const refreshUniforms = [
	'alphaMap',
	'alphaTest',
	'anisotropy',
	'anisotropyMap',
	'anisotropyRotation',
	'aoMap',
	'attenuationColor',
	'attenuationDistance',
	'bumpMap',
	'clearcoat',
	'clearcoatMap',
	'clearcoatNormalMap',
	'clearcoatNormalScale',
	'clearcoatRoughness',
	'color',
	'dispersion',
	'displacementMap',
	'emissive',
	'emissiveMap',
	'envMap',
	'gradientMap',
	'ior',
	'iridescence',
	'iridescenceIOR',
	'iridescenceMap',
	'iridescenceThicknessMap',
	'lightMap',
	'map',
	'matcap',
	'metalness',
	'metalnessMap',
	'normalMap',
	'normalScale',
	'opacity',
	'roughness',
	'roughnessMap',
	'sheen',
	'sheenColor',
	'sheenColorMap',
	'sheenRoughnessMap',
	'shininess',
	'specular',
	'specularColor',
	'specularColorMap',
	'specularIntensity',
	'specularIntensityMap',
	'specularMap',
	'thickness',
	'transmission',
	'transmissionMap'
];

class NodeMaterialObserver {

	constructor( builder ) {

		this.renderObjects = new WeakMap();
		this.hasNode = this.containsNode( builder );
		this.hasAnimation = builder.object.isSkinnedMesh === true;
		this.refreshUniforms = refreshUniforms;
		this.renderId = 0;

	}

	firstInitialization( renderObject ) {

		const hasInitialized = this.renderObjects.has( renderObject );

		if ( hasInitialized === false ) {

			this.getRenderObjectData( renderObject );

			return true;

		}

		return false;

	}

	getRenderObjectData( renderObject ) {

		let data = this.renderObjects.get( renderObject );

		if ( data === undefined ) {

			const { geometry, material, object } = renderObject;

			data = {
				material: this.getMaterialData( material ),
				geometry: {
					attributes: this.getAttributesData( geometry.attributes ),
					indexVersion: geometry.index ? geometry.index.version : null,
					drawRange: { start: geometry.drawRange.start, count: geometry.drawRange.count }
				},
				worldMatrix: object.matrixWorld.clone()
			};

			if ( object.center ) {

				data.center = object.center.clone();

			}

			if ( object.morphTargetInfluences ) {

				data.morphTargetInfluences = object.morphTargetInfluences.slice();

			}

			if ( renderObject.bundle !== null ) {

				data.version = renderObject.bundle.version;

			}

			if ( data.material.transmission > 0 ) {

				const { width, height } = renderObject.context;

				data.bufferWidth = width;
				data.bufferHeight = height;

			}

			this.renderObjects.set( renderObject, data );

		}

		return data;

	}

	getAttributesData( attributes ) {

		const attributesData = {};

		for ( const name in attributes ) {

			const attribute = attributes[ name ];

			attributesData[ name ] = {
				version: attribute.version
			};

		}

		return attributesData;

	}

	containsNode( builder ) {

		const material = builder.material;

		for ( const property in material ) {

			if ( material[ property ] && material[ property ].isNode )
				return true;

		}

		if ( builder.renderer.nodes.modelViewMatrix !== null || builder.renderer.nodes.modelNormalViewMatrix !== null )
			return true;

		return false;

	}

	getMaterialData( material ) {

		const data = {};

		for ( const property of this.refreshUniforms ) {

			const value = material[ property ];

			if ( value === null || value === undefined ) continue;

			if ( typeof value === 'object' && value.clone !== undefined ) {

				if ( value.isTexture === true ) {

					data[ property ] = { id: value.id, version: value.version };

				} else {

					data[ property ] = value.clone();

				}

			} else {

				data[ property ] = value;

			}

		}

		return data;

	}

	equals( renderObject ) {

		const { object, material, geometry } = renderObject;

		const renderObjectData = this.getRenderObjectData( renderObject );

		// world matrix

		if ( renderObjectData.worldMatrix.equals( object.matrixWorld ) !== true ) {

			renderObjectData.worldMatrix.copy( object.matrixWorld );

			return false;

		}

		// material

		const materialData = renderObjectData.material;

		for ( const property in materialData ) {

			const value = materialData[ property ];
			const mtlValue = material[ property ];

			if ( value.equals !== undefined ) {

				if ( value.equals( mtlValue ) === false ) {

					value.copy( mtlValue );

					return false;

				}

			} else if ( mtlValue.isTexture === true ) {

				if ( value.id !== mtlValue.id || value.version !== mtlValue.version ) {

					value.id = mtlValue.id;
					value.version = mtlValue.version;

					return false;

				}

			} else if ( value !== mtlValue ) {

				materialData[ property ] = mtlValue;

				return false;

			}

		}

		if ( materialData.transmission > 0 ) {

			const { width, height } = renderObject.context;

			if ( renderObjectData.bufferWidth !== width || renderObjectData.bufferHeight !== height ) {

				renderObjectData.bufferWidth = width;
				renderObjectData.bufferHeight = height;

				return false;

			}

		}

		// geometry

		const storedGeometryData = renderObjectData.geometry;
		const attributes = geometry.attributes;
		const storedAttributes = storedGeometryData.attributes;

		const storedAttributeNames = Object.keys( storedAttributes );
		const currentAttributeNames = Object.keys( attributes );

		if ( storedAttributeNames.length !== currentAttributeNames.length ) {

			renderObjectData.geometry.attributes = this.getAttributesData( attributes );
			return false;

		}

		// compare each attribute

		for ( const name of storedAttributeNames ) {

			const storedAttributeData = storedAttributes[ name ];
			const attribute = attributes[ name ];

			if ( attribute === undefined ) {

				// attribute was removed
				delete storedAttributes[ name ];
				return false;

			}

			if ( storedAttributeData.version !== attribute.version ) {

				storedAttributeData.version = attribute.version;
				return false;

			}

		}

		// check index

		const index = geometry.index;
		const storedIndexVersion = storedGeometryData.indexVersion;
		const currentIndexVersion = index ? index.version : null;

		if ( storedIndexVersion !== currentIndexVersion ) {

			storedGeometryData.indexVersion = currentIndexVersion;
			return false;

		}

		// check drawRange

		if ( storedGeometryData.drawRange.start !== geometry.drawRange.start || storedGeometryData.drawRange.count !== geometry.drawRange.count ) {

			storedGeometryData.drawRange.start = geometry.drawRange.start;
			storedGeometryData.drawRange.count = geometry.drawRange.count;
			return false;

		}

		// morph targets

		if ( renderObjectData.morphTargetInfluences ) {

			let morphChanged = false;

			for ( let i = 0; i < renderObjectData.morphTargetInfluences.length; i ++ ) {

				if ( renderObjectData.morphTargetInfluences[ i ] !== object.morphTargetInfluences[ i ] ) {

					morphChanged = true;

				}

			}

			if ( morphChanged ) return true;

		}

		// center

		if ( renderObjectData.center ) {

			if ( renderObjectData.center.equals( object.center ) === false ) {

				renderObjectData.center.copy( object.center );

				return true;

			}

		}

		// bundle

		if ( renderObject.bundle !== null ) {

			renderObjectData.version = renderObject.bundle.version;

		}

		return true;

	}

	needsRefresh( renderObject, nodeFrame ) {

		if ( this.hasNode || this.hasAnimation || this.firstInitialization( renderObject ) )
			return true;

		const { renderId } = nodeFrame;

		if ( this.renderId !== renderId ) {

			this.renderId = renderId;

			return true;

		}

		const isStatic = renderObject.object.static === true;
		const isBundle = renderObject.bundle !== null && renderObject.bundle.static === true && this.getRenderObjectData( renderObject ).version === renderObject.bundle.version;

		if ( isStatic || isBundle )
			return false;

		const notEqual = this.equals( renderObject ) !== true;

		return notEqual;

	}

}

// cyrb53 (c) 2018 bryc (github.com/bryc). License: Public domain. Attribution appreciated.
// A fast and simple 64-bit (or 53-bit) string hash function with decent collision resistance.
// Largely inspired by MurmurHash2/3, but with a focus on speed/simplicity.
// See https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript/52171480#52171480
// https://github.com/bryc/code/blob/master/jshash/experimental/cyrb53.js
function cyrb53( value, seed = 0 ) {

	let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;

	if ( value instanceof Array ) {

		for ( let i = 0, val; i < value.length; i ++ ) {

			val = value[ i ];
			h1 = Math.imul( h1 ^ val, 2654435761 );
			h2 = Math.imul( h2 ^ val, 1597334677 );

		}

	} else {

		for ( let i = 0, ch; i < value.length; i ++ ) {

			ch = value.charCodeAt( i );
			h1 = Math.imul( h1 ^ ch, 2654435761 );
			h2 = Math.imul( h2 ^ ch, 1597334677 );

		}

	}

	h1 = Math.imul( h1 ^ ( h1 >>> 16 ), 2246822507 );
	h1 ^= Math.imul( h2 ^ ( h2 >>> 13 ), 3266489909 );
	h2 = Math.imul( h2 ^ ( h2 >>> 16 ), 2246822507 );
	h2 ^= Math.imul( h1 ^ ( h1 >>> 13 ), 3266489909 );

	return 4294967296 * ( 2097151 & h2 ) + ( h1 >>> 0 );

}

const hashString = ( str ) => cyrb53( str );
const hashArray = ( array ) => cyrb53( array );
const hash$1 = ( ...params ) => cyrb53( params );

function getCacheKey$1( object, force = false ) {

	const values = [];

	if ( object.isNode === true ) {

		values.push( object.id );
		object = object.getSelf();

	}

	for ( const { property, childNode } of getNodeChildren( object ) ) {

		values.push( values, cyrb53( property.slice( 0, -4 ) ), childNode.getCacheKey( force ) );

	}

	return cyrb53( values );

}

function* getNodeChildren( node, toJSON = false ) {

	for ( const property in node ) {

		// Ignore private properties.
		if ( property.startsWith( '_' ) === true ) continue;

		const object = node[ property ];

		if ( Array.isArray( object ) === true ) {

			for ( let i = 0; i < object.length; i ++ ) {

				const child = object[ i ];

				if ( child && ( child.isNode === true || toJSON && typeof child.toJSON === 'function' ) ) {

					yield { property, index: i, childNode: child };

				}

			}

		} else if ( object && object.isNode === true ) {

			yield { property, childNode: object };

		} else if ( typeof object === 'object' ) {

			for ( const subProperty in object ) {

				const child = object[ subProperty ];

				if ( child && ( child.isNode === true || toJSON && typeof child.toJSON === 'function' ) ) {

					yield { property, index: subProperty, childNode: child };

				}

			}

		}

	}

}

const typeFromLength = /*@__PURE__*/ new Map( [
	[ 1, 'float' ],
	[ 2, 'vec2' ],
	[ 3, 'vec3' ],
	[ 4, 'vec4' ],
	[ 9, 'mat3' ],
	[ 16, 'mat4' ]
] );

function getTypeFromLength( length ) {

	return typeFromLength.get( length );

}

function getLengthFromType( type ) {

	if ( /float|int|uint/.test( type ) ) return 1;
	if ( /vec2/.test( type ) ) return 2;
	if ( /vec3/.test( type ) ) return 3;
	if ( /vec4/.test( type ) ) return 4;
	if ( /mat3/.test( type ) ) return 9;
	if ( /mat4/.test( type ) ) return 16;

	console.error( 'THREE.TSL: Unsupported type:', type );

}

function getValueType( value ) {

	if ( value === undefined || value === null ) return null;

	const typeOf = typeof value;

	if ( value.isNode === true ) {

		return 'node';

	} else if ( typeOf === 'number' ) {

		return 'float';

	} else if ( typeOf === 'boolean' ) {

		return 'bool';

	} else if ( typeOf === 'string' ) {

		return 'string';

	} else if ( typeOf === 'function' ) {

		return 'shader';

	} else if ( value.isVector2 === true ) {

		return 'vec2';

	} else if ( value.isVector3 === true ) {

		return 'vec3';

	} else if ( value.isVector4 === true ) {

		return 'vec4';

	} else if ( value.isMatrix3 === true ) {

		return 'mat3';

	} else if ( value.isMatrix4 === true ) {

		return 'mat4';

	} else if ( value.isColor === true ) {

		return 'color';

	} else if ( value instanceof ArrayBuffer ) {

		return 'ArrayBuffer';

	}

	return null;

}

function getValueFromType( type, ...params ) {

	const last4 = type ? type.slice( -4 ) : undefined;

	if ( params.length === 1 ) { // ensure same behaviour as in NodeBuilder.format()

		if ( last4 === 'vec2' ) params = [ params[ 0 ], params[ 0 ] ];
		else if ( last4 === 'vec3' ) params = [ params[ 0 ], params[ 0 ], params[ 0 ] ];
		else if ( last4 === 'vec4' ) params = [ params[ 0 ], params[ 0 ], params[ 0 ], params[ 0 ] ];

	}

	if ( type === 'color' ) {

		return new Color( ...params );

	} else if ( last4 === 'vec2' ) {

		return new Vector2( ...params );

	} else if ( last4 === 'vec3' ) {

		return new Vector3( ...params );

	} else if ( last4 === 'vec4' ) {

		return new Vector4( ...params );

	} else if ( last4 === 'mat3' ) {

		return new Matrix3( ...params );

	} else if ( last4 === 'mat4' ) {

		return new Matrix4( ...params );

	} else if ( type === 'bool' ) {

		return params[ 0 ] || false;

	} else if ( ( type === 'float' ) || ( type === 'int' ) || ( type === 'uint' ) ) {

		return params[ 0 ] || 0;

	} else if ( type === 'string' ) {

		return params[ 0 ] || '';

	} else if ( type === 'ArrayBuffer' ) {

		return base64ToArrayBuffer( params[ 0 ] );

	}

	return null;

}

function arrayBufferToBase64( arrayBuffer ) {

	let chars = '';

	const array = new Uint8Array( arrayBuffer );

	for ( let i = 0; i < array.length; i ++ ) {

		chars += String.fromCharCode( array[ i ] );

	}

	return btoa( chars );

}

function base64ToArrayBuffer( base64 ) {

	return Uint8Array.from( atob( base64 ), c => c.charCodeAt( 0 ) ).buffer;

}

const NodeShaderStage = {
	VERTEX: 'vertex',
	FRAGMENT: 'fragment'
};

const NodeUpdateType = {
	NONE: 'none',
	FRAME: 'frame',
	RENDER: 'render',
	OBJECT: 'object'
};

const NodeType = {
	BOOLEAN: 'bool',
	INTEGER: 'int',
	FLOAT: 'float',
	VECTOR2: 'vec2',
	VECTOR3: 'vec3',
	VECTOR4: 'vec4',
	MATRIX2: 'mat2',
	MATRIX3: 'mat3',
	MATRIX4: 'mat4'
};

const NodeAccess = {
	READ_ONLY: 'readOnly',
	WRITE_ONLY: 'writeOnly',
	READ_WRITE: 'readWrite',
};

const defaultShaderStages = [ 'fragment', 'vertex' ];
const defaultBuildStages = [ 'setup', 'analyze', 'generate' ];
const shaderStages = [ ...defaultShaderStages, 'compute' ];
const vectorComponents = [ 'x', 'y', 'z', 'w' ];

let _nodeId = 0;

class Node extends EventDispatcher {

	static get type() {

		return 'Node';

	}

	constructor( nodeType = null ) {

		super();

		this.nodeType = nodeType;

		this.updateType = NodeUpdateType.NONE;
		this.updateBeforeType = NodeUpdateType.NONE;
		this.updateAfterType = NodeUpdateType.NONE;

		this.uuid = MathUtils.generateUUID();

		this.version = 0;

		this._cacheKey = null;
		this._cacheKeyVersion = 0;

		this.global = false;

		this.isNode = true;

		Object.defineProperty( this, 'id', { value: _nodeId ++ } );

	}

	set needsUpdate( value ) {

		if ( value === true ) {

			this.version ++;

		}

	}

	get type() {

		return this.constructor.type;

	}

	onUpdate( callback, updateType ) {

		this.updateType = updateType;
		this.update = callback.bind( this.getSelf() );

		return this;

	}

	onFrameUpdate( callback ) {

		return this.onUpdate( callback, NodeUpdateType.FRAME );

	}

	onRenderUpdate( callback ) {

		return this.onUpdate( callback, NodeUpdateType.RENDER );

	}

	onObjectUpdate( callback ) {

		return this.onUpdate( callback, NodeUpdateType.OBJECT );

	}

	onReference( callback ) {

		this.updateReference = callback.bind( this.getSelf() );

		return this;

	}

	getSelf() {

		// Returns non-node object.

		return this.self || this;

	}

	updateReference( /*state*/ ) {

		return this;

	}

	isGlobal( /*builder*/ ) {

		return this.global;

	}

	* getChildren() {

		for ( const { childNode } of getNodeChildren( this ) ) {

			yield childNode;

		}

	}

	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

	}

	traverse( callback ) {

		callback( this );

		for ( const childNode of this.getChildren() ) {

			childNode.traverse( callback );

		}

	}

	getCacheKey( force = false ) {

		force = force || this.version !== this._cacheKeyVersion;

		if ( force === true || this._cacheKey === null ) {

			this._cacheKey = getCacheKey$1( this, force );
			this._cacheKeyVersion = this.version;

		}

		return this._cacheKey;

	}

	getScope() {

		return this;

	}

	getHash( /*builder*/ ) {

		return this.uuid;

	}

	getUpdateType() {

		return this.updateType;

	}

	getUpdateBeforeType() {

		return this.updateBeforeType;

	}

	getUpdateAfterType() {

		return this.updateAfterType;

	}

	getElementType( builder ) {

		const type = this.getNodeType( builder );
		const elementType = builder.getElementType( type );

		return elementType;

	}

	getNodeType( builder ) {

		const nodeProperties = builder.getNodeProperties( this );

		if ( nodeProperties.outputNode ) {

			return nodeProperties.outputNode.getNodeType( builder );

		}

		return this.nodeType;

	}

	getShared( builder ) {

		const hash = this.getHash( builder );
		const nodeFromHash = builder.getNodeFromHash( hash );

		return nodeFromHash || this;

	}

	setup( builder ) {

		const nodeProperties = builder.getNodeProperties( this );

		let index = 0;

		for ( const childNode of this.getChildren() ) {

			nodeProperties[ 'node' + index ++ ] = childNode;

		}

		// return a outputNode if exists
		return null;

	}

	analyze( builder ) {

		const usageCount = builder.increaseUsage( this );

		if ( usageCount === 1 ) {

			// node flow children

			const nodeProperties = builder.getNodeProperties( this );

			for ( const childNode of Object.values( nodeProperties ) ) {

				if ( childNode && childNode.isNode === true ) {

					childNode.build( builder );

				}

			}

		}

	}

	generate( builder, output ) {

		const { outputNode } = builder.getNodeProperties( this );

		if ( outputNode && outputNode.isNode === true ) {

			return outputNode.build( builder, output );

		}

	}

	updateBefore( /*frame*/ ) {

		console.warn( 'Abstract function.' );

	}

	updateAfter( /*frame*/ ) {

		console.warn( 'Abstract function.' );

	}

	update( /*frame*/ ) {

		console.warn( 'Abstract function.' );

	}

	build( builder, output = null ) {

		const refNode = this.getShared( builder );

		if ( this !== refNode ) {

			return refNode.build( builder, output );

		}

		builder.addNode( this );
		builder.addChain( this );

		/* Build stages expected results:
			- "setup"		-> Node
			- "analyze"		-> null
			- "generate"	-> String
		*/
		let result = null;

		const buildStage = builder.getBuildStage();

		if ( buildStage === 'setup' ) {

			this.updateReference( builder );

			const properties = builder.getNodeProperties( this );

			if ( properties.initialized !== true ) {

				const stackNodesBeforeSetup = builder.stack.nodes.length;

				properties.initialized = true;
				properties.outputNode = this.setup( builder );

				if ( properties.outputNode !== null && builder.stack.nodes.length !== stackNodesBeforeSetup ) ;

				for ( const childNode of Object.values( properties ) ) {

					if ( childNode && childNode.isNode === true ) {

						childNode.build( builder );

					}

				}

			}

		} else if ( buildStage === 'analyze' ) {

			this.analyze( builder );

		} else if ( buildStage === 'generate' ) {

			const isGenerateOnce = this.generate.length === 1;

			if ( isGenerateOnce ) {

				const type = this.getNodeType( builder );
				const nodeData = builder.getDataFromNode( this );

				result = nodeData.snippet;

				if ( result === undefined ) {

					result = this.generate( builder ) || '';

					nodeData.snippet = result;

				} else if ( nodeData.flowCodes !== undefined && builder.context.nodeBlock !== undefined ) {

					builder.addFlowCodeHierarchy( this, builder.context.nodeBlock );

				}

				result = builder.format( result, type, output );

			} else {

				result = this.generate( builder, output ) || '';

			}

		}

		builder.removeChain( this );
		builder.addSequentialNode( this );

		return result;

	}

	getSerializeChildren() {

		return getNodeChildren( this );

	}

	serialize( json ) {

		const nodeChildren = this.getSerializeChildren();

		const inputNodes = {};

		for ( const { property, index, childNode } of nodeChildren ) {

			if ( index !== undefined ) {

				if ( inputNodes[ property ] === undefined ) {

					inputNodes[ property ] = Number.isInteger( index ) ? [] : {};

				}

				inputNodes[ property ][ index ] = childNode.toJSON( json.meta ).uuid;

			} else {

				inputNodes[ property ] = childNode.toJSON( json.meta ).uuid;

			}

		}

		if ( Object.keys( inputNodes ).length > 0 ) {

			json.inputNodes = inputNodes;

		}

	}

	deserialize( json ) {

		if ( json.inputNodes !== undefined ) {

			const nodes = json.meta.nodes;

			for ( const property in json.inputNodes ) {

				if ( Array.isArray( json.inputNodes[ property ] ) ) {

					const inputArray = [];

					for ( const uuid of json.inputNodes[ property ] ) {

						inputArray.push( nodes[ uuid ] );

					}

					this[ property ] = inputArray;

				} else if ( typeof json.inputNodes[ property ] === 'object' ) {

					const inputObject = {};

					for ( const subProperty in json.inputNodes[ property ] ) {

						const uuid = json.inputNodes[ property ][ subProperty ];

						inputObject[ subProperty ] = nodes[ uuid ];

					}

					this[ property ] = inputObject;

				} else {

					const uuid = json.inputNodes[ property ];

					this[ property ] = nodes[ uuid ];

				}

			}

		}

	}

	toJSON( meta ) {

		const { uuid, type } = this;
		const isRoot = ( meta === undefined || typeof meta === 'string' );

		if ( isRoot ) {

			meta = {
				textures: {},
				images: {},
				nodes: {}
			};

		}

		// serialize

		let data = meta.nodes[ uuid ];

		if ( data === undefined ) {

			data = {
				uuid,
				type,
				meta,
				metadata: {
					version: 4.6,
					type: 'Node',
					generator: 'Node.toJSON'
				}
			};

			if ( isRoot !== true ) meta.nodes[ data.uuid ] = data;

			this.serialize( data );

			delete data.meta;

		}

		// TODO: Copied from Object3D.toJSON

		function extractFromCache( cache ) {

			const values = [];

			for ( const key in cache ) {

				const data = cache[ key ];
				delete data.metadata;
				values.push( data );

			}

			return values;

		}

		if ( isRoot ) {

			const textures = extractFromCache( meta.textures );
			const images = extractFromCache( meta.images );
			const nodes = extractFromCache( meta.nodes );

			if ( textures.length > 0 ) data.textures = textures;
			if ( images.length > 0 ) data.images = images;
			if ( nodes.length > 0 ) data.nodes = nodes;

		}

		return data;

	}

}

class ArrayElementNode extends Node {

	static get type() {

		return 'ArrayElementNode';

	} // @TODO: If extending from TempNode it breaks webgpu_compute

	constructor( node, indexNode ) {

		super();

		this.node = node;
		this.indexNode = indexNode;

		this.isArrayElementNode = true;

	}

	getNodeType( builder ) {

		return this.node.getElementType( builder );

	}

	generate( builder ) {

		const nodeSnippet = this.node.build( builder );
		const indexSnippet = this.indexNode.build( builder, 'uint' );

		return `${nodeSnippet}[ ${indexSnippet} ]`;

	}

}

class ConvertNode extends Node {

	static get type() {

		return 'ConvertNode';

	}

	constructor( node, convertTo ) {

		super();

		this.node = node;
		this.convertTo = convertTo;

	}

	getNodeType( builder ) {

		const requestType = this.node.getNodeType( builder );

		let convertTo = null;

		for ( const overloadingType of this.convertTo.split( '|' ) ) {

			if ( convertTo === null || builder.getTypeLength( requestType ) === builder.getTypeLength( overloadingType ) ) {

				convertTo = overloadingType;

			}

		}

		return convertTo;

	}

	serialize( data ) {

		super.serialize( data );

		data.convertTo = this.convertTo;

	}

	deserialize( data ) {

		super.deserialize( data );

		this.convertTo = data.convertTo;

	}

	generate( builder, output ) {

		const node = this.node;
		const type = this.getNodeType( builder );

		const snippet = node.build( builder, type );

		return builder.format( snippet, type, output );

	}

}

class TempNode extends Node {

	static get type() {

		return 'TempNode';

	}

	constructor( type ) {

		super( type );

		this.isTempNode = true;

	}

	hasDependencies( builder ) {

		return builder.getDataFromNode( this ).usageCount > 1;

	}

	build( builder, output ) {

		const buildStage = builder.getBuildStage();

		if ( buildStage === 'generate' ) {

			const type = builder.getVectorType( this.getNodeType( builder, output ) );
			const nodeData = builder.getDataFromNode( this );

			if ( nodeData.propertyName !== undefined ) {

				return builder.format( nodeData.propertyName, type, output );

			} else if ( type !== 'void' && output !== 'void' && this.hasDependencies( builder ) ) {

				const snippet = super.build( builder, type );

				const nodeVar = builder.getVarFromNode( this, null, type );
				const propertyName = builder.getPropertyName( nodeVar );

				builder.addLineFlowCode( `${propertyName} = ${snippet}`, this );

				nodeData.snippet = snippet;
				nodeData.propertyName = propertyName;

				return builder.format( nodeData.propertyName, type, output );

			}

		}

		return super.build( builder, output );

	}

}

class JoinNode extends TempNode {

	static get type() {

		return 'JoinNode';

	}

	constructor( nodes = [], nodeType = null ) {

		super( nodeType );

		this.nodes = nodes;

	}

	getNodeType( builder ) {

		if ( this.nodeType !== null ) {

			return builder.getVectorType( this.nodeType );

		}

		return builder.getTypeFromLength( this.nodes.reduce( ( count, cur ) => count + builder.getTypeLength( cur.getNodeType( builder ) ), 0 ) );

	}

	generate( builder, output ) {

		const type = this.getNodeType( builder );
		const nodes = this.nodes;

		const primitiveType = builder.getComponentType( type );

		const snippetValues = [];

		for ( const input of nodes ) {

			let inputSnippet = input.build( builder );

			const inputPrimitiveType = builder.getComponentType( input.getNodeType( builder ) );

			if ( inputPrimitiveType !== primitiveType ) {

				inputSnippet = builder.format( inputSnippet, inputPrimitiveType, primitiveType );

			}

			snippetValues.push( inputSnippet );

		}

		const snippet = `${ builder.getType( type ) }( ${ snippetValues.join( ', ' ) } )`;

		return builder.format( snippet, type, output );

	}

}

const stringVectorComponents = vectorComponents.join( '' );

class SplitNode extends Node {

	static get type() {

		return 'SplitNode';

	}

	constructor( node, components = 'x' ) {

		super();

		this.node = node;
		this.components = components;

		this.isSplitNode = true;

	}

	getVectorLength() {

		let vectorLength = this.components.length;

		for ( const c of this.components ) {

			vectorLength = Math.max( vectorComponents.indexOf( c ) + 1, vectorLength );

		}

		return vectorLength;

	}

	getComponentType( builder ) {

		return builder.getComponentType( this.node.getNodeType( builder ) );

	}

	getNodeType( builder ) {

		return builder.getTypeFromLength( this.components.length, this.getComponentType( builder ) );

	}

	generate( builder, output ) {

		const node = this.node;
		const nodeTypeLength = builder.getTypeLength( node.getNodeType( builder ) );

		let snippet = null;

		if ( nodeTypeLength > 1 ) {

			let type = null;

			const componentsLength = this.getVectorLength();

			if ( componentsLength >= nodeTypeLength ) {

				// needed expand the input node

				type = builder.getTypeFromLength( this.getVectorLength(), this.getComponentType( builder ) );

			}

			const nodeSnippet = node.build( builder, type );

			if ( this.components.length === nodeTypeLength && this.components === stringVectorComponents.slice( 0, this.components.length ) ) {

				// unnecessary swizzle

				snippet = builder.format( nodeSnippet, type, output );

			} else {

				snippet = builder.format( `${nodeSnippet}.${this.components}`, this.getNodeType( builder ), output );

			}

		} else {

			// ignore .components if .node returns float/integer

			snippet = node.build( builder, output );

		}

		return snippet;

	}

	serialize( data ) {

		super.serialize( data );

		data.components = this.components;

	}

	deserialize( data ) {

		super.deserialize( data );

		this.components = data.components;

	}

}

class SetNode extends TempNode {

	static get type() {

		return 'SetNode';

	}

	constructor( sourceNode, components, targetNode ) {

		super();

		this.sourceNode = sourceNode;
		this.components = components;
		this.targetNode = targetNode;

	}

	getNodeType( builder ) {

		return this.sourceNode.getNodeType( builder );

	}

	generate( builder ) {

		const { sourceNode, components, targetNode } = this;

		const sourceType = this.getNodeType( builder );
		const targetType = builder.getTypeFromLength( components.length, targetNode.getNodeType( builder ) );

		const targetSnippet = targetNode.build( builder, targetType );
		const sourceSnippet = sourceNode.build( builder, sourceType );

		const length = builder.getTypeLength( sourceType );
		const snippetValues = [];

		for ( let i = 0; i < length; i ++ ) {

			const component = vectorComponents[ i ];

			if ( component === components[ 0 ] ) {

				snippetValues.push( targetSnippet );

				i += components.length - 1;

			} else {

				snippetValues.push( sourceSnippet + '.' + component );

			}

		}

		return `${ builder.getType( sourceType ) }( ${ snippetValues.join( ', ' ) } )`;

	}

}

class FlipNode extends TempNode {

	static get type() {

		return 'FlipNode';

	}

	constructor( sourceNode, components ) {

		super();

		this.sourceNode = sourceNode;
		this.components = components;

	}

	getNodeType( builder ) {

		return this.sourceNode.getNodeType( builder );

	}

	generate( builder ) {

		const { components, sourceNode } = this;

		const sourceType = this.getNodeType( builder );
		const sourceSnippet = sourceNode.build( builder );

		const sourceCache = builder.getVarFromNode( this );
		const sourceProperty = builder.getPropertyName( sourceCache );

		builder.addLineFlowCode( sourceProperty + ' = ' + sourceSnippet, this );

		const length = builder.getTypeLength( sourceType );
		const snippetValues = [];

		let componentIndex = 0;

		for ( let i = 0; i < length; i ++ ) {

			const component = vectorComponents[ i ];

			if ( component === components[ componentIndex ] ) {

				snippetValues.push( '1.0 - ' + ( sourceProperty + '.' + component ) );

				componentIndex ++;

			} else {

				snippetValues.push( sourceProperty + '.' + component );

			}

		}

		return `${ builder.getType( sourceType ) }( ${ snippetValues.join( ', ' ) } )`;

	}

}

class InputNode extends Node {

	static get type() {

		return 'InputNode';

	}

	constructor( value, nodeType = null ) {

		super( nodeType );

		this.isInputNode = true;

		this.value = value;
		this.precision = null;

	}

	getNodeType( /*builder*/ ) {

		if ( this.nodeType === null ) {

			return getValueType( this.value );

		}

		return this.nodeType;

	}

	getInputType( builder ) {

		return this.getNodeType( builder );

	}

	setPrecision( precision ) {

		this.precision = precision;

		return this;

	}

	serialize( data ) {

		super.serialize( data );

		data.value = this.value;

		if ( this.value && this.value.toArray ) data.value = this.value.toArray();

		data.valueType = getValueType( this.value );
		data.nodeType = this.nodeType;

		if ( data.valueType === 'ArrayBuffer' ) data.value = arrayBufferToBase64( data.value );

		data.precision = this.precision;

	}

	deserialize( data ) {

		super.deserialize( data );

		this.nodeType = data.nodeType;
		this.value = Array.isArray( data.value ) ? getValueFromType( data.valueType, ...data.value ) : data.value;

		this.precision = data.precision || null;

		if ( this.value && this.value.fromArray ) this.value = this.value.fromArray( data.value );

	}

	generate( /*builder, output*/ ) {

		console.warn( 'Abstract function.' );

	}

}

class ConstNode extends InputNode {

	static get type() {

		return 'ConstNode';

	}

	constructor( value, nodeType = null ) {

		super( value, nodeType );

		this.isConstNode = true;

	}

	generateConst( builder ) {

		return builder.generateConst( this.getNodeType( builder ), this.value );

	}

	generate( builder, output ) {

		const type = this.getNodeType( builder );

		return builder.format( this.generateConst( builder ), type, output );

	}

}

//

let currentStack = null;

const NodeElements = new Map();

function addMethodChaining( name, nodeElement ) {

	if ( NodeElements.has( name ) ) {

		console.warn( `Redefinition of method chaining ${ name }` );
		return;

	}

	if ( typeof nodeElement !== 'function' ) throw new Error( `Node element ${ name } is not a function` );

	NodeElements.set( name, nodeElement );

}

const parseSwizzle = ( props ) => props.replace( /r|s/g, 'x' ).replace( /g|t/g, 'y' ).replace( /b|p/g, 'z' ).replace( /a|q/g, 'w' );
const parseSwizzleAndSort = ( props ) => parseSwizzle( props ).split( '' ).sort().join( '' );

const shaderNodeHandler = {

	setup( NodeClosure, params ) {

		const inputs = params.shift();

		return NodeClosure( nodeObjects( inputs ), ...params );

	},

	get( node, prop, nodeObj ) {

		if ( typeof prop === 'string' && node[ prop ] === undefined ) {

			if ( node.isStackNode !== true && prop === 'assign' ) {

				return ( ...params ) => {

					currentStack.assign( nodeObj, ...params );

					return nodeObj;

				};

			} else if ( NodeElements.has( prop ) ) {

				const nodeElement = NodeElements.get( prop );

				return node.isStackNode ? ( ...params ) => nodeObj.add( nodeElement( ...params ) ) : ( ...params ) => nodeElement( nodeObj, ...params );

			} else if ( prop === 'self' ) {

				return node;

			} else if ( prop.endsWith( 'Assign' ) && NodeElements.has( prop.slice( 0, prop.length - 'Assign'.length ) ) ) {

				const nodeElement = NodeElements.get( prop.slice( 0, prop.length - 'Assign'.length ) );

				return node.isStackNode ? ( ...params ) => nodeObj.assign( params[ 0 ], nodeElement( ...params ) ) : ( ...params ) => nodeObj.assign( nodeElement( nodeObj, ...params ) );

			} else if ( /^[xyzwrgbastpq]{1,4}$/.test( prop ) === true ) {

				// accessing properties ( swizzle )

				prop = parseSwizzle( prop );

				return nodeObject( new SplitNode( nodeObj, prop ) );

			} else if ( /^set[XYZWRGBASTPQ]{1,4}$/.test( prop ) === true ) {

				// set properties ( swizzle ) and sort to xyzw sequence

				prop = parseSwizzleAndSort( prop.slice( 3 ).toLowerCase() );

				return ( value ) => nodeObject( new SetNode( node, prop, value ) );

			} else if ( /^flip[XYZWRGBASTPQ]{1,4}$/.test( prop ) === true ) {

				// set properties ( swizzle ) and sort to xyzw sequence

				prop = parseSwizzleAndSort( prop.slice( 4 ).toLowerCase() );

				return () => nodeObject( new FlipNode( nodeObject( node ), prop ) );

			} else if ( prop === 'width' || prop === 'height' || prop === 'depth' ) {

				// accessing property

				if ( prop === 'width' ) prop = 'x';
				else if ( prop === 'height' ) prop = 'y';
				else if ( prop === 'depth' ) prop = 'z';

				return nodeObject( new SplitNode( node, prop ) );

			} else if ( /^\d+$/.test( prop ) === true ) {

				// accessing array

				return nodeObject( new ArrayElementNode( nodeObj, new ConstNode( Number( prop ), 'uint' ) ) );

			}

		}

		return Reflect.get( node, prop, nodeObj );

	},

	set( node, prop, value, nodeObj ) {

		if ( typeof prop === 'string' && node[ prop ] === undefined ) {

			// setting properties

			if ( /^[xyzwrgbastpq]{1,4}$/.test( prop ) === true || prop === 'width' || prop === 'height' || prop === 'depth' || /^\d+$/.test( prop ) === true ) {

				nodeObj[ prop ].assign( value );

				return true;

			}

		}

		return Reflect.set( node, prop, value, nodeObj );

	}

};

const nodeObjectsCacheMap = new WeakMap();
const nodeBuilderFunctionsCacheMap = new WeakMap();

const ShaderNodeObject = function ( obj, altType = null ) {

	const type = getValueType( obj );

	if ( type === 'node' ) {

		let nodeObject = nodeObjectsCacheMap.get( obj );

		if ( nodeObject === undefined ) {

			nodeObject = new Proxy( obj, shaderNodeHandler );

			nodeObjectsCacheMap.set( obj, nodeObject );
			nodeObjectsCacheMap.set( nodeObject, nodeObject );

		}

		return nodeObject;

	} else if ( ( altType === null && ( type === 'float' || type === 'boolean' ) ) || ( type && type !== 'shader' && type !== 'string' ) ) {

		return nodeObject( getConstNode( obj, altType ) );

	} else if ( type === 'shader' ) {

		return Fn$1( obj );

	}

	return obj;

};

const ShaderNodeObjects = function ( objects, altType = null ) {

	for ( const name in objects ) {

		objects[ name ] = nodeObject( objects[ name ], altType );

	}

	return objects;

};

const ShaderNodeArray = function ( array, altType = null ) {

	const len = array.length;

	for ( let i = 0; i < len; i ++ ) {

		array[ i ] = nodeObject( array[ i ], altType );

	}

	return array;

};

const ShaderNodeProxy = function ( NodeClass, scope = null, factor = null, settings = null ) {

	const assignNode = ( node ) => nodeObject( settings !== null ? Object.assign( node, settings ) : node );

	if ( scope === null ) {

		return ( ...params ) => {

			return assignNode( new NodeClass( ...nodeArray( params ) ) );

		};

	} else if ( factor !== null ) {

		factor = nodeObject( factor );

		return ( ...params ) => {

			return assignNode( new NodeClass( scope, ...nodeArray( params ), factor ) );

		};

	} else {

		return ( ...params ) => {

			return assignNode( new NodeClass( scope, ...nodeArray( params ) ) );

		};

	}

};

const ShaderNodeImmutable = function ( NodeClass, ...params ) {

	return nodeObject( new NodeClass( ...nodeArray( params ) ) );

};

class ShaderCallNodeInternal extends Node {

	constructor( shaderNode, inputNodes ) {

		super();

		this.shaderNode = shaderNode;
		this.inputNodes = inputNodes;

	}

	getNodeType( builder ) {

		return this.shaderNode.nodeType || this.getOutputNode( builder ).getNodeType( builder );

	}

	call( builder ) {

		const { shaderNode, inputNodes } = this;

		const properties = builder.getNodeProperties( shaderNode );
		if ( properties.onceOutput ) return properties.onceOutput;

		//

		let result = null;

		if ( shaderNode.layout ) {

			let functionNodesCacheMap = nodeBuilderFunctionsCacheMap.get( builder.constructor );

			if ( functionNodesCacheMap === undefined ) {

				functionNodesCacheMap = new WeakMap();

				nodeBuilderFunctionsCacheMap.set( builder.constructor, functionNodesCacheMap );

			}

			let functionNode = functionNodesCacheMap.get( shaderNode );

			if ( functionNode === undefined ) {

				functionNode = nodeObject( builder.buildFunctionNode( shaderNode ) );

				functionNodesCacheMap.set( shaderNode, functionNode );

			}

			if ( builder.currentFunctionNode !== null ) {

				builder.currentFunctionNode.includes.push( functionNode );

			}

			result = nodeObject( functionNode.call( inputNodes ) );

		} else {

			const jsFunc = shaderNode.jsFunc;
			const outputNode = inputNodes !== null ? jsFunc( inputNodes, builder ) : jsFunc( builder );

			result = nodeObject( outputNode );

		}

		if ( shaderNode.once ) {

			properties.onceOutput = result;

		}

		return result;

	}

	getOutputNode( builder ) {

		const properties = builder.getNodeProperties( this );

		if ( properties.outputNode === null ) {

			properties.outputNode = this.setupOutput( builder );

		}

		return properties.outputNode;

	}

	setup( builder ) {

		return this.getOutputNode( builder );

	}

	setupOutput( builder ) {

		builder.addStack();

		builder.stack.outputNode = this.call( builder );

		return builder.removeStack();

	}

	generate( builder, output ) {

		const outputNode = this.getOutputNode( builder );

		return outputNode.build( builder, output );

	}

}

class ShaderNodeInternal extends Node {

	constructor( jsFunc, nodeType ) {

		super( nodeType );

		this.jsFunc = jsFunc;
		this.layout = null;

		this.global = true;

		this.once = false;

	}

	setLayout( layout ) {

		this.layout = layout;

		return this;

	}

	call( inputs = null ) {

		nodeObjects( inputs );

		return nodeObject( new ShaderCallNodeInternal( this, inputs ) );

	}

	setup() {

		return this.call();

	}

}

const bools = [ false, true ];
const uints = [ 0, 1, 2, 3 ];
const ints = [ -1, -2 ];
const floats = [ 0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / ( Math.PI * 2 ), Math.PI / 2 ];

const boolsCacheMap = new Map();
for ( const bool of bools ) boolsCacheMap.set( bool, new ConstNode( bool ) );

const uintsCacheMap = new Map();
for ( const uint of uints ) uintsCacheMap.set( uint, new ConstNode( uint, 'uint' ) );

const intsCacheMap = new Map( [ ...uintsCacheMap ].map( el => new ConstNode( el.value, 'int' ) ) );
for ( const int of ints ) intsCacheMap.set( int, new ConstNode( int, 'int' ) );

const floatsCacheMap = new Map( [ ...intsCacheMap ].map( el => new ConstNode( el.value ) ) );
for ( const float of floats ) floatsCacheMap.set( float, new ConstNode( float ) );
for ( const float of floats ) floatsCacheMap.set( - float, new ConstNode( - float ) );

const cacheMaps = { bool: boolsCacheMap, uint: uintsCacheMap, ints: intsCacheMap, float: floatsCacheMap };

const constNodesCacheMap = new Map( [ ...boolsCacheMap, ...floatsCacheMap ] );

const getConstNode = ( value, type ) => {

	if ( constNodesCacheMap.has( value ) ) {

		return constNodesCacheMap.get( value );

	} else if ( value.isNode === true ) {

		return value;

	} else {

		return new ConstNode( value, type );

	}

};

const safeGetNodeType = ( node ) => {

	try {

		return node.getNodeType();

	} catch ( _ ) {

		return undefined;

	}

};

const ConvertType = function ( type, cacheMap = null ) {

	return ( ...params ) => {

		if ( params.length === 0 || ( ! [ 'bool', 'float', 'int', 'uint' ].includes( type ) && params.every( param => typeof param !== 'object' ) ) ) {

			params = [ getValueFromType( type, ...params ) ];

		}

		if ( params.length === 1 && cacheMap !== null && cacheMap.has( params[ 0 ] ) ) {

			return nodeObject( cacheMap.get( params[ 0 ] ) );

		}

		if ( params.length === 1 ) {

			const node = getConstNode( params[ 0 ], type );
			if ( safeGetNodeType( node ) === type ) return nodeObject( node );
			return nodeObject( new ConvertNode( node, type ) );

		}

		const nodes = params.map( param => getConstNode( param ) );
		return nodeObject( new JoinNode( nodes, type ) );

	};

};

// exports

const defined = ( v ) => typeof v === 'object' && v !== null ? v.value : v; // TODO: remove boolean conversion and defined function

// utils

const getConstNodeType = ( value ) => ( value !== undefined && value !== null ) ? ( value.nodeType || value.convertTo || ( typeof value === 'string' ? value : null ) ) : null;

// shader node base

function ShaderNode( jsFunc, nodeType ) {

	return new Proxy( new ShaderNodeInternal( jsFunc, nodeType ), shaderNodeHandler );

}

const nodeObject = ( val, altType = null ) => /* new */ ShaderNodeObject( val, altType );
const nodeObjects = ( val, altType = null ) => new ShaderNodeObjects( val, altType );
const nodeArray = ( val, altType = null ) => new ShaderNodeArray( val, altType );
const nodeProxy = ( ...params ) => new ShaderNodeProxy( ...params );
const nodeImmutable = ( ...params ) => new ShaderNodeImmutable( ...params );

const Fn$1 = ( jsFunc, nodeType ) => {

	const shaderNode = new ShaderNode( jsFunc, nodeType );

	const fn = ( ...params ) => {

		let inputs;

		nodeObjects( params );

		if ( params[ 0 ] && params[ 0 ].isNode ) {

			inputs = [ ...params ];

		} else {

			inputs = params[ 0 ];

		}

		return shaderNode.call( inputs );

	};

	fn.shaderNode = shaderNode;

	fn.setLayout = ( layout ) => {

		shaderNode.setLayout( layout );

		return fn;

	};

	fn.once = () => {

		shaderNode.once = true;

		return fn;

	};

	return fn;

};

const tslFn = ( ...params ) => { // @deprecated, r168

	console.warn( 'TSL.ShaderNode: tslFn() has been renamed to Fn().' );
	return Fn$1( ...params );

};

//

addMethodChaining( 'toGlobal', ( node ) => {

	node.global = true;

	return node;

} );

//

const setCurrentStack = ( stack ) => {

	currentStack = stack;

};

const getCurrentStack = () => currentStack;

const If = ( ...params ) => currentStack.If( ...params );

function append( node ) {

	if ( currentStack ) currentStack.add( node );

	return node;

}

addMethodChaining( 'append', append );

// types

const color$1 = new ConvertType( 'color' );

const float$1 = new ConvertType( 'float', cacheMaps.float );
const int = new ConvertType( 'int', cacheMaps.ints );
const uint = new ConvertType( 'uint', cacheMaps.uint );
const bool = new ConvertType( 'bool', cacheMaps.bool );

const vec2$1 = new ConvertType( 'vec2' );
const ivec2 = new ConvertType( 'ivec2' );
const uvec2 = new ConvertType( 'uvec2' );
const bvec2 = new ConvertType( 'bvec2' );

const vec3$1 = new ConvertType( 'vec3' );
const ivec3 = new ConvertType( 'ivec3' );
const uvec3 = new ConvertType( 'uvec3' );
const bvec3 = new ConvertType( 'bvec3' );

const vec4$1 = new ConvertType( 'vec4' );
const ivec4 = new ConvertType( 'ivec4' );
const uvec4 = new ConvertType( 'uvec4' );
const bvec4 = new ConvertType( 'bvec4' );

const mat2 = new ConvertType( 'mat2' );
const mat3 = new ConvertType( 'mat3' );
const mat4 = new ConvertType( 'mat4' );

const string = ( value = '' ) => nodeObject( new ConstNode( value, 'string' ) );
const arrayBuffer = ( value ) => nodeObject( new ConstNode( value, 'ArrayBuffer' ) );

addMethodChaining( 'toColor', color$1 );
addMethodChaining( 'toFloat', float$1 );
addMethodChaining( 'toInt', int );
addMethodChaining( 'toUint', uint );
addMethodChaining( 'toBool', bool );
addMethodChaining( 'toVec2', vec2$1 );
addMethodChaining( 'toIVec2', ivec2 );
addMethodChaining( 'toUVec2', uvec2 );
addMethodChaining( 'toBVec2', bvec2 );
addMethodChaining( 'toVec3', vec3$1 );
addMethodChaining( 'toIVec3', ivec3 );
addMethodChaining( 'toUVec3', uvec3 );
addMethodChaining( 'toBVec3', bvec3 );
addMethodChaining( 'toVec4', vec4$1 );
addMethodChaining( 'toIVec4', ivec4 );
addMethodChaining( 'toUVec4', uvec4 );
addMethodChaining( 'toBVec4', bvec4 );
addMethodChaining( 'toMat2', mat2 );
addMethodChaining( 'toMat3', mat3 );
addMethodChaining( 'toMat4', mat4 );

// basic nodes

const element = /*@__PURE__*/ nodeProxy( ArrayElementNode );
const convert = ( node, types ) => nodeObject( new ConvertNode( nodeObject( node ), types ) );
const split = ( node, channels ) => nodeObject( new SplitNode( nodeObject( node ), channels ) );

addMethodChaining( 'element', element );
addMethodChaining( 'convert', convert );

class UniformGroupNode extends Node {

	static get type() {

		return 'UniformGroupNode';

	}

	constructor( name, shared = false, order = 1 ) {

		super( 'string' );

		this.name = name;
		this.version = 0;

		this.shared = shared;
		this.order = order;
		this.isUniformGroup = true;

	}

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

	serialize( data ) {

		super.serialize( data );

		data.name = this.name;
		data.version = this.version;
		data.shared = this.shared;

	}

	deserialize( data ) {

		super.deserialize( data );

		this.name = data.name;
		this.version = data.version;
		this.shared = data.shared;

	}

}

const uniformGroup = ( name ) => new UniformGroupNode( name );
const sharedUniformGroup = ( name, order = 0 ) => new UniformGroupNode( name, true, order );

const frameGroup = /*@__PURE__*/ sharedUniformGroup( 'frame' );
const renderGroup = /*@__PURE__*/ sharedUniformGroup( 'render' );
const objectGroup = /*@__PURE__*/ uniformGroup( 'object' );

class UniformNode extends InputNode {

	static get type() {

		return 'UniformNode';

	}

	constructor( value, nodeType = null ) {

		super( value, nodeType );

		this.isUniformNode = true;

		this.name = '';
		this.groupNode = objectGroup;

	}

	label( name ) {

		this.name = name;

		return this;

	}

	setGroup( group ) {

		this.groupNode = group;

		return this;

	}

	getGroup() {

		return this.groupNode;

	}

	getUniformHash( builder ) {

		return this.getHash( builder );

	}

	onUpdate( callback, updateType ) {

		const self = this.getSelf();

		callback = callback.bind( self );

		return super.onUpdate( ( frame ) => {

			const value = callback( frame, self );

			if ( value !== undefined ) {

				this.value = value;

			}

	 	}, updateType );

	}

	generate( builder, output ) {

		const type = this.getNodeType( builder );

		const hash = this.getUniformHash( builder );

		let sharedNode = builder.getNodeFromHash( hash );

		if ( sharedNode === undefined ) {

			builder.setHashNode( this, hash );

			sharedNode = this;

		}

		const sharedNodeType = sharedNode.getInputType( builder );

		const nodeUniform = builder.getUniformFromNode( sharedNode, sharedNodeType, builder.shaderStage, this.name || builder.context.label );
		const propertyName = builder.getPropertyName( nodeUniform );

		if ( builder.context.label !== undefined ) delete builder.context.label;

		return builder.format( propertyName, type, output );

	}

}

const uniform$1 = ( arg1, arg2 ) => {

	const nodeType = getConstNodeType( arg2 || arg1 );

	// @TODO: get ConstNode from .traverse() in the future
	const value = ( arg1 && arg1.isNode === true ) ? ( arg1.node && arg1.node.value ) || arg1.value : arg1;

	return nodeObject( new UniformNode( value, nodeType ) );

};

class PropertyNode extends Node {

	static get type() {

		return 'PropertyNode';

	}

	constructor( nodeType, name = null, varying = false ) {

		super( nodeType );

		this.name = name;
		this.varying = varying;

		this.isPropertyNode = true;

	}

	getHash( builder ) {

		return this.name || super.getHash( builder );

	}

	isGlobal( /*builder*/ ) {

		return true;

	}

	generate( builder ) {

		let nodeVar;

		if ( this.varying === true ) {

			nodeVar = builder.getVaryingFromNode( this, this.name );
			nodeVar.needsInterpolation = true;

		} else {

			nodeVar = builder.getVarFromNode( this, this.name );

		}

		return builder.getPropertyName( nodeVar );

	}

}

const property = ( type, name ) => nodeObject( new PropertyNode( type, name ) );
const varyingProperty = ( type, name ) => nodeObject( new PropertyNode( type, name, true ) );

const diffuseColor = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec4', 'DiffuseColor' );
const emissive = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec3', 'EmissiveColor' );
const roughness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Roughness' );
const metalness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Metalness' );
const clearcoat = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Clearcoat' );
const clearcoatRoughness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'ClearcoatRoughness' );
const sheen = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec3', 'Sheen' );
const sheenRoughness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'SheenRoughness' );
const iridescence = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Iridescence' );
const iridescenceIOR = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'IridescenceIOR' );
const iridescenceThickness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'IridescenceThickness' );
const alphaT = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'AlphaT' );
const anisotropy = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Anisotropy' );
const anisotropyT = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec3', 'AnisotropyT' );
const anisotropyB = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec3', 'AnisotropyB' );
const specularColor = /*@__PURE__*/ nodeImmutable( PropertyNode, 'color', 'SpecularColor' );
const specularF90 = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'SpecularF90' );
const shininess = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Shininess' );
const output = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec4', 'Output' );
const dashSize = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'dashSize' );
const gapSize = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'gapSize' );
const pointWidth = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'pointWidth' );
const ior = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'IOR' );
const transmission = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Transmission' );
const thickness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Thickness' );
const attenuationDistance = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'AttenuationDistance' );
const attenuationColor = /*@__PURE__*/ nodeImmutable( PropertyNode, 'color', 'AttenuationColor' );
const dispersion = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Dispersion' );

class AssignNode extends TempNode {

	static get type() {

		return 'AssignNode';

	}

	constructor( targetNode, sourceNode ) {

		super();

		this.targetNode = targetNode;
		this.sourceNode = sourceNode;

	}

	hasDependencies() {

		return false;

	}

	getNodeType( builder, output ) {

		return output !== 'void' ? this.targetNode.getNodeType( builder ) : 'void';

	}

	needsSplitAssign( builder ) {

		const { targetNode } = this;

		if ( builder.isAvailable( 'swizzleAssign' ) === false && targetNode.isSplitNode && targetNode.components.length > 1 ) {

			const targetLength = builder.getTypeLength( targetNode.node.getNodeType( builder ) );
			const assignDiferentVector = vectorComponents.join( '' ).slice( 0, targetLength ) !== targetNode.components;

			return assignDiferentVector;

		}

		return false;

	}

	generate( builder, output ) {

		const { targetNode, sourceNode } = this;

		const needsSplitAssign = this.needsSplitAssign( builder );

		const targetType = targetNode.getNodeType( builder );

		const target = targetNode.context( { assign: true } ).build( builder );
		const source = sourceNode.build( builder, targetType );

		const sourceType = sourceNode.getNodeType( builder );

		const nodeData = builder.getDataFromNode( this );

		//

		let snippet;

		if ( nodeData.initialized === true ) {

			if ( output !== 'void' ) {

				snippet = target;

			}

		} else if ( needsSplitAssign ) {

			const sourceVar = builder.getVarFromNode( this, null, targetType );
			const sourceProperty = builder.getPropertyName( sourceVar );

			builder.addLineFlowCode( `${ sourceProperty } = ${ source }`, this );

			const targetRoot = targetNode.node.context( { assign: true } ).build( builder );

			for ( let i = 0; i < targetNode.components.length; i ++ ) {

				const component = targetNode.components[ i ];

				builder.addLineFlowCode( `${ targetRoot }.${ component } = ${ sourceProperty }[ ${ i } ]`, this );

			}

			if ( output !== 'void' ) {

				snippet = target;

			}

		} else {

			snippet = `${ target } = ${ source }`;

			if ( output === 'void' || sourceType === 'void' ) {

				builder.addLineFlowCode( snippet, this );

				if ( output !== 'void' ) {

					snippet = target;

				}

			}

		}

		nodeData.initialized = true;

		return builder.format( snippet, targetType, output );

	}

}

const assign = /*@__PURE__*/ nodeProxy( AssignNode );

addMethodChaining( 'assign', assign );

class FunctionCallNode extends TempNode {

	static get type() {

		return 'FunctionCallNode';

	}

	constructor( functionNode = null, parameters = {} ) {

		super();

		this.functionNode = functionNode;
		this.parameters = parameters;

	}

	setParameters( parameters ) {

		this.parameters = parameters;

		return this;

	}

	getParameters() {

		return this.parameters;

	}

	getNodeType( builder ) {

		return this.functionNode.getNodeType( builder );

	}

	generate( builder ) {

		const params = [];

		const functionNode = this.functionNode;

		const inputs = functionNode.getInputs( builder );
		const parameters = this.parameters;

		const generateInput = ( node, inputNode ) => {

			const type = inputNode.type;
			const pointer = type === 'pointer';

			let output;

			if ( pointer ) output = '&' + node.build( builder );
			else output = node.build( builder, type );

			return output;

		};

		if ( Array.isArray( parameters ) ) {

			for ( let i = 0; i < parameters.length; i ++ ) {

				params.push( generateInput( parameters[ i ], inputs[ i ] ) );

			}

		} else {

			for ( const inputNode of inputs ) {

				const node = parameters[ inputNode.name ];

				if ( node !== undefined ) {

					params.push( generateInput( node, inputNode ) );

				} else {

					throw new Error( `FunctionCallNode: Input '${inputNode.name}' not found in FunctionNode.` );

				}

			}

		}

		const functionName = functionNode.build( builder, 'property' );

		return `${functionName}( ${params.join( ', ' )} )`;

	}

}

const call = ( func, ...params ) => {

	params = params.length > 1 || ( params[ 0 ] && params[ 0 ].isNode === true ) ? nodeArray( params ) : nodeObjects( params[ 0 ] );

	return nodeObject( new FunctionCallNode( nodeObject( func ), params ) );

};

addMethodChaining( 'call', call );

class OperatorNode extends TempNode {

	static get type() {

		return 'OperatorNode';

	}

	constructor( op, aNode, bNode, ...params ) {

		super();

		if ( params.length > 0 ) {

			let finalOp = new OperatorNode( op, aNode, bNode );

			for ( let i = 0; i < params.length - 1; i ++ ) {

				finalOp = new OperatorNode( op, finalOp, params[ i ] );

			}

			aNode = finalOp;
			bNode = params[ params.length - 1 ];

		}

		this.op = op;
		this.aNode = aNode;
		this.bNode = bNode;

	}

	getNodeType( builder, output ) {

		const op = this.op;

		const aNode = this.aNode;
		const bNode = this.bNode;

		const typeA = aNode.getNodeType( builder );
		const typeB = typeof bNode !== 'undefined' ? bNode.getNodeType( builder ) : null;

		if ( typeA === 'void' || typeB === 'void' ) {

			return 'void';

		} else if ( op === '%' ) {

			return typeA;

		} else if ( op === '~' || op === '&' || op === '|' || op === '^' || op === '>>' || op === '<<' ) {

			return builder.getIntegerType( typeA );

		} else if ( op === '!' || op === '==' || op === '&&' || op === '||' || op === '^^' ) {

			return 'bool';

		} else if ( op === '<' || op === '>' || op === '<=' || op === '>=' ) {

			const typeLength = output ? builder.getTypeLength( output ) : Math.max( builder.getTypeLength( typeA ), builder.getTypeLength( typeB ) );

			return typeLength > 1 ? `bvec${ typeLength }` : 'bool';

		} else {

			if ( typeA === 'float' && builder.isMatrix( typeB ) ) {

				return typeB;

			} else if ( builder.isMatrix( typeA ) && builder.isVector( typeB ) ) {

				// matrix x vector

				return builder.getVectorFromMatrix( typeA );

			} else if ( builder.isVector( typeA ) && builder.isMatrix( typeB ) ) {

				// vector x matrix

				return builder.getVectorFromMatrix( typeB );

			} else if ( builder.getTypeLength( typeB ) > builder.getTypeLength( typeA ) ) {

				// anytype x anytype: use the greater length vector

				return typeB;

			}

			return typeA;

		}

	}

	generate( builder, output ) {

		const op = this.op;

		const aNode = this.aNode;
		const bNode = this.bNode;

		const type = this.getNodeType( builder, output );

		let typeA = null;
		let typeB = null;

		if ( type !== 'void' ) {

			typeA = aNode.getNodeType( builder );
			typeB = typeof bNode !== 'undefined' ? bNode.getNodeType( builder ) : null;

			if ( op === '<' || op === '>' || op === '<=' || op === '>=' || op === '==' ) {

				if ( builder.isVector( typeA ) ) {

					typeB = typeA;

				} else if ( typeA !== typeB ) {

					typeA = typeB = 'float';

				}

			} else if ( op === '>>' || op === '<<' ) {

				typeA = type;
				typeB = builder.changeComponentType( typeB, 'uint' );

			} else if ( builder.isMatrix( typeA ) && builder.isVector( typeB ) ) {

				// matrix x vector

				typeB = builder.getVectorFromMatrix( typeA );

			} else if ( builder.isVector( typeA ) && builder.isMatrix( typeB ) ) {

				// vector x matrix

				typeA = builder.getVectorFromMatrix( typeB );

			} else {

				// anytype x anytype

				typeA = typeB = type;

			}

		} else {

			typeA = typeB = type;

		}

		const a = aNode.build( builder, typeA );
		const b = typeof bNode !== 'undefined' ? bNode.build( builder, typeB ) : null;

		const outputLength = builder.getTypeLength( output );
		const fnOpSnippet = builder.getFunctionOperator( op );

		if ( output !== 'void' ) {

			if ( op === '<' && outputLength > 1 ) {

				if ( builder.useComparisonMethod ) {

					return builder.format( `${ builder.getMethod( 'lessThan', output ) }( ${ a }, ${ b } )`, type, output );

				} else {

					return builder.format( `( ${ a } < ${ b } )`, type, output );

				}

			} else if ( op === '<=' && outputLength > 1 ) {

				if ( builder.useComparisonMethod ) {

					return builder.format( `${ builder.getMethod( 'lessThanEqual', output ) }( ${ a }, ${ b } )`, type, output );

				} else {

					return builder.format( `( ${ a } <= ${ b } )`, type, output );

				}

			} else if ( op === '>' && outputLength > 1 ) {

				if ( builder.useComparisonMethod ) {

					return builder.format( `${ builder.getMethod( 'greaterThan', output ) }( ${ a }, ${ b } )`, type, output );

				} else {

					return builder.format( `( ${ a } > ${ b } )`, type, output );

				}

			} else if ( op === '>=' && outputLength > 1 ) {

				if ( builder.useComparisonMethod ) {

					return builder.format( `${ builder.getMethod( 'greaterThanEqual', output ) }( ${ a }, ${ b } )`, type, output );

				} else {

					return builder.format( `( ${ a } >= ${ b } )`, type, output );

				}

			} else if ( op === '!' || op === '~' ) {

				return builder.format( `(${op}${a})`, typeA, output );

			} else if ( fnOpSnippet ) {

				return builder.format( `${ fnOpSnippet }( ${ a }, ${ b } )`, type, output );

			} else {

				return builder.format( `( ${ a } ${ op } ${ b } )`, type, output );

			}

		} else if ( typeA !== 'void' ) {

			if ( fnOpSnippet ) {

				return builder.format( `${ fnOpSnippet }( ${ a }, ${ b } )`, type, output );

			} else {

				return builder.format( `${ a } ${ op } ${ b }`, type, output );

			}

		}

	}

	serialize( data ) {

		super.serialize( data );

		data.op = this.op;

	}

	deserialize( data ) {

		super.deserialize( data );

		this.op = data.op;

	}

}

const add$1 = /*@__PURE__*/ nodeProxy( OperatorNode, '+' );
const sub$1 = /*@__PURE__*/ nodeProxy( OperatorNode, '-' );
const mul$1 = /*@__PURE__*/ nodeProxy( OperatorNode, '*' );
const div$1 = /*@__PURE__*/ nodeProxy( OperatorNode, '/' );
const modInt = /*@__PURE__*/ nodeProxy( OperatorNode, '%' );
const equal = /*@__PURE__*/ nodeProxy( OperatorNode, '==' );
const notEqual = /*@__PURE__*/ nodeProxy( OperatorNode, '!=' );
const lessThan = /*@__PURE__*/ nodeProxy( OperatorNode, '<' );
const greaterThan = /*@__PURE__*/ nodeProxy( OperatorNode, '>' );
const lessThanEqual = /*@__PURE__*/ nodeProxy( OperatorNode, '<=' );
const greaterThanEqual = /*@__PURE__*/ nodeProxy( OperatorNode, '>=' );
const and = /*@__PURE__*/ nodeProxy( OperatorNode, '&&' );
const or = /*@__PURE__*/ nodeProxy( OperatorNode, '||' );
const not = /*@__PURE__*/ nodeProxy( OperatorNode, '!' );
const xor = /*@__PURE__*/ nodeProxy( OperatorNode, '^^' );
const bitAnd = /*@__PURE__*/ nodeProxy( OperatorNode, '&' );
const bitNot = /*@__PURE__*/ nodeProxy( OperatorNode, '~' );
const bitOr = /*@__PURE__*/ nodeProxy( OperatorNode, '|' );
const bitXor = /*@__PURE__*/ nodeProxy( OperatorNode, '^' );
const shiftLeft = /*@__PURE__*/ nodeProxy( OperatorNode, '<<' );
const shiftRight = /*@__PURE__*/ nodeProxy( OperatorNode, '>>' );

addMethodChaining( 'add', add$1 );
addMethodChaining( 'sub', sub$1 );
addMethodChaining( 'mul', mul$1 );
addMethodChaining( 'div', div$1 );
addMethodChaining( 'modInt', modInt );
addMethodChaining( 'equal', equal );
addMethodChaining( 'notEqual', notEqual );
addMethodChaining( 'lessThan', lessThan );
addMethodChaining( 'greaterThan', greaterThan );
addMethodChaining( 'lessThanEqual', lessThanEqual );
addMethodChaining( 'greaterThanEqual', greaterThanEqual );
addMethodChaining( 'and', and );
addMethodChaining( 'or', or );
addMethodChaining( 'not', not );
addMethodChaining( 'xor', xor );
addMethodChaining( 'bitAnd', bitAnd );
addMethodChaining( 'bitNot', bitNot );
addMethodChaining( 'bitOr', bitOr );
addMethodChaining( 'bitXor', bitXor );
addMethodChaining( 'shiftLeft', shiftLeft );
addMethodChaining( 'shiftRight', shiftRight );


const remainder = ( ...params ) => { // @deprecated, r168

	console.warn( 'TSL.OperatorNode: .remainder() has been renamed to .modInt().' );
	return modInt( ...params );

};

addMethodChaining( 'remainder', remainder );

class MathNode extends TempNode {

	static get type() {

		return 'MathNode';

	}

	constructor( method, aNode, bNode = null, cNode = null ) {

		super();

		this.method = method;

		this.aNode = aNode;
		this.bNode = bNode;
		this.cNode = cNode;

	}

	getInputType( builder ) {

		const aType = this.aNode.getNodeType( builder );
		const bType = this.bNode ? this.bNode.getNodeType( builder ) : null;
		const cType = this.cNode ? this.cNode.getNodeType( builder ) : null;

		const aLen = builder.isMatrix( aType ) ? 0 : builder.getTypeLength( aType );
		const bLen = builder.isMatrix( bType ) ? 0 : builder.getTypeLength( bType );
		const cLen = builder.isMatrix( cType ) ? 0 : builder.getTypeLength( cType );

		if ( aLen > bLen && aLen > cLen ) {

			return aType;

		} else if ( bLen > cLen ) {

			return bType;

		} else if ( cLen > aLen ) {

			return cType;

		}

		return aType;

	}

	getNodeType( builder ) {

		const method = this.method;

		if ( method === MathNode.LENGTH || method === MathNode.DISTANCE || method === MathNode.DOT ) {

			return 'float';

		} else if ( method === MathNode.CROSS ) {

			return 'vec3';

		} else if ( method === MathNode.ALL ) {

			return 'bool';

		} else if ( method === MathNode.EQUALS ) {

			return builder.changeComponentType( this.aNode.getNodeType( builder ), 'bool' );

		} else if ( method === MathNode.MOD ) {

			return this.aNode.getNodeType( builder );

		} else {

			return this.getInputType( builder );

		}

	}

	generate( builder, output ) {

		const method = this.method;

		const type = this.getNodeType( builder );
		const inputType = this.getInputType( builder );

		const a = this.aNode;
		const b = this.bNode;
		const c = this.cNode;

		const isWebGL = builder.renderer.isWebGLRenderer === true;

		if ( method === MathNode.TRANSFORM_DIRECTION ) {

			// dir can be either a direction vector or a normal vector
			// upper-left 3x3 of matrix is assumed to be orthogonal

			let tA = a;
			let tB = b;

			if ( builder.isMatrix( tA.getNodeType( builder ) ) ) {

				tB = vec4$1( vec3$1( tB ), 0.0 );

			} else {

				tA = vec4$1( vec3$1( tA ), 0.0 );

			}

			const mulNode = mul$1( tA, tB ).xyz;

			return normalize$1( mulNode ).build( builder, output );

		} else if ( method === MathNode.NEGATE ) {

			return builder.format( '( - ' + a.build( builder, inputType ) + ' )', type, output );

		} else if ( method === MathNode.ONE_MINUS ) {

			return sub$1( 1.0, a ).build( builder, output );

		} else if ( method === MathNode.RECIPROCAL ) {

			return div$1( 1.0, a ).build( builder, output );

		} else if ( method === MathNode.DIFFERENCE ) {

			return abs$1( sub$1( a, b ) ).build( builder, output );

		} else {

			const params = [];

			if ( method === MathNode.CROSS || method === MathNode.MOD ) {

				params.push(
					a.build( builder, type ),
					b.build( builder, type )
				);

			} else if ( isWebGL && method === MathNode.STEP ) {

				params.push(
					a.build( builder, builder.getTypeLength( a.getNodeType( builder ) ) === 1 ? 'float' : inputType ),
					b.build( builder, inputType )
				);

			} else if ( ( isWebGL && ( method === MathNode.MIN || method === MathNode.MAX ) ) || method === MathNode.MOD ) {

				params.push(
					a.build( builder, inputType ),
					b.build( builder, builder.getTypeLength( b.getNodeType( builder ) ) === 1 ? 'float' : inputType )
				);

			} else if ( method === MathNode.REFRACT ) {

				params.push(
					a.build( builder, inputType ),
					b.build( builder, inputType ),
					c.build( builder, 'float' )
				);

			} else if ( method === MathNode.MIX ) {

				params.push(
					a.build( builder, inputType ),
					b.build( builder, inputType ),
					c.build( builder, builder.getTypeLength( c.getNodeType( builder ) ) === 1 ? 'float' : inputType )
				);

			} else {

				params.push( a.build( builder, inputType ) );
				if ( b !== null ) params.push( b.build( builder, inputType ) );
				if ( c !== null ) params.push( c.build( builder, inputType ) );

			}

			return builder.format( `${ builder.getMethod( method, type ) }( ${params.join( ', ' )} )`, type, output );

		}

	}

	serialize( data ) {

		super.serialize( data );

		data.method = this.method;

	}

	deserialize( data ) {

		super.deserialize( data );

		this.method = data.method;

	}

}

// 1 input

MathNode.ALL = 'all';
MathNode.ANY = 'any';
MathNode.EQUALS = 'equals';

MathNode.RADIANS = 'radians';
MathNode.DEGREES = 'degrees';
MathNode.EXP = 'exp';
MathNode.EXP2 = 'exp2';
MathNode.LOG = 'log';
MathNode.LOG2 = 'log2';
MathNode.SQRT = 'sqrt';
MathNode.INVERSE_SQRT = 'inversesqrt';
MathNode.FLOOR = 'floor';
MathNode.CEIL = 'ceil';
MathNode.NORMALIZE = 'normalize';
MathNode.FRACT = 'fract';
MathNode.SIN = 'sin';
MathNode.COS = 'cos';
MathNode.TAN = 'tan';
MathNode.ASIN = 'asin';
MathNode.ACOS = 'acos';
MathNode.ATAN = 'atan';
MathNode.ABS = 'abs';
MathNode.SIGN = 'sign';
MathNode.LENGTH = 'length';
MathNode.NEGATE = 'negate';
MathNode.ONE_MINUS = 'oneMinus';
MathNode.DFDX = 'dFdx';
MathNode.DFDY = 'dFdy';
MathNode.ROUND = 'round';
MathNode.RECIPROCAL = 'reciprocal';
MathNode.TRUNC = 'trunc';
MathNode.FWIDTH = 'fwidth';
MathNode.BITCAST = 'bitcast';
MathNode.TRANSPOSE = 'transpose';

// 2 inputs

MathNode.ATAN2 = 'atan2';
MathNode.MIN = 'min';
MathNode.MAX = 'max';
MathNode.MOD = 'mod';
MathNode.STEP = 'step';
MathNode.REFLECT = 'reflect';
MathNode.DISTANCE = 'distance';
MathNode.DIFFERENCE = 'difference';
MathNode.DOT = 'dot';
MathNode.CROSS = 'cross';
MathNode.POW = 'pow';
MathNode.TRANSFORM_DIRECTION = 'transformDirection';

// 3 inputs

MathNode.MIX = 'mix';
MathNode.CLAMP = 'clamp';
MathNode.REFRACT = 'refract';
MathNode.SMOOTHSTEP = 'smoothstep';
MathNode.FACEFORWARD = 'faceforward';

const EPSILON = /*@__PURE__*/ float$1( 1e-6 );
const INFINITY = /*@__PURE__*/ float$1( 1e6 );
const PI = /*@__PURE__*/ float$1( Math.PI );
const PI2 = /*@__PURE__*/ float$1( Math.PI * 2 );

const all = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ALL );
const any = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ANY );
const equals = /*@__PURE__*/ nodeProxy( MathNode, MathNode.EQUALS );

const radians = /*@__PURE__*/ nodeProxy( MathNode, MathNode.RADIANS );
const degrees = /*@__PURE__*/ nodeProxy( MathNode, MathNode.DEGREES );
const exp$1 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.EXP );
const exp2 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.EXP2 );
const log = /*@__PURE__*/ nodeProxy( MathNode, MathNode.LOG );
const log2 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.LOG2 );
const sqrt = /*@__PURE__*/ nodeProxy( MathNode, MathNode.SQRT );
const inverseSqrt = /*@__PURE__*/ nodeProxy( MathNode, MathNode.INVERSE_SQRT );
const floor$1 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.FLOOR );
const ceil = /*@__PURE__*/ nodeProxy( MathNode, MathNode.CEIL );
const normalize$1 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.NORMALIZE );
const fract$1 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.FRACT );
const sin$1 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.SIN );
const cos$1 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.COS );
const tan = /*@__PURE__*/ nodeProxy( MathNode, MathNode.TAN );
const asin = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ASIN );
const acos = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ACOS );
const atan = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ATAN );
const abs$1 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ABS );
const sign = /*@__PURE__*/ nodeProxy( MathNode, MathNode.SIGN );
const length = /*@__PURE__*/ nodeProxy( MathNode, MathNode.LENGTH );
const negate = /*@__PURE__*/ nodeProxy( MathNode, MathNode.NEGATE );
const oneMinus = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ONE_MINUS );
const dFdx = /*@__PURE__*/ nodeProxy( MathNode, MathNode.DFDX );
const dFdy = /*@__PURE__*/ nodeProxy( MathNode, MathNode.DFDY );
const round = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ROUND );
const reciprocal = /*@__PURE__*/ nodeProxy( MathNode, MathNode.RECIPROCAL );
const trunc = /*@__PURE__*/ nodeProxy( MathNode, MathNode.TRUNC );
const fwidth = /*@__PURE__*/ nodeProxy( MathNode, MathNode.FWIDTH );
const bitcast = /*@__PURE__*/ nodeProxy( MathNode, MathNode.BITCAST );
const transpose = /*@__PURE__*/ nodeProxy( MathNode, MathNode.TRANSPOSE );

const atan2 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ATAN2 );
const min$1 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.MIN );
const max$1 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.MAX );
const mod = /*@__PURE__*/ nodeProxy( MathNode, MathNode.MOD );
const step = /*@__PURE__*/ nodeProxy( MathNode, MathNode.STEP );
const reflect = /*@__PURE__*/ nodeProxy( MathNode, MathNode.REFLECT );
const distance$1 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.DISTANCE );
const difference = /*@__PURE__*/ nodeProxy( MathNode, MathNode.DIFFERENCE );
const dot$1 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.DOT );
const cross = /*@__PURE__*/ nodeProxy( MathNode, MathNode.CROSS );
const pow$1 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.POW );
const pow2 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.POW, 2 );
const pow3 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.POW, 3 );
const pow4 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.POW, 4 );
const transformDirection = /*@__PURE__*/ nodeProxy( MathNode, MathNode.TRANSFORM_DIRECTION );

const cbrt = ( a ) => mul$1( sign( a ), pow$1( abs$1( a ), 1.0 / 3.0 ) );
const lengthSq = ( a ) => dot$1( a, a );
const mix$1 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.MIX );
const clamp = ( value, low = 0, high = 1 ) => nodeObject( new MathNode( MathNode.CLAMP, nodeObject( value ), nodeObject( low ), nodeObject( high ) ) );
const saturate = ( value ) => clamp( value );
const refract = /*@__PURE__*/ nodeProxy( MathNode, MathNode.REFRACT );
const smoothstep$1 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.SMOOTHSTEP );
const faceForward = /*@__PURE__*/ nodeProxy( MathNode, MathNode.FACEFORWARD );

const rand = /*@__PURE__*/ Fn$1( ( [ uv ] ) => {

	const a = 12.9898, b = 78.233, c = 43758.5453;
	const dt = dot$1( uv.xy, vec2$1( a, b ) ), sn = mod( dt, PI );

	return fract$1( sin$1( sn ).mul( c ) );

} );

const mixElement = ( t, e1, e2 ) => mix$1( e1, e2, t );
const smoothstepElement = ( x, low, high ) => smoothstep$1( low, high, x );

addMethodChaining( 'all', all );
addMethodChaining( 'any', any );
addMethodChaining( 'equals', equals );

addMethodChaining( 'radians', radians );
addMethodChaining( 'degrees', degrees );
addMethodChaining( 'exp', exp$1 );
addMethodChaining( 'exp2', exp2 );
addMethodChaining( 'log', log );
addMethodChaining( 'log2', log2 );
addMethodChaining( 'sqrt', sqrt );
addMethodChaining( 'inverseSqrt', inverseSqrt );
addMethodChaining( 'floor', floor$1 );
addMethodChaining( 'ceil', ceil );
addMethodChaining( 'normalize', normalize$1 );
addMethodChaining( 'fract', fract$1 );
addMethodChaining( 'sin', sin$1 );
addMethodChaining( 'cos', cos$1 );
addMethodChaining( 'tan', tan );
addMethodChaining( 'asin', asin );
addMethodChaining( 'acos', acos );
addMethodChaining( 'atan', atan );
addMethodChaining( 'abs', abs$1 );
addMethodChaining( 'sign', sign );
addMethodChaining( 'length', length );
addMethodChaining( 'lengthSq', lengthSq );
addMethodChaining( 'negate', negate );
addMethodChaining( 'oneMinus', oneMinus );
addMethodChaining( 'dFdx', dFdx );
addMethodChaining( 'dFdy', dFdy );
addMethodChaining( 'round', round );
addMethodChaining( 'reciprocal', reciprocal );
addMethodChaining( 'trunc', trunc );
addMethodChaining( 'fwidth', fwidth );
addMethodChaining( 'atan2', atan2 );
addMethodChaining( 'min', min$1 );
addMethodChaining( 'max', max$1 );
addMethodChaining( 'mod', mod );
addMethodChaining( 'step', step );
addMethodChaining( 'reflect', reflect );
addMethodChaining( 'distance', distance$1 );
addMethodChaining( 'dot', dot$1 );
addMethodChaining( 'cross', cross );
addMethodChaining( 'pow', pow$1 );
addMethodChaining( 'pow2', pow2 );
addMethodChaining( 'pow3', pow3 );
addMethodChaining( 'pow4', pow4 );
addMethodChaining( 'transformDirection', transformDirection );
addMethodChaining( 'mix', mixElement );
addMethodChaining( 'clamp', clamp );
addMethodChaining( 'refract', refract );
addMethodChaining( 'smoothstep', smoothstepElement );
addMethodChaining( 'faceForward', faceForward );
addMethodChaining( 'difference', difference );
addMethodChaining( 'saturate', saturate );
addMethodChaining( 'cbrt', cbrt );
addMethodChaining( 'transpose', transpose );
addMethodChaining( 'rand', rand );

class ConditionalNode extends Node {

	static get type() {

		return 'ConditionalNode';

	}

	constructor( condNode, ifNode, elseNode = null ) {

		super();

		this.condNode = condNode;

		this.ifNode = ifNode;
		this.elseNode = elseNode;

	}

	getNodeType( builder ) {

		const ifType = this.ifNode.getNodeType( builder );

		if ( this.elseNode !== null ) {

			const elseType = this.elseNode.getNodeType( builder );

			if ( builder.getTypeLength( elseType ) > builder.getTypeLength( ifType ) ) {

				return elseType;

			}

		}

		return ifType;

	}

	setup( builder ) {

		const condNode = this.condNode.cache();
		const ifNode = this.ifNode.cache();
		const elseNode = this.elseNode ? this.elseNode.cache() : null;

		//

		const currentNodeBlock = builder.context.nodeBlock;

		builder.getDataFromNode( ifNode ).parentNodeBlock = currentNodeBlock;
		if ( elseNode !== null ) builder.getDataFromNode( elseNode ).parentNodeBlock = currentNodeBlock;

		//

		const properties = builder.getNodeProperties( this );
		properties.condNode = condNode;
		properties.ifNode = ifNode.context( { nodeBlock: ifNode } );
		properties.elseNode = elseNode ? elseNode.context( { nodeBlock: elseNode } ) : null;

	}

	generate( builder, output ) {

		const type = this.getNodeType( builder );

		const nodeData = builder.getDataFromNode( this );

		if ( nodeData.nodeProperty !== undefined ) {

			return nodeData.nodeProperty;

		}

		const { condNode, ifNode, elseNode } = builder.getNodeProperties( this );

		const needsOutput = output !== 'void';
		const nodeProperty = needsOutput ? property( type ).build( builder ) : '';

		nodeData.nodeProperty = nodeProperty;

		const nodeSnippet = condNode.build( builder, 'bool' );

		builder.addFlowCode( `\n${ builder.tab }if ( ${ nodeSnippet } ) {\n\n` ).addFlowTab();

		let ifSnippet = ifNode.build( builder, type );

		if ( ifSnippet ) {

			if ( needsOutput ) {

				ifSnippet = nodeProperty + ' = ' + ifSnippet + ';';

			} else {

				ifSnippet = 'return ' + ifSnippet + ';';

			}

		}

		builder.removeFlowTab().addFlowCode( builder.tab + '\t' + ifSnippet + '\n\n' + builder.tab + '}' );

		if ( elseNode !== null ) {

			builder.addFlowCode( ' else {\n\n' ).addFlowTab();

			let elseSnippet = elseNode.build( builder, type );

			if ( elseSnippet ) {

				if ( needsOutput ) {

					elseSnippet = nodeProperty + ' = ' + elseSnippet + ';';

				} else {

					elseSnippet = 'return ' + elseSnippet + ';';

				}

			}

			builder.removeFlowTab().addFlowCode( builder.tab + '\t' + elseSnippet + '\n\n' + builder.tab + '}\n\n' );

		} else {

			builder.addFlowCode( '\n\n' );

		}

		return builder.format( nodeProperty, type, output );

	}

}

const select = /*@__PURE__*/ nodeProxy( ConditionalNode );

addMethodChaining( 'select', select );

//

const cond = ( ...params ) => { // @deprecated, r168

	console.warn( 'TSL.ConditionalNode: cond() has been renamed to select().' );
	return select( ...params );

};

addMethodChaining( 'cond', cond );

class ContextNode extends Node {

	static get type() {

		return 'ContextNode';

	}

	constructor( node, value = {} ) {

		super();

		this.isContextNode = true;

		this.node = node;
		this.value = value;

	}

	getScope() {

		return this.node.getScope();

	}

	getNodeType( builder ) {

		return this.node.getNodeType( builder );

	}

	analyze( builder ) {

		this.node.build( builder );

	}

	setup( builder ) {

		const previousContext = builder.getContext();

		builder.setContext( { ...builder.context, ...this.value } );

		const node = this.node.build( builder );

		builder.setContext( previousContext );

		return node;

	}

	generate( builder, output ) {

		const previousContext = builder.getContext();

		builder.setContext( { ...builder.context, ...this.value } );

		const snippet = this.node.build( builder, output );

		builder.setContext( previousContext );

		return snippet;

	}

}

const context = /*@__PURE__*/ nodeProxy( ContextNode );
const label = ( node, name ) => context( node, { label: name } );

addMethodChaining( 'context', context );
addMethodChaining( 'label', label );

class VarNode extends Node {

	static get type() {

		return 'VarNode';

	}

	constructor( node, name = null ) {

		super();

		this.node = node;
		this.name = name;

		this.global = true;

		this.isVarNode = true;

	}

	getHash( builder ) {

		return this.name || super.getHash( builder );

	}

	getNodeType( builder ) {

		return this.node.getNodeType( builder );

	}

	generate( builder ) {

		const { node, name } = this;

		const nodeVar = builder.getVarFromNode( this, name, builder.getVectorType( this.getNodeType( builder ) ) );

		const propertyName = builder.getPropertyName( nodeVar );

		const snippet = node.build( builder, nodeVar.type );

		builder.addLineFlowCode( `${propertyName} = ${snippet}`, this );

		return propertyName;

	}

}

const createVar = /*@__PURE__*/ nodeProxy( VarNode );

addMethodChaining( 'toVar', ( ...params ) => createVar( ...params ).append() );

// Deprecated

const temp = ( node ) => { // @deprecated, r170

	console.warn( 'TSL: "temp" is deprecated. Use ".toVar()" instead.' );

	return createVar( node );

};

addMethodChaining( 'temp', temp );

class VaryingNode extends Node {

	static get type() {

		return 'VaryingNode';

	}

	constructor( node, name = null ) {

		super();

		this.node = node;
		this.name = name;

		this.isVaryingNode = true;

	}

	isGlobal() {

		return true;

	}

	getHash( builder ) {

		return this.name || super.getHash( builder );

	}

	getNodeType( builder ) {

		// VaryingNode is auto type

		return this.node.getNodeType( builder );

	}

	setupVarying( builder ) {

		const properties = builder.getNodeProperties( this );

		let varying = properties.varying;

		if ( varying === undefined ) {

			const name = this.name;
			const type = this.getNodeType( builder );

			properties.varying = varying = builder.getVaryingFromNode( this, name, type );
			properties.node = this.node;

		}

		// this property can be used to check if the varying can be optimized for a variable
		varying.needsInterpolation || ( varying.needsInterpolation = ( builder.shaderStage === 'fragment' ) );

		return varying;

	}

	setup( builder ) {

		this.setupVarying( builder );

	}

	analyze( builder ) {

		this.setupVarying( builder );

		return this.node.analyze( builder );

	}

	generate( builder ) {

		const properties = builder.getNodeProperties( this );
		const varying = this.setupVarying( builder );

		if ( properties.propertyName === undefined ) {

			const type = this.getNodeType( builder );
			const propertyName = builder.getPropertyName( varying, NodeShaderStage.VERTEX );

			// force node run in vertex stage
			builder.flowNodeFromShaderStage( NodeShaderStage.VERTEX, this.node, type, propertyName );

			properties.propertyName = propertyName;

		}

		return builder.getPropertyName( varying );

	}

}

const varying = /*@__PURE__*/ nodeProxy( VaryingNode );

addMethodChaining( 'varying', varying );

const sRGBTransferEOTF = /*@__PURE__*/ Fn$1( ( [ color ] ) => {

	const a = color.mul( 0.9478672986 ).add( 0.0521327014 ).pow( 2.4 );
	const b = color.mul( 0.0773993808 );
	const factor = color.lessThanEqual( 0.04045 );

	const rgbResult = mix$1( a, b, factor );

	return rgbResult;

} ).setLayout( {
	name: 'sRGBTransferEOTF',
	type: 'vec3',
	inputs: [
		{ name: 'color', type: 'vec3' }
	]
} );

const sRGBTransferOETF = /*@__PURE__*/ Fn$1( ( [ color ] ) => {

	const a = color.pow( 0.41666 ).mul( 1.055 ).sub( 0.055 );
	const b = color.mul( 12.92 );
	const factor = color.lessThanEqual( 0.0031308 );

	const rgbResult = mix$1( a, b, factor );

	return rgbResult;

} ).setLayout( {
	name: 'sRGBTransferOETF',
	type: 'vec3',
	inputs: [
		{ name: 'color', type: 'vec3' }
	]
} );

const WORKING_COLOR_SPACE = 'WorkingColorSpace';
const OUTPUT_COLOR_SPACE = 'OutputColorSpace';

class ColorSpaceNode extends TempNode {

	static get type() {

		return 'ColorSpaceNode';

	}

	constructor( colorNode, source, target ) {

		super( 'vec4' );

		this.colorNode = colorNode;
		this.source = source;
		this.target = target;

	}

	resolveColorSpace( builder, colorSpace ) {

		if ( colorSpace === WORKING_COLOR_SPACE ) {

			return ColorManagement.workingColorSpace;

		} else if ( colorSpace === OUTPUT_COLOR_SPACE ) {

			return builder.context.outputColorSpace || builder.renderer.outputColorSpace;

		}

		return colorSpace;

	}

	setup( builder ) {

		const { colorNode } = this;

		const source = this.resolveColorSpace( builder, this.source );
		const target = this.resolveColorSpace( builder, this.target );

		let outputNode = colorNode;

		if ( ColorManagement.enabled === false || source === target || ! source || ! target ) {

			return outputNode;

		}

		if ( ColorManagement.getTransfer( source ) === SRGBTransfer ) {

			outputNode = vec4$1( sRGBTransferEOTF( outputNode.rgb ), outputNode.a );

		}

		if ( ColorManagement.getPrimaries( source ) !== ColorManagement.getPrimaries( target ) ) {

			outputNode = vec4$1(
				mat3( ColorManagement._getMatrix( new Matrix3(), source, target ) ).mul( outputNode.rgb ),
				outputNode.a
			);

		}

		if ( ColorManagement.getTransfer( target ) === SRGBTransfer ) {

			outputNode = vec4$1( sRGBTransferOETF( outputNode.rgb ), outputNode.a );

		}

		return outputNode;

	}

}

const toOutputColorSpace = ( node ) => nodeObject( new ColorSpaceNode( nodeObject( node ), WORKING_COLOR_SPACE, OUTPUT_COLOR_SPACE ) );
const toWorkingColorSpace = ( node ) => nodeObject( new ColorSpaceNode( nodeObject( node ), OUTPUT_COLOR_SPACE, WORKING_COLOR_SPACE ) );

const workingToColorSpace = ( node, colorSpace ) => nodeObject( new ColorSpaceNode( nodeObject( node ), WORKING_COLOR_SPACE, colorSpace ) );
const colorSpaceToWorking = ( node, colorSpace ) => nodeObject( new ColorSpaceNode( nodeObject( node ), colorSpace, WORKING_COLOR_SPACE ) );

const convertColorSpace = ( node, sourceColorSpace, targetColorSpace ) => nodeObject( new ColorSpaceNode( nodeObject( node ), sourceColorSpace, targetColorSpace ) );

addMethodChaining( 'toOutputColorSpace', toOutputColorSpace );
addMethodChaining( 'toWorkingColorSpace', toWorkingColorSpace );

addMethodChaining( 'workingToColorSpace', workingToColorSpace );
addMethodChaining( 'colorSpaceToWorking', colorSpaceToWorking );

let ReferenceElementNode$1 = class ReferenceElementNode extends ArrayElementNode {

	static get type() {

		return 'ReferenceElementNode';

	}

	constructor( referenceNode, indexNode ) {

		super( referenceNode, indexNode );

		this.referenceNode = referenceNode;

		this.isReferenceElementNode = true;

	}

	getNodeType() {

		return this.referenceNode.uniformType;

	}

	generate( builder ) {

		const snippet = super.generate( builder );
		const arrayType = this.referenceNode.getNodeType();
		const elementType = this.getNodeType();

		return builder.format( snippet, arrayType, elementType );

	}

};

class ReferenceBaseNode extends Node {

	static get type() {

		return 'ReferenceBaseNode';

	}

	constructor( property, uniformType, object = null, count = null ) {

		super();

		this.property = property;
		this.uniformType = uniformType;
		this.object = object;
		this.count = count;

		this.properties = property.split( '.' );
		this.reference = object;
		this.node = null;
		this.group = null;

		this.updateType = NodeUpdateType.OBJECT;

	}

	setGroup( group ) {

		this.group = group;

		return this;

	}

	element( indexNode ) {

		return nodeObject( new ReferenceElementNode$1( this, nodeObject( indexNode ) ) );

	}

	setNodeType( uniformType ) {

		const node = uniform$1( null, uniformType ).getSelf();

		if ( this.group !== null ) {

			node.setGroup( this.group );

		}

		this.node = node;

	}

	getNodeType( builder ) {

		if ( this.node === null ) {

			this.updateReference( builder );
			this.updateValue();

		}

		return this.node.getNodeType( builder );

	}

	getValueFromReference( object = this.reference ) {

		const { properties } = this;

		let value = object[ properties[ 0 ] ];

		for ( let i = 1; i < properties.length; i ++ ) {

			value = value[ properties[ i ] ];

		}

		return value;

	}

	updateReference( state ) {

		this.reference = this.object !== null ? this.object : state.object;

		return this.reference;

	}

	setup() {

		this.updateValue();

		return this.node;

	}

	update( /*frame*/ ) {

		this.updateValue();

	}

	updateValue() {

		if ( this.node === null ) this.setNodeType( this.uniformType );

		const value = this.getValueFromReference();

		if ( Array.isArray( value ) ) {

			this.node.array = value;

		} else {

			this.node.value = value;

		}

	}

}

const reference$1 = ( name, type, object ) => nodeObject( new ReferenceBaseNode( name, type, object ) );

class RendererReferenceNode extends ReferenceBaseNode {

	static get type() {

		return 'RendererReferenceNode';

	}

	constructor( property, inputType, renderer = null ) {

		super( property, inputType, renderer );

		this.renderer = renderer;

		this.setGroup( renderGroup );

	}

	updateReference( state ) {

		this.reference = this.renderer !== null ? this.renderer : state.renderer;

		return this.reference;

	}

}

const rendererReference = ( name, type, renderer ) => nodeObject( new RendererReferenceNode( name, type, renderer ) );

class ToneMappingNode extends TempNode {

	static get type() {

		return 'ToneMappingNode';

	}

	constructor( toneMapping, exposureNode = toneMappingExposure, colorNode = null ) {

		super( 'vec3' );

		this.toneMapping = toneMapping;

		this.exposureNode = exposureNode;
		this.colorNode = colorNode;

	}

	getCacheKey() {

		return hash$1( super.getCacheKey(), this.toneMapping );

	}

	setup( builder ) {

		const colorNode = this.colorNode || builder.context.color;
		const toneMapping = this.toneMapping;

		if ( toneMapping === NoToneMapping ) return colorNode;

		let outputNode = null;

		const toneMappingFn = builder.renderer.library.getToneMappingFunction( toneMapping );

		if ( toneMappingFn !== null ) {

			outputNode = vec4$1( toneMappingFn( colorNode.rgb, this.exposureNode ), colorNode.a );

		} else {

			console.error( 'ToneMappingNode: Unsupported Tone Mapping configuration.', toneMapping );

			outputNode = colorNode;

		}

		return outputNode;

	}

}

const toneMapping = ( mapping, exposure, color ) => nodeObject( new ToneMappingNode( mapping, nodeObject( exposure ), nodeObject( color ) ) );
const toneMappingExposure = /*@__PURE__*/ rendererReference( 'toneMappingExposure', 'float' );

addMethodChaining( 'toneMapping', ( color, mapping, exposure ) => toneMapping( mapping, exposure, color ) );

class BufferAttributeNode extends InputNode {

	static get type() {

		return 'BufferAttributeNode';

	}

	constructor( value, bufferType = null, bufferStride = 0, bufferOffset = 0 ) {

		super( value, bufferType );

		this.isBufferNode = true;

		this.bufferType = bufferType;
		this.bufferStride = bufferStride;
		this.bufferOffset = bufferOffset;

		this.usage = StaticDrawUsage;
		this.instanced = false;

		this.attribute = null;

		this.global = true;

		if ( value && value.isBufferAttribute === true ) {

			this.attribute = value;
			this.usage = value.usage;
			this.instanced = value.isInstancedBufferAttribute;

		}

	}

	getHash( builder ) {

		if ( this.bufferStride === 0 && this.bufferOffset === 0 ) {

			let bufferData = builder.globalCache.getData( this.value );

			if ( bufferData === undefined ) {

				bufferData = {
					node: this
				};

				builder.globalCache.setData( this.value, bufferData );

			}

			return bufferData.node.uuid;

		}

		return this.uuid;

	}

	getNodeType( builder ) {

		if ( this.bufferType === null ) {

			this.bufferType = builder.getTypeFromAttribute( this.attribute );

		}

		return this.bufferType;

	}

	setup( builder ) {

		if ( this.attribute !== null ) return;

		const type = this.getNodeType( builder );
		const array = this.value;
		const itemSize = builder.getTypeLength( type );
		const stride = this.bufferStride || itemSize;
		const offset = this.bufferOffset;

		const buffer = array.isInterleavedBuffer === true ? array : new InterleavedBuffer( array, stride );
		const bufferAttribute = new InterleavedBufferAttribute( buffer, itemSize, offset );

		buffer.setUsage( this.usage );

		this.attribute = bufferAttribute;
		this.attribute.isInstancedBufferAttribute = this.instanced; // @TODO: Add a possible: InstancedInterleavedBufferAttribute

	}

	generate( builder ) {

		const nodeType = this.getNodeType( builder );

		const nodeAttribute = builder.getBufferAttributeFromNode( this, nodeType );
		const propertyName = builder.getPropertyName( nodeAttribute );

		let output = null;

		if ( builder.shaderStage === 'vertex' || builder.shaderStage === 'compute' ) {

			this.name = propertyName;

			output = propertyName;

		} else {

			const nodeVarying = varying( this );

			output = nodeVarying.build( builder, nodeType );

		}

		return output;

	}

	getInputType( /*builder*/ ) {

		return 'bufferAttribute';

	}

	setUsage( value ) {

		this.usage = value;

		if ( this.attribute && this.attribute.isBufferAttribute === true ) {

			this.attribute.usage = value;

		}

		return this;

	}

	setInstanced( value ) {

		this.instanced = value;

		return this;

	}

}

const bufferAttribute = ( array, type, stride, offset ) => nodeObject( new BufferAttributeNode( array, type, stride, offset ) );
const dynamicBufferAttribute = ( array, type, stride, offset ) => bufferAttribute( array, type, stride, offset ).setUsage( DynamicDrawUsage );

const instancedBufferAttribute = ( array, type, stride, offset ) => bufferAttribute( array, type, stride, offset ).setInstanced( true );
const instancedDynamicBufferAttribute = ( array, type, stride, offset ) => dynamicBufferAttribute( array, type, stride, offset ).setInstanced( true );

addMethodChaining( 'toAttribute', ( bufferNode ) => bufferAttribute( bufferNode.value ) );

class ComputeNode extends Node {

	static get type() {

		return 'ComputeNode';

	}

	constructor( computeNode, count, workgroupSize = [ 64 ] ) {

		super( 'void' );

		this.isComputeNode = true;

		this.computeNode = computeNode;

		this.count = count;
		this.workgroupSize = workgroupSize;
		this.dispatchCount = 0;

		this.version = 1;
		this.updateBeforeType = NodeUpdateType.OBJECT;

		this.onInitFunction = null;

		this.updateDispatchCount();

	}

	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

	}

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

	updateDispatchCount() {

		const { count, workgroupSize } = this;

		let size = workgroupSize[ 0 ];

		for ( let i = 1; i < workgroupSize.length; i ++ )
			size *= workgroupSize[ i ];

		this.dispatchCount = Math.ceil( count / size );

	}

	onInit( callback ) {

		this.onInitFunction = callback;

		return this;

	}

	updateBefore( { renderer } ) {

		renderer.compute( this );

	}

	generate( builder ) {

		const { shaderStage } = builder;

		if ( shaderStage === 'compute' ) {

			const snippet = this.computeNode.build( builder, 'void' );

			if ( snippet !== '' ) {

				builder.addLineFlowCode( snippet, this );

			}

		}

	}

}

const compute = ( node, count, workgroupSize ) => nodeObject( new ComputeNode( nodeObject( node ), count, workgroupSize ) );

addMethodChaining( 'compute', compute );

class CacheNode extends Node {

	static get type() {

		return 'CacheNode';

	}

	constructor( node, parent = true ) {

		super();

		this.node = node;
		this.parent = parent;

		this.isCacheNode = true;

	}

	getNodeType( builder ) {

		return this.node.getNodeType( builder );

	}

	build( builder, ...params ) {

		const previousCache = builder.getCache();
		const cache = builder.getCacheFromNode( this, this.parent );

		builder.setCache( cache );

		const data = this.node.build( builder, ...params );

		builder.setCache( previousCache );

		return data;

	}

}

const cache = ( node, ...params ) => nodeObject( new CacheNode( nodeObject( node ), ...params ) );

addMethodChaining( 'cache', cache );

class BypassNode extends Node {

	static get type() {

		return 'BypassNode';

	}

	constructor( returnNode, callNode ) {

		super();

		this.isBypassNode = true;

		this.outputNode = returnNode;
		this.callNode = callNode;

	}

	getNodeType( builder ) {

		return this.outputNode.getNodeType( builder );

	}

	generate( builder ) {

		const snippet = this.callNode.build( builder, 'void' );

		if ( snippet !== '' ) {

			builder.addLineFlowCode( snippet, this );

		}

		return this.outputNode.build( builder );

	}

}

const bypass = /*@__PURE__*/ nodeProxy( BypassNode );

addMethodChaining( 'bypass', bypass );

class RemapNode extends Node {

	static get type() {

		return 'RemapNode';

	}

	constructor( node, inLowNode, inHighNode, outLowNode = float$1( 0 ), outHighNode = float$1( 1 ) ) {

		super();

		this.node = node;
		this.inLowNode = inLowNode;
		this.inHighNode = inHighNode;
		this.outLowNode = outLowNode;
		this.outHighNode = outHighNode;

		this.doClamp = true;

	}

	setup() {

		const { node, inLowNode, inHighNode, outLowNode, outHighNode, doClamp } = this;

		let t = node.sub( inLowNode ).div( inHighNode.sub( inLowNode ) );

		if ( doClamp === true ) t = t.clamp();

		return t.mul( outHighNode.sub( outLowNode ) ).add( outLowNode );

	}

}

const remap = /*@__PURE__*/ nodeProxy( RemapNode, null, null, { doClamp: false } );
const remapClamp = /*@__PURE__*/ nodeProxy( RemapNode );

addMethodChaining( 'remap', remap );
addMethodChaining( 'remapClamp', remapClamp );

class ExpressionNode extends Node {

	static get type() {

		return 'ExpressionNode';

	}

	constructor( snippet = '', nodeType = 'void' ) {

		super( nodeType );

		this.snippet = snippet;

	}

	generate( builder, output ) {

		const type = this.getNodeType( builder );
		const snippet = this.snippet;

		if ( type === 'void' ) {

			builder.addLineFlowCode( snippet, this );

		} else {

			return builder.format( `( ${ snippet } )`, type, output );

		}

	}

}

const expression = /*@__PURE__*/ nodeProxy( ExpressionNode );

const Discard = ( conditional ) => ( conditional ? select( conditional, expression( 'discard' ) ) : expression( 'discard' ) ).append();
const Return = () => expression( 'return' ).append();

addMethodChaining( 'discard', Discard );

class RenderOutputNode extends TempNode {

	static get type() {

		return 'RenderOutputNode';

	}

	constructor( colorNode, toneMapping, outputColorSpace ) {

		super( 'vec4' );

		this.colorNode = colorNode;
		this.toneMapping = toneMapping;
		this.outputColorSpace = outputColorSpace;

		this.isRenderOutput = true;

	}

	setup( { context } ) {

		let outputNode = this.colorNode || context.color;

		// tone mapping

		const toneMapping = ( this.toneMapping !== null ? this.toneMapping : context.toneMapping ) || NoToneMapping;
		const outputColorSpace = ( this.outputColorSpace !== null ? this.outputColorSpace : context.outputColorSpace ) || NoColorSpace;

		if ( toneMapping !== NoToneMapping ) {

			outputNode = outputNode.toneMapping( toneMapping );

		}

		// working to output color space

		if ( outputColorSpace !== NoColorSpace && outputColorSpace !== ColorManagement.workingColorSpace ) {

			outputNode = outputNode.workingToColorSpace( outputColorSpace );

		}

		return outputNode;

	}

}

const renderOutput = ( color, toneMapping = null, outputColorSpace = null ) => nodeObject( new RenderOutputNode( nodeObject( color ), toneMapping, outputColorSpace ) );

addMethodChaining( 'renderOutput', renderOutput );

// Non-PURE exports list, side-effects are required here.
// TSL Base Syntax


function addNodeElement( name/*, nodeElement*/ ) {

	console.warn( 'THREE.TSLBase: AddNodeElement has been removed in favor of tree-shaking. Trying add', name );

}

class AttributeNode extends Node {

	static get type() {

		return 'AttributeNode';

	}

	constructor( attributeName, nodeType = null ) {

		super( nodeType );

		this.global = true;

		this._attributeName = attributeName;

	}

	getHash( builder ) {

		return this.getAttributeName( builder );

	}

	getNodeType( builder ) {

		let nodeType = this.nodeType;

		if ( nodeType === null ) {

			const attributeName = this.getAttributeName( builder );

			if ( builder.hasGeometryAttribute( attributeName ) ) {

				const attribute = builder.geometry.getAttribute( attributeName );

				nodeType = builder.getTypeFromAttribute( attribute );

			} else {

				nodeType = 'float';

			}

		}

		return nodeType;

	}

	setAttributeName( attributeName ) {

		this._attributeName = attributeName;

		return this;

	}

	getAttributeName( /*builder*/ ) {

		return this._attributeName;

	}

	generate( builder ) {

		const attributeName = this.getAttributeName( builder );
		const nodeType = this.getNodeType( builder );
		const geometryAttribute = builder.hasGeometryAttribute( attributeName );

		if ( geometryAttribute === true ) {

			const attribute = builder.geometry.getAttribute( attributeName );
			const attributeType = builder.getTypeFromAttribute( attribute );

			const nodeAttribute = builder.getAttribute( attributeName, attributeType );

			if ( builder.shaderStage === 'vertex' ) {

				return builder.format( nodeAttribute.name, attributeType, nodeType );

			} else {

				const nodeVarying = varying( this );

				return nodeVarying.build( builder, nodeType );

			}

		} else {

			console.warn( `AttributeNode: Vertex attribute "${ attributeName }" not found on geometry.` );

			return builder.generateConst( nodeType );

		}

	}

	serialize( data ) {

		super.serialize( data );

		data.global = this.global;
		data._attributeName = this._attributeName;

	}

	deserialize( data ) {

		super.deserialize( data );

		this.global = data.global;
		this._attributeName = data._attributeName;

	}

}

const attribute$1 = ( name, nodeType ) => nodeObject( new AttributeNode( name, nodeType ) );

const uv$1 = ( index ) => attribute$1( 'uv' + ( index > 0 ? index : '' ), 'vec2' );

class TextureSizeNode extends Node {

	static get type() {

		return 'TextureSizeNode';

	}

	constructor( textureNode, levelNode = null ) {

		super( 'uvec2' );

		this.isTextureSizeNode = true;

		this.textureNode = textureNode;
		this.levelNode = levelNode;

	}

	generate( builder, output ) {

		const textureProperty = this.textureNode.build( builder, 'property' );
		const level = this.levelNode === null ? '0' : this.levelNode.build( builder, 'int' );

		return builder.format( `${ builder.getMethod( 'textureDimensions' ) }( ${ textureProperty }, ${ level } )`, this.getNodeType( builder ), output );

	}

}

const textureSize = /*@__PURE__*/ nodeProxy( TextureSizeNode );

class MaxMipLevelNode extends UniformNode {

	static get type() {

		return 'MaxMipLevelNode';

	}

	constructor( textureNode ) {

		super( 0 );

		this._textureNode = textureNode;

		this.updateType = NodeUpdateType.FRAME;

	}

	get textureNode() {

		return this._textureNode;

	}

	get texture() {

		return this._textureNode.value;

	}

	update() {

		const texture = this.texture;
		const images = texture.images;
		const image = ( images && images.length > 0 ) ? ( ( images[ 0 ] && images[ 0 ].image ) || images[ 0 ] ) : texture.image;

		if ( image && image.width !== undefined ) {

			const { width, height } = image;

			this.value = Math.log2( Math.max( width, height ) );

		}

	}

}

const maxMipLevel = /*@__PURE__*/ nodeProxy( MaxMipLevelNode );

class TextureNode extends UniformNode {

	static get type() {

		return 'TextureNode';

	}

	constructor( value, uvNode = null, levelNode = null, biasNode = null ) {

		super( value );

		this.isTextureNode = true;

		this.uvNode = uvNode;
		this.levelNode = levelNode;
		this.biasNode = biasNode;
		this.compareNode = null;
		this.depthNode = null;
		this.gradNode = null;

		this.sampler = true;
		this.updateMatrix = false;
		this.updateType = NodeUpdateType.NONE;

		this.referenceNode = null;

		this._value = value;
		this._matrixUniform = null;

		this.setUpdateMatrix( uvNode === null );

	}

	set value( value ) {

		if ( this.referenceNode ) {

			this.referenceNode.value = value;

		} else {

			this._value = value;

		}

	}

	get value() {

		return this.referenceNode ? this.referenceNode.value : this._value;

	}

	getUniformHash( /*builder*/ ) {

		return this.value.uuid;

	}

	getNodeType( /*builder*/ ) {

		if ( this.value.isDepthTexture === true ) return 'float';

		if ( this.value.type === UnsignedIntType ) {

			return 'uvec4';

		} else if ( this.value.type === IntType ) {

			return 'ivec4';

		}

		return 'vec4';

	}

	getInputType( /*builder*/ ) {

		return 'texture';

	}

	getDefaultUV() {

		return uv$1( this.value.channel );

	}

	updateReference( /*state*/ ) {

		return this.value;

	}

	getTransformedUV( uvNode ) {

		if ( this._matrixUniform === null ) this._matrixUniform = uniform$1( this.value.matrix );

		return this._matrixUniform.mul( vec3$1( uvNode, 1 ) ).xy;

	}

	setUpdateMatrix( value ) {

		this.updateMatrix = value;
		this.updateType = value ? NodeUpdateType.FRAME : NodeUpdateType.NONE;

		return this;

	}

	setupUV( builder, uvNode ) {

		const texture = this.value;

		if ( builder.isFlipY() && ( ( texture.image instanceof ImageBitmap && texture.flipY === true ) || texture.isRenderTargetTexture === true || texture.isFramebufferTexture === true || texture.isDepthTexture === true ) ) {

			if ( this.sampler ) {

				uvNode = uvNode.flipY();

			} else {

				uvNode = uvNode.setY( int( textureSize( this, this.levelNode ).y ).sub( uvNode.y ).sub( 1 ) );

			}

		}

		return uvNode;

	}

	setup( builder ) {

		const properties = builder.getNodeProperties( this );
		properties.referenceNode = this.referenceNode;

		//

		let uvNode = this.uvNode;

		if ( ( uvNode === null || builder.context.forceUVContext === true ) && builder.context.getUV ) {

			uvNode = builder.context.getUV( this );

		}

		if ( ! uvNode ) uvNode = this.getDefaultUV();

		if ( this.updateMatrix === true ) {

			uvNode = this.getTransformedUV( uvNode );

		}

		uvNode = this.setupUV( builder, uvNode );

		//

		let levelNode = this.levelNode;

		if ( levelNode === null && builder.context.getTextureLevel ) {

			levelNode = builder.context.getTextureLevel( this );

		}

		//

		properties.uvNode = uvNode;
		properties.levelNode = levelNode;
		properties.biasNode = this.biasNode;
		properties.compareNode = this.compareNode;
		properties.gradNode = this.gradNode;
		properties.depthNode = this.depthNode;

	}

	generateUV( builder, uvNode ) {

		return uvNode.build( builder, this.sampler === true ? 'vec2' : 'ivec2' );

	}

	generateSnippet( builder, textureProperty, uvSnippet, levelSnippet, biasSnippet, depthSnippet, compareSnippet, gradSnippet ) {

		const texture = this.value;

		let snippet;

		if ( levelSnippet ) {

			snippet = builder.generateTextureLevel( texture, textureProperty, uvSnippet, levelSnippet, depthSnippet );

		} else if ( biasSnippet ) {

			snippet = builder.generateTextureBias( texture, textureProperty, uvSnippet, biasSnippet, depthSnippet );

		} else if ( gradSnippet ) {

			snippet = builder.generateTextureGrad( texture, textureProperty, uvSnippet, gradSnippet, depthSnippet );

		} else if ( compareSnippet ) {

			snippet = builder.generateTextureCompare( texture, textureProperty, uvSnippet, compareSnippet, depthSnippet );

		} else if ( this.sampler === false ) {

			snippet = builder.generateTextureLoad( texture, textureProperty, uvSnippet, depthSnippet );

		} else {

			snippet = builder.generateTexture( texture, textureProperty, uvSnippet, depthSnippet );

		}

		return snippet;

	}

	generate( builder, output ) {

		const properties = builder.getNodeProperties( this );

		const texture = this.value;

		if ( ! texture || texture.isTexture !== true ) {

			throw new Error( 'TextureNode: Need a three.js texture.' );

		}

		const textureProperty = super.generate( builder, 'property' );

		if ( output === 'sampler' ) {

			return textureProperty + '_sampler';

		} else if ( builder.isReference( output ) ) {

			return textureProperty;

		} else {

			const nodeData = builder.getDataFromNode( this );

			let propertyName = nodeData.propertyName;

			if ( propertyName === undefined ) {

				const { uvNode, levelNode, biasNode, compareNode, depthNode, gradNode } = properties;

				const uvSnippet = this.generateUV( builder, uvNode );
				const levelSnippet = levelNode ? levelNode.build( builder, 'float' ) : null;
				const biasSnippet = biasNode ? biasNode.build( builder, 'float' ) : null;
				const depthSnippet = depthNode ? depthNode.build( builder, 'int' ) : null;
				const compareSnippet = compareNode ? compareNode.build( builder, 'float' ) : null;
				const gradSnippet = gradNode ? [ gradNode[ 0 ].build( builder, 'vec2' ), gradNode[ 1 ].build( builder, 'vec2' ) ] : null;

				const nodeVar = builder.getVarFromNode( this );

				propertyName = builder.getPropertyName( nodeVar );

				const snippet = this.generateSnippet( builder, textureProperty, uvSnippet, levelSnippet, biasSnippet, depthSnippet, compareSnippet, gradSnippet );

				builder.addLineFlowCode( `${propertyName} = ${snippet}`, this );

				nodeData.snippet = snippet;
				nodeData.propertyName = propertyName;

			}

			let snippet = propertyName;
			const nodeType = this.getNodeType( builder );

			if ( builder.needsToWorkingColorSpace( texture ) ) {

				snippet = colorSpaceToWorking( expression( snippet, nodeType ), texture.colorSpace ).setup( builder ).build( builder, nodeType );

			}

			return builder.format( snippet, nodeType, output );

		}

	}

	setSampler( value ) {

		this.sampler = value;

		return this;

	}

	getSampler() {

		return this.sampler;

	}

	// @TODO: Move to TSL

	uv( uvNode ) {

		const textureNode = this.clone();
		textureNode.uvNode = nodeObject( uvNode );
		textureNode.referenceNode = this.getSelf();

		return nodeObject( textureNode );

	}

	blur( amountNode ) {

		const textureNode = this.clone();
		textureNode.biasNode = nodeObject( amountNode ).mul( maxMipLevel( textureNode ) );
		textureNode.referenceNode = this.getSelf();

		return nodeObject( textureNode );

	}

	level( levelNode ) {

		const textureNode = this.clone();
		textureNode.levelNode = nodeObject( levelNode );
		textureNode.referenceNode = this.getSelf();

		return nodeObject( textureNode );

	}

	size( levelNode ) {

		return textureSize( this, levelNode );

	}

	bias( biasNode ) {

		const textureNode = this.clone();
		textureNode.biasNode = nodeObject( biasNode );
		textureNode.referenceNode = this.getSelf();

		return nodeObject( textureNode );

	}

	compare( compareNode ) {

		const textureNode = this.clone();
		textureNode.compareNode = nodeObject( compareNode );
		textureNode.referenceNode = this.getSelf();

		return nodeObject( textureNode );

	}

	grad( gradNodeX, gradNodeY ) {

		const textureNode = this.clone();
		textureNode.gradNode = [ nodeObject( gradNodeX ), nodeObject( gradNodeY ) ];
		textureNode.referenceNode = this.getSelf();

		return nodeObject( textureNode );

	}

	depth( depthNode ) {

		const textureNode = this.clone();
		textureNode.depthNode = nodeObject( depthNode );
		textureNode.referenceNode = this.getSelf();

		return nodeObject( textureNode );

	}

	// --

	serialize( data ) {

		super.serialize( data );

		data.value = this.value.toJSON( data.meta ).uuid;
		data.sampler = this.sampler;
		data.updateMatrix = this.updateMatrix;
		data.updateType = this.updateType;

	}

	deserialize( data ) {

		super.deserialize( data );

		this.value = data.meta.textures[ data.value ];
		this.sampler = data.sampler;
		this.updateMatrix = data.updateMatrix;
		this.updateType = data.updateType;

	}

	update() {

		const texture = this.value;
		const matrixUniform = this._matrixUniform;

		if ( matrixUniform !== null ) matrixUniform.value = texture.matrix;

		if ( texture.matrixAutoUpdate === true ) {

			texture.updateMatrix();

		}

	}

	clone() {

		const newNode = new this.constructor( this.value, this.uvNode, this.levelNode, this.biasNode );
		newNode.sampler = this.sampler;

		return newNode;

	}

}

const texture = /*@__PURE__*/ nodeProxy( TextureNode );
const textureLoad = ( ...params ) => texture( ...params ).setSampler( false );

//export const textureLevel = ( value, uv, level ) => texture( value, uv ).level( level );

const sampler = ( aTexture ) => ( aTexture.isNode === true ? aTexture : texture( aTexture ) ).convert( 'sampler' );

const cameraNear = /*@__PURE__*/ uniform$1( 'float' ).label( 'cameraNear' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.near );
const cameraFar = /*@__PURE__*/ uniform$1( 'float' ).label( 'cameraFar' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.far );
const cameraProjectionMatrix = /*@__PURE__*/ uniform$1( 'mat4' ).label( 'cameraProjectionMatrix' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.projectionMatrix );
const cameraProjectionMatrixInverse = /*@__PURE__*/ uniform$1( 'mat4' ).label( 'cameraProjectionMatrixInverse' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.projectionMatrixInverse );
const cameraViewMatrix = /*@__PURE__*/ uniform$1( 'mat4' ).label( 'cameraViewMatrix' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.matrixWorldInverse );
const cameraWorldMatrix = /*@__PURE__*/ uniform$1( 'mat4' ).label( 'cameraWorldMatrix' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.matrixWorld );
const cameraNormalMatrix = /*@__PURE__*/ uniform$1( 'mat3' ).label( 'cameraNormalMatrix' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.normalMatrix );
const cameraPosition$1 = /*@__PURE__*/ uniform$1( new Vector3() ).label( 'cameraPosition' ).setGroup( renderGroup ).onRenderUpdate( ( { camera }, self ) => self.value.setFromMatrixPosition( camera.matrixWorld ) );

class Object3DNode extends Node {

	static get type() {

		return 'Object3DNode';

	}

	constructor( scope, object3d = null ) {

		super();

		this.scope = scope;
		this.object3d = object3d;

		this.updateType = NodeUpdateType.OBJECT;

		this._uniformNode = new UniformNode( null );

	}

	getNodeType() {

		const scope = this.scope;

		if ( scope === Object3DNode.WORLD_MATRIX ) {

			return 'mat4';

		} else if ( scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION || scope === Object3DNode.DIRECTION || scope === Object3DNode.SCALE ) {

			return 'vec3';

		}

	}

	update( frame ) {

		const object = this.object3d;
		const uniformNode = this._uniformNode;
		const scope = this.scope;

		if ( scope === Object3DNode.WORLD_MATRIX ) {

			uniformNode.value = object.matrixWorld;

		} else if ( scope === Object3DNode.POSITION ) {

			uniformNode.value = uniformNode.value || new Vector3();

			uniformNode.value.setFromMatrixPosition( object.matrixWorld );

		} else if ( scope === Object3DNode.SCALE ) {

			uniformNode.value = uniformNode.value || new Vector3();

			uniformNode.value.setFromMatrixScale( object.matrixWorld );

		} else if ( scope === Object3DNode.DIRECTION ) {

			uniformNode.value = uniformNode.value || new Vector3();

			object.getWorldDirection( uniformNode.value );

		} else if ( scope === Object3DNode.VIEW_POSITION ) {

			const camera = frame.camera;

			uniformNode.value = uniformNode.value || new Vector3();
			uniformNode.value.setFromMatrixPosition( object.matrixWorld );

			uniformNode.value.applyMatrix4( camera.matrixWorldInverse );

		}

	}

	generate( builder ) {

		const scope = this.scope;

		if ( scope === Object3DNode.WORLD_MATRIX ) {

			this._uniformNode.nodeType = 'mat4';

		} else if ( scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION || scope === Object3DNode.DIRECTION || scope === Object3DNode.SCALE ) {

			this._uniformNode.nodeType = 'vec3';

		}

		return this._uniformNode.build( builder );

	}

	serialize( data ) {

		super.serialize( data );

		data.scope = this.scope;

	}

	deserialize( data ) {

		super.deserialize( data );

		this.scope = data.scope;

	}

}

Object3DNode.WORLD_MATRIX = 'worldMatrix';
Object3DNode.POSITION = 'position';
Object3DNode.SCALE = 'scale';
Object3DNode.VIEW_POSITION = 'viewPosition';
Object3DNode.DIRECTION = 'direction';

const objectDirection = /*@__PURE__*/ nodeProxy( Object3DNode, Object3DNode.DIRECTION );
const objectWorldMatrix = /*@__PURE__*/ nodeProxy( Object3DNode, Object3DNode.WORLD_MATRIX );
const objectPosition = /*@__PURE__*/ nodeProxy( Object3DNode, Object3DNode.POSITION );
const objectScale = /*@__PURE__*/ nodeProxy( Object3DNode, Object3DNode.SCALE );
const objectViewPosition = /*@__PURE__*/ nodeProxy( Object3DNode, Object3DNode.VIEW_POSITION );

class ModelNode extends Object3DNode {

	static get type() {

		return 'ModelNode';

	}

	constructor( scope ) {

		super( scope );

	}

	update( frame ) {

		this.object3d = frame.object;

		super.update( frame );

	}

}

const modelDirection = /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.DIRECTION );
const modelWorldMatrix = /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.WORLD_MATRIX );
const modelPosition = /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.POSITION );
const modelScale = /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.SCALE );
const modelViewPosition = /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.VIEW_POSITION );
const modelNormalMatrix = /*@__PURE__*/ uniform$1( new Matrix3() ).onObjectUpdate( ( { object }, self ) => self.value.getNormalMatrix( object.matrixWorld ) );
const modelWorldMatrixInverse = /*@__PURE__*/ uniform$1( new Matrix4() ).onObjectUpdate( ( { object }, self ) => self.value.copy( object.matrixWorld ).invert() );
const modelViewMatrix = /*@__PURE__*/ cameraViewMatrix.mul( modelWorldMatrix ).toVar( 'modelViewMatrix' );

const highPrecisionModelViewMatrix = /*@__PURE__*/ ( Fn$1( ( builder ) => {

	builder.context.isHighPrecisionModelViewMatrix = true;

	return uniform$1( 'mat4' ).onObjectUpdate( ( { object, camera } ) => {

		return object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );

	} );

} ).once() )().toVar( 'highPrecisionModelViewMatrix' );

const highPrecisionModelNormalViewMatrix = /*@__PURE__*/ ( Fn$1( ( builder ) => {

	const isHighPrecisionModelViewMatrix = builder.context.isHighPrecisionModelViewMatrix;

	return uniform$1( 'mat3' ).onObjectUpdate( ( { object, camera } ) => {

		if ( isHighPrecisionModelViewMatrix !== true ) {

			object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );

		}

		return object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

	} );

} ).once() )().toVar( 'highPrecisionModelNormalMatrix' );

const positionGeometry = /*@__PURE__*/ attribute$1( 'position', 'vec3' );
const positionLocal$1 = /*@__PURE__*/ positionGeometry.varying( 'positionLocal' );
const positionPrevious = /*@__PURE__*/ positionGeometry.varying( 'positionPrevious' );
const positionWorld$1 = /*@__PURE__*/ modelWorldMatrix.mul( positionLocal$1 ).xyz.varying( 'v_positionWorld' );
const positionWorldDirection = /*@__PURE__*/ positionLocal$1.transformDirection( modelWorldMatrix ).varying( 'v_positionWorldDirection' ).normalize().toVar( 'positionWorldDirection' );
const positionView$1 = /*@__PURE__*/ modelViewMatrix.mul( positionLocal$1 ).xyz.varying( 'v_positionView' );
const positionViewDirection = /*@__PURE__*/ positionView$1.negate().varying( 'v_positionViewDirection' ).normalize().toVar( 'positionViewDirection' );

class FrontFacingNode extends Node {

	static get type() {

		return 'FrontFacingNode';

	}

	constructor() {

		super( 'bool' );

		this.isFrontFacingNode = true;

	}

	generate( builder ) {

		const { renderer, material } = builder;

		if ( renderer.coordinateSystem === WebGLCoordinateSystem ) {

			if ( material.side === BackSide ) {

				return 'false';

			}

		}

		return builder.getFrontFacing();

	}

}

const frontFacing = /*@__PURE__*/ nodeImmutable( FrontFacingNode );
const faceDirection = /*@__PURE__*/ float$1( frontFacing ).mul( 2.0 ).sub( 1.0 );

const normalGeometry = /*@__PURE__*/ attribute$1( 'normal', 'vec3' );

const normalLocal = /*@__PURE__*/ ( Fn$1( ( builder ) => {

	if ( builder.geometry.hasAttribute( 'normal' ) === false ) {

		console.warn( 'TSL.NormalNode: Vertex attribute "normal" not found on geometry.' );

		return vec3$1( 0, 1, 0 );

	}

	return normalGeometry;

}, 'vec3' ).once() )().toVar( 'normalLocal' );

const normalFlat = /*@__PURE__*/ positionView$1.dFdx().cross( positionView$1.dFdy() ).normalize().toVar( 'normalFlat' );

const normalView$1 = /*@__PURE__*/ ( Fn$1( ( builder ) => {

	let node;

	if ( builder.material.flatShading === true ) {

		node = normalFlat;

	} else {

		node = varying( transformNormalToView( normalLocal ), 'v_normalView' ).normalize();

	}

	return node;

}, 'vec3' ).once() )().toVar( 'normalView' );

const normalWorld$1 = /*@__PURE__*/ varying( normalView$1.transformDirection( cameraViewMatrix ), 'v_normalWorld' ).normalize().toVar( 'normalWorld' );

const transformedNormalView = /*@__PURE__*/ ( Fn$1( ( builder ) => {

	return builder.context.setupNormal();

}, 'vec3' ).once() )().mul( faceDirection ).toVar( 'transformedNormalView' );


const transformedNormalWorld = /*@__PURE__*/ transformedNormalView.transformDirection( cameraViewMatrix ).toVar( 'transformedNormalWorld' );

const transformedClearcoatNormalView = /*@__PURE__*/ ( Fn$1( ( builder ) => {

	return builder.context.setupClearcoatNormal();

}, 'vec3' ).once() )().mul( faceDirection ).toVar( 'transformedClearcoatNormalView' );

const transformNormal = /*@__PURE__*/ Fn$1( ( [ normal, matrix = modelWorldMatrix ] ) => {

	const m = mat3( matrix );

	const transformedNormal = normal.div( vec3$1( m[ 0 ].dot( m[ 0 ] ), m[ 1 ].dot( m[ 1 ] ), m[ 2 ].dot( m[ 2 ] ) ) );

	return m.mul( transformedNormal ).xyz;

} );

const transformNormalToView = /*@__PURE__*/ Fn$1( ( [ normal ], builder ) => {

	const modelNormalViewMatrix = builder.renderer.nodes.modelNormalViewMatrix;

	if ( modelNormalViewMatrix !== null ) {

		return modelNormalViewMatrix.transformDirection( normal );

	}

	//

	const transformedNormal = modelNormalMatrix.mul( normal );

	return cameraViewMatrix.transformDirection( transformedNormal );

} );

const materialRefractionRatio = /*@__PURE__*/ uniform$1( 0 ).onReference( ( { material } ) => material ).onRenderUpdate( ( { material } ) => material.refractionRatio );

const reflectView = /*@__PURE__*/ positionViewDirection.negate().reflect( transformedNormalView );
const refractView = /*@__PURE__*/ positionViewDirection.negate().refract( transformedNormalView, materialRefractionRatio );

const reflectVector = /*@__PURE__*/ reflectView.transformDirection( cameraViewMatrix ).toVar( 'reflectVector' );
const refractVector = /*@__PURE__*/ refractView.transformDirection( cameraViewMatrix ).toVar( 'reflectVector' );

class CubeTextureNode extends TextureNode {

	static get type() {

		return 'CubeTextureNode';

	}

	constructor( value, uvNode = null, levelNode = null, biasNode = null ) {

		super( value, uvNode, levelNode, biasNode );

		this.isCubeTextureNode = true;

	}

	getInputType( /*builder*/ ) {

		return 'cubeTexture';

	}

	getDefaultUV() {

		const texture = this.value;

		if ( texture.mapping === CubeReflectionMapping ) {

			return reflectVector;

		} else if ( texture.mapping === CubeRefractionMapping ) {

			return refractVector;

		} else {

			console.error( 'THREE.CubeTextureNode: Mapping "%s" not supported.', texture.mapping );

			return vec3$1( 0, 0, 0 );

		}

	}

	setUpdateMatrix( /*updateMatrix*/ ) { } // Ignore .updateMatrix for CubeTextureNode

	setupUV( builder, uvNode ) {

		const texture = this.value;

		if ( builder.renderer.coordinateSystem === WebGPUCoordinateSystem || ! texture.isRenderTargetTexture ) {

			return vec3$1( uvNode.x.negate(), uvNode.yz );

		} else {

			return uvNode;

		}

	}

	generateUV( builder, cubeUV ) {

		return cubeUV.build( builder, 'vec3' );

	}

}

const cubeTexture = /*@__PURE__*/ nodeProxy( CubeTextureNode );

class BufferNode extends UniformNode {

	static get type() {

		return 'BufferNode';

	}

	constructor( value, bufferType, bufferCount = 0 ) {

		super( value, bufferType );

		this.isBufferNode = true;

		this.bufferType = bufferType;
		this.bufferCount = bufferCount;

	}

	getElementType( builder ) {

		return this.getNodeType( builder );

	}

	getInputType( /*builder*/ ) {

		return 'buffer';

	}

}

const buffer = ( value, type, count ) => nodeObject( new BufferNode( value, type, count ) );

class UniformArrayElementNode extends ArrayElementNode {

	static get type() {

		return 'UniformArrayElementNode';

	}

	constructor( arrayBuffer, indexNode ) {

		super( arrayBuffer, indexNode );

		this.isArrayBufferElementNode = true;

	}

	generate( builder ) {

		const snippet = super.generate( builder );
		const type = this.getNodeType();

		return builder.format( snippet, 'vec4', type );

	}

}

class UniformArrayNode extends BufferNode {

	static get type() {

		return 'UniformArrayNode';

	}

	constructor( value, elementType = null ) {

		super( null, 'vec4' );

		this.array = value;
		this.elementType = elementType;

		this._elementType = null;
		this._elementLength = 0;

		this.updateType = NodeUpdateType.RENDER;

		this.isArrayBufferNode = true;

	}

	getElementType() {

		return this.elementType || this._elementType;

	}

	getElementLength() {

		return this._elementLength;

	}

	update( /*frame*/ ) {

		const { array, value } = this;

		const elementLength = this.getElementLength();
		const elementType = this.getElementType();

		if ( elementLength === 1 ) {

			for ( let i = 0; i < array.length; i ++ ) {

				const index = i * 4;

				value[ index ] = array[ i ];

			}

		} else if ( elementType === 'color' ) {

			for ( let i = 0; i < array.length; i ++ ) {

				const index = i * 4;
				const vector = array[ i ];

				value[ index ] = vector.r;
				value[ index + 1 ] = vector.g;
				value[ index + 2 ] = vector.b || 0;
				//value[ index + 3 ] = vector.a || 0;

			}

		} else {

			for ( let i = 0; i < array.length; i ++ ) {

				const index = i * 4;
				const vector = array[ i ];

				value[ index ] = vector.x;
				value[ index + 1 ] = vector.y;
				value[ index + 2 ] = vector.z || 0;
				value[ index + 3 ] = vector.w || 0;

			}

		}

	}

	setup( builder ) {

		const length = this.array.length;

		this._elementType = this.elementType === null ? getValueType( this.array[ 0 ] ) : this.elementType;
		this._elementLength = builder.getTypeLength( this._elementType );

		let arrayType = Float32Array;

		if ( this._elementType.charAt( 0 ) === 'i' ) arrayType = Int32Array;
		else if ( this._elementType.charAt( 0 ) === 'u' ) arrayType = Uint32Array;

		this.value = new arrayType( length * 4 );
		this.bufferCount = length;
		this.bufferType = builder.changeComponentType( 'vec4', builder.getComponentType( this._elementType ) );

		return super.setup( builder );

	}

	element( indexNode ) {

		return nodeObject( new UniformArrayElementNode( this, nodeObject( indexNode ) ) );

	}

}

const uniformArray = ( values, nodeType ) => nodeObject( new UniformArrayNode( values, nodeType ) );

//

const uniforms = ( values, nodeType ) => { // @deprecated, r168

	console.warn( 'TSL.UniformArrayNode: uniforms() has been renamed to uniformArray().' );
	return nodeObject( new UniformArrayNode( values, nodeType ) );

};

class ReferenceElementNode extends ArrayElementNode {

	static get type() {

		return 'ReferenceElementNode';

	}

	constructor( referenceNode, indexNode ) {

		super( referenceNode, indexNode );

		this.referenceNode = referenceNode;

		this.isReferenceElementNode = true;

	}

	getNodeType() {

		return this.referenceNode.uniformType;

	}

	generate( builder ) {

		const snippet = super.generate( builder );
		const arrayType = this.referenceNode.getNodeType();
		const elementType = this.getNodeType();

		return builder.format( snippet, arrayType, elementType );

	}

}

// TODO: Extends this from ReferenceBaseNode
class ReferenceNode extends Node {

	static get type() {

		return 'ReferenceNode';

	}

	constructor( property, uniformType, object = null, count = null ) {

		super();

		this.property = property;
		this.uniformType = uniformType;
		this.object = object;
		this.count = count;

		this.properties = property.split( '.' );
		this.reference = object;
		this.node = null;
		this.group = null;
		this.name = null;

		this.updateType = NodeUpdateType.OBJECT;

	}

	element( indexNode ) {

		return nodeObject( new ReferenceElementNode( this, nodeObject( indexNode ) ) );

	}

	setGroup( group ) {

		this.group = group;

		return this;

	}

	label( name ) {

		this.name = name;

		return this;

	}

	setNodeType( uniformType ) {

		let node = null;

		if ( this.count !== null ) {

			node = buffer( null, uniformType, this.count );

		} else if ( Array.isArray( this.getValueFromReference() ) ) {

			node = uniformArray( null, uniformType );

		} else if ( uniformType === 'texture' ) {

			node = texture( null );

		} else if ( uniformType === 'cubeTexture' ) {

			node = cubeTexture( null );

		} else {

			node = uniform$1( null, uniformType );

		}

		if ( this.group !== null ) {

			node.setGroup( this.group );

		}

		if ( this.name !== null ) node.label( this.name );

		this.node = node.getSelf();

	}

	getNodeType( builder ) {

		if ( this.node === null ) {

			this.updateReference( builder );
			this.updateValue();

		}

		return this.node.getNodeType( builder );

	}

	getValueFromReference( object = this.reference ) {

		const { properties } = this;

		let value = object[ properties[ 0 ] ];

		for ( let i = 1; i < properties.length; i ++ ) {

			value = value[ properties[ i ] ];

		}

		return value;

	}

	updateReference( state ) {

		this.reference = this.object !== null ? this.object : state.object;

		return this.reference;

	}

	setup() {

		this.updateValue();

		return this.node;

	}

	update( /*frame*/ ) {

		this.updateValue();

	}

	updateValue() {

		if ( this.node === null ) this.setNodeType( this.uniformType );

		const value = this.getValueFromReference();

		if ( Array.isArray( value ) ) {

			this.node.array = value;

		} else {

			this.node.value = value;

		}

	}

}

const reference = ( name, type, object ) => nodeObject( new ReferenceNode( name, type, object ) );
const referenceBuffer = ( name, type, count, object ) => nodeObject( new ReferenceNode( name, type, object, count ) );

class MaterialReferenceNode extends ReferenceNode {

	static get type() {

		return 'MaterialReferenceNode';

	}

	constructor( property, inputType, material = null ) {

		super( property, inputType, material );

		this.material = material;

		//this.updateType = NodeUpdateType.RENDER;

		this.isMaterialReferenceNode = true;

	}

	/*setNodeType( node ) {

		super.setNodeType( node );

		this.node.groupNode = renderGroup;

	}*/

	updateReference( state ) {

		this.reference = this.material !== null ? this.material : state.material;

		return this.reference;

	}

}

const materialReference = ( name, type, material ) => nodeObject( new MaterialReferenceNode( name, type, material ) );

const tangentGeometry = /*@__PURE__*/ Fn$1( ( builder ) => {

	if ( builder.geometry.hasAttribute( 'tangent' ) === false ) {

		builder.geometry.computeTangents();

	}

	return attribute$1( 'tangent', 'vec4' );

} )();

const tangentLocal = /*@__PURE__*/ tangentGeometry.xyz.toVar( 'tangentLocal' );
const tangentView = /*@__PURE__*/ modelViewMatrix.mul( vec4$1( tangentLocal, 0 ) ).xyz.varying( 'v_tangentView' ).normalize().toVar( 'tangentView' );
const tangentWorld = /*@__PURE__*/ tangentView.transformDirection( cameraViewMatrix ).varying( 'v_tangentWorld' ).normalize().toVar( 'tangentWorld' );
const transformedTangentView = /*@__PURE__*/ tangentView.toVar( 'transformedTangentView' );
const transformedTangentWorld = /*@__PURE__*/ transformedTangentView.transformDirection( cameraViewMatrix ).normalize().toVar( 'transformedTangentWorld' );

const getBitangent = ( crossNormalTangent ) => crossNormalTangent.mul( tangentGeometry.w ).xyz;

const bitangentGeometry = /*@__PURE__*/ varying( getBitangent( normalGeometry.cross( tangentGeometry ) ), 'v_bitangentGeometry' ).normalize().toVar( 'bitangentGeometry' );
const bitangentLocal = /*@__PURE__*/ varying( getBitangent( normalLocal.cross( tangentLocal ) ), 'v_bitangentLocal' ).normalize().toVar( 'bitangentLocal' );
const bitangentView = /*@__PURE__*/ varying( getBitangent( normalView$1.cross( tangentView ) ), 'v_bitangentView' ).normalize().toVar( 'bitangentView' );
const bitangentWorld = /*@__PURE__*/ varying( getBitangent( normalWorld$1.cross( tangentWorld ) ), 'v_bitangentWorld' ).normalize().toVar( 'bitangentWorld' );
const transformedBitangentView = /*@__PURE__*/ getBitangent( transformedNormalView.cross( transformedTangentView ) ).normalize().toVar( 'transformedBitangentView' );
const transformedBitangentWorld = /*@__PURE__*/ transformedBitangentView.transformDirection( cameraViewMatrix ).normalize().toVar( 'transformedBitangentWorld' );

const TBNViewMatrix = /*@__PURE__*/ mat3( tangentView, bitangentView, normalView$1 );

const parallaxDirection = /*@__PURE__*/ positionViewDirection.mul( TBNViewMatrix )/*.normalize()*/;
const parallaxUV = ( uv, scale ) => uv.sub( parallaxDirection.mul( scale ) );

const transformedBentNormalView = /*@__PURE__*/ ( () => {

	// https://google.github.io/filament/Filament.md.html#lighting/imagebasedlights/anisotropy

	let bentNormal = anisotropyB.cross( positionViewDirection );
	bentNormal = bentNormal.cross( anisotropyB ).normalize();
	bentNormal = mix$1( bentNormal, transformedNormalView, anisotropy.mul( roughness.oneMinus() ).oneMinus().pow2().pow2() ).normalize();

	return bentNormal;


} )();

// Normal Mapping Without Precomputed Tangents
// http://www.thetenthplanet.de/archives/1180

const perturbNormal2Arb = /*@__PURE__*/ Fn$1( ( inputs ) => {

	const { eye_pos, surf_norm, mapN, uv } = inputs;

	const q0 = eye_pos.dFdx();
	const q1 = eye_pos.dFdy();
	const st0 = uv.dFdx();
	const st1 = uv.dFdy();

	const N = surf_norm; // normalized

	const q1perp = q1.cross( N );
	const q0perp = N.cross( q0 );

	const T = q1perp.mul( st0.x ).add( q0perp.mul( st1.x ) );
	const B = q1perp.mul( st0.y ).add( q0perp.mul( st1.y ) );

	const det = T.dot( T ).max( B.dot( B ) );
	const scale = faceDirection.mul( det.inverseSqrt() );

	return add$1( T.mul( mapN.x, scale ), B.mul( mapN.y, scale ), N.mul( mapN.z ) ).normalize();

} );

class NormalMapNode extends TempNode {

	static get type() {

		return 'NormalMapNode';

	}

	constructor( node, scaleNode = null ) {

		super( 'vec3' );

		this.node = node;
		this.scaleNode = scaleNode;

		this.normalMapType = TangentSpaceNormalMap;

	}

	setup( builder ) {

		const { normalMapType, scaleNode } = this;

		let normalMap = this.node.mul( 2.0 ).sub( 1.0 );

		if ( scaleNode !== null ) {

			normalMap = vec3$1( normalMap.xy.mul( scaleNode ), normalMap.z );

		}

		let outputNode = null;

		if ( normalMapType === ObjectSpaceNormalMap ) {

			outputNode = transformNormalToView( normalMap );

		} else if ( normalMapType === TangentSpaceNormalMap ) {

			const tangent = builder.hasGeometryAttribute( 'tangent' );

			if ( tangent === true ) {

				outputNode = TBNViewMatrix.mul( normalMap ).normalize();

			} else {

				outputNode = perturbNormal2Arb( {
					eye_pos: positionView$1,
					surf_norm: normalView$1,
					mapN: normalMap,
					uv: uv$1()
				} );

			}

		}

		return outputNode;

	}

}

const normalMap = /*@__PURE__*/ nodeProxy( NormalMapNode );

// Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen
// https://mmikk.github.io/papers3d/mm_sfgrad_bump.pdf

const dHdxy_fwd = Fn$1( ( { textureNode, bumpScale } ) => {

	// It's used to preserve the same TextureNode instance
	const sampleTexture = ( callback ) => textureNode.cache().context( { getUV: ( texNode ) => callback( texNode.uvNode || uv$1() ), forceUVContext: true } );

	const Hll = float$1( sampleTexture( ( uvNode ) => uvNode ) );

	return vec2$1(
		float$1( sampleTexture( ( uvNode ) => uvNode.add( uvNode.dFdx() ) ) ).sub( Hll ),
		float$1( sampleTexture( ( uvNode ) => uvNode.add( uvNode.dFdy() ) ) ).sub( Hll )
	).mul( bumpScale );

} );

// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)

const perturbNormalArb = Fn$1( ( inputs ) => {

	const { surf_pos, surf_norm, dHdxy } = inputs;

	// normalize is done to ensure that the bump map looks the same regardless of the texture's scale
	const vSigmaX = surf_pos.dFdx().normalize();
	const vSigmaY = surf_pos.dFdy().normalize();
	const vN = surf_norm; // normalized

	const R1 = vSigmaY.cross( vN );
	const R2 = vN.cross( vSigmaX );

	const fDet = vSigmaX.dot( R1 ).mul( faceDirection );

	const vGrad = fDet.sign().mul( dHdxy.x.mul( R1 ).add( dHdxy.y.mul( R2 ) ) );

	return fDet.abs().mul( surf_norm ).sub( vGrad ).normalize();

} );

class BumpMapNode extends TempNode {

	static get type() {

		return 'BumpMapNode';

	}

	constructor( textureNode, scaleNode = null ) {

		super( 'vec3' );

		this.textureNode = textureNode;
		this.scaleNode = scaleNode;

	}

	setup() {

		const bumpScale = this.scaleNode !== null ? this.scaleNode : 1;
		const dHdxy = dHdxy_fwd( { textureNode: this.textureNode, bumpScale } );

		return perturbNormalArb( {
			surf_pos: positionView$1,
			surf_norm: normalView$1,
			dHdxy
		} );

	}

}

const bumpMap = /*@__PURE__*/ nodeProxy( BumpMapNode );

const _propertyCache = new Map();

class MaterialNode extends Node {

	static get type() {

		return 'MaterialNode';

	}

	constructor( scope ) {

		super();

		this.scope = scope;

	}

	getCache( property, type ) {

		let node = _propertyCache.get( property );

		if ( node === undefined ) {

			node = materialReference( property, type );

			_propertyCache.set( property, node );

		}

		return node;

	}

	getFloat( property ) {

		return this.getCache( property, 'float' );

	}

	getColor( property ) {

		return this.getCache( property, 'color' );

	}

	getTexture( property ) {

		return this.getCache( property === 'map' ? 'map' : property + 'Map', 'texture' );

	}

	setup( builder ) {

		const material = builder.context.material;
		const scope = this.scope;

		let node = null;

		if ( scope === MaterialNode.COLOR ) {

			const colorNode = material.color !== undefined ? this.getColor( scope ) : vec3$1();

			if ( material.map && material.map.isTexture === true ) {

				node = colorNode.mul( this.getTexture( 'map' ) );

			} else {

				node = colorNode;

			}

		} else if ( scope === MaterialNode.OPACITY ) {

			const opacityNode = this.getFloat( scope );

			if ( material.alphaMap && material.alphaMap.isTexture === true ) {

				node = opacityNode.mul( this.getTexture( 'alpha' ) );

			} else {

				node = opacityNode;

			}

		} else if ( scope === MaterialNode.SPECULAR_STRENGTH ) {

			if ( material.specularMap && material.specularMap.isTexture === true ) {

				node = this.getTexture( 'specular' ).r;

			} else {

				node = float$1( 1 );

			}

		} else if ( scope === MaterialNode.SPECULAR_INTENSITY ) {

			const specularIntensity = this.getFloat( scope );

			if ( material.specularMap ) {

				node = specularIntensity.mul( this.getTexture( scope ).a );

			} else {

				node = specularIntensity;

			}

		} else if ( scope === MaterialNode.SPECULAR_COLOR ) {

			const specularColorNode = this.getColor( scope );

			if ( material.specularColorMap && material.specularColorMap.isTexture === true ) {

				node = specularColorNode.mul( this.getTexture( scope ).rgb );

			} else {

				node = specularColorNode;

			}

		} else if ( scope === MaterialNode.ROUGHNESS ) { // TODO: cleanup similar branches

			const roughnessNode = this.getFloat( scope );

			if ( material.roughnessMap && material.roughnessMap.isTexture === true ) {

				node = roughnessNode.mul( this.getTexture( scope ).g );

			} else {

				node = roughnessNode;

			}

		} else if ( scope === MaterialNode.METALNESS ) {

			const metalnessNode = this.getFloat( scope );

			if ( material.metalnessMap && material.metalnessMap.isTexture === true ) {

				node = metalnessNode.mul( this.getTexture( scope ).b );

			} else {

				node = metalnessNode;

			}

		} else if ( scope === MaterialNode.EMISSIVE ) {

			const emissiveIntensityNode = this.getFloat( 'emissiveIntensity' );
			const emissiveNode = this.getColor( scope ).mul( emissiveIntensityNode );

			if ( material.emissiveMap && material.emissiveMap.isTexture === true ) {

				node = emissiveNode.mul( this.getTexture( scope ) );

			} else {

				node = emissiveNode;

			}

		} else if ( scope === MaterialNode.NORMAL ) {

			if ( material.normalMap ) {

				node = normalMap( this.getTexture( 'normal' ), this.getCache( 'normalScale', 'vec2' ) );
				node.normalMapType = material.normalMapType;

			} else if ( material.bumpMap ) {

				node = bumpMap( this.getTexture( 'bump' ).r, this.getFloat( 'bumpScale' ) );

			} else {

				node = normalView$1;

			}

		} else if ( scope === MaterialNode.CLEARCOAT ) {

			const clearcoatNode = this.getFloat( scope );

			if ( material.clearcoatMap && material.clearcoatMap.isTexture === true ) {

				node = clearcoatNode.mul( this.getTexture( scope ).r );

			} else {

				node = clearcoatNode;

			}

		} else if ( scope === MaterialNode.CLEARCOAT_ROUGHNESS ) {

			const clearcoatRoughnessNode = this.getFloat( scope );

			if ( material.clearcoatRoughnessMap && material.clearcoatRoughnessMap.isTexture === true ) {

				node = clearcoatRoughnessNode.mul( this.getTexture( scope ).r );

			} else {

				node = clearcoatRoughnessNode;

			}

		} else if ( scope === MaterialNode.CLEARCOAT_NORMAL ) {

			if ( material.clearcoatNormalMap ) {

				node = normalMap( this.getTexture( scope ), this.getCache( scope + 'Scale', 'vec2' ) );

			} else {

				node = normalView$1;

			}

		} else if ( scope === MaterialNode.SHEEN ) {

			const sheenNode = this.getColor( 'sheenColor' ).mul( this.getFloat( 'sheen' ) ); // Move this mul() to CPU

			if ( material.sheenColorMap && material.sheenColorMap.isTexture === true ) {

				node = sheenNode.mul( this.getTexture( 'sheenColor' ).rgb );

			} else {

				node = sheenNode;

			}

		} else if ( scope === MaterialNode.SHEEN_ROUGHNESS ) {

			const sheenRoughnessNode = this.getFloat( scope );

			if ( material.sheenRoughnessMap && material.sheenRoughnessMap.isTexture === true ) {

				node = sheenRoughnessNode.mul( this.getTexture( scope ).a );

			} else {

				node = sheenRoughnessNode;

			}

			node = node.clamp( 0.07, 1.0 );

		} else if ( scope === MaterialNode.ANISOTROPY ) {

			if ( material.anisotropyMap && material.anisotropyMap.isTexture === true ) {

				const anisotropyPolar = this.getTexture( scope );
				const anisotropyMat = mat2( materialAnisotropyVector.x, materialAnisotropyVector.y, materialAnisotropyVector.y.negate(), materialAnisotropyVector.x );

				node = anisotropyMat.mul( anisotropyPolar.rg.mul( 2.0 ).sub( vec2$1( 1.0 ) ).normalize().mul( anisotropyPolar.b ) );

			} else {

				node = materialAnisotropyVector;

			}

		} else if ( scope === MaterialNode.IRIDESCENCE_THICKNESS ) {

			const iridescenceThicknessMaximum = reference( '1', 'float', material.iridescenceThicknessRange );

			if ( material.iridescenceThicknessMap ) {

				const iridescenceThicknessMinimum = reference( '0', 'float', material.iridescenceThicknessRange );

				node = iridescenceThicknessMaximum.sub( iridescenceThicknessMinimum ).mul( this.getTexture( scope ).g ).add( iridescenceThicknessMinimum );

			} else {

				node = iridescenceThicknessMaximum;

			}

		} else if ( scope === MaterialNode.TRANSMISSION ) {

			const transmissionNode = this.getFloat( scope );

			if ( material.transmissionMap ) {

				node = transmissionNode.mul( this.getTexture( scope ).r );

			} else {

				node = transmissionNode;

			}

		} else if ( scope === MaterialNode.THICKNESS ) {

			const thicknessNode = this.getFloat( scope );

			if ( material.thicknessMap ) {

				node = thicknessNode.mul( this.getTexture( scope ).g );

			} else {

				node = thicknessNode;

			}

		} else if ( scope === MaterialNode.IOR ) {

			node = this.getFloat( scope );

		} else if ( scope === MaterialNode.LIGHT_MAP ) {

			node = this.getTexture( scope ).rgb.mul( this.getFloat( 'lightMapIntensity' ) );

		} else if ( scope === MaterialNode.AO_MAP ) {

			node = this.getTexture( scope ).r.sub( 1.0 ).mul( this.getFloat( 'aoMapIntensity' ) ).add( 1.0 );

		} else {

			const outputType = this.getNodeType( builder );

			node = this.getCache( scope, outputType );

		}

		return node;

	}

}

MaterialNode.ALPHA_TEST = 'alphaTest';
MaterialNode.COLOR = 'color';
MaterialNode.OPACITY = 'opacity';
MaterialNode.SHININESS = 'shininess';
MaterialNode.SPECULAR = 'specular';
MaterialNode.SPECULAR_STRENGTH = 'specularStrength';
MaterialNode.SPECULAR_INTENSITY = 'specularIntensity';
MaterialNode.SPECULAR_COLOR = 'specularColor';
MaterialNode.REFLECTIVITY = 'reflectivity';
MaterialNode.ROUGHNESS = 'roughness';
MaterialNode.METALNESS = 'metalness';
MaterialNode.NORMAL = 'normal';
MaterialNode.CLEARCOAT = 'clearcoat';
MaterialNode.CLEARCOAT_ROUGHNESS = 'clearcoatRoughness';
MaterialNode.CLEARCOAT_NORMAL = 'clearcoatNormal';
MaterialNode.EMISSIVE = 'emissive';
MaterialNode.ROTATION = 'rotation';
MaterialNode.SHEEN = 'sheen';
MaterialNode.SHEEN_ROUGHNESS = 'sheenRoughness';
MaterialNode.ANISOTROPY = 'anisotropy';
MaterialNode.IRIDESCENCE = 'iridescence';
MaterialNode.IRIDESCENCE_IOR = 'iridescenceIOR';
MaterialNode.IRIDESCENCE_THICKNESS = 'iridescenceThickness';
MaterialNode.IOR = 'ior';
MaterialNode.TRANSMISSION = 'transmission';
MaterialNode.THICKNESS = 'thickness';
MaterialNode.ATTENUATION_DISTANCE = 'attenuationDistance';
MaterialNode.ATTENUATION_COLOR = 'attenuationColor';
MaterialNode.LINE_SCALE = 'scale';
MaterialNode.LINE_DASH_SIZE = 'dashSize';
MaterialNode.LINE_GAP_SIZE = 'gapSize';
MaterialNode.LINE_WIDTH = 'linewidth';
MaterialNode.LINE_DASH_OFFSET = 'dashOffset';
MaterialNode.POINT_WIDTH = 'pointWidth';
MaterialNode.DISPERSION = 'dispersion';
MaterialNode.LIGHT_MAP = 'light';
MaterialNode.AO_MAP = 'ao';

const materialAlphaTest = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ALPHA_TEST );
const materialColor = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.COLOR );
const materialShininess = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SHININESS );
const materialEmissive = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.EMISSIVE );
const materialOpacity = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.OPACITY );
const materialSpecular = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SPECULAR );

const materialSpecularIntensity = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SPECULAR_INTENSITY );
const materialSpecularColor = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SPECULAR_COLOR );

const materialSpecularStrength = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SPECULAR_STRENGTH );
const materialReflectivity = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.REFLECTIVITY );
const materialRoughness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ROUGHNESS );
const materialMetalness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.METALNESS );
const materialNormal = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.NORMAL ).context( { getUV: null } );
const materialClearcoat = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.CLEARCOAT );
const materialClearcoatRoughness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.CLEARCOAT_ROUGHNESS );
const materialClearcoatNormal = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.CLEARCOAT_NORMAL ).context( { getUV: null } );
const materialRotation = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ROTATION );
const materialSheen = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SHEEN );
const materialSheenRoughness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SHEEN_ROUGHNESS );
const materialAnisotropy = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ANISOTROPY );
const materialIridescence = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.IRIDESCENCE );
const materialIridescenceIOR = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.IRIDESCENCE_IOR );
const materialIridescenceThickness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.IRIDESCENCE_THICKNESS );
const materialTransmission = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.TRANSMISSION );
const materialThickness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.THICKNESS );
const materialIOR = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.IOR );
const materialAttenuationDistance = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ATTENUATION_DISTANCE );
const materialAttenuationColor = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ATTENUATION_COLOR );
const materialLineScale = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LINE_SCALE );
const materialLineDashSize = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LINE_DASH_SIZE );
const materialLineGapSize = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LINE_GAP_SIZE );
const materialLineWidth = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LINE_WIDTH );
const materialLineDashOffset = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LINE_DASH_OFFSET );
const materialPointWidth = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.POINT_WIDTH );
const materialDispersion = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.DISPERSION );
const materialLightMap = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LIGHT_MAP );
const materialAOMap = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.AO_MAP );
const materialAnisotropyVector = /*@__PURE__*/ uniform$1( new Vector2() ).onReference( function ( frame ) {

	return frame.material;

} ).onRenderUpdate( function ( { material } ) {

	this.value.set( material.anisotropy * Math.cos( material.anisotropyRotation ), material.anisotropy * Math.sin( material.anisotropyRotation ) );

} );

class ModelViewProjectionNode extends TempNode {

	static get type() {

		return 'ModelViewProjectionNode';

	}

	constructor( positionNode = null ) {

		super( 'vec4' );

		this.positionNode = positionNode;

	}

	setup( builder ) {

		if ( builder.shaderStage === 'fragment' ) {

			return varying( builder.context.mvp );

		}

		const position = this.positionNode || positionLocal$1;
		const viewMatrix = builder.renderer.nodes.modelViewMatrix || modelViewMatrix;

		return cameraProjectionMatrix.mul( viewMatrix ).mul( position );

	}

}

const modelViewProjection = /*@__PURE__*/ nodeProxy( ModelViewProjectionNode );

class IndexNode extends Node {

	static get type() {

		return 'IndexNode';

	}

	constructor( scope ) {

		super( 'uint' );

		this.scope = scope;

		this.isInstanceIndexNode = true;

	}

	generate( builder ) {

		const nodeType = this.getNodeType( builder );
		const scope = this.scope;

		let propertyName;

		if ( scope === IndexNode.VERTEX ) {

			// The index of a vertex within a mesh.
			propertyName = builder.getVertexIndex();

		} else if ( scope === IndexNode.INSTANCE ) {

			// The index of either a mesh instance or an invocation of a compute shader.
			propertyName = builder.getInstanceIndex();

		} else if ( scope === IndexNode.DRAW ) {

			// The index of a draw call.
			propertyName = builder.getDrawIndex();

		} else if ( scope === IndexNode.INVOCATION_LOCAL ) {

			// The index of a compute invocation within the scope of a workgroup load.
			propertyName = builder.getInvocationLocalIndex();

		} else if ( scope === IndexNode.INVOCATION_SUBGROUP ) {

			// The index of a compute invocation within the scope of a subgroup.
			propertyName = builder.getInvocationSubgroupIndex();

		} else if ( scope === IndexNode.SUBGROUP ) {

			// The index of the subgroup the current compute invocation belongs to.
			propertyName = builder.getSubgroupIndex();

		} else {

			throw new Error( 'THREE.IndexNode: Unknown scope: ' + scope );

		}

		let output;

		if ( builder.shaderStage === 'vertex' || builder.shaderStage === 'compute' ) {

			output = propertyName;

		} else {

			const nodeVarying = varying( this );

			output = nodeVarying.build( builder, nodeType );

		}

		return output;

	}

}

IndexNode.VERTEX = 'vertex';
IndexNode.INSTANCE = 'instance';
IndexNode.SUBGROUP = 'subgroup';
IndexNode.INVOCATION_LOCAL = 'invocationLocal';
IndexNode.INVOCATION_SUBGROUP = 'invocationSubgroup';
IndexNode.DRAW = 'draw';

const vertexIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.VERTEX );
const instanceIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.INSTANCE );
const subgroupIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.SUBGROUP );
const invocationSubgroupIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.INVOCATION_SUBGROUP );
const invocationLocalIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.INVOCATION_LOCAL );
const drawIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.DRAW );

class InstanceNode extends Node {

	static get type() {

		return 'InstanceNode';

	}

	constructor( count, instanceMatrix, instanceColor ) {

		super( 'void' );

		this.count = count;
		this.instanceMatrix = instanceMatrix;
		this.instanceColor = instanceColor;

		this.instanceMatrixNode = null;

		this.instanceColorNode = null;

		this.updateType = NodeUpdateType.FRAME;

		this.buffer = null;
		this.bufferColor = null;

	}

	setup( builder ) {

		const { count, instanceMatrix, instanceColor } = this;

		let { instanceMatrixNode, instanceColorNode } = this;

		if ( instanceMatrixNode === null ) {

			// Both WebGPU and WebGL backends have UBO max limited to 64kb. Matrix count number bigger than 1000 ( 16 * 4 * 1000 = 64kb ) will fallback to attribute.

			if ( count <= 1000 ) {

				instanceMatrixNode = buffer( instanceMatrix.array, 'mat4', Math.max( count, 1 ) ).element( instanceIndex );

			} else {

				const buffer = new InstancedInterleavedBuffer( instanceMatrix.array, 16, 1 );

				this.buffer = buffer;

				const bufferFn = instanceMatrix.usage === DynamicDrawUsage ? instancedDynamicBufferAttribute : instancedBufferAttribute;

				const instanceBuffers = [
					// F.Signature -> bufferAttribute( array, type, stride, offset )
					bufferFn( buffer, 'vec4', 16, 0 ),
					bufferFn( buffer, 'vec4', 16, 4 ),
					bufferFn( buffer, 'vec4', 16, 8 ),
					bufferFn( buffer, 'vec4', 16, 12 )
				];

				instanceMatrixNode = mat4( ...instanceBuffers );

			}

			this.instanceMatrixNode = instanceMatrixNode;

		}

		if ( instanceColor && instanceColorNode === null ) {

			const buffer = new InstancedBufferAttribute( instanceColor.array, 3 );

			const bufferFn = instanceColor.usage === DynamicDrawUsage ? instancedDynamicBufferAttribute : instancedBufferAttribute;

			this.bufferColor = buffer;

			instanceColorNode = vec3$1( bufferFn( buffer, 'vec3', 3, 0 ) );

			this.instanceColorNode = instanceColorNode;

		}

		// POSITION

		const instancePosition = instanceMatrixNode.mul( positionLocal$1 ).xyz;
		positionLocal$1.assign( instancePosition );

		// NORMAL

		if ( builder.hasGeometryAttribute( 'normal' ) ) {

			const instanceNormal = transformNormal( normalLocal, instanceMatrixNode );

			// ASSIGNS

			normalLocal.assign( instanceNormal );

		}

		// COLOR

		if ( this.instanceColorNode !== null ) {

			varyingProperty( 'vec3', 'vInstanceColor' ).assign( this.instanceColorNode );

		}

	}

	update( /*frame*/ ) {

		if ( this.instanceMatrix.usage !== DynamicDrawUsage && this.buffer != null && this.instanceMatrix.version !== this.buffer.version ) {

			this.buffer.version = this.instanceMatrix.version;

		}

		if ( this.instanceColor && this.instanceColor.usage !== DynamicDrawUsage && this.bufferColor != null && this.instanceColor.version !== this.bufferColor.version ) {

			this.bufferColor.version = this.instanceColor.version;

		}

	}

}

const instance = /*@__PURE__*/ nodeProxy( InstanceNode );

class InstancedMeshNode extends InstanceNode {

	static get type() {

		return 'InstancedMeshNode';

	}

	constructor( instanceMesh ) {

		const { count, instanceMatrix, instanceColor } = instanceMesh;

		super( count, instanceMatrix, instanceColor );

		this.instanceMesh = instanceMesh;

	}

}

const instancedMesh = /*@__PURE__*/ nodeProxy( InstancedMeshNode );

class BatchNode extends Node {

	static get type() {

		return 'BatchNode';

	}

	constructor( batchMesh ) {

		super( 'void' );

		this.batchMesh = batchMesh;


		this.batchingIdNode = null;

	}

	setup( builder ) {

		// POSITION

		if ( this.batchingIdNode === null ) {

			if ( builder.getDrawIndex() === null ) {

				this.batchingIdNode = instanceIndex;

			} else {

				this.batchingIdNode = drawIndex;

			}

		}

		const getIndirectIndex = Fn$1( ( [ id ] ) => {

			const size = textureSize( textureLoad( this.batchMesh._indirectTexture ), 0 );
			const x = int( id ).modInt( int( size ) );
			const y = int( id ).div( int( size ) );
			return textureLoad( this.batchMesh._indirectTexture, ivec2( x, y ) ).x;

		} ).setLayout( {
			name: 'getIndirectIndex',
			type: 'uint',
			inputs: [
				{ name: 'id', type: 'int' }
			]
		} );

		const indirectId = getIndirectIndex( int( this.batchingIdNode ) );

		const matricesTexture = this.batchMesh._matricesTexture;

		const size = textureSize( textureLoad( matricesTexture ), 0 );
		const j = float$1( indirectId ).mul( 4 ).toInt().toVar();

		const x = j.modInt( size );
		const y = j.div( int( size ) );
		const batchingMatrix = mat4(
			textureLoad( matricesTexture, ivec2( x, y ) ),
			textureLoad( matricesTexture, ivec2( x.add( 1 ), y ) ),
			textureLoad( matricesTexture, ivec2( x.add( 2 ), y ) ),
			textureLoad( matricesTexture, ivec2( x.add( 3 ), y ) )
		);


		const colorsTexture = this.batchMesh._colorsTexture;

		if ( colorsTexture !== null ) {

			const getBatchingColor = Fn$1( ( [ id ] ) => {

				const size = textureSize( textureLoad( colorsTexture ), 0 ).x;
				const j = id;
				const x = j.modInt( size );
				const y = j.div( size );
				return textureLoad( colorsTexture, ivec2( x, y ) ).rgb;

			} ).setLayout( {
				name: 'getBatchingColor',
				type: 'vec3',
				inputs: [
					{ name: 'id', type: 'int' }
				]
			} );

			const color = getBatchingColor( indirectId );

			varyingProperty( 'vec3', 'vBatchColor' ).assign( color );

		}

		const bm = mat3( batchingMatrix );

		positionLocal$1.assign( batchingMatrix.mul( positionLocal$1 ) );

		const transformedNormal = normalLocal.div( vec3$1( bm[ 0 ].dot( bm[ 0 ] ), bm[ 1 ].dot( bm[ 1 ] ), bm[ 2 ].dot( bm[ 2 ] ) ) );

		const batchingNormal = bm.mul( transformedNormal ).xyz;

		normalLocal.assign( batchingNormal );

		if ( builder.hasGeometryAttribute( 'tangent' ) ) {

			tangentLocal.mulAssign( bm );

		}

	}

}

const batch = /*@__PURE__*/ nodeProxy( BatchNode );

const _frameId = new WeakMap();

class SkinningNode extends Node {

	static get type() {

		return 'SkinningNode';

	}

	constructor( skinnedMesh, useReference = false ) {

		super( 'void' );

		this.skinnedMesh = skinnedMesh;
		this.useReference = useReference;

		this.updateType = NodeUpdateType.OBJECT;

		//

		this.skinIndexNode = attribute$1( 'skinIndex', 'uvec4' );
		this.skinWeightNode = attribute$1( 'skinWeight', 'vec4' );

		let bindMatrixNode, bindMatrixInverseNode, boneMatricesNode;

		if ( useReference ) {

			bindMatrixNode = reference( 'bindMatrix', 'mat4' );
			bindMatrixInverseNode = reference( 'bindMatrixInverse', 'mat4' );
			boneMatricesNode = referenceBuffer( 'skeleton.boneMatrices', 'mat4', skinnedMesh.skeleton.bones.length );

		} else {

			bindMatrixNode = uniform$1( skinnedMesh.bindMatrix, 'mat4' );
			bindMatrixInverseNode = uniform$1( skinnedMesh.bindMatrixInverse, 'mat4' );
			boneMatricesNode = buffer( skinnedMesh.skeleton.boneMatrices, 'mat4', skinnedMesh.skeleton.bones.length );

		}

		this.bindMatrixNode = bindMatrixNode;
		this.bindMatrixInverseNode = bindMatrixInverseNode;
		this.boneMatricesNode = boneMatricesNode;
		this.previousBoneMatricesNode = null;

	}

	getSkinnedPosition( boneMatrices = this.boneMatricesNode, position = positionLocal$1 ) {

		const { skinIndexNode, skinWeightNode, bindMatrixNode, bindMatrixInverseNode } = this;

		const boneMatX = boneMatrices.element( skinIndexNode.x );
		const boneMatY = boneMatrices.element( skinIndexNode.y );
		const boneMatZ = boneMatrices.element( skinIndexNode.z );
		const boneMatW = boneMatrices.element( skinIndexNode.w );

		// POSITION

		const skinVertex = bindMatrixNode.mul( position );

		const skinned = add$1(
			boneMatX.mul( skinWeightNode.x ).mul( skinVertex ),
			boneMatY.mul( skinWeightNode.y ).mul( skinVertex ),
			boneMatZ.mul( skinWeightNode.z ).mul( skinVertex ),
			boneMatW.mul( skinWeightNode.w ).mul( skinVertex )
		);

		return bindMatrixInverseNode.mul( skinned ).xyz;

	}

	getSkinnedNormal( boneMatrices = this.boneMatricesNode, normal = normalLocal ) {

		const { skinIndexNode, skinWeightNode, bindMatrixNode, bindMatrixInverseNode } = this;

		const boneMatX = boneMatrices.element( skinIndexNode.x );
		const boneMatY = boneMatrices.element( skinIndexNode.y );
		const boneMatZ = boneMatrices.element( skinIndexNode.z );
		const boneMatW = boneMatrices.element( skinIndexNode.w );

		// NORMAL

		let skinMatrix = add$1(
			skinWeightNode.x.mul( boneMatX ),
			skinWeightNode.y.mul( boneMatY ),
			skinWeightNode.z.mul( boneMatZ ),
			skinWeightNode.w.mul( boneMatW )
		);

		skinMatrix = bindMatrixInverseNode.mul( skinMatrix ).mul( bindMatrixNode );

		return skinMatrix.transformDirection( normal ).xyz;

	}

	getPreviousSkinnedPosition( builder ) {

		const skinnedMesh = builder.object;

		if ( this.previousBoneMatricesNode === null ) {

			skinnedMesh.skeleton.previousBoneMatrices = new Float32Array( skinnedMesh.skeleton.boneMatrices );

			this.previousBoneMatricesNode = referenceBuffer( 'skeleton.previousBoneMatrices', 'mat4', skinnedMesh.skeleton.bones.length );

		}

		return this.getSkinnedPosition( this.previousBoneMatricesNode, positionPrevious );

	}

	needsPreviousBoneMatrices( builder ) {

		const mrt = builder.renderer.getMRT();

		return mrt && mrt.has( 'velocity' );

	}

	setup( builder ) {

		if ( this.needsPreviousBoneMatrices( builder ) ) {

			positionPrevious.assign( this.getPreviousSkinnedPosition( builder ) );

		}

		const skinPosition = this.getSkinnedPosition();


		positionLocal$1.assign( skinPosition );

		if ( builder.hasGeometryAttribute( 'normal' ) ) {

			const skinNormal = this.getSkinnedNormal();

			normalLocal.assign( skinNormal );

			if ( builder.hasGeometryAttribute( 'tangent' ) ) {

				tangentLocal.assign( skinNormal );

			}

		}

	}

	generate( builder, output ) {

		if ( output !== 'void' ) {

			return positionLocal$1.build( builder, output );

		}

	}

	update( frame ) {

		const object = this.useReference ? frame.object : this.skinnedMesh;
		const skeleton = object.skeleton;

		if ( _frameId.get( skeleton ) === frame.frameId ) return;

		_frameId.set( skeleton, frame.frameId );

		if ( this.previousBoneMatricesNode !== null ) skeleton.previousBoneMatrices.set( skeleton.boneMatrices );

		skeleton.update();

	}

}

const skinning = ( skinnedMesh ) => nodeObject( new SkinningNode( skinnedMesh ) );
const skinningReference = ( skinnedMesh ) => nodeObject( new SkinningNode( skinnedMesh, true ) );

class LoopNode extends Node {

	static get type() {

		return 'LoopNode';

	}

	constructor( params = [] ) {

		super();

		this.params = params;

	}

	getVarName( index ) {

		return String.fromCharCode( 'i'.charCodeAt() + index );

	}

	getProperties( builder ) {

		const properties = builder.getNodeProperties( this );

		if ( properties.stackNode !== undefined ) return properties;

		//

		const inputs = {};

		for ( let i = 0, l = this.params.length - 1; i < l; i ++ ) {

			const param = this.params[ i ];

			const name = ( param.isNode !== true && param.name ) || this.getVarName( i );
			const type = ( param.isNode !== true && param.type ) || 'int';

			inputs[ name ] = expression( name, type );

		}

		const stack = builder.addStack(); // TODO: cache() it

		properties.returnsNode = this.params[ this.params.length - 1 ]( inputs, stack, builder );
		properties.stackNode = stack;

		builder.removeStack();

		return properties;

	}

	getNodeType( builder ) {

		const { returnsNode } = this.getProperties( builder );

		return returnsNode ? returnsNode.getNodeType( builder ) : 'void';

	}

	setup( builder ) {

		// setup properties

		this.getProperties( builder );

	}

	generate( builder ) {

		const properties = this.getProperties( builder );

		const params = this.params;
		const stackNode = properties.stackNode;

		for ( let i = 0, l = params.length - 1; i < l; i ++ ) {

			const param = params[ i ];

			let start = null, end = null, name = null, type = null, condition = null, update = null;

			if ( param.isNode ) {

				type = 'int';
				name = this.getVarName( i );
				start = '0';
				end = param.build( builder, type );
				condition = '<';

			} else {

				type = param.type || 'int';
				name = param.name || this.getVarName( i );
				start = param.start;
				end = param.end;
				condition = param.condition;
				update = param.update;

				if ( typeof start === 'number' ) start = builder.generateConst( type, start );
				else if ( start && start.isNode ) start = start.build( builder, type );

				if ( typeof end === 'number' ) end = builder.generateConst( type, end );
				else if ( end && end.isNode ) end = end.build( builder, type );

				if ( start !== undefined && end === undefined ) {

					start = start + ' - 1';
					end = '0';
					condition = '>=';

				} else if ( end !== undefined && start === undefined ) {

					start = '0';
					condition = '<';

				}

				if ( condition === undefined ) {

					if ( Number( start ) > Number( end ) ) {

						condition = '>=';

					} else {

						condition = '<';

					}

				}

			}

			const internalParam = { start, end};

			//

			const startSnippet = internalParam.start;
			const endSnippet = internalParam.end;

			let declarationSnippet = '';
			let conditionalSnippet = '';
			let updateSnippet = '';

			if ( ! update ) {

				if ( type === 'int' || type === 'uint' ) {

					if ( condition.includes( '<' ) ) update = '++';
					else update = '--';

				} else {

					if ( condition.includes( '<' ) ) update = '+= 1.';
					else update = '-= 1.';

				}

			}

			declarationSnippet += builder.getVar( type, name ) + ' = ' + startSnippet;

			conditionalSnippet += name + ' ' + condition + ' ' + endSnippet;
			updateSnippet += name + ' ' + update;

			const forSnippet = `for ( ${ declarationSnippet }; ${ conditionalSnippet }; ${ updateSnippet } )`;

			builder.addFlowCode( ( i === 0 ? '\n' : '' ) + builder.tab + forSnippet + ' {\n\n' ).addFlowTab();

		}

		const stackSnippet = stackNode.build( builder, 'void' );

		const returnsSnippet = properties.returnsNode ? properties.returnsNode.build( builder ) : '';

		builder.removeFlowTab().addFlowCode( '\n' + builder.tab + stackSnippet );

		for ( let i = 0, l = this.params.length - 1; i < l; i ++ ) {

			builder.addFlowCode( ( i === 0 ? '' : builder.tab ) + '}\n\n' ).removeFlowTab();

		}

		builder.addFlowTab();

		return returnsSnippet;

	}

}

const Loop = ( ...params ) => nodeObject( new LoopNode( nodeArray( params, 'int' ) ) ).append();
const Continue = () => expression( 'continue' ).append();
const Break = () => expression( 'break' ).append();

//

const loop = ( ...params ) => { // @deprecated, r168

	console.warn( 'TSL.LoopNode: loop() has been renamed to Loop().' );
	return Loop( ...params );

};

const _morphTextures = /*@__PURE__*/ new WeakMap();
const _morphVec4 = /*@__PURE__*/ new Vector4();

const getMorph = /*@__PURE__*/ Fn$1( ( { bufferMap, influence, stride, width, depth, offset } ) => {

	const texelIndex = int( vertexIndex ).mul( stride ).add( offset );

	const y = texelIndex.div( width );
	const x = texelIndex.sub( y.mul( width ) );

	const bufferAttrib = textureLoad( bufferMap, ivec2( x, y ) ).depth( depth );

	return bufferAttrib.mul( influence );

} );

function getEntry( geometry ) {

	const hasMorphPosition = geometry.morphAttributes.position !== undefined;
	const hasMorphNormals = geometry.morphAttributes.normal !== undefined;
	const hasMorphColors = geometry.morphAttributes.color !== undefined;

	// instead of using attributes, the WebGL 2 code path encodes morph targets
	// into an array of data textures. Each layer represents a single morph target.

	const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
	const morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;

	let entry = _morphTextures.get( geometry );

	if ( entry === undefined || entry.count !== morphTargetsCount ) {

		if ( entry !== undefined ) entry.texture.dispose();

		const morphTargets = geometry.morphAttributes.position || [];
		const morphNormals = geometry.morphAttributes.normal || [];
		const morphColors = geometry.morphAttributes.color || [];

		let vertexDataCount = 0;

		if ( hasMorphPosition === true ) vertexDataCount = 1;
		if ( hasMorphNormals === true ) vertexDataCount = 2;
		if ( hasMorphColors === true ) vertexDataCount = 3;

		let width = geometry.attributes.position.count * vertexDataCount;
		let height = 1;

		const maxTextureSize = 4096; // @TODO: Use 'capabilities.maxTextureSize'

		if ( width > maxTextureSize ) {

			height = Math.ceil( width / maxTextureSize );
			width = maxTextureSize;

		}

		const buffer = new Float32Array( width * height * 4 * morphTargetsCount );

		const bufferTexture = new DataArrayTexture( buffer, width, height, morphTargetsCount );
		bufferTexture.type = FloatType;
		bufferTexture.needsUpdate = true;

		// fill buffer

		const vertexDataStride = vertexDataCount * 4;

		for ( let i = 0; i < morphTargetsCount; i ++ ) {

			const morphTarget = morphTargets[ i ];
			const morphNormal = morphNormals[ i ];
			const morphColor = morphColors[ i ];

			const offset = width * height * 4 * i;

			for ( let j = 0; j < morphTarget.count; j ++ ) {

				const stride = j * vertexDataStride;

				if ( hasMorphPosition === true ) {

					_morphVec4.fromBufferAttribute( morphTarget, j );

					buffer[ offset + stride + 0 ] = _morphVec4.x;
					buffer[ offset + stride + 1 ] = _morphVec4.y;
					buffer[ offset + stride + 2 ] = _morphVec4.z;
					buffer[ offset + stride + 3 ] = 0;

				}

				if ( hasMorphNormals === true ) {

					_morphVec4.fromBufferAttribute( morphNormal, j );

					buffer[ offset + stride + 4 ] = _morphVec4.x;
					buffer[ offset + stride + 5 ] = _morphVec4.y;
					buffer[ offset + stride + 6 ] = _morphVec4.z;
					buffer[ offset + stride + 7 ] = 0;

				}

				if ( hasMorphColors === true ) {

					_morphVec4.fromBufferAttribute( morphColor, j );

					buffer[ offset + stride + 8 ] = _morphVec4.x;
					buffer[ offset + stride + 9 ] = _morphVec4.y;
					buffer[ offset + stride + 10 ] = _morphVec4.z;
					buffer[ offset + stride + 11 ] = ( morphColor.itemSize === 4 ) ? _morphVec4.w : 1;

				}

			}

		}

		entry = {
			count: morphTargetsCount,
			texture: bufferTexture,
			stride: vertexDataCount,
			size: new Vector2( width, height )
		};

		_morphTextures.set( geometry, entry );

		function disposeTexture() {

			bufferTexture.dispose();

			_morphTextures.delete( geometry );

			geometry.removeEventListener( 'dispose', disposeTexture );

		}

		geometry.addEventListener( 'dispose', disposeTexture );

	}

	return entry;

}


class MorphNode extends Node {

	static get type() {

		return 'MorphNode';

	}

	constructor( mesh ) {

		super( 'void' );

		this.mesh = mesh;
		this.morphBaseInfluence = uniform$1( 1 );

		this.updateType = NodeUpdateType.OBJECT;

	}

	setup( builder ) {

		const { geometry } = builder;

		const hasMorphPosition = geometry.morphAttributes.position !== undefined;
		const hasMorphNormals = geometry.hasAttribute( 'normal' ) && geometry.morphAttributes.normal !== undefined;

		const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
		const morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;

		// nodes

		const { texture: bufferMap, stride, size } = getEntry( geometry );

		if ( hasMorphPosition === true ) positionLocal$1.mulAssign( this.morphBaseInfluence );
		if ( hasMorphNormals === true ) normalLocal.mulAssign( this.morphBaseInfluence );

		const width = int( size.width );

		Loop( morphTargetsCount, ( { i } ) => {

			const influence = float$1( 0 ).toVar();

			if ( this.mesh.count > 1 && ( this.mesh.morphTexture !== null && this.mesh.morphTexture !== undefined ) ) {

				influence.assign( textureLoad( this.mesh.morphTexture, ivec2( int( i ).add( 1 ), int( instanceIndex ) ) ).r );

			} else {

				influence.assign( reference( 'morphTargetInfluences', 'float' ).element( i ).toVar() );

			}

			if ( hasMorphPosition === true ) {

				positionLocal$1.addAssign( getMorph( {
					bufferMap,
					influence,
					stride,
					width,
					depth: i,
					offset: int( 0 )
				} ) );

			}

			if ( hasMorphNormals === true ) {

				normalLocal.addAssign( getMorph( {
					bufferMap,
					influence,
					stride,
					width,
					depth: i,
					offset: int( 1 )
				} ) );

			}

		} );

	}

	update() {

		const morphBaseInfluence = this.morphBaseInfluence;

		if ( this.mesh.geometry.morphTargetsRelative ) {

			morphBaseInfluence.value = 1;

		} else {

			morphBaseInfluence.value = 1 - this.mesh.morphTargetInfluences.reduce( ( a, b ) => a + b, 0 );

		}

	}

}

const morphReference = /*@__PURE__*/ nodeProxy( MorphNode );

class LightingNode extends Node {

	static get type() {

		return 'LightingNode';

	}

	constructor() {

		super( 'vec3' );

		this.isLightingNode = true;

	}

	generate( /*builder*/ ) {

		console.warn( 'Abstract function.' );

	}

}

class AONode extends LightingNode {

	static get type() {

		return 'AONode';

	}

	constructor( aoNode = null ) {

		super();

		this.aoNode = aoNode;

	}

	setup( builder ) {

		builder.context.ambientOcclusion.mulAssign( this.aoNode );

	}

}

class LightingContextNode extends ContextNode {

	static get type() {

		return 'LightingContextNode';

	}

	constructor( node, lightingModel = null, backdropNode = null, backdropAlphaNode = null ) {

		super( node );

		this.lightingModel = lightingModel;
		this.backdropNode = backdropNode;
		this.backdropAlphaNode = backdropAlphaNode;

		this._value = null;

	}

	getContext() {

		const { backdropNode, backdropAlphaNode } = this;

		const directDiffuse = vec3$1().toVar( 'directDiffuse' ),
			directSpecular = vec3$1().toVar( 'directSpecular' ),
			indirectDiffuse = vec3$1().toVar( 'indirectDiffuse' ),
			indirectSpecular = vec3$1().toVar( 'indirectSpecular' );

		const reflectedLight = {
			directDiffuse,
			directSpecular,
			indirectDiffuse,
			indirectSpecular
		};

		const context = {
			radiance: vec3$1().toVar( 'radiance' ),
			irradiance: vec3$1().toVar( 'irradiance' ),
			iblIrradiance: vec3$1().toVar( 'iblIrradiance' ),
			ambientOcclusion: float$1( 1 ).toVar( 'ambientOcclusion' ),
			reflectedLight,
			backdrop: backdropNode,
			backdropAlpha: backdropAlphaNode
		};

		return context;

	}

	setup( builder ) {

		this.value = this._value || ( this._value = this.getContext() );
		this.value.lightingModel = this.lightingModel || builder.context.lightingModel;

		return super.setup( builder );

	}

}

const lightingContext = /*@__PURE__*/ nodeProxy( LightingContextNode );

class IrradianceNode extends LightingNode {

	static get type() {

		return 'IrradianceNode';

	}

	constructor( node ) {

		super();

		this.node = node;

	}

	setup( builder ) {

		builder.context.irradiance.addAssign( this.node );

	}

}

let screenSizeVec, viewportVec;

class ScreenNode extends Node {

	static get type() {

		return 'ScreenNode';

	}

	constructor( scope ) {

		super();

		this.scope = scope;

		this.isViewportNode = true;

	}

	getNodeType() {

		if ( this.scope === ScreenNode.VIEWPORT ) return 'vec4';
		else return 'vec2';

	}

	getUpdateType() {

		let updateType = NodeUpdateType.NONE;

		if ( this.scope === ScreenNode.SIZE || this.scope === ScreenNode.VIEWPORT ) {

			updateType = NodeUpdateType.RENDER;

		}

		this.updateType = updateType;

		return updateType;

	}

	update( { renderer } ) {

		const renderTarget = renderer.getRenderTarget();

		if ( this.scope === ScreenNode.VIEWPORT ) {

			if ( renderTarget !== null ) {

				viewportVec.copy( renderTarget.viewport );

			} else {

				renderer.getViewport( viewportVec );

				viewportVec.multiplyScalar( renderer.getPixelRatio() );

			}

		} else {

			if ( renderTarget !== null ) {

				screenSizeVec.width = renderTarget.width;
				screenSizeVec.height = renderTarget.height;

			} else {

				renderer.getDrawingBufferSize( screenSizeVec );

			}

		}

	}

	setup( /*builder*/ ) {

		const scope = this.scope;

		let output = null;

		if ( scope === ScreenNode.SIZE ) {

			output = uniform$1( screenSizeVec || ( screenSizeVec = new Vector2() ) );

		} else if ( scope === ScreenNode.VIEWPORT ) {

			output = uniform$1( viewportVec || ( viewportVec = new Vector4() ) );

		} else {

			output = vec2$1( screenCoordinate.div( screenSize ) );

		}

		return output;

	}

	generate( builder ) {

		if ( this.scope === ScreenNode.COORDINATE ) {

			let coord = builder.getFragCoord();

			if ( builder.isFlipY() ) {

				// follow webgpu standards

				const size = builder.getNodeProperties( screenSize ).outputNode.build( builder );

				coord = `${ builder.getType( 'vec2' ) }( ${ coord }.x, ${ size }.y - ${ coord }.y )`;

			}

			return coord;

		}

		return super.generate( builder );

	}

}

ScreenNode.COORDINATE = 'coordinate';
ScreenNode.VIEWPORT = 'viewport';
ScreenNode.SIZE = 'size';
ScreenNode.UV = 'uv';

// Screen

const screenUV = /*@__PURE__*/ nodeImmutable( ScreenNode, ScreenNode.UV );
const screenSize = /*@__PURE__*/ nodeImmutable( ScreenNode, ScreenNode.SIZE );
const screenCoordinate = /*@__PURE__*/ nodeImmutable( ScreenNode, ScreenNode.COORDINATE );

// Viewport

const viewport = /*@__PURE__*/ nodeImmutable( ScreenNode, ScreenNode.VIEWPORT );
const viewportSize = viewport.zw;
const viewportCoordinate = /*@__PURE__*/ screenCoordinate.sub( viewport.xy );
const viewportUV = /*@__PURE__*/ viewportCoordinate.div( viewportSize );

// Deprecated

const viewportResolution = /*@__PURE__*/ ( Fn$1( () => { // @deprecated, r169

	console.warn( 'TSL.ViewportNode: "viewportResolution" is deprecated. Use "screenSize" instead.' );

	return screenSize;

}, 'vec2' ).once() )();

const viewportTopLeft = /*@__PURE__*/ ( Fn$1( () => { // @deprecated, r168

	console.warn( 'TSL.ViewportNode: "viewportTopLeft" is deprecated. Use "screenUV" instead.' );

	return screenUV;

}, 'vec2' ).once() )();

const viewportBottomLeft = /*@__PURE__*/ ( Fn$1( () => { // @deprecated, r168

	console.warn( 'TSL.ViewportNode: "viewportBottomLeft" is deprecated. Use "screenUV.flipY()" instead.' );

	return screenUV.flipY();

}, 'vec2' ).once() )();

const _size$4 = /*@__PURE__*/ new Vector2();

class ViewportTextureNode extends TextureNode {

	static get type() {

		return 'ViewportTextureNode';

	}

	constructor( uvNode = screenUV, levelNode = null, framebufferTexture = null ) {

		if ( framebufferTexture === null ) {

			framebufferTexture = new FramebufferTexture();
			framebufferTexture.minFilter = LinearMipmapLinearFilter;

		}

		super( framebufferTexture, uvNode, levelNode );

		this.generateMipmaps = false;

		this.isOutputTextureNode = true;

		this.updateBeforeType = NodeUpdateType.FRAME;

	}

	updateBefore( frame ) {

		const renderer = frame.renderer;
		renderer.getDrawingBufferSize( _size$4 );

		//

		const framebufferTexture = this.value;

		if ( framebufferTexture.image.width !== _size$4.width || framebufferTexture.image.height !== _size$4.height ) {

			framebufferTexture.image.width = _size$4.width;
			framebufferTexture.image.height = _size$4.height;
			framebufferTexture.needsUpdate = true;

		}

		//

		const currentGenerateMipmaps = framebufferTexture.generateMipmaps;
		framebufferTexture.generateMipmaps = this.generateMipmaps;

		renderer.copyFramebufferToTexture( framebufferTexture );

		framebufferTexture.generateMipmaps = currentGenerateMipmaps;

	}

	clone() {

		const viewportTextureNode = new this.constructor( this.uvNode, this.levelNode, this.value );
		viewportTextureNode.generateMipmaps = this.generateMipmaps;

		return viewportTextureNode;

	}

}

const viewportTexture = /*@__PURE__*/ nodeProxy( ViewportTextureNode );
const viewportMipTexture = /*@__PURE__*/ nodeProxy( ViewportTextureNode, null, null, { generateMipmaps: true } );

let sharedDepthbuffer = null;

class ViewportDepthTextureNode extends ViewportTextureNode {

	static get type() {

		return 'ViewportDepthTextureNode';

	}

	constructor( uvNode = screenUV, levelNode = null ) {

		if ( sharedDepthbuffer === null ) {

			sharedDepthbuffer = new DepthTexture();

		}

		super( uvNode, levelNode, sharedDepthbuffer );

	}

}

const viewportDepthTexture = /*@__PURE__*/ nodeProxy( ViewportDepthTextureNode );

class ViewportDepthNode extends Node {

	static get type() {

		return 'ViewportDepthNode';

	}

	constructor( scope, valueNode = null ) {

		super( 'float' );

		this.scope = scope;
		this.valueNode = valueNode;

		this.isViewportDepthNode = true;

	}

	generate( builder ) {

		const { scope } = this;

		if ( scope === ViewportDepthNode.DEPTH_BASE ) {

			return builder.getFragDepth();

		}

		return super.generate( builder );

	}

	setup( { camera } ) {

		const { scope } = this;
		const value = this.valueNode;

		let node = null;

		if ( scope === ViewportDepthNode.DEPTH_BASE ) {

			if ( value !== null ) {

 				node = depthBase().assign( value );

			}

		} else if ( scope === ViewportDepthNode.DEPTH ) {

			if ( camera.isPerspectiveCamera ) {

				node = viewZToPerspectiveDepth( positionView$1.z, cameraNear, cameraFar );

			} else {

				node = viewZToOrthographicDepth( positionView$1.z, cameraNear, cameraFar );

			}

		} else if ( scope === ViewportDepthNode.LINEAR_DEPTH ) {

			if ( value !== null ) {

				if ( camera.isPerspectiveCamera ) {

					const viewZ = perspectiveDepthToViewZ( value, cameraNear, cameraFar );

					node = viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );

				} else {

					node = value;

				}

			} else {

				node = viewZToOrthographicDepth( positionView$1.z, cameraNear, cameraFar );

			}

		}

		return node;

	}

}

ViewportDepthNode.DEPTH_BASE = 'depthBase';
ViewportDepthNode.DEPTH = 'depth';
ViewportDepthNode.LINEAR_DEPTH = 'linearDepth';

// NOTE: viewZ, the z-coordinate in camera space, is negative for points in front of the camera

// -near maps to 0; -far maps to 1
const viewZToOrthographicDepth = ( viewZ, near, far ) => viewZ.add( near ).div( near.sub( far ) );

// maps orthographic depth in [ 0, 1 ] to viewZ
const orthographicDepthToViewZ = ( depth, near, far ) => near.sub( far ).mul( depth ).sub( near );

// NOTE: https://twitter.com/gonnavis/status/1377183786949959682

// -near maps to 0; -far maps to 1
const viewZToPerspectiveDepth = ( viewZ, near, far ) => near.add( viewZ ).mul( far ).div( far.sub( near ).mul( viewZ ) );

// maps perspective depth in [ 0, 1 ] to viewZ
const perspectiveDepthToViewZ = ( depth, near, far ) => near.mul( far ).div( far.sub( near ).mul( depth ).sub( far ) );

// -near maps to 0; -far maps to 1
const viewZToLogarithmicDepth = ( viewZ, near, far ) => {

	// NOTE: viewZ must be negative--see explanation at the end of this comment block.
	// The final logarithmic depth formula used here is adapted from one described in an
	// article by Thatcher Ulrich (see http://tulrich.com/geekstuff/log_depth_buffer.txt),
	// which was an improvement upon an earlier formula one described in an
	// Outerra article (https://outerra.blogspot.com/2009/08/logarithmic-z-buffer.html).
	// Ulrich's formula is the following:
	//     z = K * log( w / cameraNear ) / log( cameraFar / cameraNear )
	//     where K = 2^k - 1, and k is the number of bits in the depth buffer.
	// The Outerra variant ignored the camera near plane (it assumed it was 0) and instead
	// opted for a "C-constant" for resolution adjustment of objects near the camera.
	// Outerra states: "Notice that the 'C' variant doesnt use a near plane distance, it has it
	// set at 0" (quote from https://outerra.blogspot.com/2012/11/maximizing-depth-buffer-range-and.html).
	// Ulrich's variant has the benefit of constant relative precision over the whole near-far range.
	// It was debated here whether Outerra's "C-constant" or Ulrich's "near plane" variant should
	// be used, and ultimately Ulrich's "near plane" version was chosen.
	// Outerra eventually made another improvement to their original "C-constant" variant,
	// but it still does not incorporate the camera near plane (for this version,
	// see https://outerra.blogspot.com/2013/07/logarithmic-depth-buffer-optimizations.html).
	// Here we make 4 changes to Ulrich's formula:
	// 1. Clamp the camera near plane so we don't divide by 0.
	// 2. Use log2 instead of log to avoid an extra multiply (shaders implement log using log2).
	// 3. Assume K is 1 (K = maximum value in depth buffer; see Ulrich's formula above).
	// 4. To maintain consistency with the functions "viewZToOrthographicDepth" and "viewZToPerspectiveDepth",
	//    we modify the formula here to use 'viewZ' instead of 'w'. The other functions expect a negative viewZ,
	//    so we do the same here, hence the 'viewZ.negate()' call.
	// For visual representation of this depth curve, see https://www.desmos.com/calculator/uyqk0vex1u
	near = near.max( 1e-6 ).toVar();
	const numerator = log2( viewZ.negate().div( near ) );
	const denominator = log2( far.div( near ) );
	return numerator.div( denominator );

};

// maps logarithmic depth in [ 0, 1 ] to viewZ
const logarithmicDepthToViewZ = ( depth, near, far ) => {

	// NOTE: we add a 'negate()' call to the return value here to maintain consistency with
	// the functions "orthographicDepthToViewZ" and "perspectiveDepthToViewZ" (they return
	// a negative viewZ).
	const exponent = depth.mul( log( far.div( near ) ) );
	return float$1( Math.E ).pow( exponent ).mul( near ).negate();

};

const depthBase = /*@__PURE__*/ nodeProxy( ViewportDepthNode, ViewportDepthNode.DEPTH_BASE );

const depth = /*@__PURE__*/ nodeImmutable( ViewportDepthNode, ViewportDepthNode.DEPTH );
const linearDepth = /*@__PURE__*/ nodeProxy( ViewportDepthNode, ViewportDepthNode.LINEAR_DEPTH );
const viewportLinearDepth = /*@__PURE__*/ linearDepth( viewportDepthTexture() );

depth.assign = ( value ) => depthBase( value );

class BuiltinNode extends Node {

	constructor( name ) {

		super( 'float' );

		this.name = name;

		this.isBuiltinNode = true;

	}

	generate( /* builder */ ) {

		return this.name;

	}

}

const builtin = nodeProxy( BuiltinNode );

class ClippingNode extends Node {

	static get type() {

		return 'ClippingNode';

	}

	constructor( scope = ClippingNode.DEFAULT ) {

		super();

		this.scope = scope;

	}

	setup( builder ) {

		super.setup( builder );

		const clippingContext = builder.clippingContext;
		const { intersectionPlanes, unionPlanes } = clippingContext;

		this.hardwareClipping = builder.material.hardwareClipping;

		if ( this.scope === ClippingNode.ALPHA_TO_COVERAGE ) {

			return this.setupAlphaToCoverage( intersectionPlanes, unionPlanes );

		} else if ( this.scope === ClippingNode.HARDWARE ) {

			return this.setupHardwareClipping( unionPlanes, builder );

		} else {

			return this.setupDefault( intersectionPlanes, unionPlanes );

		}

	}

	setupAlphaToCoverage( intersectionPlanes, unionPlanes ) {

		return Fn$1( () => {

			const distanceToPlane = float$1().toVar( 'distanceToPlane' );
			const distanceGradient = float$1().toVar( 'distanceToGradient' );

			const clipOpacity = float$1( 1 ).toVar( 'clipOpacity' );

			const numUnionPlanes = unionPlanes.length;

			if ( ! this.hardwareClipping && numUnionPlanes > 0 ) {

				const clippingPlanes = uniformArray( unionPlanes );

				Loop( numUnionPlanes, ( { i } ) => {

					const plane = clippingPlanes.element( i );

					distanceToPlane.assign( positionView$1.dot( plane.xyz ).negate().add( plane.w ) );
					distanceGradient.assign( distanceToPlane.fwidth().div( 2.0 ) );

					clipOpacity.mulAssign( smoothstep$1( distanceGradient.negate(), distanceGradient, distanceToPlane ) );

				} );

			}

			const numIntersectionPlanes = intersectionPlanes.length;

			if ( numIntersectionPlanes > 0 ) {

				const clippingPlanes = uniformArray( intersectionPlanes );
				const intersectionClipOpacity = float$1( 1 ).toVar( 'intersectionClipOpacity' );

				Loop( numIntersectionPlanes, ( { i } ) => {

					const plane = clippingPlanes.element( i );

					distanceToPlane.assign( positionView$1.dot( plane.xyz ).negate().add( plane.w ) );
					distanceGradient.assign( distanceToPlane.fwidth().div( 2.0 ) );

					intersectionClipOpacity.mulAssign( smoothstep$1( distanceGradient.negate(), distanceGradient, distanceToPlane ).oneMinus() );

				} );

				clipOpacity.mulAssign( intersectionClipOpacity.oneMinus() );

			}

			diffuseColor.a.mulAssign( clipOpacity );

			diffuseColor.a.equal( 0.0 ).discard();

		} )();

	}

	setupDefault( intersectionPlanes, unionPlanes ) {

		return Fn$1( () => {

			const numUnionPlanes = unionPlanes.length;

			if ( ! this.hardwareClipping && numUnionPlanes > 0 ) {

				const clippingPlanes = uniformArray( unionPlanes );

				Loop( numUnionPlanes, ( { i } ) => {

					const plane = clippingPlanes.element( i );
					positionView$1.dot( plane.xyz ).greaterThan( plane.w ).discard();

				} );

			}

			const numIntersectionPlanes = intersectionPlanes.length;

			if ( numIntersectionPlanes > 0 ) {

				const clippingPlanes = uniformArray( intersectionPlanes );
				const clipped = bool( true ).toVar( 'clipped' );

				Loop( numIntersectionPlanes, ( { i } ) => {

					const plane = clippingPlanes.element( i );
					clipped.assign( positionView$1.dot( plane.xyz ).greaterThan( plane.w ).and( clipped ) );

				} );

				clipped.discard();

			}

		} )();

	}

	setupHardwareClipping( unionPlanes, builder ) {

		const numUnionPlanes = unionPlanes.length;

		builder.enableHardwareClipping( numUnionPlanes );

		return Fn$1( () => {

			const clippingPlanes = uniformArray( unionPlanes );
			const hw_clip_distances = builtin( builder.getClipDistance() );

			Loop( numUnionPlanes, ( { i } ) => {

				const plane = clippingPlanes.element( i );

				const distance = positionView$1.dot( plane.xyz ).sub( plane.w ).negate();
				hw_clip_distances.element( i ).assign( distance );

			} );

		} )();

	}

}

ClippingNode.ALPHA_TO_COVERAGE = 'alphaToCoverage';
ClippingNode.DEFAULT = 'default';
ClippingNode.HARDWARE = 'hardware';

const clipping = () => nodeObject( new ClippingNode() );
const clippingAlpha = () => nodeObject( new ClippingNode( ClippingNode.ALPHA_TO_COVERAGE ) );
const hardwareClipping = () => nodeObject( new ClippingNode( ClippingNode.HARDWARE ) );

/**
 * See: https://casual-effects.com/research/Wyman2017Hashed/index.html
 */

const ALPHA_HASH_SCALE = 0.05; // Derived from trials only, and may be changed.

const hash2D = /*@__PURE__*/ Fn$1( ( [ value ] ) => {

	return fract$1( mul$1( 1.0e4, sin$1( mul$1( 17.0, value.x ).add( mul$1( 0.1, value.y ) ) ) ).mul( add$1( 0.1, abs$1( sin$1( mul$1( 13.0, value.y ).add( value.x ) ) ) ) ) );

} );

const hash3D = /*@__PURE__*/ Fn$1( ( [ value ] ) => {

	return hash2D( vec2$1( hash2D( value.xy ), value.z ) );

} );

const getAlphaHashThreshold = /*@__PURE__*/ Fn$1( ( [ position ] ) => {

	// Find the discretized derivatives of our coordinates
	const maxDeriv = max$1(
		length( dFdx( position.xyz ) ),
		length( dFdy( position.xyz ) )
	);

	const pixScale = float$1( 1 ).div( float$1( ALPHA_HASH_SCALE ).mul( maxDeriv ) ).toVar( 'pixScale' );

	// Find two nearest log-discretized noise scales
	const pixScales = vec2$1(
		exp2( floor$1( log2( pixScale ) ) ),
		exp2( ceil( log2( pixScale ) ) )
	);

	// Compute alpha thresholds at our two noise scales
	const alpha = vec2$1(
		hash3D( floor$1( pixScales.x.mul( position.xyz ) ) ),
		hash3D( floor$1( pixScales.y.mul( position.xyz ) ) ),
	);

	// Factor to interpolate lerp with
	const lerpFactor = fract$1( log2( pixScale ) );

	// Interpolate alpha threshold from noise at two scales
	const x = add$1( mul$1( lerpFactor.oneMinus(), alpha.x ), mul$1( lerpFactor, alpha.y ) );

	// Pass into CDF to compute uniformly distrib threshold
	const a = min$1( lerpFactor, lerpFactor.oneMinus() );
	const cases = vec3$1(
		x.mul( x ).div( mul$1( 2.0, a ).mul( sub$1( 1.0, a ) ) ),
		x.sub( mul$1( 0.5, a ) ).div( sub$1( 1.0, a ) ),
		sub$1( 1.0, sub$1( 1.0, x ).mul( sub$1( 1.0, x ) ).div( mul$1( 2.0, a ).mul( sub$1( 1.0, a ) ) ) ) );

	// Find our final, uniformly distributed alpha threshold ()
	const threshold = x.lessThan( a.oneMinus() ).select( x.lessThan( a ).select( cases.x, cases.y ), cases.z );

	// Avoids  == 0. Could also do  =1-
	return clamp( threshold, 1.0e-6, 1.0 );

} ).setLayout( {
	name: 'getAlphaHashThreshold',
	type: 'float',
	inputs: [
		{ name: 'position', type: 'vec3' }
	]
} );

class NodeMaterial extends Material {

	static get type() {

		return 'NodeMaterial';

	}

	get type() {

		return this.constructor.type;

	}

	set type( _value ) { /* */ }

	constructor() {

		super();

		this.isNodeMaterial = true;

		this.forceSinglePass = false;

		this.fog = true;
		this.lights = false;
		this.hardwareClipping = false;

		this.lightsNode = null;
		this.envNode = null;
		this.aoNode = null;

		this.colorNode = null;
		this.normalNode = null;
		this.opacityNode = null;
		this.backdropNode = null;
		this.backdropAlphaNode = null;
		this.alphaTestNode = null;

		this.positionNode = null;
		this.geometryNode = null;

		this.depthNode = null;
		this.shadowPositionNode = null;
		this.receivedShadowNode = null;
		this.castShadowNode = null;

		this.outputNode = null;
		this.mrtNode = null;

		this.fragmentNode = null;
		this.vertexNode = null;

	}

	customProgramCacheKey() {

		return this.type + getCacheKey$1( this );

	}

	build( builder ) {

		this.setup( builder );

	}

	setupObserver( builder ) {

		return new NodeMaterialObserver( builder );

	}

	setup( builder ) {

		builder.context.setupNormal = () => this.setupNormal( builder );

		const renderer = builder.renderer;
		const renderTarget = renderer.getRenderTarget();

		// < VERTEX STAGE >

		builder.addStack();

		builder.stack.outputNode = this.vertexNode || this.setupPosition( builder );

		if ( this.geometryNode !== null ) {

			builder.stack.outputNode = builder.stack.outputNode.bypass( this.geometryNode );

		}

		builder.addFlow( 'vertex', builder.removeStack() );

		// < FRAGMENT STAGE >

		builder.addStack();

		let resultNode;

		const clippingNode = this.setupClipping( builder );

		if ( this.depthWrite === true ) {

			// only write depth if depth buffer is configured

			if ( renderTarget !== null ) {

				if ( renderTarget.depthBuffer === true ) this.setupDepth( builder );

			} else {

				if ( renderer.depth === true ) this.setupDepth( builder );

			}

		}

		if ( this.fragmentNode === null ) {

			this.setupDiffuseColor( builder );
			this.setupVariants( builder );

			const outgoingLightNode = this.setupLighting( builder );

			if ( clippingNode !== null ) builder.stack.add( clippingNode );

			// force unsigned floats - useful for RenderTargets

			const basicOutput = vec4$1( outgoingLightNode, diffuseColor.a ).max( 0 );

			resultNode = this.setupOutput( builder, basicOutput );

			// OUTPUT NODE

			output.assign( resultNode );

			//

			if ( this.outputNode !== null ) resultNode = this.outputNode;

			// MRT

			if ( renderTarget !== null ) {

				const mrt = renderer.getMRT();
				const materialMRT = this.mrtNode;

				if ( mrt !== null ) {

					resultNode = mrt;

					if ( materialMRT !== null ) {

						resultNode = mrt.merge( materialMRT );

					}

				} else if ( materialMRT !== null ) {

					resultNode = materialMRT;

				}

			}

		} else {

			let fragmentNode = this.fragmentNode;

			if ( fragmentNode.isOutputStructNode !== true ) {

				fragmentNode = vec4$1( fragmentNode );

			}

			resultNode = this.setupOutput( builder, fragmentNode );

		}

		builder.stack.outputNode = resultNode;

		builder.addFlow( 'fragment', builder.removeStack() );

		// < MONITOR >

		builder.monitor = this.setupObserver( builder );

	}

	setupClipping( builder ) {

		if ( builder.clippingContext === null ) return null;

		const { unionPlanes, intersectionPlanes } = builder.clippingContext;

		let result = null;

		if ( unionPlanes.length > 0 || intersectionPlanes.length > 0 ) {

			const samples = builder.renderer.samples;

			if ( this.alphaToCoverage && samples > 1 ) {

				// to be added to flow when the color/alpha value has been determined
				result = clippingAlpha();

			} else {

				builder.stack.add( clipping() );

			}

		}

		return result;

	}

	setupHardwareClipping( builder ) {

		this.hardwareClipping = false;

		if ( builder.clippingContext === null ) return;

		const candidateCount = builder.clippingContext.unionPlanes.length;

		// 8 planes supported by WebGL ANGLE_clip_cull_distance and WebGPU clip-distances

		if ( candidateCount > 0 && candidateCount <= 8 && builder.isAvailable( 'clipDistance' ) ) {

			builder.stack.add( hardwareClipping() );

			this.hardwareClipping = true;

		}

		return;

	}

	setupDepth( builder ) {

		const { renderer, camera } = builder;

		// Depth

		let depthNode = this.depthNode;

		if ( depthNode === null ) {

			const mrt = renderer.getMRT();

			if ( mrt && mrt.has( 'depth' ) ) {

				depthNode = mrt.get( 'depth' );

			} else if ( renderer.logarithmicDepthBuffer === true ) {

				if ( camera.isPerspectiveCamera ) {

					depthNode = viewZToLogarithmicDepth( positionView$1.z, cameraNear, cameraFar );

				} else {

					depthNode = viewZToOrthographicDepth( positionView$1.z, cameraNear, cameraFar );

				}

			}

		}

		if ( depthNode !== null ) {

			depth.assign( depthNode ).append();

		}

	}

	setupPosition( builder ) {

		const { object } = builder;
		const geometry = object.geometry;

		builder.addStack();

		// Vertex

		if ( geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color ) {

			morphReference( object ).append();

		}

		if ( object.isSkinnedMesh === true ) {

			skinningReference( object ).append();

		}

		if ( this.displacementMap ) {

			const displacementMap = materialReference( 'displacementMap', 'texture' );
			const displacementScale = materialReference( 'displacementScale', 'float' );
			const displacementBias = materialReference( 'displacementBias', 'float' );

			positionLocal$1.addAssign( normalLocal.normalize().mul( ( displacementMap.x.mul( displacementScale ).add( displacementBias ) ) ) );

		}

		if ( object.isBatchedMesh ) {

			batch( object ).append();

		}

		if ( ( object.isInstancedMesh && object.instanceMatrix && object.instanceMatrix.isInstancedBufferAttribute === true ) ) {

			instancedMesh( object ).append();

		}

		if ( this.positionNode !== null ) {

			positionLocal$1.assign( this.positionNode );

		}

		this.setupHardwareClipping( builder );

		const mvp = modelViewProjection();

		builder.context.vertex = builder.removeStack();
		builder.context.mvp = mvp;

		return mvp;

	}

	setupDiffuseColor( { object, geometry } ) {

		let colorNode = this.colorNode ? vec4$1( this.colorNode ) : materialColor;

		// VERTEX COLORS

		if ( this.vertexColors === true && geometry.hasAttribute( 'color' ) ) {

			colorNode = vec4$1( colorNode.xyz.mul( attribute$1( 'color', 'vec3' ) ), colorNode.a );

		}

		// Instanced colors

		if ( object.instanceColor ) {

			const instanceColor = varyingProperty( 'vec3', 'vInstanceColor' );

			colorNode = instanceColor.mul( colorNode );

		}

		if ( object.isBatchedMesh && object._colorsTexture ) {

			const batchColor = varyingProperty( 'vec3', 'vBatchColor' );

			colorNode = batchColor.mul( colorNode );

		}


		// COLOR

		diffuseColor.assign( colorNode );

		// OPACITY

		const opacityNode = this.opacityNode ? float$1( this.opacityNode ) : materialOpacity;
		diffuseColor.a.assign( diffuseColor.a.mul( opacityNode ) );

		// ALPHA TEST

		if ( this.alphaTestNode !== null || this.alphaTest > 0 ) {

			const alphaTestNode = this.alphaTestNode !== null ? float$1( this.alphaTestNode ) : materialAlphaTest;

			diffuseColor.a.lessThanEqual( alphaTestNode ).discard();

		}

		// ALPHA HASH

		if ( this.alphaHash === true ) {

			diffuseColor.a.lessThan( getAlphaHashThreshold( positionLocal$1 ) ).discard();

		}

		if ( this.transparent === false && this.blending === NormalBlending && this.alphaToCoverage === false ) {

			diffuseColor.a.assign( 1.0 );

		}

	}

	setupVariants( /*builder*/ ) {

		// Interface function.

	}

	setupOutgoingLight() {

		return ( this.lights === true ) ? vec3$1( 0 ) : diffuseColor.rgb;

	}

	setupNormal() {

		return this.normalNode ? vec3$1( this.normalNode ) : materialNormal;

	}

	setupEnvironment( /*builder*/ ) {

		let node = null;

		if ( this.envNode ) {

			node = this.envNode;

		} else if ( this.envMap ) {

			node = this.envMap.isCubeTexture ? materialReference( 'envMap', 'cubeTexture' ) : materialReference( 'envMap', 'texture' );

		}

		return node;

	}

	setupLightMap( builder ) {

		let node = null;

		if ( builder.material.lightMap ) {

			node = new IrradianceNode( materialLightMap );

		}

		return node;

	}

	setupLights( builder ) {

		const materialLightsNode = [];

		//

		const envNode = this.setupEnvironment( builder );

		if ( envNode && envNode.isLightingNode ) {

			materialLightsNode.push( envNode );

		}

		const lightMapNode = this.setupLightMap( builder );

		if ( lightMapNode && lightMapNode.isLightingNode ) {

			materialLightsNode.push( lightMapNode );

		}

		if ( this.aoNode !== null || builder.material.aoMap ) {

			const aoNode = this.aoNode !== null ? this.aoNode : materialAOMap;

			materialLightsNode.push( new AONode( aoNode ) );

		}

		let lightsN = this.lightsNode || builder.lightsNode;

		if ( materialLightsNode.length > 0 ) {

			lightsN = builder.renderer.lighting.createNode( [ ...lightsN.getLights(), ...materialLightsNode ] );

		}

		return lightsN;

	}

	setupLightingModel( /*builder*/ ) {

		// Interface function.

	}

	setupLighting( builder ) {

		const { material } = builder;
		const { backdropNode, backdropAlphaNode, emissiveNode } = this;

		// OUTGOING LIGHT

		const lights = this.lights === true || this.lightsNode !== null;

		const lightsNode = lights ? this.setupLights( builder ) : null;

		let outgoingLightNode = this.setupOutgoingLight( builder );

		if ( lightsNode && lightsNode.getScope().hasLights ) {

			const lightingModel = this.setupLightingModel( builder );

			outgoingLightNode = lightingContext( lightsNode, lightingModel, backdropNode, backdropAlphaNode );

		} else if ( backdropNode !== null ) {

			outgoingLightNode = vec3$1( backdropAlphaNode !== null ? mix$1( outgoingLightNode, backdropNode, backdropAlphaNode ) : backdropNode );

		}

		// EMISSIVE

		if ( ( emissiveNode && emissiveNode.isNode === true ) || ( material.emissive && material.emissive.isColor === true ) ) {

			emissive.assign( vec3$1( emissiveNode ? emissiveNode : materialEmissive ) );

			outgoingLightNode = outgoingLightNode.add( emissive );

		}

		return outgoingLightNode;

	}

	setupOutput( builder, outputNode ) {

		// FOG

		if ( this.fog === true ) {

			const fogNode = builder.fogNode;

			if ( fogNode ) outputNode = vec4$1( fogNode.mix( outputNode.rgb, fogNode.colorNode ), outputNode.a );

		}

		return outputNode;

	}

	setDefaultValues( material ) {

		// This approach is to reuse the native refreshUniforms*
		// and turn available the use of features like transmission and environment in core

		for ( const property in material ) {

			const value = material[ property ];

			if ( this[ property ] === undefined ) {

				this[ property ] = value;

				if ( value && value.clone ) this[ property ] = value.clone();

			}

		}

		const descriptors = Object.getOwnPropertyDescriptors( material.constructor.prototype );

		for ( const key in descriptors ) {

			if ( Object.getOwnPropertyDescriptor( this.constructor.prototype, key ) === undefined &&
			     descriptors[ key ].get !== undefined ) {

				Object.defineProperty( this.constructor.prototype, key, descriptors[ key ] );

			}

		}

	}

	toJSON( meta ) {

		const isRoot = ( meta === undefined || typeof meta === 'string' );

		if ( isRoot ) {

			meta = {
				textures: {},
				images: {},
				nodes: {}
			};

		}

		const data = Material.prototype.toJSON.call( this, meta );
		const nodeChildren = getNodeChildren( this );

		data.inputNodes = {};

		for ( const { property, childNode } of nodeChildren ) {

			data.inputNodes[ property ] = childNode.toJSON( meta ).uuid;

		}

		// TODO: Copied from Object3D.toJSON

		function extractFromCache( cache ) {

			const values = [];

			for ( const key in cache ) {

				const data = cache[ key ];
				delete data.metadata;
				values.push( data );

			}

			return values;

		}

		if ( isRoot ) {

			const textures = extractFromCache( meta.textures );
			const images = extractFromCache( meta.images );
			const nodes = extractFromCache( meta.nodes );

			if ( textures.length > 0 ) data.textures = textures;
			if ( images.length > 0 ) data.images = images;
			if ( nodes.length > 0 ) data.nodes = nodes;

		}

		return data;

	}

	copy( source ) {

		this.lightsNode = source.lightsNode;
		this.envNode = source.envNode;

		this.colorNode = source.colorNode;
		this.normalNode = source.normalNode;
		this.opacityNode = source.opacityNode;
		this.backdropNode = source.backdropNode;
		this.backdropAlphaNode = source.backdropAlphaNode;
		this.alphaTestNode = source.alphaTestNode;

		this.positionNode = source.positionNode;
		this.geometryNode = source.geometryNode;

		this.depthNode = source.depthNode;
		this.shadowPositionNode = source.shadowPositionNode;
		this.receivedShadowNode = source.receivedShadowNode;
		this.castShadowNode = source.castShadowNode;

		this.outputNode = source.outputNode;
		this.mrtNode = source.mrtNode;

		this.fragmentNode = source.fragmentNode;
		this.vertexNode = source.vertexNode;

		return super.copy( source );

	}

}

const _defaultValues$d = /*@__PURE__*/ new LineBasicMaterial();

class LineBasicNodeMaterial extends NodeMaterial {

	static get type() {

		return 'LineBasicNodeMaterial';

	}

	constructor( parameters ) {

		super();

		this.isLineBasicNodeMaterial = true;

		this.lights = false;

		this.setDefaultValues( _defaultValues$d );

		this.setValues( parameters );

	}

}

const _defaultValues$c = /*@__PURE__*/ new LineDashedMaterial();

class LineDashedNodeMaterial extends NodeMaterial {

	static get type() {

		return 'LineDashedNodeMaterial';

	}

	constructor( parameters ) {

		super();

		this.isLineDashedNodeMaterial = true;

		this.lights = false;

		this.setDefaultValues( _defaultValues$c );

		this.dashOffset = 0;

		this.offsetNode = null;
		this.dashScaleNode = null;
		this.dashSizeNode = null;
		this.gapSizeNode = null;

		this.setValues( parameters );

	}

	setupVariants() {

		const offsetNode = this.offsetNode ? float$1( this.offsetNodeNode ) : materialLineDashOffset;
		const dashScaleNode = this.dashScaleNode ? float$1( this.dashScaleNode ) : materialLineScale;
		const dashSizeNode = this.dashSizeNode ? float$1( this.dashSizeNode ) : materialLineDashSize;
		const gapSizeNode = this.dashSizeNode ? float$1( this.dashGapNode ) : materialLineGapSize;

		dashSize.assign( dashSizeNode );
		gapSize.assign( gapSizeNode );

		const vLineDistance = varying( attribute$1( 'lineDistance' ).mul( dashScaleNode ) );
		const vLineDistanceOffset = offsetNode ? vLineDistance.add( offsetNode ) : vLineDistance;

		vLineDistanceOffset.mod( dashSize.add( gapSize ) ).greaterThan( dashSize ).discard();

	}

}

let _sharedFramebuffer = null;

class ViewportSharedTextureNode extends ViewportTextureNode {

	static get type() {

		return 'ViewportSharedTextureNode';

	}

	constructor( uvNode = screenUV, levelNode = null ) {

		if ( _sharedFramebuffer === null ) {

			_sharedFramebuffer = new FramebufferTexture();

		}

		super( uvNode, levelNode, _sharedFramebuffer );

	}

	updateReference() {

		return this;

	}

}

const viewportSharedTexture = /*@__PURE__*/ nodeProxy( ViewportSharedTextureNode );

const directionToColor = ( node ) => nodeObject( node ).mul( 0.5 ).add( 0.5 );
const colorToDirection = ( node ) => nodeObject( node ).mul( 2.0 ).sub( 1 );

const _defaultValues$a = /*@__PURE__*/ new MeshNormalMaterial();

class MeshNormalNodeMaterial extends NodeMaterial {

	static get type() {

		return 'MeshNormalNodeMaterial';

	}

	constructor( parameters ) {

		super();

		this.lights = false;

		this.isMeshNormalNodeMaterial = true;

		this.setDefaultValues( _defaultValues$a );

		this.setValues( parameters );

	}

	setupDiffuseColor() {

		const opacityNode = this.opacityNode ? float$1( this.opacityNode ) : materialOpacity;

		diffuseColor.assign( vec4$1( directionToColor( transformedNormalView ), opacityNode ) );

	}

}

class EquirectUVNode extends TempNode {

	static get type() {

		return 'EquirectUVNode';

	}

	constructor( dirNode = positionWorldDirection ) {

		super( 'vec2' );

		this.dirNode = dirNode;

	}

	setup() {

		const dir = this.dirNode;

		const u = dir.z.atan2( dir.x ).mul( 1 / ( Math.PI * 2 ) ).add( 0.5 );
		const v = dir.y.clamp( -1, 1.0 ).asin().mul( 1 / Math.PI ).add( 0.5 );

		return vec2$1( u, v );

	}

}

const equirectUV = /*@__PURE__*/ nodeProxy( EquirectUVNode );

// @TODO: Consider rename WebGLCubeRenderTarget to just CubeRenderTarget

class CubeRenderTarget extends WebGLCubeRenderTarget {

	constructor( size = 1, options = {} ) {

		super( size, options );

		this.isCubeRenderTarget = true;

	}

	fromEquirectangularTexture( renderer, texture$1 ) {

		const currentMinFilter = texture$1.minFilter;
		const currentGenerateMipmaps = texture$1.generateMipmaps;

		texture$1.generateMipmaps = true;

		this.texture.type = texture$1.type;
		this.texture.colorSpace = texture$1.colorSpace;

		this.texture.generateMipmaps = texture$1.generateMipmaps;
		this.texture.minFilter = texture$1.minFilter;
		this.texture.magFilter = texture$1.magFilter;

		const geometry = new BoxGeometry( 5, 5, 5 );

		const uvNode = equirectUV( positionWorldDirection );

		const material = new NodeMaterial();
		material.colorNode = texture( texture$1, uvNode, 0 );
		material.side = BackSide;
		material.blending = NoBlending;

		const mesh = new Mesh( geometry, material );

		const scene = new Scene();
		scene.add( mesh );

		// Avoid blurred poles
		if ( texture$1.minFilter === LinearMipmapLinearFilter ) texture$1.minFilter = LinearFilter;

		const camera = new CubeCamera( 1, 10, this );

		const currentMRT = renderer.getMRT();
		renderer.setMRT( null );

		camera.update( renderer, scene );

		renderer.setMRT( currentMRT );

		texture$1.minFilter = currentMinFilter;
		texture$1.currentGenerateMipmaps = currentGenerateMipmaps;

		mesh.geometry.dispose();
		mesh.material.dispose();

		return this;

	}

}

const _cache$1 = new WeakMap();

class CubeMapNode extends TempNode {

	static get type() {

		return 'CubeMapNode';

	}

	constructor( envNode ) {

		super( 'vec3' );

		this.envNode = envNode;

		this._cubeTexture = null;
		this._cubeTextureNode = cubeTexture();

		const defaultTexture = new CubeTexture();
		defaultTexture.isRenderTargetTexture = true;

		this._defaultTexture = defaultTexture;

		this.updateBeforeType = NodeUpdateType.RENDER;

	}

	updateBefore( frame ) {

		const { renderer, material } = frame;

		const envNode = this.envNode;

		if ( envNode.isTextureNode || envNode.isMaterialReferenceNode ) {

			const texture = ( envNode.isTextureNode ) ? envNode.value : material[ envNode.property ];

			if ( texture && texture.isTexture ) {

				const mapping = texture.mapping;

				if ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) {

					// check for converted cubemap map

					if ( _cache$1.has( texture ) ) {

						const cubeMap = _cache$1.get( texture );

						mapTextureMapping( cubeMap, texture.mapping );
						this._cubeTexture = cubeMap;

					} else {

						// create cube map from equirectangular map

						const image = texture.image;

						if ( isEquirectangularMapReady$1( image ) ) {

							const renderTarget = new CubeRenderTarget( image.height );
							renderTarget.fromEquirectangularTexture( renderer, texture );

							mapTextureMapping( renderTarget.texture, texture.mapping );
							this._cubeTexture = renderTarget.texture;

							_cache$1.set( texture, renderTarget.texture );

							texture.addEventListener( 'dispose', onTextureDispose );

						} else {

							// default cube texture as fallback when equirectangular texture is not yet loaded

							this._cubeTexture = this._defaultTexture;

						}

					}

					//

					this._cubeTextureNode.value = this._cubeTexture;

				} else {

					// envNode already refers to a cube map

					this._cubeTextureNode = this.envNode;

				}

			}

		}

	}

	setup( builder ) {

		this.updateBefore( builder );

		return this._cubeTextureNode;

	}

}

function isEquirectangularMapReady$1( image ) {

	if ( image === null || image === undefined ) return false;

	return image.height > 0;

}

function onTextureDispose( event ) {

	const texture = event.target;

	texture.removeEventListener( 'dispose', onTextureDispose );

	const renderTarget = _cache$1.get( texture );

	if ( renderTarget !== undefined ) {

		_cache$1.delete( texture );

		renderTarget.dispose();

	}

}

function mapTextureMapping( texture, mapping ) {

	if ( mapping === EquirectangularReflectionMapping ) {

		texture.mapping = CubeReflectionMapping;

	} else if ( mapping === EquirectangularRefractionMapping ) {

		texture.mapping = CubeRefractionMapping;

	}

}

const cubeMapNode = /*@__PURE__*/ nodeProxy( CubeMapNode );

class BasicEnvironmentNode extends LightingNode {

	static get type() {

		return 'BasicEnvironmentNode';

	}

	constructor( envNode = null ) {

		super();

		this.envNode = envNode;

	}

	setup( builder ) {

		// environment property is used in the finish() method of BasicLightingModel

		builder.context.environment = cubeMapNode( this.envNode );

	}

}

class BasicLightMapNode extends LightingNode {

	static get type() {

		return 'BasicLightMapNode';

	}

	constructor( lightMapNode = null ) {

		super();

		this.lightMapNode = lightMapNode;

	}

	setup( builder ) {

		// irradianceLightMap property is used in the indirectDiffuse() method of BasicLightingModel

		const RECIPROCAL_PI = float$1( 1 / Math.PI );

		builder.context.irradianceLightMap = this.lightMapNode.mul( RECIPROCAL_PI );

	}

}

class LightingModel {

	start( /*input, stack, builder*/ ) { }

	finish( /*input, stack, builder*/ ) { }

	direct( /*input, stack, builder*/ ) { }

	directRectArea( /*input, stack, builder*/ ) {}

	indirect( /*input, stack, builder*/ ) { }

	ambientOcclusion( /*input, stack, builder*/ ) { }

}

class BasicLightingModel extends LightingModel {

	constructor() {

		super();

	}

	indirect( context, stack, builder ) {

		const ambientOcclusion = context.ambientOcclusion;
		const reflectedLight = context.reflectedLight;
		const irradianceLightMap = builder.context.irradianceLightMap;

		reflectedLight.indirectDiffuse.assign( vec4$1( 0.0 ) );

		// accumulation (baked indirect lighting only)

		if ( irradianceLightMap ) {

			reflectedLight.indirectDiffuse.addAssign( irradianceLightMap );

		} else {

			reflectedLight.indirectDiffuse.addAssign( vec4$1( 1.0, 1.0, 1.0, 0.0 ) );

		}

		// modulation

		reflectedLight.indirectDiffuse.mulAssign( ambientOcclusion );

		reflectedLight.indirectDiffuse.mulAssign( diffuseColor.rgb );

	}

	finish( context, stack, builder ) {

		const material = builder.material;
		const outgoingLight = context.outgoingLight;
		const envNode = builder.context.environment;

		if ( envNode ) {

			switch ( material.combine ) {

				case MultiplyOperation:
					outgoingLight.rgb.assign( mix$1( outgoingLight.rgb, outgoingLight.rgb.mul( envNode.rgb ), materialSpecularStrength.mul( materialReflectivity ) ) );
					break;

				case MixOperation:
					outgoingLight.rgb.assign( mix$1( outgoingLight.rgb, envNode.rgb, materialSpecularStrength.mul( materialReflectivity ) ) );
					break;

				case AddOperation:
					outgoingLight.rgb.addAssign( envNode.rgb.mul( materialSpecularStrength.mul( materialReflectivity ) ) );
					break;

				default:
					console.warn( 'THREE.BasicLightingModel: Unsupported .combine value:', material.combine );
					break;

			}

		}

	}

}

const _defaultValues$9 = /*@__PURE__*/ new MeshBasicMaterial();

class MeshBasicNodeMaterial extends NodeMaterial {

	static get type() {

		return 'MeshBasicNodeMaterial';

	}

	constructor( parameters ) {

		super();

		this.isMeshBasicNodeMaterial = true;

		this.lights = true;

		this.setDefaultValues( _defaultValues$9 );

		this.setValues( parameters );

	}

	setupNormal() {

		return normalView$1; // see #28839

	}

	setupEnvironment( builder ) {

		const envNode = super.setupEnvironment( builder );

		return envNode ? new BasicEnvironmentNode( envNode ) : null;

	}

	setupLightMap( builder ) {

		let node = null;

		if ( builder.material.lightMap ) {

			node = new BasicLightMapNode( materialLightMap );

		}

		return node;

	}

	setupOutgoingLight() {

		return diffuseColor.rgb;

	}

	setupLightingModel() {

		return new BasicLightingModel();

	}

}

const F_Schlick = /*@__PURE__*/ Fn$1( ( { f0, f90, dotVH } ) => {

	// Original approximation by Christophe Schlick '94
	// float fresnel = pow( 1.0 - dotVH, 5.0 );

	// Optimized variant (presented by Epic at SIGGRAPH '13)
	// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf
	const fresnel = dotVH.mul( -5.55473 ).sub( 6.98316 ).mul( dotVH ).exp2();

	return f0.mul( fresnel.oneMinus() ).add( f90.mul( fresnel ) );

} ); // validated

const BRDF_Lambert = /*@__PURE__*/ Fn$1( ( inputs ) => {

	return inputs.diffuseColor.mul( 1 / Math.PI ); // punctual light

} ); // validated

const G_BlinnPhong_Implicit = () => float$1( 0.25 );

const D_BlinnPhong = /*@__PURE__*/ Fn$1( ( { dotNH } ) => {

	return shininess.mul( float$1( 0.5 ) ).add( 1.0 ).mul( float$1( 1 / Math.PI ) ).mul( dotNH.pow( shininess ) );

} );

const BRDF_BlinnPhong = /*@__PURE__*/ Fn$1( ( { lightDirection } ) => {

	const halfDir = lightDirection.add( positionViewDirection ).normalize();

	const dotNH = transformedNormalView.dot( halfDir ).clamp();
	const dotVH = positionViewDirection.dot( halfDir ).clamp();

	const F = F_Schlick( { f0: specularColor, f90: 1.0, dotVH } );
	const G = G_BlinnPhong_Implicit();
	const D = D_BlinnPhong( { dotNH } );

	return F.mul( G ).mul( D );

} );

class PhongLightingModel extends BasicLightingModel {

	constructor( specular = true ) {

		super();

		this.specular = specular;

	}

	direct( { lightDirection, lightColor, reflectedLight } ) {

		const dotNL = transformedNormalView.dot( lightDirection ).clamp();
		const irradiance = dotNL.mul( lightColor );

		reflectedLight.directDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor: diffuseColor.rgb } ) ) );

		if ( this.specular === true ) {

			reflectedLight.directSpecular.addAssign( irradiance.mul( BRDF_BlinnPhong( { lightDirection } ) ).mul( materialSpecularStrength ) );

		}

	}

	indirect( { ambientOcclusion, irradiance, reflectedLight } ) {

		reflectedLight.indirectDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor } ) ) );

		reflectedLight.indirectDiffuse.mulAssign( ambientOcclusion );

	}

}

const _defaultValues$8 = /*@__PURE__*/ new MeshLambertMaterial();

class MeshLambertNodeMaterial extends NodeMaterial {

	static get type() {

		return 'MeshLambertNodeMaterial';

	}

	constructor( parameters ) {

		super();

		this.isMeshLambertNodeMaterial = true;

		this.lights = true;

		this.setDefaultValues( _defaultValues$8 );

		this.setValues( parameters );

	}

	setupEnvironment( builder ) {

		const envNode = super.setupEnvironment( builder );

		return envNode ? new BasicEnvironmentNode( envNode ) : null;

	}

	setupLightingModel( /*builder*/ ) {

		return new PhongLightingModel( false ); // ( specular ) -> force lambert

	}

}

const _defaultValues$7 = /*@__PURE__*/ new MeshPhongMaterial();

class MeshPhongNodeMaterial extends NodeMaterial {

	static get type() {

		return 'MeshPhongNodeMaterial';

	}

	constructor( parameters ) {

		super();

		this.isMeshPhongNodeMaterial = true;

		this.lights = true;

		this.shininessNode = null;
		this.specularNode = null;

		this.setDefaultValues( _defaultValues$7 );

		this.setValues( parameters );

	}

	setupEnvironment( builder ) {

		const envNode = super.setupEnvironment( builder );

		return envNode ? new BasicEnvironmentNode( envNode ) : null;

	}

	setupLightingModel( /*builder*/ ) {

		return new PhongLightingModel();

	}

	setupVariants() {

		// SHININESS

		const shininessNode = ( this.shininessNode ? float$1( this.shininessNode ) : materialShininess ).max( 1e-4 ); // to prevent pow( 0.0, 0.0 )

		shininess.assign( shininessNode );

		// SPECULAR COLOR

		const specularNode = this.specularNode || materialSpecular;

		specularColor.assign( specularNode );

	}

	copy( source ) {

		this.shininessNode = source.shininessNode;
		this.specularNode = source.specularNode;

		return super.copy( source );

	}

}

const getGeometryRoughness = /*@__PURE__*/ Fn$1( ( builder ) => {

	if ( builder.geometry.hasAttribute( 'normal' ) === false ) {

		return float$1( 0 );

	}

	const dxy = normalView$1.dFdx().abs().max( normalView$1.dFdy().abs() );
	const geometryRoughness = dxy.x.max( dxy.y ).max( dxy.z );

	return geometryRoughness;

} );

const getRoughness = /*@__PURE__*/ Fn$1( ( inputs ) => {

	const { roughness } = inputs;

	const geometryRoughness = getGeometryRoughness();

	let roughnessFactor = roughness.max( 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.
	roughnessFactor = roughnessFactor.add( geometryRoughness );
	roughnessFactor = roughnessFactor.min( 1.0 );

	return roughnessFactor;

} );

// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2
// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
const V_GGX_SmithCorrelated = /*@__PURE__*/ Fn$1( ( { alpha, dotNL, dotNV } ) => {

	const a2 = alpha.pow2();

	const gv = dotNL.mul( a2.add( a2.oneMinus().mul( dotNV.pow2() ) ).sqrt() );
	const gl = dotNV.mul( a2.add( a2.oneMinus().mul( dotNL.pow2() ) ).sqrt() );

	return div$1( 0.5, gv.add( gl ).max( EPSILON ) );

} ).setLayout( {
	name: 'V_GGX_SmithCorrelated',
	type: 'float',
	inputs: [
		{ name: 'alpha', type: 'float' },
		{ name: 'dotNL', type: 'float' },
		{ name: 'dotNV', type: 'float' }
	]
} ); // validated

// https://google.github.io/filament/Filament.md.html#materialsystem/anisotropicmodel/anisotropicspecularbrdf

const V_GGX_SmithCorrelated_Anisotropic = /*@__PURE__*/ Fn$1( ( { alphaT, alphaB, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL } ) => {

	const gv = dotNL.mul( vec3$1( alphaT.mul( dotTV ), alphaB.mul( dotBV ), dotNV ).length() );
	const gl = dotNV.mul( vec3$1( alphaT.mul( dotTL ), alphaB.mul( dotBL ), dotNL ).length() );
	const v = div$1( 0.5, gv.add( gl ) );

	return v.saturate();

} ).setLayout( {
	name: 'V_GGX_SmithCorrelated_Anisotropic',
	type: 'float',
	inputs: [
		{ name: 'alphaT', type: 'float', qualifier: 'in' },
		{ name: 'alphaB', type: 'float', qualifier: 'in' },
		{ name: 'dotTV', type: 'float', qualifier: 'in' },
		{ name: 'dotBV', type: 'float', qualifier: 'in' },
		{ name: 'dotTL', type: 'float', qualifier: 'in' },
		{ name: 'dotBL', type: 'float', qualifier: 'in' },
		{ name: 'dotNV', type: 'float', qualifier: 'in' },
		{ name: 'dotNL', type: 'float', qualifier: 'in' }
	]
} );

// Microfacet Models for Refraction through Rough Surfaces - equation (33)
// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html
// alpha is "roughness squared" in Disneys reparameterization
const D_GGX = /*@__PURE__*/ Fn$1( ( { alpha, dotNH } ) => {

	const a2 = alpha.pow2();

	const denom = dotNH.pow2().mul( a2.oneMinus() ).oneMinus(); // avoid alpha = 0 with dotNH = 1

	return a2.div( denom.pow2() ).mul( 1 / Math.PI );

} ).setLayout( {
	name: 'D_GGX',
	type: 'float',
	inputs: [
		{ name: 'alpha', type: 'float' },
		{ name: 'dotNH', type: 'float' }
	]
} ); // validated

const RECIPROCAL_PI = /*@__PURE__*/ float$1( 1 / Math.PI );

// https://google.github.io/filament/Filament.md.html#materialsystem/anisotropicmodel/anisotropicspecularbrdf

const D_GGX_Anisotropic = /*@__PURE__*/ Fn$1( ( { alphaT, alphaB, dotNH, dotTH, dotBH } ) => {

	const a2 = alphaT.mul( alphaB );
	const v = vec3$1( alphaB.mul( dotTH ), alphaT.mul( dotBH ), a2.mul( dotNH ) );
	const v2 = v.dot( v );
	const w2 = a2.div( v2 );

	return RECIPROCAL_PI.mul( a2.mul( w2.pow2() ) );

} ).setLayout( {
	name: 'D_GGX_Anisotropic',
	type: 'float',
	inputs: [
		{ name: 'alphaT', type: 'float', qualifier: 'in' },
		{ name: 'alphaB', type: 'float', qualifier: 'in' },
		{ name: 'dotNH', type: 'float', qualifier: 'in' },
		{ name: 'dotTH', type: 'float', qualifier: 'in' },
		{ name: 'dotBH', type: 'float', qualifier: 'in' }
	]
} );

// GGX Distribution, Schlick Fresnel, GGX_SmithCorrelated Visibility
const BRDF_GGX = /*@__PURE__*/ Fn$1( ( inputs ) => {

	const { lightDirection, f0, f90, roughness, f, USE_IRIDESCENCE, USE_ANISOTROPY } = inputs;

	const normalView = inputs.normalView || transformedNormalView;

	const alpha = roughness.pow2(); // UE4's roughness

	const halfDir = lightDirection.add( positionViewDirection ).normalize();

	const dotNL = normalView.dot( lightDirection ).clamp();
	const dotNV = normalView.dot( positionViewDirection ).clamp(); // @ TODO: Move to core dotNV
	const dotNH = normalView.dot( halfDir ).clamp();
	const dotVH = positionViewDirection.dot( halfDir ).clamp();

	let F = F_Schlick( { f0, f90, dotVH } );
	let V, D;

	if ( defined( USE_IRIDESCENCE ) ) {

		F = iridescence.mix( F, f );

	}

	if ( defined( USE_ANISOTROPY ) ) {

		const dotTL = anisotropyT.dot( lightDirection );
		const dotTV = anisotropyT.dot( positionViewDirection );
		const dotTH = anisotropyT.dot( halfDir );
		const dotBL = anisotropyB.dot( lightDirection );
		const dotBV = anisotropyB.dot( positionViewDirection );
		const dotBH = anisotropyB.dot( halfDir );

		V = V_GGX_SmithCorrelated_Anisotropic( { alphaT, alphaB: alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL } );
		D = D_GGX_Anisotropic( { alphaT, alphaB: alpha, dotNH, dotTH, dotBH } );

	} else {

		V = V_GGX_SmithCorrelated( { alpha, dotNL, dotNV } );
		D = D_GGX( { alpha, dotNH } );

	}

	return F.mul( V ).mul( D );

} ); // validated

// Analytical approximation of the DFG LUT, one half of the
// split-sum approximation used in indirect specular lighting.
// via 'environmentBRDF' from "Physically Based Shading on Mobile"
// https://www.unrealengine.com/blog/physically-based-shading-on-mobile
const DFGApprox = /*@__PURE__*/ Fn$1( ( { roughness, dotNV } ) => {

	const c0 = vec4$1( -1, -0.0275, -0.572, 0.022 );

	const c1 = vec4$1( 1, 0.0425, 1.04, -0.04 );

	const r = roughness.mul( c0 ).add( c1 );

	const a004 = r.x.mul( r.x ).min( dotNV.mul( -9.28 ).exp2() ).mul( r.x ).add( r.y );

	const fab = vec2$1( -1.04, 1.04 ).mul( a004 ).add( r.zw );

	return fab;

} ).setLayout( {
	name: 'DFGApprox',
	type: 'vec2',
	inputs: [
		{ name: 'roughness', type: 'float' },
		{ name: 'dotNV', type: 'vec3' }
	]
} );

const EnvironmentBRDF = /*@__PURE__*/ Fn$1( ( inputs ) => {

	const { dotNV, specularColor, specularF90, roughness } = inputs;

	const fab = DFGApprox( { dotNV, roughness } );
	return specularColor.mul( fab.x ).add( specularF90.mul( fab.y ) );

} );

const Schlick_to_F0 = /*@__PURE__*/ Fn$1( ( { f, f90, dotVH } ) => {

	const x = dotVH.oneMinus().saturate();
	const x2 = x.mul( x );
	const x5 = x.mul( x2, x2 ).clamp( 0, .9999 );

	return f.sub( vec3$1( f90 ).mul( x5 ) ).div( x5.oneMinus() );

} ).setLayout( {
	name: 'Schlick_to_F0',
	type: 'vec3',
	inputs: [
		{ name: 'f', type: 'vec3' },
		{ name: 'f90', type: 'float' },
		{ name: 'dotVH', type: 'float' }
	]
} );

// https://github.com/google/filament/blob/master/shaders/src/brdf.fs
const D_Charlie = /*@__PURE__*/ Fn$1( ( { roughness, dotNH } ) => {

	const alpha = roughness.pow2();

	// Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF"
	const invAlpha = float$1( 1.0 ).div( alpha );
	const cos2h = dotNH.pow2();
	const sin2h = cos2h.oneMinus().max( 0.0078125 ); // 2^(-14/2), so sin2h^2 > 0 in fp16

	return float$1( 2.0 ).add( invAlpha ).mul( sin2h.pow( invAlpha.mul( 0.5 ) ) ).div( 2.0 * Math.PI );

} ).setLayout( {
	name: 'D_Charlie',
	type: 'float',
	inputs: [
		{ name: 'roughness', type: 'float' },
		{ name: 'dotNH', type: 'float' }
	]
} );

// https://github.com/google/filament/blob/master/shaders/src/brdf.fs
const V_Neubelt = /*@__PURE__*/ Fn$1( ( { dotNV, dotNL } ) => {

	// Neubelt and Pettineo 2013, "Crafting a Next-gen Material Pipeline for The Order: 1886"
	return float$1( 1.0 ).div( float$1( 4.0 ).mul( dotNL.add( dotNV ).sub( dotNL.mul( dotNV ) ) ) );

} ).setLayout( {
	name: 'V_Neubelt',
	type: 'float',
	inputs: [
		{ name: 'dotNV', type: 'float' },
		{ name: 'dotNL', type: 'float' }
	]
} );

const BRDF_Sheen = /*@__PURE__*/ Fn$1( ( { lightDirection } ) => {

	const halfDir = lightDirection.add( positionViewDirection ).normalize();

	const dotNL = transformedNormalView.dot( lightDirection ).clamp();
	const dotNV = transformedNormalView.dot( positionViewDirection ).clamp();
	const dotNH = transformedNormalView.dot( halfDir ).clamp();

	const D = D_Charlie( { roughness: sheenRoughness, dotNH } );
	const V = V_Neubelt( { dotNV, dotNL } );

	return sheen.mul( D ).mul( V );

} );

// Rect Area Light

// Real-Time Polygonal-Light Shading with Linearly Transformed Cosines
// by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt
// code: https://github.com/selfshadow/ltc_code/

const LTC_Uv = /*@__PURE__*/ Fn$1( ( { N, V, roughness } ) => {

	const LUT_SIZE = 64.0;
	const LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const LUT_BIAS = 0.5 / LUT_SIZE;

	const dotNV = N.dot( V ).saturate();

	// texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )
	const uv = vec2$1( roughness, dotNV.oneMinus().sqrt() );

	uv.assign( uv.mul( LUT_SCALE ).add( LUT_BIAS ) );

	return uv;

} ).setLayout( {
	name: 'LTC_Uv',
	type: 'vec2',
	inputs: [
		{ name: 'N', type: 'vec3' },
		{ name: 'V', type: 'vec3' },
		{ name: 'roughness', type: 'float' }
	]
} );

const LTC_ClippedSphereFormFactor = /*@__PURE__*/ Fn$1( ( { f } ) => {

	// Real-Time Area Lighting: a Journey from Research to Production (p.102)
	// An approximation of the form factor of a horizon-clipped rectangle.

	const l = f.length();

	return max$1( l.mul( l ).add( f.z ).div( l.add( 1.0 ) ), 0 );

} ).setLayout( {
	name: 'LTC_ClippedSphereFormFactor',
	type: 'float',
	inputs: [
		{ name: 'f', type: 'vec3' }
	]
} );

const LTC_EdgeVectorFormFactor = /*@__PURE__*/ Fn$1( ( { v1, v2 } ) => {

	const x = v1.dot( v2 );
	const y = x.abs().toVar();

	// rational polynomial approximation to theta / sin( theta ) / 2PI
	const a = y.mul( 0.0145206 ).add( 0.4965155 ).mul( y ).add( 0.8543985 ).toVar();
	const b = y.add( 4.1616724 ).mul( y ).add( 3.4175940 ).toVar();
	const v = a.div( b );

	const theta_sintheta = x.greaterThan( 0.0 ).select( v, max$1( x.mul( x ).oneMinus(), 1e-7 ).inverseSqrt().mul( 0.5 ).sub( v ) );

	return v1.cross( v2 ).mul( theta_sintheta );

} ).setLayout( {
	name: 'LTC_EdgeVectorFormFactor',
	type: 'vec3',
	inputs: [
		{ name: 'v1', type: 'vec3' },
		{ name: 'v2', type: 'vec3' }
	]
} );

const LTC_Evaluate = /*@__PURE__*/ Fn$1( ( { N, V, P, mInv, p0, p1, p2, p3 } ) => {

	// bail if point is on back side of plane of light
	// assumes ccw winding order of light vertices
	const v1 = p1.sub( p0 ).toVar();
	const v2 = p3.sub( p0 ).toVar();

	const lightNormal = v1.cross( v2 );
	const result = vec3$1().toVar();

	If( lightNormal.dot( P.sub( p0 ) ).greaterThanEqual( 0.0 ), () => {

		// construct orthonormal basis around N
		const T1 = V.sub( N.mul( V.dot( N ) ) ).normalize();
		const T2 = N.cross( T1 ).negate(); // negated from paper; possibly due to a different handedness of world coordinate system

		// compute transform
		const mat = mInv.mul( mat3( T1, T2, N ).transpose() ).toVar();

		// transform rect
		// & project rect onto sphere
		const coords0 = mat.mul( p0.sub( P ) ).normalize().toVar();
		const coords1 = mat.mul( p1.sub( P ) ).normalize().toVar();
		const coords2 = mat.mul( p2.sub( P ) ).normalize().toVar();
		const coords3 = mat.mul( p3.sub( P ) ).normalize().toVar();

		// calculate vector form factor
		const vectorFormFactor = vec3$1( 0 ).toVar();
		vectorFormFactor.addAssign( LTC_EdgeVectorFormFactor( { v1: coords0, v2: coords1 } ) );
		vectorFormFactor.addAssign( LTC_EdgeVectorFormFactor( { v1: coords1, v2: coords2 } ) );
		vectorFormFactor.addAssign( LTC_EdgeVectorFormFactor( { v1: coords2, v2: coords3 } ) );
		vectorFormFactor.addAssign( LTC_EdgeVectorFormFactor( { v1: coords3, v2: coords0 } ) );

		// adjust for horizon clipping
		result.assign( vec3$1( LTC_ClippedSphereFormFactor( { f: vectorFormFactor } ) ) );

	} );

	return result;

} ).setLayout( {
	name: 'LTC_Evaluate',
	type: 'vec3',
	inputs: [
		{ name: 'N', type: 'vec3' },
		{ name: 'V', type: 'vec3' },
		{ name: 'P', type: 'vec3' },
		{ name: 'mInv', type: 'mat3' },
		{ name: 'p0', type: 'vec3' },
		{ name: 'p1', type: 'vec3' },
		{ name: 'p2', type: 'vec3' },
		{ name: 'p3', type: 'vec3' }
	]
} );

// Mipped Bicubic Texture Filtering by N8
// https://www.shadertoy.com/view/Dl2SDW

const bC = 1.0 / 6.0;

const w0 = ( a ) => mul$1( bC, mul$1( a, mul$1( a, a.negate().add( 3.0 ) ).sub( 3.0 ) ).add( 1.0 ) );

const w1 = ( a ) => mul$1( bC, mul$1( a, mul$1( a, mul$1( 3.0, a ).sub( 6.0 ) ) ).add( 4.0 ) );

const w2 = ( a ) => mul$1( bC, mul$1( a, mul$1( a, mul$1( -3, a ).add( 3.0 ) ).add( 3.0 ) ).add( 1.0 ) );

const w3 = ( a ) => mul$1( bC, pow$1( a, 3 ) );

const g0 = ( a ) => w0( a ).add( w1( a ) );

const g1 = ( a ) => w2( a ).add( w3( a ) );

// h0 and h1 are the two offset functions
const h0 = ( a ) => add$1( -1, w1( a ).div( w0( a ).add( w1( a ) ) ) );

const h1 = ( a ) => add$1( 1.0, w3( a ).div( w2( a ).add( w3( a ) ) ) );

const bicubic = ( textureNode, texelSize, lod ) => {

	const uv = textureNode.uvNode;
	const uvScaled = mul$1( uv, texelSize.zw ).add( 0.5 );

	const iuv = floor$1( uvScaled );
	const fuv = fract$1( uvScaled );

	const g0x = g0( fuv.x );
	const g1x = g1( fuv.x );
	const h0x = h0( fuv.x );
	const h1x = h1( fuv.x );
	const h0y = h0( fuv.y );
	const h1y = h1( fuv.y );

	const p0 = vec2$1( iuv.x.add( h0x ), iuv.y.add( h0y ) ).sub( 0.5 ).mul( texelSize.xy );
	const p1 = vec2$1( iuv.x.add( h1x ), iuv.y.add( h0y ) ).sub( 0.5 ).mul( texelSize.xy );
	const p2 = vec2$1( iuv.x.add( h0x ), iuv.y.add( h1y ) ).sub( 0.5 ).mul( texelSize.xy );
	const p3 = vec2$1( iuv.x.add( h1x ), iuv.y.add( h1y ) ).sub( 0.5 ).mul( texelSize.xy );

	const a = g0( fuv.y ).mul( add$1( g0x.mul( textureNode.uv( p0 ).level( lod ) ), g1x.mul( textureNode.uv( p1 ).level( lod ) ) ) );
	const b = g1( fuv.y ).mul( add$1( g0x.mul( textureNode.uv( p2 ).level( lod ) ), g1x.mul( textureNode.uv( p3 ).level( lod ) ) ) );

	return a.add( b );

};

const textureBicubic = /*@__PURE__*/ Fn$1( ( [ textureNode, lodNode = float$1( 3 ) ] ) => {

	const fLodSize = vec2$1( textureNode.size( int( lodNode ) ) );
	const cLodSize = vec2$1( textureNode.size( int( lodNode.add( 1.0 ) ) ) );
	const fLodSizeInv = div$1( 1.0, fLodSize );
	const cLodSizeInv = div$1( 1.0, cLodSize );
	const fSample = bicubic( textureNode, vec4$1( fLodSizeInv, fLodSize ), floor$1( lodNode ) );
	const cSample = bicubic( textureNode, vec4$1( cLodSizeInv, cLodSize ), ceil( lodNode ) );

	return fract$1( lodNode ).mix( fSample, cSample );

} );

//
// Transmission
//

const getVolumeTransmissionRay = /*@__PURE__*/ Fn$1( ( [ n, v, thickness, ior, modelMatrix ] ) => {

	// Direction of refracted light.
	const refractionVector = vec3$1( refract( v.negate(), normalize$1( n ), div$1( 1.0, ior ) ) );

	// Compute rotation-independant scaling of the model matrix.
	const modelScale = vec3$1(
		length( modelMatrix[ 0 ].xyz ),
		length( modelMatrix[ 1 ].xyz ),
		length( modelMatrix[ 2 ].xyz )
	);

	// The thickness is specified in local space.
	return normalize$1( refractionVector ).mul( thickness.mul( modelScale ) );

} ).setLayout( {
	name: 'getVolumeTransmissionRay',
	type: 'vec3',
	inputs: [
		{ name: 'n', type: 'vec3' },
		{ name: 'v', type: 'vec3' },
		{ name: 'thickness', type: 'float' },
		{ name: 'ior', type: 'float' },
		{ name: 'modelMatrix', type: 'mat4' }
	]
} );

const applyIorToRoughness = /*@__PURE__*/ Fn$1( ( [ roughness, ior ] ) => {

	// Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and
	// an IOR of 1.5 results in the default amount of microfacet refraction.
	return roughness.mul( clamp( ior.mul( 2.0 ).sub( 2.0 ), 0.0, 1.0 ) );

} ).setLayout( {
	name: 'applyIorToRoughness',
	type: 'float',
	inputs: [
		{ name: 'roughness', type: 'float' },
		{ name: 'ior', type: 'float' }
	]
} );

const viewportBackSideTexture = /*@__PURE__*/ viewportMipTexture();
const viewportFrontSideTexture = /*@__PURE__*/ viewportMipTexture();

const getTransmissionSample = /*@__PURE__*/ Fn$1( ( [ fragCoord, roughness, ior ], { material } ) => {

	const vTexture = material.side == BackSide ? viewportBackSideTexture : viewportFrontSideTexture;

	const transmissionSample = vTexture.uv( fragCoord );
	//const transmissionSample = viewportMipTexture( fragCoord );

	const lod = log2( screenSize.x ).mul( applyIorToRoughness( roughness, ior ) );

	return textureBicubic( transmissionSample, lod );

} );

const volumeAttenuation = /*@__PURE__*/ Fn$1( ( [ transmissionDistance, attenuationColor, attenuationDistance ] ) => {

	If( attenuationDistance.notEqual( 0 ), () => {

		// Compute light attenuation using Beer's law.
		const attenuationCoefficient = log( attenuationColor ).negate().div( attenuationDistance );
		const transmittance = exp$1( attenuationCoefficient.negate().mul( transmissionDistance ) );

		return transmittance;

	} );

	// Attenuation distance is +, i.e. the transmitted color is not attenuated at all.
	return vec3$1( 1.0 );

} ).setLayout( {
	name: 'volumeAttenuation',
	type: 'vec3',
	inputs: [
		{ name: 'transmissionDistance', type: 'float' },
		{ name: 'attenuationColor', type: 'vec3' },
		{ name: 'attenuationDistance', type: 'float' }
	]
} );

const getIBLVolumeRefraction = /*@__PURE__*/ Fn$1( ( [ n, v, roughness, diffuseColor, specularColor, specularF90, position, modelMatrix, viewMatrix, projMatrix, ior, thickness, attenuationColor, attenuationDistance, dispersion ] ) => {

	let transmittedLight, transmittance;

	if ( dispersion ) {

		transmittedLight = vec4$1().toVar();
		transmittance = vec3$1().toVar();

		const halfSpread = ior.sub( 1.0 ).mul( dispersion.mul( 0.025 ) );
		const iors = vec3$1( ior.sub( halfSpread ), ior, ior.add( halfSpread ) );

		Loop( { start: 0, end: 3 }, ( { i } ) => {

			const ior = iors.element( i );

			const transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			const refractedRayExit = position.add( transmissionRay );

			// Project refracted vector on the framebuffer, while mapping to normalized device coordinates.
			const ndcPos = projMatrix.mul( viewMatrix.mul( vec4$1( refractedRayExit, 1.0 ) ) );
			const refractionCoords = vec2$1( ndcPos.xy.div( ndcPos.w ) ).toVar();
			refractionCoords.addAssign( 1.0 );
			refractionCoords.divAssign( 2.0 );
			refractionCoords.assign( vec2$1( refractionCoords.x, refractionCoords.y.oneMinus() ) ); // webgpu

			// Sample framebuffer to get pixel the refracted ray hits.
			const transmissionSample = getTransmissionSample( refractionCoords, roughness, ior );

			transmittedLight.element( i ).assign( transmissionSample.element( i ) );
			transmittedLight.a.addAssign( transmissionSample.a );

			transmittance.element( i ).assign( diffuseColor.element( i ).mul( volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance ).element( i ) ) );

		} );

		transmittedLight.a.divAssign( 3.0 );

	} else {

		const transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		const refractedRayExit = position.add( transmissionRay );

		// Project refracted vector on the framebuffer, while mapping to normalized device coordinates.
		const ndcPos = projMatrix.mul( viewMatrix.mul( vec4$1( refractedRayExit, 1.0 ) ) );
		const refractionCoords = vec2$1( ndcPos.xy.div( ndcPos.w ) ).toVar();
		refractionCoords.addAssign( 1.0 );
		refractionCoords.divAssign( 2.0 );
		refractionCoords.assign( vec2$1( refractionCoords.x, refractionCoords.y.oneMinus() ) ); // webgpu

		// Sample framebuffer to get pixel the refracted ray hits.
		transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		transmittance = diffuseColor.mul( volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance ) );

	}

	const attenuatedColor = transmittance.rgb.mul( transmittedLight.rgb );
	const dotNV = n.dot( v ).clamp();

	// Get the specular component.
	const F = vec3$1( EnvironmentBRDF( { // n, v, specularColor, specularF90, roughness
		dotNV,
		specularColor,
		specularF90,
		roughness
	} ) );

	// As less light is transmitted, the opacity should be increased. This simple approximation does a decent job
	// of modulating a CSS background, and has no effect when the buffer is opaque, due to a solid object or clear color.
	const transmittanceFactor = transmittance.r.add( transmittance.g, transmittance.b ).div( 3.0 );

	return vec4$1( F.oneMinus().mul( attenuatedColor ), transmittedLight.a.oneMinus().mul( transmittanceFactor ).oneMinus() );

} );

//
// Iridescence
//

// XYZ to linear-sRGB color space
const XYZ_TO_REC709 = /*@__PURE__*/ mat3(
	3.2404542, -0.969266, 0.0556434,
	-1.5371385, 1.8760108, -0.2040259,
	-0.4985314, 0.0415560, 1.0572252
);

// Assume air interface for top
// Note: We don't handle the case fresnel0 == 1
const Fresnel0ToIor = ( fresnel0 ) => {

	const sqrtF0 = fresnel0.sqrt();
	return vec3$1( 1.0 ).add( sqrtF0 ).div( vec3$1( 1.0 ).sub( sqrtF0 ) );

};

// ior is a value between 1.0 and 3.0. 1.0 is air interface
const IorToFresnel0 = ( transmittedIor, incidentIor ) => {

	return transmittedIor.sub( incidentIor ).div( transmittedIor.add( incidentIor ) ).pow2();

};

// Fresnel equations for dielectric/dielectric interfaces.
// Ref: https://belcour.github.io/blog/research/2017/05/01/brdf-thin-film.html
// Evaluation XYZ sensitivity curves in Fourier space
const evalSensitivity = ( OPD, shift ) => {

	const phase = OPD.mul( 2.0 * Math.PI * 1.0e-9 );
	const val = vec3$1( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
	const pos = vec3$1( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
	const VAR = vec3$1( 4.3278e+09, 9.3046e+09, 6.6121e+09 );

	const x = float$1( 9.7470e-14 * Math.sqrt( 2.0 * Math.PI * 4.5282e+09 ) ).mul( phase.mul( 2.2399e+06 ).add( shift.x ).cos() ).mul( phase.pow2().mul( -45282e5 ).exp() );

	let xyz = val.mul( VAR.mul( 2.0 * Math.PI ).sqrt() ).mul( pos.mul( phase ).add( shift ).cos() ).mul( phase.pow2().negate().mul( VAR ).exp() );
	xyz = vec3$1( xyz.x.add( x ), xyz.y, xyz.z ).div( 1.0685e-7 );

	const rgb = XYZ_TO_REC709.mul( xyz );

	return rgb;

};

const evalIridescence = /*@__PURE__*/ Fn$1( ( { outsideIOR, eta2, cosTheta1, thinFilmThickness, baseF0 } ) => {

	// Force iridescenceIOR -> outsideIOR when thinFilmThickness -> 0.0
	const iridescenceIOR = mix$1( outsideIOR, eta2, smoothstep$1( 0.0, 0.03, thinFilmThickness ) );
	// Evaluate the cosTheta on the base layer (Snell law)
	const sinTheta2Sq = outsideIOR.div( iridescenceIOR ).pow2().mul( cosTheta1.pow2().oneMinus() );

	// Handle TIR:
	const cosTheta2Sq = sinTheta2Sq.oneMinus();

	If( cosTheta2Sq.lessThan( 0 ), () => {

		return vec3$1( 1.0 );

	} );

	const cosTheta2 = cosTheta2Sq.sqrt();

	// First interface
	const R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
	const R12 = F_Schlick( { f0: R0, f90: 1.0, dotVH: cosTheta1 } );
	//const R21 = R12;
	const T121 = R12.oneMinus();
	const phi12 = iridescenceIOR.lessThan( outsideIOR ).select( Math.PI, 0.0 );
	const phi21 = float$1( Math.PI ).sub( phi12 );

	// Second interface
	const baseIOR = Fresnel0ToIor( baseF0.clamp( 0.0, 0.9999 ) ); // guard against 1.0
	const R1 = IorToFresnel0( baseIOR, iridescenceIOR.toVec3() );
	const R23 = F_Schlick( { f0: R1, f90: 1.0, dotVH: cosTheta2 } );
	const phi23 = vec3$1(
		baseIOR.x.lessThan( iridescenceIOR ).select( Math.PI, 0.0 ),
		baseIOR.y.lessThan( iridescenceIOR ).select( Math.PI, 0.0 ),
		baseIOR.z.lessThan( iridescenceIOR ).select( Math.PI, 0.0 )
	);

	// Phase shift
	const OPD = iridescenceIOR.mul( thinFilmThickness, cosTheta2, 2.0 );
	const phi = vec3$1( phi21 ).add( phi23 );

	// Compound terms
	const R123 = R12.mul( R23 ).clamp( 1e-5, 0.9999 );
	const r123 = R123.sqrt();
	const Rs = T121.pow2().mul( R23 ).div( vec3$1( 1.0 ).sub( R123 ) );

	// Reflectance term for m = 0 (DC term amplitude)
	const C0 = R12.add( Rs );
	const I = C0.toVar();

	// Reflectance term for m > 0 (pairs of diracs)
	const Cm = Rs.sub( T121 ).toVar();

	Loop( { start: 1, end: 2, condition: '<=', name: 'm' }, ( { m } ) => {

		Cm.mulAssign( r123 );
		const Sm = evalSensitivity( float$1( m ).mul( OPD ), float$1( m ).mul( phi ) ).mul( 2.0 );
		I.addAssign( Cm.mul( Sm ) );

	} );

	// Since out of gamut colors might be produced, negative color values are clamped to 0.
	return I.max( vec3$1( 0.0 ) );

} ).setLayout( {
	name: 'evalIridescence',
	type: 'vec3',
	inputs: [
		{ name: 'outsideIOR', type: 'float' },
		{ name: 'eta2', type: 'float' },
		{ name: 'cosTheta1', type: 'float' },
		{ name: 'thinFilmThickness', type: 'float' },
		{ name: 'baseF0', type: 'vec3' }
	]
} );

//
//	Sheen
//

// This is a curve-fit approxmation to the "Charlie sheen" BRDF integrated over the hemisphere from
// Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF". The analysis can be found
// in the Sheen section of https://drive.google.com/file/d/1T0D1VSyR4AllqIJTQAraEIzjlb5h4FKH/view?usp=sharing
const IBLSheenBRDF = /*@__PURE__*/ Fn$1( ( { normal, viewDir, roughness } ) => {

	const dotNV = normal.dot( viewDir ).saturate();

	const r2 = roughness.pow2();

	const a = select(
		roughness.lessThan( 0.25 ),
		float$1( -339.2 ).mul( r2 ).add( float$1( 161.4 ).mul( roughness ) ).sub( 25.9 ),
		float$1( -8.48 ).mul( r2 ).add( float$1( 14.3 ).mul( roughness ) ).sub( 9.95 )
	);

	const b = select(
		roughness.lessThan( 0.25 ),
		float$1( 44.0 ).mul( r2 ).sub( float$1( 23.7 ).mul( roughness ) ).add( 3.26 ),
		float$1( 1.97 ).mul( r2 ).sub( float$1( 3.27 ).mul( roughness ) ).add( 0.72 )
	);

	const DG = select( roughness.lessThan( 0.25 ), 0.0, float$1( 0.1 ).mul( roughness ).sub( 0.025 ) ).add( a.mul( dotNV ).add( b ).exp() );

	return DG.mul( 1.0 / Math.PI ).saturate();

} );

const clearcoatF0 = vec3$1( 0.04 );
const clearcoatF90 = float$1( 1 );

//

class PhysicalLightingModel extends LightingModel {

	constructor( clearcoat = false, sheen = false, iridescence = false, anisotropy = false, transmission = false, dispersion = false ) {

		super();

		this.clearcoat = clearcoat;
		this.sheen = sheen;
		this.iridescence = iridescence;
		this.anisotropy = anisotropy;
		this.transmission = transmission;
		this.dispersion = dispersion;

		this.clearcoatRadiance = null;
		this.clearcoatSpecularDirect = null;
		this.clearcoatSpecularIndirect = null;
		this.sheenSpecularDirect = null;
		this.sheenSpecularIndirect = null;
		this.iridescenceFresnel = null;
		this.iridescenceF0 = null;

	}

	start( context ) {

		if ( this.clearcoat === true ) {

			this.clearcoatRadiance = vec3$1().toVar( 'clearcoatRadiance' );
			this.clearcoatSpecularDirect = vec3$1().toVar( 'clearcoatSpecularDirect' );
			this.clearcoatSpecularIndirect = vec3$1().toVar( 'clearcoatSpecularIndirect' );

		}

		if ( this.sheen === true ) {

			this.sheenSpecularDirect = vec3$1().toVar( 'sheenSpecularDirect' );
			this.sheenSpecularIndirect = vec3$1().toVar( 'sheenSpecularIndirect' );

		}

		if ( this.iridescence === true ) {

			const dotNVi = transformedNormalView.dot( positionViewDirection ).clamp();

			this.iridescenceFresnel = evalIridescence( {
				outsideIOR: float$1( 1.0 ),
				eta2: iridescenceIOR,
				cosTheta1: dotNVi,
				thinFilmThickness: iridescenceThickness,
				baseF0: specularColor
			} );

			this.iridescenceF0 = Schlick_to_F0( { f: this.iridescenceFresnel, f90: 1.0, dotVH: dotNVi } );

		}

		if ( this.transmission === true ) {

			const position = positionWorld$1;
			const v = cameraPosition$1.sub( positionWorld$1 ).normalize(); // TODO: Create Node for this, same issue in MaterialX
			const n = transformedNormalWorld;

			context.backdrop = getIBLVolumeRefraction(
				n,
				v,
				roughness,
				diffuseColor,
				specularColor,
				specularF90, // specularF90
				position, // positionWorld
				modelWorldMatrix, // modelMatrix
				cameraViewMatrix, // viewMatrix
				cameraProjectionMatrix, // projMatrix
				ior,
				thickness,
				attenuationColor,
				attenuationDistance,
				this.dispersion ? dispersion : null
			);

			context.backdropAlpha = transmission;

			diffuseColor.a.mulAssign( mix$1( 1, context.backdrop.a, transmission ) );

		}

	}

	// Fdez-Agera's "Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting"
	// Approximates multiscattering in order to preserve energy.
	// http://www.jcgt.org/published/0008/01/03/

	computeMultiscattering( singleScatter, multiScatter, specularF90 ) {

		const dotNV = transformedNormalView.dot( positionViewDirection ).clamp(); // @ TODO: Move to core dotNV

		const fab = DFGApprox( { roughness, dotNV } );

		const Fr = this.iridescenceF0 ? iridescence.mix( specularColor, this.iridescenceF0 ) : specularColor;

		const FssEss = Fr.mul( fab.x ).add( specularF90.mul( fab.y ) );

		const Ess = fab.x.add( fab.y );
		const Ems = Ess.oneMinus();

		const Favg = specularColor.add( specularColor.oneMinus().mul( 0.047619 ) ); // 1/21
		const Fms = FssEss.mul( Favg ).div( Ems.mul( Favg ).oneMinus() );

		singleScatter.addAssign( FssEss );
		multiScatter.addAssign( Fms.mul( Ems ) );

	}

	direct( { lightDirection, lightColor, reflectedLight } ) {

		const dotNL = transformedNormalView.dot( lightDirection ).clamp();
		const irradiance = dotNL.mul( lightColor );

		if ( this.sheen === true ) {

			this.sheenSpecularDirect.addAssign( irradiance.mul( BRDF_Sheen( { lightDirection } ) ) );

		}

		if ( this.clearcoat === true ) {

			const dotNLcc = transformedClearcoatNormalView.dot( lightDirection ).clamp();
			const ccIrradiance = dotNLcc.mul( lightColor );

			this.clearcoatSpecularDirect.addAssign( ccIrradiance.mul( BRDF_GGX( { lightDirection, f0: clearcoatF0, f90: clearcoatF90, roughness: clearcoatRoughness, normalView: transformedClearcoatNormalView } ) ) );

		}

		reflectedLight.directDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor: diffuseColor.rgb } ) ) );

		reflectedLight.directSpecular.addAssign( irradiance.mul( BRDF_GGX( { lightDirection, f0: specularColor, f90: 1, roughness, iridescence: this.iridescence, f: this.iridescenceFresnel, USE_IRIDESCENCE: this.iridescence, USE_ANISOTROPY: this.anisotropy } ) ) );

	}

	directRectArea( { lightColor, lightPosition, halfWidth, halfHeight, reflectedLight, ltc_1, ltc_2 } ) {

		const p0 = lightPosition.add( halfWidth ).sub( halfHeight ); // counterclockwise; light shines in local neg z direction
		const p1 = lightPosition.sub( halfWidth ).sub( halfHeight );
		const p2 = lightPosition.sub( halfWidth ).add( halfHeight );
		const p3 = lightPosition.add( halfWidth ).add( halfHeight );

		const N = transformedNormalView;
		const V = positionViewDirection;
		const P = positionView$1.toVar();

		const uv = LTC_Uv( { N, V, roughness } );

		const t1 = ltc_1.uv( uv ).toVar();
		const t2 = ltc_2.uv( uv ).toVar();

		const mInv = mat3(
			vec3$1( t1.x, 0, t1.y ),
			vec3$1( 0, 1, 0 ),
			vec3$1( t1.z, 0, t1.w )
		).toVar();

		// LTC Fresnel Approximation by Stephen Hill
		// http://blog.selfshadow.com/publications/s2016-advances/s2016_ltc_fresnel.pdf
		const fresnel = specularColor.mul( t2.x ).add( specularColor.oneMinus().mul( t2.y ) ).toVar();

		reflectedLight.directSpecular.addAssign( lightColor.mul( fresnel ).mul( LTC_Evaluate( { N, V, P, mInv, p0, p1, p2, p3 } ) ) );

		reflectedLight.directDiffuse.addAssign( lightColor.mul( diffuseColor ).mul( LTC_Evaluate( { N, V, P, mInv: mat3( 1, 0, 0, 0, 1, 0, 0, 0, 1 ), p0, p1, p2, p3 } ) ) );

	}

	indirect( context, stack, builder ) {

		this.indirectDiffuse( context, stack, builder );
		this.indirectSpecular( context, stack, builder );
		this.ambientOcclusion( context, stack, builder );

	}

	indirectDiffuse( { irradiance, reflectedLight } ) {

		reflectedLight.indirectDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor } ) ) );

	}

	indirectSpecular( { radiance, iblIrradiance, reflectedLight } ) {

		if ( this.sheen === true ) {

			this.sheenSpecularIndirect.addAssign( iblIrradiance.mul(
				sheen,
				IBLSheenBRDF( {
					normal: transformedNormalView,
					viewDir: positionViewDirection,
					roughness: sheenRoughness
				} )
			) );

		}

		if ( this.clearcoat === true ) {

			const dotNVcc = transformedClearcoatNormalView.dot( positionViewDirection ).clamp();

			const clearcoatEnv = EnvironmentBRDF( {
				dotNV: dotNVcc,
				specularColor: clearcoatF0,
				specularF90: clearcoatF90,
				roughness: clearcoatRoughness
			} );

			this.clearcoatSpecularIndirect.addAssign( this.clearcoatRadiance.mul( clearcoatEnv ) );

		}

		// Both indirect specular and indirect diffuse light accumulate here

		const singleScattering = vec3$1().toVar( 'singleScattering' );
		const multiScattering = vec3$1().toVar( 'multiScattering' );
		const cosineWeightedIrradiance = iblIrradiance.mul( 1 / Math.PI );

		this.computeMultiscattering( singleScattering, multiScattering, specularF90 );

		const totalScattering = singleScattering.add( multiScattering );

		const diffuse = diffuseColor.mul( totalScattering.r.max( totalScattering.g ).max( totalScattering.b ).oneMinus() );

		reflectedLight.indirectSpecular.addAssign( radiance.mul( singleScattering ) );
		reflectedLight.indirectSpecular.addAssign( multiScattering.mul( cosineWeightedIrradiance ) );

		reflectedLight.indirectDiffuse.addAssign( diffuse.mul( cosineWeightedIrradiance ) );

	}

	ambientOcclusion( { ambientOcclusion, reflectedLight } ) {

		const dotNV = transformedNormalView.dot( positionViewDirection ).clamp(); // @ TODO: Move to core dotNV

		const aoNV = dotNV.add( ambientOcclusion );
		const aoExp = roughness.mul( -16 ).oneMinus().negate().exp2();

		const aoNode = ambientOcclusion.sub( aoNV.pow( aoExp ).oneMinus() ).clamp();

		if ( this.clearcoat === true ) {

			this.clearcoatSpecularIndirect.mulAssign( ambientOcclusion );

		}

		if ( this.sheen === true ) {

			this.sheenSpecularIndirect.mulAssign( ambientOcclusion );

		}

		reflectedLight.indirectDiffuse.mulAssign( ambientOcclusion );
		reflectedLight.indirectSpecular.mulAssign( aoNode );

	}

	finish( context ) {

		const { outgoingLight } = context;

		if ( this.clearcoat === true ) {

			const dotNVcc = transformedClearcoatNormalView.dot( positionViewDirection ).clamp();

			const Fcc = F_Schlick( {
				dotVH: dotNVcc,
				f0: clearcoatF0,
				f90: clearcoatF90
			} );

			const clearcoatLight = outgoingLight.mul( clearcoat.mul( Fcc ).oneMinus() ).add( this.clearcoatSpecularDirect.add( this.clearcoatSpecularIndirect ).mul( clearcoat ) );

			outgoingLight.assign( clearcoatLight );

		}

		if ( this.sheen === true ) {

			const sheenEnergyComp = sheen.r.max( sheen.g ).max( sheen.b ).mul( 0.157 ).oneMinus();
			const sheenLight = outgoingLight.mul( sheenEnergyComp ).add( this.sheenSpecularDirect, this.sheenSpecularIndirect );

			outgoingLight.assign( sheenLight );

		}

	}

}

// These defines must match with PMREMGenerator

const cubeUV_r0 = /*@__PURE__*/ float$1( 1.0 );
const cubeUV_m0 = /*@__PURE__*/ float$1( -2 );
const cubeUV_r1 = /*@__PURE__*/ float$1( 0.8 );
const cubeUV_m1 = /*@__PURE__*/ float$1( -1 );
const cubeUV_r4 = /*@__PURE__*/ float$1( 0.4 );
const cubeUV_m4 = /*@__PURE__*/ float$1( 2.0 );
const cubeUV_r5 = /*@__PURE__*/ float$1( 0.305 );
const cubeUV_m5 = /*@__PURE__*/ float$1( 3.0 );
const cubeUV_r6 = /*@__PURE__*/ float$1( 0.21 );
const cubeUV_m6 = /*@__PURE__*/ float$1( 4.0 );

const cubeUV_minMipLevel = /*@__PURE__*/ float$1( 4.0 );
const cubeUV_minTileSize = /*@__PURE__*/ float$1( 16.0 );

// These shader functions convert between the UV coordinates of a single face of
// a cubemap, the 0-5 integer index of a cube face, and the direction vector for
// sampling a textureCube (not generally normalized ).

const getFace = /*@__PURE__*/ Fn$1( ( [ direction ] ) => {

	const absDirection = vec3$1( abs$1( direction ) ).toVar();
	const face = float$1( -1 ).toVar();

	If( absDirection.x.greaterThan( absDirection.z ), () => {

		If( absDirection.x.greaterThan( absDirection.y ), () => {

			face.assign( select( direction.x.greaterThan( 0.0 ), 0.0, 3.0 ) );

		} ).Else( () => {

			face.assign( select( direction.y.greaterThan( 0.0 ), 1.0, 4.0 ) );

		} );

	} ).Else( () => {

		If( absDirection.z.greaterThan( absDirection.y ), () => {

			face.assign( select( direction.z.greaterThan( 0.0 ), 2.0, 5.0 ) );

		} ).Else( () => {

			face.assign( select( direction.y.greaterThan( 0.0 ), 1.0, 4.0 ) );

		} );

	} );

	return face;

} ).setLayout( {
	name: 'getFace',
	type: 'float',
	inputs: [
		{ name: 'direction', type: 'vec3' }
	]
} );

// RH coordinate system; PMREM face-indexing convention
const getUV = /*@__PURE__*/ Fn$1( ( [ direction, face ] ) => {

	const uv = vec2$1().toVar();

	If( face.equal( 0.0 ), () => {

		uv.assign( vec2$1( direction.z, direction.y ).div( abs$1( direction.x ) ) ); // pos x

	} ).ElseIf( face.equal( 1.0 ), () => {

		uv.assign( vec2$1( direction.x.negate(), direction.z.negate() ).div( abs$1( direction.y ) ) ); // pos y

	} ).ElseIf( face.equal( 2.0 ), () => {

		uv.assign( vec2$1( direction.x.negate(), direction.y ).div( abs$1( direction.z ) ) ); // pos z

	} ).ElseIf( face.equal( 3.0 ), () => {

		uv.assign( vec2$1( direction.z.negate(), direction.y ).div( abs$1( direction.x ) ) ); // neg x

	} ).ElseIf( face.equal( 4.0 ), () => {

		uv.assign( vec2$1( direction.x.negate(), direction.z ).div( abs$1( direction.y ) ) ); // neg y

	} ).Else( () => {

		uv.assign( vec2$1( direction.x, direction.y ).div( abs$1( direction.z ) ) ); // neg z

	} );

	return mul$1( 0.5, uv.add( 1.0 ) );

} ).setLayout( {
	name: 'getUV',
	type: 'vec2',
	inputs: [
		{ name: 'direction', type: 'vec3' },
		{ name: 'face', type: 'float' }
	]
} );

const roughnessToMip = /*@__PURE__*/ Fn$1( ( [ roughness ] ) => {

	const mip = float$1( 0.0 ).toVar();

	If( roughness.greaterThanEqual( cubeUV_r1 ), () => {

		mip.assign( cubeUV_r0.sub( roughness ).mul( cubeUV_m1.sub( cubeUV_m0 ) ).div( cubeUV_r0.sub( cubeUV_r1 ) ).add( cubeUV_m0 ) );

	} ).ElseIf( roughness.greaterThanEqual( cubeUV_r4 ), () => {

		mip.assign( cubeUV_r1.sub( roughness ).mul( cubeUV_m4.sub( cubeUV_m1 ) ).div( cubeUV_r1.sub( cubeUV_r4 ) ).add( cubeUV_m1 ) );

	} ).ElseIf( roughness.greaterThanEqual( cubeUV_r5 ), () => {

		mip.assign( cubeUV_r4.sub( roughness ).mul( cubeUV_m5.sub( cubeUV_m4 ) ).div( cubeUV_r4.sub( cubeUV_r5 ) ).add( cubeUV_m4 ) );

	} ).ElseIf( roughness.greaterThanEqual( cubeUV_r6 ), () => {

		mip.assign( cubeUV_r5.sub( roughness ).mul( cubeUV_m6.sub( cubeUV_m5 ) ).div( cubeUV_r5.sub( cubeUV_r6 ) ).add( cubeUV_m5 ) );

	} ).Else( () => {

		mip.assign( float$1( -2 ).mul( log2( mul$1( 1.16, roughness ) ) ) ); // 1.16 = 1.79^0.25

	} );

	return mip;

} ).setLayout( {
	name: 'roughnessToMip',
	type: 'float',
	inputs: [
		{ name: 'roughness', type: 'float' }
	]
} );

// RH coordinate system; PMREM face-indexing convention
const getDirection = /*@__PURE__*/ Fn$1( ( [ uv_immutable, face ] ) => {

	const uv = uv_immutable.toVar();
	uv.assign( mul$1( 2.0, uv ).sub( 1.0 ) );
	const direction = vec3$1( uv, 1.0 ).toVar();

	If( face.equal( 0.0 ), () => {

		direction.assign( direction.zyx ); // ( 1, v, u ) pos x

	} ).ElseIf( face.equal( 1.0 ), () => {

		direction.assign( direction.xzy );
		direction.xz.mulAssign( -1 ); // ( -u, 1, -v ) pos y

	} ).ElseIf( face.equal( 2.0 ), () => {

		direction.x.mulAssign( -1 ); // ( -u, v, 1 ) pos z

	} ).ElseIf( face.equal( 3.0 ), () => {

		direction.assign( direction.zyx );
		direction.xz.mulAssign( -1 ); // ( -1, v, -u ) neg x

	} ).ElseIf( face.equal( 4.0 ), () => {

		direction.assign( direction.xzy );
		direction.xy.mulAssign( -1 ); // ( -u, -1, v ) neg y

	} ).ElseIf( face.equal( 5.0 ), () => {

		direction.z.mulAssign( -1 ); // ( u, v, -1 ) neg zS

	} );

	return direction;

} ).setLayout( {
	name: 'getDirection',
	type: 'vec3',
	inputs: [
		{ name: 'uv', type: 'vec2' },
		{ name: 'face', type: 'float' }
	]
} );

//

const textureCubeUV = /*@__PURE__*/ Fn$1( ( [ envMap, sampleDir_immutable, roughness_immutable, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP ] ) => {

	const roughness = float$1( roughness_immutable );
	const sampleDir = vec3$1( sampleDir_immutable );

	const mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
	const mipF = fract$1( mip );
	const mipInt = floor$1( mip );
	const color0 = vec3$1( bilinearCubeUV( envMap, sampleDir, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP ) ).toVar();

	If( mipF.notEqual( 0.0 ), () => {

		const color1 = vec3$1( bilinearCubeUV( envMap, sampleDir, mipInt.add( 1.0 ), CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP ) ).toVar();

		color0.assign( mix$1( color0, color1, mipF ) );

	} );

	return color0;

} );

const bilinearCubeUV = /*@__PURE__*/ Fn$1( ( [ envMap, direction_immutable, mipInt_immutable, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP ] ) => {

	const mipInt = float$1( mipInt_immutable ).toVar();
	const direction = vec3$1( direction_immutable );
	const face = float$1( getFace( direction ) ).toVar();
	const filterInt = float$1( max$1( cubeUV_minMipLevel.sub( mipInt ), 0.0 ) ).toVar();
	mipInt.assign( max$1( mipInt, cubeUV_minMipLevel ) );
	const faceSize = float$1( exp2( mipInt ) ).toVar();
	const uv = vec2$1( getUV( direction, face ).mul( faceSize.sub( 2.0 ) ).add( 1.0 ) ).toVar();

	If( face.greaterThan( 2.0 ), () => {

		uv.y.addAssign( faceSize );
		face.subAssign( 3.0 );

	} );

	uv.x.addAssign( face.mul( faceSize ) );
	uv.x.addAssign( filterInt.mul( mul$1( 3.0, cubeUV_minTileSize ) ) );
	uv.y.addAssign( mul$1( 4.0, exp2( CUBEUV_MAX_MIP ).sub( faceSize ) ) );
	uv.x.mulAssign( CUBEUV_TEXEL_WIDTH );
	uv.y.mulAssign( CUBEUV_TEXEL_HEIGHT );

	return envMap.uv( uv ).grad( vec2$1(), vec2$1() ); // disable anisotropic filtering

} );

const getSample = /*@__PURE__*/ Fn$1( ( { envMap, mipInt, outputDirection, theta, axis, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) => {

	const cosTheta = cos$1( theta );

	// Rodrigues' axis-angle rotation
	const sampleDirection = outputDirection.mul( cosTheta )
		.add( axis.cross( outputDirection ).mul( sin$1( theta ) ) )
		.add( axis.mul( axis.dot( outputDirection ).mul( cosTheta.oneMinus() ) ) );

	return bilinearCubeUV( envMap, sampleDirection, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP );

} );

const blur = /*@__PURE__*/ Fn$1( ( { n, latitudinal, poleAxis, outputDirection, weights, samples, dTheta, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) => {

	const axis = vec3$1( select( latitudinal, poleAxis, cross( poleAxis, outputDirection ) ) ).toVar();

	If( all( axis.equals( vec3$1( 0.0 ) ) ), () => {

		axis.assign( vec3$1( outputDirection.z, 0.0, outputDirection.x.negate() ) );

	} );

	axis.assign( normalize$1( axis ) );

	const gl_FragColor = vec3$1().toVar();
	gl_FragColor.addAssign( weights.element( int( 0 ) ).mul( getSample( { theta: 0.0, axis, outputDirection, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) ) );

	Loop( { start: int( 1 ), end: n }, ( { i } ) => {

		If( i.greaterThanEqual( samples ), () => {

			Break();

		} );

		const theta = float$1( dTheta.mul( float$1( i ) ) ).toVar();
		gl_FragColor.addAssign( weights.element( i ).mul( getSample( { theta: theta.mul( -1 ), axis, outputDirection, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) ) );
		gl_FragColor.addAssign( weights.element( i ).mul( getSample( { theta, axis, outputDirection, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) ) );

	} );

	return vec4$1( gl_FragColor, 1 );

} );

let _generator = null;

const _cache = new WeakMap();

function _generateCubeUVSize( imageHeight ) {

	const maxMip = Math.log2( imageHeight ) - 2;

	const texelHeight = 1.0 / imageHeight;

	const texelWidth = 1.0 / ( 3 * Math.max( Math.pow( 2, maxMip ), 7 * 16 ) );

	return { texelWidth, texelHeight, maxMip };

}

function _getPMREMFromTexture( texture ) {

	let cacheTexture = _cache.get( texture );

	const pmremVersion = cacheTexture !== undefined ? cacheTexture.pmremVersion : -1;

	if ( pmremVersion !== texture.pmremVersion ) {

		const image = texture.image;

		if ( texture.isCubeTexture ) {

			if ( isCubeMapReady( image ) ) {

				cacheTexture = _generator.fromCubemap( texture, cacheTexture );

			} else {

				return null;

			}


		} else {

			if ( isEquirectangularMapReady( image ) ) {

				cacheTexture = _generator.fromEquirectangular( texture, cacheTexture );

			} else {

				return null;

			}

		}

		cacheTexture.pmremVersion = texture.pmremVersion;

		_cache.set( texture, cacheTexture );

	}

	return cacheTexture.texture;

}

class PMREMNode extends TempNode {

	static get type() {

		return 'PMREMNode';

	}

	constructor( value, uvNode = null, levelNode = null ) {

		super( 'vec3' );

		this._value = value;
		this._pmrem = null;

		this.uvNode = uvNode;
		this.levelNode = levelNode;

		this._generator = null;

		const defaultTexture = new Texture();
		defaultTexture.isRenderTargetTexture = true;

		this._texture = texture( defaultTexture );

		this._width = uniform$1( 0 );
		this._height = uniform$1( 0 );
		this._maxMip = uniform$1( 0 );

		this.updateBeforeType = NodeUpdateType.RENDER;

	}

	set value( value ) {

		this._value = value;
		this._pmrem = null;

	}

	get value() {

		return this._value;

	}

	updateFromTexture( texture ) {

		const cubeUVSize = _generateCubeUVSize( texture.image.height );

		this._texture.value = texture;
		this._width.value = cubeUVSize.texelWidth;
		this._height.value = cubeUVSize.texelHeight;
		this._maxMip.value = cubeUVSize.maxMip;

	}

	updateBefore() {

		let pmrem = this._pmrem;

		const pmremVersion = pmrem ? pmrem.pmremVersion : -1;
		const texture = this._value;

		if ( pmremVersion !== texture.pmremVersion ) {

			if ( texture.isPMREMTexture === true ) {

				pmrem = texture;

			} else {

				pmrem = _getPMREMFromTexture( texture );

			}

			if ( pmrem !== null ) {

				this._pmrem = pmrem;

				this.updateFromTexture( pmrem );

			}

		}

	}

	setup( builder ) {

		if ( _generator === null ) {

			_generator = builder.createPMREMGenerator();

		}

		//

		this.updateBefore( builder );

		//

		let uvNode = this.uvNode;

		if ( uvNode === null && builder.context.getUV ) {

			uvNode = builder.context.getUV( this );

		}

		//

		const texture = this.value;

		if ( builder.renderer.coordinateSystem === WebGLCoordinateSystem && texture.isPMREMTexture !== true && texture.isRenderTargetTexture === true ) {

			uvNode = vec3$1( uvNode.x.negate(), uvNode.yz );

		}

		//

		let levelNode = this.levelNode;

		if ( levelNode === null && builder.context.getTextureLevel ) {

			levelNode = builder.context.getTextureLevel( this );

		}

		//

		return textureCubeUV( this._texture, uvNode, levelNode, this._width, this._height, this._maxMip );

	}

}

function isCubeMapReady( image ) {

	if ( image === null || image === undefined ) return false;

	let count = 0;
	const length = 6;

	for ( let i = 0; i < length; i ++ ) {

		if ( image[ i ] !== undefined ) count ++;

	}

	return count === length;


}

function isEquirectangularMapReady( image ) {

	if ( image === null || image === undefined ) return false;

	return image.height > 0;

}

const pmremTexture = /*@__PURE__*/ nodeProxy( PMREMNode );

const _envNodeCache = new WeakMap();

class EnvironmentNode extends LightingNode {

	static get type() {

		return 'EnvironmentNode';

	}

	constructor( envNode = null ) {

		super();

		this.envNode = envNode;

	}

	setup( builder ) {

		const { material } = builder;

		let envNode = this.envNode;

		if ( envNode.isTextureNode || envNode.isMaterialReferenceNode ) {

			const value = ( envNode.isTextureNode ) ? envNode.value : material[ envNode.property ];

			let cacheEnvNode = _envNodeCache.get( value );

			if ( cacheEnvNode === undefined ) {

				cacheEnvNode = pmremTexture( value );

				_envNodeCache.set( value, cacheEnvNode );

			}

			envNode	= cacheEnvNode;

		}

		//

		const envMap = material.envMap;
		const intensity = envMap ? reference( 'envMapIntensity', 'float', builder.material ) : reference( 'environmentIntensity', 'float', builder.scene ); // @TODO: Add materialEnvIntensity in MaterialNode

		const useAnisotropy = material.useAnisotropy === true || material.anisotropy > 0;
		const radianceNormalView = useAnisotropy ? transformedBentNormalView : transformedNormalView;

		const radiance = envNode.context( createRadianceContext( roughness, radianceNormalView ) ).mul( intensity );
		const irradiance = envNode.context( createIrradianceContext( transformedNormalWorld ) ).mul( Math.PI ).mul( intensity );

		const isolateRadiance = cache( radiance );
		const isolateIrradiance = cache( irradiance );

		//

		builder.context.radiance.addAssign( isolateRadiance );

		builder.context.iblIrradiance.addAssign( isolateIrradiance );

		//

		const clearcoatRadiance = builder.context.lightingModel.clearcoatRadiance;

		if ( clearcoatRadiance ) {

			const clearcoatRadianceContext = envNode.context( createRadianceContext( clearcoatRoughness, transformedClearcoatNormalView ) ).mul( intensity );
			const isolateClearcoatRadiance = cache( clearcoatRadianceContext );

			clearcoatRadiance.addAssign( isolateClearcoatRadiance );

		}

	}

}

const createRadianceContext = ( roughnessNode, normalViewNode ) => {

	let reflectVec = null;

	return {
		getUV: () => {

			if ( reflectVec === null ) {

				reflectVec = positionViewDirection.negate().reflect( normalViewNode );

				// Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.
				reflectVec = roughnessNode.mul( roughnessNode ).mix( reflectVec, normalViewNode ).normalize();

				reflectVec = reflectVec.transformDirection( cameraViewMatrix );

			}

			return reflectVec;

		},
		getTextureLevel: () => {

			return roughnessNode;

		}
	};

};

const createIrradianceContext = ( normalWorldNode ) => {

	return {
		getUV: () => {

			return normalWorldNode;

		},
		getTextureLevel: () => {

			return float$1( 1.0 );

		}
	};

};

const _defaultValues$6 = /*@__PURE__*/ new MeshStandardMaterial();

class MeshStandardNodeMaterial extends NodeMaterial {

	static get type() {

		return 'MeshStandardNodeMaterial';

	}

	constructor( parameters ) {

		super();

		this.isMeshStandardNodeMaterial = true;

		this.lights = true;

		this.emissiveNode = null;

		this.metalnessNode = null;
		this.roughnessNode = null;

		this.setDefaultValues( _defaultValues$6 );

		this.setValues( parameters );

	}

	setupEnvironment( builder ) {

		let envNode = super.setupEnvironment( builder );

		if ( envNode === null && builder.environmentNode ) {

			envNode = builder.environmentNode;

		}

		return envNode ? new EnvironmentNode( envNode ) : null;

	}

	setupLightingModel( /*builder*/ ) {

		return new PhysicalLightingModel();

	}

	setupSpecular() {

		const specularColorNode = mix$1( vec3$1( 0.04 ), diffuseColor.rgb, metalness );

		specularColor.assign( specularColorNode );
		specularF90.assign( 1.0 );

	}

	setupVariants() {

		// METALNESS

		const metalnessNode = this.metalnessNode ? float$1( this.metalnessNode ) : materialMetalness;

		metalness.assign( metalnessNode );

		// ROUGHNESS

		let roughnessNode = this.roughnessNode ? float$1( this.roughnessNode ) : materialRoughness;
		roughnessNode = getRoughness( { roughness: roughnessNode } );

		roughness.assign( roughnessNode );

		// SPECULAR COLOR

		this.setupSpecular();

		// DIFFUSE COLOR

		diffuseColor.assign( vec4$1( diffuseColor.rgb.mul( metalnessNode.oneMinus() ), diffuseColor.a ) );

	}

	copy( source ) {

		this.emissiveNode = source.emissiveNode;

		this.metalnessNode = source.metalnessNode;
		this.roughnessNode = source.roughnessNode;

		return super.copy( source );

	}

}

const _defaultValues$5 = /*@__PURE__*/ new MeshPhysicalMaterial();

class MeshPhysicalNodeMaterial extends MeshStandardNodeMaterial {

	static get type() {

		return 'MeshPhysicalNodeMaterial';

	}

	constructor( parameters ) {

		super();

		this.isMeshPhysicalNodeMaterial = true;

		this.clearcoatNode = null;
		this.clearcoatRoughnessNode = null;
		this.clearcoatNormalNode = null;

		this.sheenNode = null;
		this.sheenRoughnessNode = null;

		this.iridescenceNode = null;
		this.iridescenceIORNode = null;
		this.iridescenceThicknessNode = null;

		this.specularIntensityNode = null;
		this.specularColorNode = null;

		this.iorNode = null;
		this.transmissionNode = null;
		this.thicknessNode = null;
		this.attenuationDistanceNode = null;
		this.attenuationColorNode = null;
		this.dispersionNode = null;

		this.anisotropyNode = null;

		this.setDefaultValues( _defaultValues$5 );

		this.setValues( parameters );

	}

	get useClearcoat() {

		return this.clearcoat > 0 || this.clearcoatNode !== null;

	}

	get useIridescence() {

		return this.iridescence > 0 || this.iridescenceNode !== null;

	}

	get useSheen() {

		return this.sheen > 0 || this.sheenNode !== null;

	}

	get useAnisotropy() {

		return this.anisotropy > 0 || this.anisotropyNode !== null;

	}

	get useTransmission() {

		return this.transmission > 0 || this.transmissionNode !== null;

	}

	get useDispersion() {

		return this.dispersion > 0 || this.dispersionNode !== null;

	}

	setupSpecular() {

		const iorNode = this.iorNode ? float$1( this.iorNode ) : materialIOR;

		ior.assign( iorNode );
		specularColor.assign( mix$1( min$1( pow2( ior.sub( 1.0 ).div( ior.add( 1.0 ) ) ).mul( materialSpecularColor ), vec3$1( 1.0 ) ).mul( materialSpecularIntensity ), diffuseColor.rgb, metalness ) );
		specularF90.assign( mix$1( materialSpecularIntensity, 1.0, metalness ) );

	}

	setupLightingModel( /*builder*/ ) {

		return new PhysicalLightingModel( this.useClearcoat, this.useSheen, this.useIridescence, this.useAnisotropy, this.useTransmission, this.useDispersion );

	}

	setupVariants( builder ) {

		super.setupVariants( builder );

		// CLEARCOAT

		if ( this.useClearcoat ) {

			const clearcoatNode = this.clearcoatNode ? float$1( this.clearcoatNode ) : materialClearcoat;
			const clearcoatRoughnessNode = this.clearcoatRoughnessNode ? float$1( this.clearcoatRoughnessNode ) : materialClearcoatRoughness;

			clearcoat.assign( clearcoatNode );
			clearcoatRoughness.assign( getRoughness( { roughness: clearcoatRoughnessNode } ) );

		}

		// SHEEN

		if ( this.useSheen ) {

			const sheenNode = this.sheenNode ? vec3$1( this.sheenNode ) : materialSheen;
			const sheenRoughnessNode = this.sheenRoughnessNode ? float$1( this.sheenRoughnessNode ) : materialSheenRoughness;

			sheen.assign( sheenNode );
			sheenRoughness.assign( sheenRoughnessNode );

		}

		// IRIDESCENCE

		if ( this.useIridescence ) {

			const iridescenceNode = this.iridescenceNode ? float$1( this.iridescenceNode ) : materialIridescence;
			const iridescenceIORNode = this.iridescenceIORNode ? float$1( this.iridescenceIORNode ) : materialIridescenceIOR;
			const iridescenceThicknessNode = this.iridescenceThicknessNode ? float$1( this.iridescenceThicknessNode ) : materialIridescenceThickness;

			iridescence.assign( iridescenceNode );
			iridescenceIOR.assign( iridescenceIORNode );
			iridescenceThickness.assign( iridescenceThicknessNode );

		}

		// ANISOTROPY

		if ( this.useAnisotropy ) {

			const anisotropyV = ( this.anisotropyNode ? vec2$1( this.anisotropyNode ) : materialAnisotropy ).toVar();

			anisotropy.assign( anisotropyV.length() );

			If( anisotropy.equal( 0.0 ), () => {

				anisotropyV.assign( vec2$1( 1.0, 0.0 ) );

			} ).Else( () => {

				anisotropyV.divAssign( vec2$1( anisotropy ) );
				anisotropy.assign( anisotropy.saturate() );

			} );

			// Roughness along the anisotropy bitangent is the material roughness, while the tangent roughness increases with anisotropy.
			alphaT.assign( anisotropy.pow2().mix( roughness.pow2(), 1.0 ) );

			anisotropyT.assign( TBNViewMatrix[ 0 ].mul( anisotropyV.x ).add( TBNViewMatrix[ 1 ].mul( anisotropyV.y ) ) );
			anisotropyB.assign( TBNViewMatrix[ 1 ].mul( anisotropyV.x ).sub( TBNViewMatrix[ 0 ].mul( anisotropyV.y ) ) );

		}

		// TRANSMISSION

		if ( this.useTransmission ) {

			const transmissionNode = this.transmissionNode ? float$1( this.transmissionNode ) : materialTransmission;
			const thicknessNode = this.thicknessNode ? float$1( this.thicknessNode ) : materialThickness;
			const attenuationDistanceNode = this.attenuationDistanceNode ? float$1( this.attenuationDistanceNode ) : materialAttenuationDistance;
			const attenuationColorNode = this.attenuationColorNode ? vec3$1( this.attenuationColorNode ) : materialAttenuationColor;

			transmission.assign( transmissionNode );
			thickness.assign( thicknessNode );
			attenuationDistance.assign( attenuationDistanceNode );
			attenuationColor.assign( attenuationColorNode );

			if ( this.useDispersion ) {

				const dispersionNode = this.dispersionNode ? float$1( this.dispersionNode ) : materialDispersion;

				dispersion.assign( dispersionNode );

			}

		}

	}

	setupClearcoatNormal() {

		return this.clearcoatNormalNode ? vec3$1( this.clearcoatNormalNode ) : materialClearcoatNormal;

	}

	setup( builder ) {

		builder.context.setupClearcoatNormal = () => this.setupClearcoatNormal( builder );

		super.setup( builder );

	}

	copy( source ) {

		this.clearcoatNode = source.clearcoatNode;
		this.clearcoatRoughnessNode = source.clearcoatRoughnessNode;
		this.clearcoatNormalNode = source.clearcoatNormalNode;

		this.sheenNode = source.sheenNode;
		this.sheenRoughnessNode = source.sheenRoughnessNode;

		this.iridescenceNode = source.iridescenceNode;
		this.iridescenceIORNode = source.iridescenceIORNode;
		this.iridescenceThicknessNode = source.iridescenceThicknessNode;

		this.specularIntensityNode = source.specularIntensityNode;
		this.specularColorNode = source.specularColorNode;

		this.transmissionNode = source.transmissionNode;
		this.thicknessNode = source.thicknessNode;
		this.attenuationDistanceNode = source.attenuationDistanceNode;
		this.attenuationColorNode = source.attenuationColorNode;
		this.dispersionNode = source.dispersionNode;

		this.anisotropyNode = source.anisotropyNode;

		return super.copy( source );

	}

}

const getGradientIrradiance = /*@__PURE__*/ Fn$1( ( { normal, lightDirection, builder } ) => {

	// dotNL will be from -1.0 to 1.0
	const dotNL = normal.dot( lightDirection );
	const coord = vec2$1( dotNL.mul( 0.5 ).add( 0.5 ), 0.0 );

	if ( builder.material.gradientMap ) {

		const gradientMap = materialReference( 'gradientMap', 'texture' ).context( { getUV: () => coord } );

		return vec3$1( gradientMap.r );

	} else {

		const fw = coord.fwidth().mul( 0.5 );

		return mix$1( vec3$1( 0.7 ), vec3$1( 1.0 ), smoothstep$1( float$1( 0.7 ).sub( fw.x ), float$1( 0.7 ).add( fw.x ), coord.x ) );

	}

} );

class ToonLightingModel extends LightingModel {

	direct( { lightDirection, lightColor, reflectedLight }, stack, builder ) {

		const irradiance = getGradientIrradiance( { normal: normalGeometry, lightDirection, builder } ).mul( lightColor );

		reflectedLight.directDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor: diffuseColor.rgb } ) ) );

	}

	indirect( { ambientOcclusion, irradiance, reflectedLight } ) {

		reflectedLight.indirectDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor } ) ) );

		reflectedLight.indirectDiffuse.mulAssign( ambientOcclusion );

	}

}

const _defaultValues$4 = /*@__PURE__*/ new MeshToonMaterial();

class MeshToonNodeMaterial extends NodeMaterial {

	static get type() {

		return 'MeshToonNodeMaterial';

	}

	constructor( parameters ) {

		super();

		this.isMeshToonNodeMaterial = true;

		this.lights = true;

		this.setDefaultValues( _defaultValues$4 );

		this.setValues( parameters );

	}

	setupLightingModel( /*builder*/ ) {

		return new ToonLightingModel();

	}

}

class MatcapUVNode extends TempNode {

	static get type() {

		return 'MatcapUVNode';

	}

	constructor() {

		super( 'vec2' );

	}

	setup() {

		const x = vec3$1( positionViewDirection.z, 0, positionViewDirection.x.negate() ).normalize();
		const y = positionViewDirection.cross( x );

		return vec2$1( x.dot( transformedNormalView ), y.dot( transformedNormalView ) ).mul( 0.495 ).add( 0.5 ); // 0.495 to remove artifacts caused by undersized matcap disks

	}

}

const matcapUV = /*@__PURE__*/ nodeImmutable( MatcapUVNode );

const _defaultValues$3 = /*@__PURE__*/ new MeshMatcapMaterial();

class MeshMatcapNodeMaterial extends NodeMaterial {

	static get type() {

		return 'MeshMatcapNodeMaterial';

	}

	constructor( parameters ) {

		super();

		this.lights = false;

		this.isMeshMatcapNodeMaterial = true;

		this.setDefaultValues( _defaultValues$3 );

		this.setValues( parameters );

	}

	setupVariants( builder ) {

		const uv = matcapUV;

		let matcapColor;

		if ( builder.material.matcap ) {

			matcapColor = materialReference( 'matcap', 'texture' ).context( { getUV: () => uv } );

		} else {

			matcapColor = vec3$1( mix$1( 0.2, 0.8, uv.y ) ); // default if matcap is missing

		}

		diffuseColor.rgb.mulAssign( matcapColor.rgb );

	}

}

const _defaultValues$2 = /*@__PURE__*/ new PointsMaterial();

class PointsNodeMaterial extends NodeMaterial {

	static get type() {

		return 'PointsNodeMaterial';

	}

	constructor( parameters ) {

		super();

		this.isPointsNodeMaterial = true;

		this.lights = false;
		this.transparent = true;

		this.sizeNode = null;

		this.setDefaultValues( _defaultValues$2 );

		this.setValues( parameters );

	}

	copy( source ) {

		this.sizeNode = source.sizeNode;

		return super.copy( source );

	}

}

class RotateNode extends TempNode {

	static get type() {

		return 'RotateNode';

	}

	constructor( positionNode, rotationNode ) {

		super();

		this.positionNode = positionNode;
		this.rotationNode = rotationNode;

	}

	getNodeType( builder ) {

		return this.positionNode.getNodeType( builder );

	}

	setup( builder ) {

		const { rotationNode, positionNode } = this;

		const nodeType = this.getNodeType( builder );

		if ( nodeType === 'vec2' ) {

			const cosAngle = rotationNode.cos();
			const sinAngle = rotationNode.sin();

			const rotationMatrix = mat2(
				cosAngle, sinAngle,
				sinAngle.negate(), cosAngle
			);

			return rotationMatrix.mul( positionNode );

		} else {

			const rotation = rotationNode;
			const rotationXMatrix = mat4( vec4$1( 1.0, 0.0, 0.0, 0.0 ), vec4$1( 0.0, cos$1( rotation.x ), sin$1( rotation.x ).negate(), 0.0 ), vec4$1( 0.0, sin$1( rotation.x ), cos$1( rotation.x ), 0.0 ), vec4$1( 0.0, 0.0, 0.0, 1.0 ) );
			const rotationYMatrix = mat4( vec4$1( cos$1( rotation.y ), 0.0, sin$1( rotation.y ), 0.0 ), vec4$1( 0.0, 1.0, 0.0, 0.0 ), vec4$1( sin$1( rotation.y ).negate(), 0.0, cos$1( rotation.y ), 0.0 ), vec4$1( 0.0, 0.0, 0.0, 1.0 ) );
			const rotationZMatrix = mat4( vec4$1( cos$1( rotation.z ), sin$1( rotation.z ).negate(), 0.0, 0.0 ), vec4$1( sin$1( rotation.z ), cos$1( rotation.z ), 0.0, 0.0 ), vec4$1( 0.0, 0.0, 1.0, 0.0 ), vec4$1( 0.0, 0.0, 0.0, 1.0 ) );

			return rotationXMatrix.mul( rotationYMatrix ).mul( rotationZMatrix ).mul( vec4$1( positionNode, 1.0 ) ).xyz;

		}

	}

}

const rotate = /*@__PURE__*/ nodeProxy( RotateNode );

const _defaultValues$1 = /*@__PURE__*/ new SpriteMaterial();

class SpriteNodeMaterial extends NodeMaterial {

	static get type() {

		return 'SpriteNodeMaterial';

	}

	constructor( parameters ) {

		super();

		this.isSpriteNodeMaterial = true;

		this.lights = false;
		this._useSizeAttenuation = true;

		this.positionNode = null;
		this.rotationNode = null;
		this.scaleNode = null;

		this.setDefaultValues( _defaultValues$1 );

		this.setValues( parameters );

	}

	setupPosition( { object, camera, context } ) {

		const sizeAttenuation = this.sizeAttenuation;

		// < VERTEX STAGE >

		const { positionNode, rotationNode, scaleNode } = this;

		const vertex = positionLocal$1;

		let mvPosition = modelViewMatrix.mul( vec3$1( positionNode || 0 ) );

		let scale = vec2$1( modelWorldMatrix[ 0 ].xyz.length(), modelWorldMatrix[ 1 ].xyz.length() );

		if ( scaleNode !== null ) {

			scale = scale.mul( scaleNode );

		}


		if ( ! sizeAttenuation ) {

			if ( camera.isPerspectiveCamera ) {

				scale = scale.mul( mvPosition.z.negate() );

			} else {

				const orthoScale = float$1( 2.0 ).div( cameraProjectionMatrix.element( 1 ).element( 1 ) );
				scale = scale.mul( orthoScale.mul( 2 ) );

			}

		}

		let alignedPosition = vertex.xy;

		if ( object.center && object.center.isVector2 === true ) {

			const center = reference$1( 'center', 'vec2' );

			alignedPosition = alignedPosition.sub( center.sub( 0.5 ) );

		}

		alignedPosition = alignedPosition.mul( scale );

		const rotation = float$1( rotationNode || materialRotation );

		const rotatedPosition = rotate( alignedPosition, rotation );

		mvPosition = vec4$1( mvPosition.xy.add( rotatedPosition ), mvPosition.zw );

		const modelViewProjection = cameraProjectionMatrix.mul( mvPosition );

		context.vertex = vertex;

		return modelViewProjection;

	}

	copy( source ) {

		this.positionNode = source.positionNode;
		this.rotationNode = source.rotationNode;
		this.scaleNode = source.scaleNode;

		return super.copy( source );

	}

	get sizeAttenuation() {

		return this._useSizeAttenuation;

	}

	set sizeAttenuation( value ) {

		if ( this._useSizeAttenuation !== value ) {

			this._useSizeAttenuation = value;
			this.needsUpdate = true;

		}

	}

}

class ShadowMaskModel extends LightingModel {

	constructor() {

		super();

		this.shadowNode = float$1( 1 ).toVar( 'shadowMask' );

	}

	direct( { shadowMask } ) {

		this.shadowNode.mulAssign( shadowMask );

	}

	finish( context ) {

		diffuseColor.a.mulAssign( this.shadowNode.oneMinus() );

		context.outgoingLight.rgb.assign( diffuseColor.rgb ); // TODO: Optimize LightsNode to avoid this assignment

	}

}

const _defaultValues = /*@__PURE__*/ new ShadowMaterial();

class ShadowNodeMaterial extends NodeMaterial {

	static get type() {

		return 'ShadowNodeMaterial';

	}

	constructor( parameters ) {

		super();

		this.isShadowNodeMaterial = true;

		this.lights = true;

		this.setDefaultValues( _defaultValues );

		this.setValues( parameters );

	}

	setupLightingModel( /*builder*/ ) {

		return new ShadowMaskModel();

	}

}

const normal = Fn$1( ( { texture, uv } ) => {

	const epsilon = 0.0001;

	const ret = vec3$1().toVar();

	If( uv.x.lessThan( epsilon ), () => {

		ret.assign( vec3$1( 1, 0, 0 ) );

	} ).ElseIf( uv.y.lessThan( epsilon ), () => {

		ret.assign( vec3$1( 0, 1, 0 ) );

	} ).ElseIf( uv.z.lessThan( epsilon ), () => {

		ret.assign( vec3$1( 0, 0, 1 ) );

	} ).ElseIf( uv.x.greaterThan( 1 - epsilon ), () => {

		ret.assign( vec3$1( -1, 0, 0 ) );

	} ).ElseIf( uv.y.greaterThan( 1 - epsilon ), () => {

		ret.assign( vec3$1( 0, -1, 0 ) );

	} ).ElseIf( uv.z.greaterThan( 1 - epsilon ), () => {

		ret.assign( vec3$1( 0, 0, -1 ) );

	} ).Else( () => {

		const step = 0.01;

		const x = texture.uv( uv.add( vec3$1( - step, 0.0, 0.0 ) ) ).r.sub( texture.uv( uv.add( vec3$1( step, 0.0, 0.0 ) ) ).r );
		const y = texture.uv( uv.add( vec3$1( 0.0, - step, 0.0 ) ) ).r.sub( texture.uv( uv.add( vec3$1( 0.0, step, 0.0 ) ) ).r );
		const z = texture.uv( uv.add( vec3$1( 0.0, 0.0, - step ) ) ).r.sub( texture.uv( uv.add( vec3$1( 0.0, 0.0, step ) ) ).r );

		ret.assign( vec3$1( x, y, z ) );

	} );

	return ret.normalize();

} );


class Texture3DNode extends TextureNode {

	static get type() {

		return 'Texture3DNode';

	}

	constructor( value, uvNode = null, levelNode = null ) {

		super( value, uvNode, levelNode );

		this.isTexture3DNode = true;

	}

	getInputType( /*builder*/ ) {

		return 'texture3D';

	}

	getDefaultUV() {

		return vec3$1( 0.5, 0.5, 0.5 );

	}

	setUpdateMatrix( /*updateMatrix*/ ) { } // Ignore .updateMatrix for 3d TextureNode

	setupUV( builder, uvNode ) {

		return uvNode;

	}

	generateUV( builder, uvNode ) {

		return uvNode.build( builder, 'vec3' );

	}

	normal( uvNode ) {

		return normal( { texture: this, uv: uvNode } );

	}

}

const texture3D = /*@__PURE__*/ nodeProxy( Texture3DNode );

class Animation {

	constructor( nodes, info ) {

		this.nodes = nodes;
		this.info = info;

		this._context = self;
		this._animationLoop = null;
		this._requestId = null;

	}

	start() {

		const update = ( time, frame ) => {

			this._requestId = this._context.requestAnimationFrame( update );

			if ( this.info.autoReset === true ) this.info.reset();

			this.nodes.nodeFrame.update();

			this.info.frame = this.nodes.nodeFrame.frameId;

			if ( this._animationLoop !== null ) this._animationLoop( time, frame );

		};

		update();

	}

	stop() {

		this._context.cancelAnimationFrame( this._requestId );

		this._requestId = null;

	}

	setAnimationLoop( callback ) {

		this._animationLoop = callback;

	}

	setContext( context ) {

		this._context = context;

	}

	dispose() {

		this.stop();

	}

}

class ChainMap {

	constructor() {

		this.weakMap = new WeakMap();

	}

	get( keys ) {

		let map = this.weakMap;

		for ( let i = 0; i < keys.length; i ++ ) {

			map = map.get( keys[ i ] );

			if ( map === undefined ) return undefined;

		}

		return map.get( keys[ keys.length - 1 ] );

	}

	set( keys, value ) {

		let map = this.weakMap;

		for ( let i = 0; i < keys.length; i ++ ) {

			const key = keys[ i ];

			if ( map.has( key ) === false ) map.set( key, new WeakMap() );

			map = map.get( key );

		}

		return map.set( keys[ keys.length - 1 ], value );

	}

	delete( keys ) {

		let map = this.weakMap;

		for ( let i = 0; i < keys.length; i ++ ) {

			map = map.get( keys[ i ] );

			if ( map === undefined ) return false;

		}

		return map.delete( keys[ keys.length - 1 ] );

	}

}

let _id$7 = 0;

function getKeys( obj ) {

	const keys = Object.keys( obj );

	let proto = Object.getPrototypeOf( obj );

	while ( proto ) {

		const descriptors = Object.getOwnPropertyDescriptors( proto );

		for ( const key in descriptors ) {

			if ( descriptors[ key ] !== undefined ) {

				const descriptor = descriptors[ key ];

				if ( descriptor && typeof descriptor.get === 'function' ) {

					keys.push( key );

				}

			}

		}

		proto = Object.getPrototypeOf( proto );

	}

	return keys;

}

class RenderObject {

	constructor( nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext ) {

		this._nodes = nodes;
		this._geometries = geometries;

		this.id = _id$7 ++;

		this.renderer = renderer;
		this.object = object;
		this.material = material;
		this.scene = scene;
		this.camera = camera;
		this.lightsNode = lightsNode;
		this.context = renderContext;

		this.geometry = object.geometry;
		this.version = material.version;

		this.drawRange = null;

		this.attributes = null;
		this.pipeline = null;
		this.vertexBuffers = null;
		this.drawParams = null;

		this.bundle = null;

		this.clippingContext = clippingContext;
		this.clippingContextCacheKey = clippingContext !== null ? clippingContext.cacheKey : '';

		this.initialNodesCacheKey = this.getDynamicCacheKey();
		this.initialCacheKey = this.getCacheKey();

		this._nodeBuilderState = null;
		this._bindings = null;
		this._monitor = null;

		this.onDispose = null;

		this.isRenderObject = true;

		this.onMaterialDispose = () => {

			this.dispose();

		};

		this.material.addEventListener( 'dispose', this.onMaterialDispose );

	}

	updateClipping( parent ) {

		this.clippingContext = parent;

	}

	get clippingNeedsUpdate() {

		if ( this.clippingContext === null || this.clippingContext.cacheKey === this.clippingContextCacheKey ) return false;

		this.clippingContextCacheKey = this.clippingContext.cacheKey;

		return true;

	}

	get hardwareClippingPlanes() {

		return this.material.hardwareClipping === true ? this.clippingContext.unionClippingCount : 0;

	}

	getNodeBuilderState() {

		return this._nodeBuilderState || ( this._nodeBuilderState = this._nodes.getForRender( this ) );

	}

	getMonitor() {

		return this._monitor || ( this._monitor = this.getNodeBuilderState().monitor );

	}

	getBindings() {

		return this._bindings || ( this._bindings = this.getNodeBuilderState().createBindings() );

	}

	getIndex() {

		return this._geometries.getIndex( this );

	}

	getIndirect() {

		return this._geometries.getIndirect( this );

	}

	getChainArray() {

		return [ this.object, this.material, this.context, this.lightsNode ];

	}

	setGeometry( geometry ) {

		this.geometry = geometry;
		this.attributes = null;

	}

	getAttributes() {

		if ( this.attributes !== null ) return this.attributes;

		const nodeAttributes = this.getNodeBuilderState().nodeAttributes;
		const geometry = this.geometry;

		const attributes = [];
		const vertexBuffers = new Set();

		for ( const nodeAttribute of nodeAttributes ) {

			const attribute = nodeAttribute.node && nodeAttribute.node.attribute ? nodeAttribute.node.attribute : geometry.getAttribute( nodeAttribute.name );

			if ( attribute === undefined ) continue;

			attributes.push( attribute );

			const bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;
			vertexBuffers.add( bufferAttribute );

		}

		this.attributes = attributes;
		this.vertexBuffers = Array.from( vertexBuffers.values() );

		return attributes;

	}

	getVertexBuffers() {

		if ( this.vertexBuffers === null ) this.getAttributes();

		return this.vertexBuffers;

	}

	getDrawParameters() {

		const { object, material, geometry, group, drawRange } = this;

		const drawParams = this.drawParams || ( this.drawParams = {
			vertexCount: 0,
			firstVertex: 0,
			instanceCount: 0,
			firstInstance: 0
		} );

		const index = this.getIndex();
		const hasIndex = ( index !== null );
		const instanceCount = geometry.isInstancedBufferGeometry ? geometry.instanceCount : ( object.count > 1 ? object.count : 1 );

		if ( instanceCount === 0 ) return null;

		drawParams.instanceCount = instanceCount;

		if ( object.isBatchedMesh === true ) return drawParams;

		let rangeFactor = 1;

		if ( material.wireframe === true && ! object.isPoints && ! object.isLineSegments && ! object.isLine && ! object.isLineLoop ) {

			rangeFactor = 2;

		}

		let firstVertex = drawRange.start * rangeFactor;
		let lastVertex = ( drawRange.start + drawRange.count ) * rangeFactor;

		if ( group !== null ) {

			firstVertex = Math.max( firstVertex, group.start * rangeFactor );
			lastVertex = Math.min( lastVertex, ( group.start + group.count ) * rangeFactor );

		}

		const position = geometry.attributes.position;
		let itemCount = Infinity;

		if ( hasIndex ) {

			itemCount = index.count;

		} else if ( position !== undefined && position !== null ) {

			itemCount = position.count;

		}

		firstVertex = Math.max( firstVertex, 0 );
		lastVertex = Math.min( lastVertex, itemCount );

		const count = lastVertex - firstVertex;

		if ( count < 0 || count === Infinity ) return null;

		drawParams.vertexCount = count;
		drawParams.firstVertex = firstVertex;

		return drawParams;

	}

	getGeometryCacheKey() {

		const { geometry } = this;

		let cacheKey = '';

		for ( const name of Object.keys( geometry.attributes ).sort() ) {

			const attribute = geometry.attributes[ name ];

			cacheKey += name + ',';

			if ( attribute.data ) cacheKey += attribute.data.stride + ',';
			if ( attribute.offset ) cacheKey += attribute.offset + ',';
			if ( attribute.itemSize ) cacheKey += attribute.itemSize + ',';
			if ( attribute.normalized ) cacheKey += 'n,';

		}

		if ( geometry.index ) {

			cacheKey += 'index,';

		}

		return cacheKey;

	}

	getMaterialCacheKey() {

		const { object, material } = this;

		let cacheKey = material.customProgramCacheKey();

		for ( const property of getKeys( material ) ) {

			if ( /^(is[A-Z]|_)|^(visible|version|uuid|name|opacity|userData)$/.test( property ) ) continue;

			const value = material[ property ];

			let valueKey;

			if ( value !== null ) {

				// some material values require a formatting

				const type = typeof value;

				if ( type === 'number' ) {

					valueKey = value !== 0 ? '1' : '0'; // Convert to on/off, important for clearcoat, transmission, etc

				} else if ( type === 'object' ) {

					valueKey = '{';

					if ( value.isTexture ) {

						valueKey += value.mapping;

					}

					valueKey += '}';

				} else {

					valueKey = String( value );

				}

			} else {

				valueKey = String( value );

			}

			cacheKey += /*property + ':' +*/ valueKey + ',';

		}

		cacheKey += this.clippingContextCacheKey + ',';

		if ( object.geometry ) {

			cacheKey += this.getGeometryCacheKey();

		}

		if ( object.skeleton ) {

			cacheKey += object.skeleton.bones.length + ',';

		}

		if ( object.morphTargetInfluences ) {

			cacheKey += object.morphTargetInfluences.length + ',';

		}

		if ( object.isBatchedMesh ) {

			cacheKey += object._matricesTexture.uuid + ',';

			if ( object._colorsTexture !== null ) {

				cacheKey += object._colorsTexture.uuid + ',';

			}

		}

		if ( object.count > 1 ) {

			// TODO: https://github.com/mrdoob/three.js/pull/29066#issuecomment-2269400850

			cacheKey += object.uuid + ',';

		}

		cacheKey += object.receiveShadow + ',';

		return hashString( cacheKey );

	}

	get needsGeometryUpdate() {

		return this.geometry.id !== this.object.geometry.id;

	}

	get needsUpdate() {

		return /*this.object.static !== true &&*/ ( this.initialNodesCacheKey !== this.getDynamicCacheKey() || this.clippingNeedsUpdate );

	}

	getDynamicCacheKey() {

		// Environment Nodes Cache Key

		let cacheKey = this._nodes.getCacheKey( this.scene, this.lightsNode );

		if ( this.object.receiveShadow ) {

			cacheKey += 1;

		}

		return cacheKey;

	}

	getCacheKey() {

		return this.getMaterialCacheKey() + this.getDynamicCacheKey();

	}

	dispose() {

		this.material.removeEventListener( 'dispose', this.onMaterialDispose );

		this.onDispose();

	}

}

const chainArray = [];

class RenderObjects {

	constructor( renderer, nodes, geometries, pipelines, bindings, info ) {

		this.renderer = renderer;
		this.nodes = nodes;
		this.geometries = geometries;
		this.pipelines = pipelines;
		this.bindings = bindings;
		this.info = info;

		this.chainMaps = {};

	}

	get( object, material, scene, camera, lightsNode, renderContext, clippingContext, passId ) {

		const chainMap = this.getChainMap( passId );

		// reuse chainArray
		chainArray[ 0 ] = object;
		chainArray[ 1 ] = material;
		chainArray[ 2 ] = renderContext;
		chainArray[ 3 ] = lightsNode;

		let renderObject = chainMap.get( chainArray );

		if ( renderObject === undefined ) {

			renderObject = this.createRenderObject( this.nodes, this.geometries, this.renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext, passId );

			chainMap.set( chainArray, renderObject );

		} else {

			renderObject.updateClipping( clippingContext );

			if ( renderObject.needsGeometryUpdate ) {

				renderObject.setGeometry( object.geometry );

			}

			if ( renderObject.version !== material.version || renderObject.needsUpdate ) {

				if ( renderObject.initialCacheKey !== renderObject.getCacheKey() ) {

					renderObject.dispose();

					renderObject = this.get( object, material, scene, camera, lightsNode, renderContext, clippingContext, passId );

				} else {

					renderObject.version = material.version;

				}

			}

		}

		return renderObject;

	}

	getChainMap( passId = 'default' ) {

		return this.chainMaps[ passId ] || ( this.chainMaps[ passId ] = new ChainMap() );

	}

	dispose() {

		this.chainMaps = {};

	}

	createRenderObject( nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext, passId ) {

		const chainMap = this.getChainMap( passId );

		const renderObject = new RenderObject( nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext );

		renderObject.onDispose = () => {

			this.pipelines.delete( renderObject );
			this.bindings.delete( renderObject );
			this.nodes.delete( renderObject );

			chainMap.delete( renderObject.getChainArray() );

		};

		return renderObject;

	}


}

class DataMap {

	constructor() {

		this.data = new WeakMap();

	}

	get( object ) {

		let map = this.data.get( object );

		if ( map === undefined ) {

			map = {};
			this.data.set( object, map );

		}

		return map;

	}

	delete( object ) {

		let map;

		if ( this.data.has( object ) ) {

			map = this.data.get( object );

			this.data.delete( object );

		}

		return map;

	}

	has( object ) {

		return this.data.has( object );

	}

	dispose() {

		this.data = new WeakMap();

	}

}

const AttributeType = {
	VERTEX: 1,
	INDEX: 2,
	STORAGE: 3,
	INDIRECT: 4
};

// size of a chunk in bytes (STD140 layout)

const GPU_CHUNK_BYTES = 16;

// @TODO: Move to src/constants.js

const BlendColorFactor = 211;
const OneMinusBlendColorFactor = 212;

class Attributes extends DataMap {

	constructor( backend ) {

		super();

		this.backend = backend;

	}

	delete( attribute ) {

		const attributeData = super.delete( attribute );

		if ( attributeData !== undefined ) {

			this.backend.destroyAttribute( attribute );

		}

		return attributeData;

	}

	update( attribute, type ) {

		const data = this.get( attribute );

		if ( data.version === undefined ) {

			if ( type === AttributeType.VERTEX ) {

				this.backend.createAttribute( attribute );

			} else if ( type === AttributeType.INDEX ) {

				this.backend.createIndexAttribute( attribute );

			} else if ( type === AttributeType.STORAGE ) {

				this.backend.createStorageAttribute( attribute );

			} else if ( type === AttributeType.INDIRECT ) {

				this.backend.createIndirectStorageAttribute( attribute );

			}

			data.version = this._getBufferAttribute( attribute ).version;

		} else {

			const bufferAttribute = this._getBufferAttribute( attribute );

			if ( data.version < bufferAttribute.version || bufferAttribute.usage === DynamicDrawUsage ) {

				this.backend.updateAttribute( attribute );

				data.version = bufferAttribute.version;

			}

		}

	}

	_getBufferAttribute( attribute ) {

		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

		return attribute;

	}

}

function arrayNeedsUint32( array ) {

	// assumes larger values usually on last

	for ( let i = array.length - 1; i >= 0; -- i ) {

		if ( array[ i ] >= 65535 ) return true; // account for PRIMITIVE_RESTART_FIXED_INDEX, #24565

	}

	return false;

}

function getWireframeVersion( geometry ) {

	return ( geometry.index !== null ) ? geometry.index.version : geometry.attributes.position.version;

}

function getWireframeIndex( geometry ) {

	const indices = [];

	const geometryIndex = geometry.index;
	const geometryPosition = geometry.attributes.position;

	if ( geometryIndex !== null ) {

		const array = geometryIndex.array;

		for ( let i = 0, l = array.length; i < l; i += 3 ) {

			const a = array[ i + 0 ];
			const b = array[ i + 1 ];
			const c = array[ i + 2 ];

			indices.push( a, b, b, c, c, a );

		}

	} else {

		const array = geometryPosition.array;

		for ( let i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

			const a = i + 0;
			const b = i + 1;
			const c = i + 2;

			indices.push( a, b, b, c, c, a );

		}

	}

	const attribute = new ( arrayNeedsUint32( indices ) ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );
	attribute.version = getWireframeVersion( geometry );

	return attribute;

}

class Geometries extends DataMap {

	constructor( attributes, info ) {

		super();

		this.attributes = attributes;
		this.info = info;

		this.wireframes = new WeakMap();

		this.attributeCall = new WeakMap();

	}

	has( renderObject ) {

		const geometry = renderObject.geometry;

		return super.has( geometry ) && this.get( geometry ).initialized === true;

	}

	updateForRender( renderObject ) {

		if ( this.has( renderObject ) === false ) this.initGeometry( renderObject );

		this.updateAttributes( renderObject );

	}

	initGeometry( renderObject ) {

		const geometry = renderObject.geometry;
		const geometryData = this.get( geometry );

		geometryData.initialized = true;

		this.info.memory.geometries ++;

		const onDispose = () => {

			this.info.memory.geometries --;

			const index = geometry.index;
			const geometryAttributes = renderObject.getAttributes();

			if ( index !== null ) {

				this.attributes.delete( index );

			}

			for ( const geometryAttribute of geometryAttributes ) {

				this.attributes.delete( geometryAttribute );

			}

			const wireframeAttribute = this.wireframes.get( geometry );

			if ( wireframeAttribute !== undefined ) {

				this.attributes.delete( wireframeAttribute );

			}

			geometry.removeEventListener( 'dispose', onDispose );

		};

		geometry.addEventListener( 'dispose', onDispose );

	}

	updateAttributes( renderObject ) {

		// attributes

		const attributes = renderObject.getAttributes();

		for ( const attribute of attributes ) {

			if ( attribute.isStorageBufferAttribute || attribute.isStorageInstancedBufferAttribute ) {

				this.updateAttribute( attribute, AttributeType.STORAGE );

			} else {

				this.updateAttribute( attribute, AttributeType.VERTEX );

			}

		}

		// indexes

		const index = this.getIndex( renderObject );

		if ( index !== null ) {

			this.updateAttribute( index, AttributeType.INDEX );

		}

		// indirect

		const indirect = renderObject.geometry.indirect;

		if ( indirect !== null ) {

			this.updateAttribute( indirect, AttributeType.INDIRECT );

		}

	}

	updateAttribute( attribute, type ) {

		const callId = this.info.render.calls;

		if ( ! attribute.isInterleavedBufferAttribute ) {

			if ( this.attributeCall.get( attribute ) !== callId ) {

				this.attributes.update( attribute, type );

				this.attributeCall.set( attribute, callId );

			}

		} else {

			if ( this.attributeCall.get( attribute ) === undefined ) {

				this.attributes.update( attribute, type );

				this.attributeCall.set( attribute, callId );

			} else if ( this.attributeCall.get( attribute.data ) !== callId ) {

				this.attributes.update( attribute, type );

				this.attributeCall.set( attribute.data, callId );

				this.attributeCall.set( attribute, callId );

			}

		}

	}

	getIndirect( renderObject ) {

		return renderObject.geometry.indirect;

	}

	getIndex( renderObject ) {

		const { geometry, material } = renderObject;

		let index = geometry.index;

		if ( material.wireframe === true ) {

			const wireframes = this.wireframes;

			let wireframeAttribute = wireframes.get( geometry );

			if ( wireframeAttribute === undefined ) {

				wireframeAttribute = getWireframeIndex( geometry );

				wireframes.set( geometry, wireframeAttribute );

			} else if ( wireframeAttribute.version !== getWireframeVersion( geometry ) ) {

				this.attributes.delete( wireframeAttribute );

				wireframeAttribute = getWireframeIndex( geometry );

				wireframes.set( geometry, wireframeAttribute );

			}

			index = wireframeAttribute;

		}

		return index;

	}

}

class Info {

	constructor() {

		this.autoReset = true;

		this.frame = 0;
		this.calls = 0;

		this.render = {
			calls: 0,
			frameCalls: 0,
			drawCalls: 0,
			triangles: 0,
			points: 0,
			lines: 0,
			timestamp: 0,
			previousFrameCalls: 0,
			timestampCalls: 0
		};

		this.compute = {
			calls: 0,
			frameCalls: 0,
			timestamp: 0,
			previousFrameCalls: 0,
			timestampCalls: 0
		};

		this.memory = {
			geometries: 0,
			textures: 0
		};

	}

	update( object, count, instanceCount ) {

		this.render.drawCalls ++;

		if ( object.isMesh || object.isSprite ) {

			this.render.triangles += instanceCount * ( count / 3 );

		} else if ( object.isPoints ) {

			this.render.points += instanceCount * count;

		} else if ( object.isLineSegments ) {

			this.render.lines += instanceCount * ( count / 2 );

		} else if ( object.isLine ) {

			this.render.lines += instanceCount * ( count - 1 );

		} else {

			console.error( 'THREE.WebGPUInfo: Unknown object type.' );

		}

	}

	updateTimestamp( type, time ) {

		if ( this[ type ].timestampCalls === 0 ) {

			this[ type ].timestamp = 0;

		}


		this[ type ].timestamp += time;

		this[ type ].timestampCalls ++;


		if ( this[ type ].timestampCalls >= this[ type ].previousFrameCalls ) {

			this[ type ].timestampCalls = 0;

		}


	}

	reset() {

		const previousRenderFrameCalls = this.render.frameCalls;
		this.render.previousFrameCalls = previousRenderFrameCalls;

		const previousComputeFrameCalls = this.compute.frameCalls;
		this.compute.previousFrameCalls = previousComputeFrameCalls;


		this.render.drawCalls = 0;
		this.render.frameCalls = 0;
		this.compute.frameCalls = 0;

		this.render.triangles = 0;
		this.render.points = 0;
		this.render.lines = 0;


	}

	dispose() {

		this.reset();

		this.calls = 0;

		this.render.calls = 0;
		this.compute.calls = 0;

		this.render.timestamp = 0;
		this.compute.timestamp = 0;
		this.memory.geometries = 0;
		this.memory.textures = 0;

	}

}

class Pipeline {

	constructor( cacheKey ) {

		this.cacheKey = cacheKey;

		this.usedTimes = 0;

	}

}

class RenderPipeline extends Pipeline {

	constructor( cacheKey, vertexProgram, fragmentProgram ) {

		super( cacheKey );

		this.vertexProgram = vertexProgram;
		this.fragmentProgram = fragmentProgram;

	}

}

class ComputePipeline extends Pipeline {

	constructor( cacheKey, computeProgram ) {

		super( cacheKey );

		this.computeProgram = computeProgram;

		this.isComputePipeline = true;

	}

}

let _id$6 = 0;

class ProgrammableStage {

	constructor( code, type, transforms = null, attributes = null ) {

		this.id = _id$6 ++;

		this.code = code;
		this.stage = type;
		this.transforms = transforms;
		this.attributes = attributes;

		this.usedTimes = 0;

	}

}

class Pipelines extends DataMap {

	constructor( backend, nodes ) {

		super();

		this.backend = backend;
		this.nodes = nodes;

		this.bindings = null; // set by the bindings

		this.caches = new Map();
		this.programs = {
			vertex: new Map(),
			fragment: new Map(),
			compute: new Map()
		};

	}

	getForCompute( computeNode, bindings ) {

		const { backend } = this;

		const data = this.get( computeNode );

		if ( this._needsComputeUpdate( computeNode ) ) {

			const previousPipeline = data.pipeline;

			if ( previousPipeline ) {

				previousPipeline.usedTimes --;
				previousPipeline.computeProgram.usedTimes --;

			}

			// get shader

			const nodeBuilderState = this.nodes.getForCompute( computeNode );

			// programmable stage

			let stageCompute = this.programs.compute.get( nodeBuilderState.computeShader );

			if ( stageCompute === undefined ) {

				if ( previousPipeline && previousPipeline.computeProgram.usedTimes === 0 ) this._releaseProgram( previousPipeline.computeProgram );

				stageCompute = new ProgrammableStage( nodeBuilderState.computeShader, 'compute', nodeBuilderState.transforms, nodeBuilderState.nodeAttributes );
				this.programs.compute.set( nodeBuilderState.computeShader, stageCompute );

				backend.createProgram( stageCompute );

			}

			// determine compute pipeline

			const cacheKey = this._getComputeCacheKey( computeNode, stageCompute );

			let pipeline = this.caches.get( cacheKey );

			if ( pipeline === undefined ) {

				if ( previousPipeline && previousPipeline.usedTimes === 0 ) this._releasePipeline( previousPipeline );

				pipeline = this._getComputePipeline( computeNode, stageCompute, cacheKey, bindings );

			}

			// keep track of all used times

			pipeline.usedTimes ++;
			stageCompute.usedTimes ++;

			//

			data.version = computeNode.version;
			data.pipeline = pipeline;

		}

		return data.pipeline;

	}

	getForRender( renderObject, promises = null ) {

		const { backend } = this;

		const data = this.get( renderObject );

		if ( this._needsRenderUpdate( renderObject ) ) {

			const previousPipeline = data.pipeline;

			if ( previousPipeline ) {

				previousPipeline.usedTimes --;
				previousPipeline.vertexProgram.usedTimes --;
				previousPipeline.fragmentProgram.usedTimes --;

			}

			// get shader

			const nodeBuilderState = renderObject.getNodeBuilderState();

			// programmable stages

			let stageVertex = this.programs.vertex.get( nodeBuilderState.vertexShader );

			if ( stageVertex === undefined ) {

				if ( previousPipeline && previousPipeline.vertexProgram.usedTimes === 0 ) this._releaseProgram( previousPipeline.vertexProgram );

				stageVertex = new ProgrammableStage( nodeBuilderState.vertexShader, 'vertex' );
				this.programs.vertex.set( nodeBuilderState.vertexShader, stageVertex );

				backend.createProgram( stageVertex );

			}

			let stageFragment = this.programs.fragment.get( nodeBuilderState.fragmentShader );

			if ( stageFragment === undefined ) {

				if ( previousPipeline && previousPipeline.fragmentProgram.usedTimes === 0 ) this._releaseProgram( previousPipeline.fragmentProgram );

				stageFragment = new ProgrammableStage( nodeBuilderState.fragmentShader, 'fragment' );
				this.programs.fragment.set( nodeBuilderState.fragmentShader, stageFragment );

				backend.createProgram( stageFragment );

			}

			// determine render pipeline

			const cacheKey = this._getRenderCacheKey( renderObject, stageVertex, stageFragment );

			let pipeline = this.caches.get( cacheKey );

			if ( pipeline === undefined ) {

				if ( previousPipeline && previousPipeline.usedTimes === 0 ) this._releasePipeline( previousPipeline );

				pipeline = this._getRenderPipeline( renderObject, stageVertex, stageFragment, cacheKey, promises );

			} else {

				renderObject.pipeline = pipeline;

			}

			// keep track of all used times

			pipeline.usedTimes ++;
			stageVertex.usedTimes ++;
			stageFragment.usedTimes ++;

			//

			data.pipeline = pipeline;

		}

		return data.pipeline;

	}

	delete( object ) {

		const pipeline = this.get( object ).pipeline;

		if ( pipeline ) {

			// pipeline

			pipeline.usedTimes --;

			if ( pipeline.usedTimes === 0 ) this._releasePipeline( pipeline );

			// programs

			if ( pipeline.isComputePipeline ) {

				pipeline.computeProgram.usedTimes --;

				if ( pipeline.computeProgram.usedTimes === 0 ) this._releaseProgram( pipeline.computeProgram );

			} else {

				pipeline.fragmentProgram.usedTimes --;
				pipeline.vertexProgram.usedTimes --;

				if ( pipeline.vertexProgram.usedTimes === 0 ) this._releaseProgram( pipeline.vertexProgram );
				if ( pipeline.fragmentProgram.usedTimes === 0 ) this._releaseProgram( pipeline.fragmentProgram );

			}

		}

		return super.delete( object );

	}

	dispose() {

		super.dispose();

		this.caches = new Map();
		this.programs = {
			vertex: new Map(),
			fragment: new Map(),
			compute: new Map()
		};

	}

	updateForRender( renderObject ) {

		this.getForRender( renderObject );

	}

	_getComputePipeline( computeNode, stageCompute, cacheKey, bindings ) {

		// check for existing pipeline

		cacheKey = cacheKey || this._getComputeCacheKey( computeNode, stageCompute );

		let pipeline = this.caches.get( cacheKey );

		if ( pipeline === undefined ) {

			pipeline = new ComputePipeline( cacheKey, stageCompute );

			this.caches.set( cacheKey, pipeline );

			this.backend.createComputePipeline( pipeline, bindings );

		}

		return pipeline;

	}

	_getRenderPipeline( renderObject, stageVertex, stageFragment, cacheKey, promises ) {

		// check for existing pipeline

		cacheKey = cacheKey || this._getRenderCacheKey( renderObject, stageVertex, stageFragment );

		let pipeline = this.caches.get( cacheKey );

		if ( pipeline === undefined ) {

			pipeline = new RenderPipeline( cacheKey, stageVertex, stageFragment );

			this.caches.set( cacheKey, pipeline );

			renderObject.pipeline = pipeline;

			this.backend.createRenderPipeline( renderObject, promises );

		}

		return pipeline;

	}

	_getComputeCacheKey( computeNode, stageCompute ) {

		return computeNode.id + ',' + stageCompute.id;

	}

	_getRenderCacheKey( renderObject, stageVertex, stageFragment ) {

		return stageVertex.id + ',' + stageFragment.id + ',' + this.backend.getRenderCacheKey( renderObject );

	}

	_releasePipeline( pipeline ) {

		this.caches.delete( pipeline.cacheKey );

	}

	_releaseProgram( program ) {

		const code = program.code;
		const stage = program.stage;

		this.programs[ stage ].delete( code );

	}

	_needsComputeUpdate( computeNode ) {

		const data = this.get( computeNode );

		return data.pipeline === undefined || data.version !== computeNode.version;

	}

	_needsRenderUpdate( renderObject ) {

		const data = this.get( renderObject );

		return data.pipeline === undefined || this.backend.needsRenderUpdate( renderObject );

	}

}

class Bindings extends DataMap {

	constructor( backend, nodes, textures, attributes, pipelines, info ) {

		super();

		this.backend = backend;
		this.textures = textures;
		this.pipelines = pipelines;
		this.attributes = attributes;
		this.nodes = nodes;
		this.info = info;

		this.pipelines.bindings = this; // assign bindings to pipelines

	}

	getForRender( renderObject ) {

		const bindings = renderObject.getBindings();

		for ( const bindGroup of bindings ) {

			const groupData = this.get( bindGroup );

			if ( groupData.bindGroup === undefined ) {

				// each object defines an array of bindings (ubos, textures, samplers etc.)

				this._init( bindGroup );

				this.backend.createBindings( bindGroup, bindings, 0 );

				groupData.bindGroup = bindGroup;

			}

		}

		return bindings;

	}

	getForCompute( computeNode ) {

		const bindings = this.nodes.getForCompute( computeNode ).bindings;

		for ( const bindGroup of bindings ) {

			const groupData = this.get( bindGroup );

			if ( groupData.bindGroup === undefined ) {

				this._init( bindGroup );

				this.backend.createBindings( bindGroup, bindings, 0 );

				groupData.bindGroup = bindGroup;

			}

		}

		return bindings;

	}

	updateForCompute( computeNode ) {

		this._updateBindings( this.getForCompute( computeNode ) );

	}

	updateForRender( renderObject ) {

		this._updateBindings( this.getForRender( renderObject ) );

	}

	_updateBindings( bindings ) {

		for ( const bindGroup of bindings ) {

			this._update( bindGroup, bindings );

		}

	}

	_init( bindGroup ) {

		for ( const binding of bindGroup.bindings ) {

			if ( binding.isSampledTexture ) {

				this.textures.updateTexture( binding.texture );

			} else if ( binding.isStorageBuffer ) {

				const attribute = binding.attribute;
				const attributeType = attribute.isIndirectStorageBufferAttribute ? AttributeType.INDIRECT : AttributeType.STORAGE;

				this.attributes.update( attribute, attributeType );

			}

		}

	}

	_update( bindGroup, bindings ) {

		const { backend } = this;

		let needsBindingsUpdate = false;
		let cacheBindings = true;
		let cacheIndex = 0;
		let version = 0;

		// iterate over all bindings and check if buffer updates or a new binding group is required

		for ( const binding of bindGroup.bindings ) {

			if ( binding.isNodeUniformsGroup ) {

				const updated = this.nodes.updateGroup( binding );

				if ( ! updated ) continue;

			}

			if ( binding.isUniformBuffer ) {

				const updated = binding.update();

				if ( updated ) {

					backend.updateBinding( binding );

				}

			} else if ( binding.isSampler ) {

				binding.update();

			} else if ( binding.isSampledTexture ) {

				const texturesTextureData = this.textures.get( binding.texture );

				if ( binding.needsBindingsUpdate( texturesTextureData.generation ) ) needsBindingsUpdate = true;

				const updated = binding.update();

				const texture = binding.texture;

				if ( updated ) {

					this.textures.updateTexture( texture );

				}

				const textureData = backend.get( texture );

				if ( textureData.externalTexture !== undefined || texturesTextureData.isDefaultTexture ) {

					cacheBindings = false;

				} else {

					cacheIndex = cacheIndex * 10 + texture.id;
					version += texture.version;

				}

				if ( backend.isWebGPUBackend === true && textureData.texture === undefined && textureData.externalTexture === undefined ) {

					// TODO: Remove this once we found why updated === false isn't bound to a texture in the WebGPU backend
					console.error( 'Bindings._update: binding should be available:', binding, updated, texture, binding.textureNode.value, needsBindingsUpdate );

					this.textures.updateTexture( texture );
					needsBindingsUpdate = true;

				}

				if ( texture.isStorageTexture === true ) {

					const textureData = this.get( texture );

					if ( binding.store === true ) {

						textureData.needsMipmap = true;

					} else if ( this.textures.needsMipmaps( texture ) && textureData.needsMipmap === true ) {

						this.backend.generateMipmaps( texture );

						textureData.needsMipmap = false;

					}

				}

			}

		}

		if ( needsBindingsUpdate === true ) {

			this.backend.updateBindings( bindGroup, bindings, cacheBindings ? cacheIndex : 0, version );

		}

	}

}

function painterSortStable( a, b ) {

	if ( a.groupOrder !== b.groupOrder ) {

		return a.groupOrder - b.groupOrder;

	} else if ( a.renderOrder !== b.renderOrder ) {

		return a.renderOrder - b.renderOrder;

	} else if ( a.material.id !== b.material.id ) {

		return a.material.id - b.material.id;

	} else if ( a.z !== b.z ) {

		return a.z - b.z;

	} else {

		return a.id - b.id;

	}

}

function reversePainterSortStable( a, b ) {

	if ( a.groupOrder !== b.groupOrder ) {

		return a.groupOrder - b.groupOrder;

	} else if ( a.renderOrder !== b.renderOrder ) {

		return a.renderOrder - b.renderOrder;

	} else if ( a.z !== b.z ) {

		return b.z - a.z;

	} else {

		return a.id - b.id;

	}

}

function needsDoublePass( material ) {

	const hasTransmission = material.transmission > 0 || material.transmissionNode;

	return hasTransmission && material.side === DoubleSide && material.forceSinglePass === false;

}

class RenderList {

	constructor( lighting, scene, camera ) {

		this.renderItems = [];
		this.renderItemsIndex = 0;

		this.opaque = [];
		this.transparentDoublePass = [];
		this.transparent = [];
		this.bundles = [];

		this.lightsNode = lighting.getNode( scene, camera );
		this.lightsArray = [];

		this.scene = scene;
		this.camera = camera;

		this.occlusionQueryCount = 0;

	}

	begin() {

		this.renderItemsIndex = 0;

		this.opaque.length = 0;
		this.transparentDoublePass.length = 0;
		this.transparent.length = 0;
		this.bundles.length = 0;

		this.lightsArray.length = 0;

		this.occlusionQueryCount = 0;

		return this;

	}

	getNextRenderItem( object, geometry, material, groupOrder, z, group, clippingContext ) {

		let renderItem = this.renderItems[ this.renderItemsIndex ];

		if ( renderItem === undefined ) {

			renderItem = {
				id: object.id,
				object: object,
				geometry: geometry,
				material: material,
				groupOrder: groupOrder,
				renderOrder: object.renderOrder,
				z: z,
				group: group,
				clippingContext: clippingContext
			};

			this.renderItems[ this.renderItemsIndex ] = renderItem;

		} else {

			renderItem.id = object.id;
			renderItem.object = object;
			renderItem.geometry = geometry;
			renderItem.material = material;
			renderItem.groupOrder = groupOrder;
			renderItem.renderOrder = object.renderOrder;
			renderItem.z = z;
			renderItem.group = group;
			renderItem.clippingContext = clippingContext;

		}

		this.renderItemsIndex ++;

		return renderItem;

	}

	push( object, geometry, material, groupOrder, z, group, clippingContext ) {

		const renderItem = this.getNextRenderItem( object, geometry, material, groupOrder, z, group, clippingContext );

		if ( object.occlusionTest === true ) this.occlusionQueryCount ++;

		if ( material.transparent === true || material.transmission > 0 ) {

			if ( needsDoublePass( material ) ) this.transparentDoublePass.push( renderItem );

			this.transparent.push( renderItem );

		} else {

			this.opaque.push( renderItem );

		}

	}

	unshift( object, geometry, material, groupOrder, z, group, clippingContext ) {

		const renderItem = this.getNextRenderItem( object, geometry, material, groupOrder, z, group, clippingContext );

		if ( material.transparent === true || material.transmission > 0 ) {

			if ( needsDoublePass( material ) ) this.transparentDoublePass.unshift( renderItem );

			this.transparent.unshift( renderItem );

		} else {

			this.opaque.unshift( renderItem );

		}

	}

	pushBundle( group ) {

		this.bundles.push( group );

	}

	pushLight( light ) {

		this.lightsArray.push( light );

	}

	sort( customOpaqueSort, customTransparentSort ) {

		if ( this.opaque.length > 1 ) this.opaque.sort( customOpaqueSort || painterSortStable );
		if ( this.transparentDoublePass.length > 1 ) this.transparentDoublePass.sort( customTransparentSort || reversePainterSortStable );
		if ( this.transparent.length > 1 ) this.transparent.sort( customTransparentSort || reversePainterSortStable );

	}

	finish() {

		// update lights

		this.lightsNode.setLights( this.lightsArray );

		// Clear references from inactive renderItems in the list

		for ( let i = this.renderItemsIndex, il = this.renderItems.length; i < il; i ++ ) {

			const renderItem = this.renderItems[ i ];

			if ( renderItem.id === null ) break;

			renderItem.id = null;
			renderItem.object = null;
			renderItem.geometry = null;
			renderItem.material = null;
			renderItem.groupOrder = null;
			renderItem.renderOrder = null;
			renderItem.z = null;
			renderItem.group = null;
			renderItem.clippingContext = null;

		}

	}

}

class RenderLists {

	constructor( lighting ) {

		this.lighting = lighting;

		this.lists = new ChainMap();

	}

	get( scene, camera ) {

		const lists = this.lists;
		const keys = [ scene, camera ];

		let list = lists.get( keys );

		if ( list === undefined ) {

			list = new RenderList( this.lighting, scene, camera );
			lists.set( keys, list );

		}

		return list;

	}

	dispose() {

		this.lists = new ChainMap();

	}

}

let id$1 = 0;

class RenderContext {

	constructor() {

		this.id = id$1 ++;

		this.color = true;
		this.clearColor = true;
		this.clearColorValue = { r: 0, g: 0, b: 0, a: 1 };

		this.depth = true;
		this.clearDepth = true;
		this.clearDepthValue = 1;

		this.stencil = false;
		this.clearStencil = true;
		this.clearStencilValue = 1;

		this.viewport = false;
		this.viewportValue = new Vector4();

		this.scissor = false;
		this.scissorValue = new Vector4();

		this.textures = null;
		this.depthTexture = null;
		this.activeCubeFace = 0;
		this.sampleCount = 1;

		this.width = 0;
		this.height = 0;

		this.isRenderContext = true;

	}

	getCacheKey() {

		return getCacheKey( this );

	}

}

function getCacheKey( renderContext ) {

	const { textures, activeCubeFace } = renderContext;

	const values = [ activeCubeFace ];

	for ( const texture of textures ) {

		values.push( texture.id );

	}

	return hashArray( values );

}

class RenderContexts {

	constructor() {

		this.chainMaps = {};

	}

	get( scene, camera, renderTarget = null ) {

		const chainKey = [ scene, camera ];

		let attachmentState;

		if ( renderTarget === null ) {

			attachmentState = 'default';

		} else {

			const format = renderTarget.texture.format;
			const count = renderTarget.textures.length;

			attachmentState = `${ count }:${ format }:${ renderTarget.samples }:${ renderTarget.depthBuffer }:${ renderTarget.stencilBuffer }`;

		}

		const chainMap = this.getChainMap( attachmentState );

		let renderState = chainMap.get( chainKey );

		if ( renderState === undefined ) {

			renderState = new RenderContext();

			chainMap.set( chainKey, renderState );

		}

		if ( renderTarget !== null ) renderState.sampleCount = renderTarget.samples === 0 ? 1 : renderTarget.samples;

		return renderState;

	}

	getChainMap( attachmentState ) {

		return this.chainMaps[ attachmentState ] || ( this.chainMaps[ attachmentState ] = new ChainMap() );

	}

	dispose() {

		this.chainMaps = {};

	}

}

const _size$3 = /*@__PURE__*/ new Vector3();

class Textures extends DataMap {

	constructor( renderer, backend, info ) {

		super();

		this.renderer = renderer;
		this.backend = backend;
		this.info = info;

	}

	updateRenderTarget( renderTarget, activeMipmapLevel = 0 ) {

		const renderTargetData = this.get( renderTarget );

		const sampleCount = renderTarget.samples === 0 ? 1 : renderTarget.samples;
		const depthTextureMips = renderTargetData.depthTextureMips || ( renderTargetData.depthTextureMips = {} );

		const textures = renderTarget.textures;

		const size = this.getSize( textures[ 0 ] );

		const mipWidth = size.width >> activeMipmapLevel;
		const mipHeight = size.height >> activeMipmapLevel;

		let depthTexture = renderTarget.depthTexture || depthTextureMips[ activeMipmapLevel ];
		const useDepthTexture = renderTarget.depthBuffer === true || renderTarget.stencilBuffer === true;

		let textureNeedsUpdate = false;

		if ( depthTexture === undefined && useDepthTexture ) {

			depthTexture = new DepthTexture();
			depthTexture.format = renderTarget.stencilBuffer ? DepthStencilFormat : DepthFormat;
			depthTexture.type = renderTarget.stencilBuffer ? UnsignedInt248Type : UnsignedIntType; // FloatType
			depthTexture.image.width = mipWidth;
			depthTexture.image.height = mipHeight;

			depthTextureMips[ activeMipmapLevel ] = depthTexture;

		}

		if ( renderTargetData.width !== size.width || size.height !== renderTargetData.height ) {

			textureNeedsUpdate = true;

			if ( depthTexture ) {

				depthTexture.needsUpdate = true;
				depthTexture.image.width = mipWidth;
				depthTexture.image.height = mipHeight;

			}

		}

		renderTargetData.width = size.width;
		renderTargetData.height = size.height;
		renderTargetData.textures = textures;
		renderTargetData.depthTexture = depthTexture || null;
		renderTargetData.depth = renderTarget.depthBuffer;
		renderTargetData.stencil = renderTarget.stencilBuffer;
		renderTargetData.renderTarget = renderTarget;

		if ( renderTargetData.sampleCount !== sampleCount ) {

			textureNeedsUpdate = true;

			if ( depthTexture ) {

				depthTexture.needsUpdate = true;

			}

			renderTargetData.sampleCount = sampleCount;

		}

		//

		const options = { sampleCount };

		for ( let i = 0; i < textures.length; i ++ ) {

			const texture = textures[ i ];

			if ( textureNeedsUpdate ) texture.needsUpdate = true;

			this.updateTexture( texture, options );

		}

		if ( depthTexture ) {

			this.updateTexture( depthTexture, options );

		}

		// dispose handler

		if ( renderTargetData.initialized !== true ) {

			renderTargetData.initialized = true;

			// dispose

			const onDispose = () => {

				renderTarget.removeEventListener( 'dispose', onDispose );

				for ( let i = 0; i < textures.length; i ++ ) {

					this._destroyTexture( textures[ i ] );

				}

				if ( depthTexture ) {

					this._destroyTexture( depthTexture );

				}

				this.delete( renderTarget );

			};

			renderTarget.addEventListener( 'dispose', onDispose );

		}

	}

	updateTexture( texture, options = {} ) {

		const textureData = this.get( texture );
		if ( textureData.initialized === true && textureData.version === texture.version ) return;

		const isRenderTarget = texture.isRenderTargetTexture || texture.isDepthTexture || texture.isFramebufferTexture;
		const backend = this.backend;

		if ( isRenderTarget && textureData.initialized === true ) {

			// it's an update

			backend.destroySampler( texture );
			backend.destroyTexture( texture );

		}

		//

		if ( texture.isFramebufferTexture ) {

			const renderTarget = this.renderer.getRenderTarget();

			if ( renderTarget ) {

				texture.type = renderTarget.texture.type;

			} else {

				texture.type = UnsignedByteType;

			}

		}

		//

		const { width, height, depth } = this.getSize( texture );

		options.width = width;
		options.height = height;
		options.depth = depth;
		options.needsMipmaps = this.needsMipmaps( texture );
		options.levels = options.needsMipmaps ? this.getMipLevels( texture, width, height ) : 1;

		//

		if ( isRenderTarget || texture.isStorageTexture === true ) {

			backend.createSampler( texture );
			backend.createTexture( texture, options );

			textureData.generation = texture.version;

		} else {

			const needsCreate = textureData.initialized !== true;

			if ( needsCreate ) backend.createSampler( texture );

			if ( texture.version > 0 ) {

				const image = texture.image;

				if ( image === undefined ) {

					console.warn( 'THREE.Renderer: Texture marked for update but image is undefined.' );

				} else if ( image.complete === false ) {

					console.warn( 'THREE.Renderer: Texture marked for update but image is incomplete.' );

				} else {

					if ( texture.images ) {

						const images = [];

						for ( const image of texture.images ) {

							images.push( image );

						}

						options.images = images;

					} else {

						options.image = image;

					}

					if ( textureData.isDefaultTexture === undefined || textureData.isDefaultTexture === true ) {

						backend.createTexture( texture, options );

						textureData.isDefaultTexture = false;
						textureData.generation = texture.version;

					}

					if ( texture.source.dataReady === true ) backend.updateTexture( texture, options );

					if ( options.needsMipmaps && texture.mipmaps.length === 0 ) backend.generateMipmaps( texture );

				}

			} else {

				// async update

				backend.createDefaultTexture( texture );

				textureData.isDefaultTexture = true;
				textureData.generation = texture.version;

			}

		}

		// dispose handler

		if ( textureData.initialized !== true ) {

			textureData.initialized = true;
			textureData.generation = texture.version;

			//

			this.info.memory.textures ++;

			// dispose

			const onDispose = () => {

				texture.removeEventListener( 'dispose', onDispose );

				this._destroyTexture( texture );

				this.info.memory.textures --;

			};

			texture.addEventListener( 'dispose', onDispose );

		}

		//

		textureData.version = texture.version;

	}

	getSize( texture, target = _size$3 ) {

		let image = texture.images ? texture.images[ 0 ] : texture.image;

		if ( image ) {

			if ( image.image !== undefined ) image = image.image;

			target.width = image.width || 1;
			target.height = image.height || 1;
			target.depth = texture.isCubeTexture ? 6 : ( image.depth || 1 );

		} else {

			target.width = target.height = target.depth = 1;

		}

		return target;

	}

	getMipLevels( texture, width, height ) {

		let mipLevelCount;

		if ( texture.isCompressedTexture ) {

			if ( texture.mipmaps ) {

				mipLevelCount = texture.mipmaps.length;

			} else {

				mipLevelCount = 1;

			}

		} else {

			mipLevelCount = Math.floor( Math.log2( Math.max( width, height ) ) ) + 1;

		}

		return mipLevelCount;

	}

	needsMipmaps( texture ) {

		return this.isEnvironmentTexture( texture ) || texture.isCompressedTexture === true || texture.generateMipmaps;

	}

	isEnvironmentTexture( texture ) {

		const mapping = texture.mapping;

		return ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) || ( mapping === CubeReflectionMapping || mapping === CubeRefractionMapping );

	}

	_destroyTexture( texture ) {

		this.backend.destroySampler( texture );
		this.backend.destroyTexture( texture );

		this.delete( texture );

	}

}

class Color4 extends Color {

	constructor( r, g, b, a = 1 ) {

		super( r, g, b );

		this.a = a;

	}

	set( r, g, b, a = 1 ) {

		this.a = a;

		return super.set( r, g, b );

	}

	copy( color ) {

		if ( color.a !== undefined ) this.a = color.a;

		return super.copy( color );

	}

	clone() {

		return new this.constructor( this.r, this.g, this.b, this.a );

	}

}

class ParameterNode extends PropertyNode {

	static get type() {

		return 'ParameterNode';

	}

	constructor( nodeType, name = null ) {

		super( nodeType, name );

		this.isParameterNode = true;

	}

	getHash() {

		return this.uuid;

	}

	generate() {

		return this.name;

	}

}

const parameter = ( type, name ) => nodeObject( new ParameterNode( type, name ) );

class StackNode extends Node {

	static get type() {

		return 'StackNode';

	}

	constructor( parent = null ) {

		super();

		this.nodes = [];
		this.outputNode = null;

		this.parent = parent;

		this._currentCond = null;

		this.isStackNode = true;

	}

	getNodeType( builder ) {

		return this.outputNode ? this.outputNode.getNodeType( builder ) : 'void';

	}

	add( node ) {

		this.nodes.push( node );

		return this;

	}

	If( boolNode, method ) {

		const methodNode = new ShaderNode( method );
		this._currentCond = select( boolNode, methodNode );

		return this.add( this._currentCond );

	}

	ElseIf( boolNode, method ) {

		const methodNode = new ShaderNode( method );
		const ifNode = select( boolNode, methodNode );

		this._currentCond.elseNode = ifNode;
		this._currentCond = ifNode;

		return this;

	}

	Else( method ) {

		this._currentCond.elseNode = new ShaderNode( method );

		return this;

	}

	build( builder, ...params ) {

		const previousStack = getCurrentStack();

		setCurrentStack( this );

		for ( const node of this.nodes ) {

			node.build( builder, 'void' );

		}

		setCurrentStack( previousStack );

		return this.outputNode ? this.outputNode.build( builder, ...params ) : super.build( builder, ...params );

	}

	//

	else( ...params ) { // @deprecated, r168

		console.warn( 'TSL.StackNode: .else() has been renamed to .Else().' );
		return this.Else( ...params );

	}

	elseif( ...params ) { // @deprecated, r168

		console.warn( 'TSL.StackNode: .elseif() has been renamed to .ElseIf().' );
		return this.ElseIf( ...params );

	}

}

const stack = /*@__PURE__*/ nodeProxy( StackNode );

class StructTypeNode extends Node {

	static get type() {

		return 'StructTypeNode';

	}

	constructor( types ) {

		super();

		this.types = types;
		this.isStructTypeNode = true;

	}

	getMemberTypes() {

		return this.types;

	}

}

class OutputStructNode extends Node {

	static get type() {

		return 'OutputStructNode';

	}

	constructor( ...members ) {

		super();

		this.members = members;

		this.isOutputStructNode = true;

	}

	setup( builder ) {

		super.setup( builder );

		const members = this.members;
		const types = [];

		for ( let i = 0; i < members.length; i ++ ) {

			types.push( members[ i ].getNodeType( builder ) );

		}

		this.nodeType = builder.getStructTypeFromNode( new StructTypeNode( types ) ).name;

	}

	generate( builder, output ) {

		const propertyName = builder.getOutputStructName();
		const members = this.members;

		const structPrefix = propertyName !== '' ? propertyName + '.' : '';

		for ( let i = 0; i < members.length; i ++ ) {

			const snippet = members[ i ].build( builder, output );

			builder.addLineFlowCode( `${ structPrefix }m${ i } = ${ snippet }`, this );

		}

		return propertyName;

	}

}

const outputStruct = /*@__PURE__*/ nodeProxy( OutputStructNode );

function getTextureIndex( textures, name ) {

	for ( let i = 0; i < textures.length; i ++ ) {

		if ( textures[ i ].name === name ) {

			return i;

		}

	}

	return -1;

}

class MRTNode extends OutputStructNode {

	static get type() {

		return 'MRTNode';

	}

	constructor( outputNodes ) {

		super();

		this.outputNodes = outputNodes;

		this.isMRTNode = true;

	}

	has( name ) {

		return this.outputNodes[ name ] !== undefined;

	}

	get( name ) {

		return this.outputNodes[ name ];

	}

	merge( mrtNode ) {

		const outputs = { ...this.outputNodes, ...mrtNode.outputNodes };

		return mrt( outputs );

	}

	setup( builder ) {

		const outputNodes = this.outputNodes;
		const mrt = builder.renderer.getRenderTarget();

		const members = [];

		const textures = mrt.textures;

		for ( const name in outputNodes ) {

			const index = getTextureIndex( textures, name );

			members[ index ] = vec4$1( outputNodes[ name ] );

		}

		this.members = members;

		return super.setup( builder );

	}

}

const mrt = /*@__PURE__*/ nodeProxy( MRTNode );

const hash = /*@__PURE__*/ Fn$1( ( [ seed ] ) => {

	// Taken from https://www.shadertoy.com/view/XlGcRh, originally from pcg-random.org

	const state = seed.toUint().mul( 747796405 ).add( 2891336453 );
	const word = state.shiftRight( state.shiftRight( 28 ).add( 4 ) ).bitXor( state ).mul( 277803737 );
	const result = word.shiftRight( 22 ).bitXor( word );

	return result.toFloat().mul( 1 / 2 ** 32 ); // Convert to range [0, 1)

} );

// remapping functions https://iquilezles.org/articles/functions/
const parabola = ( x, k ) => pow$1( mul$1( 4.0, x.mul( sub$1( 1.0, x ) ) ), k );
const gain = ( x, k ) => x.lessThan( 0.5 ) ? parabola( x.mul( 2.0 ), k ).div( 2.0 ) : sub$1( 1.0, parabola( mul$1( sub$1( 1.0, x ), 2.0 ), k ).div( 2.0 ) );
const pcurve = ( x, a, b ) => pow$1( div$1( pow$1( x, a ), add$1( pow$1( x, a ), pow$1( sub$1( 1.0, x ), b ) ) ), 1.0 / a );
const sinc = ( x, k ) => sin$1( PI.mul( k.mul( x ).sub( 1.0 ) ) ).div( PI.mul( k.mul( x ).sub( 1.0 ) ) );

// https://github.com/cabbibo/glsl-tri-noise-3d


const tri = /*@__PURE__*/ Fn$1( ( [ x ] ) => {

	return x.fract().sub( .5 ).abs();

} ).setLayout( {
	name: 'tri',
	type: 'float',
	inputs: [
		{ name: 'x', type: 'float' }
	]
} );

const tri3 = /*@__PURE__*/ Fn$1( ( [ p ] ) => {

	return vec3$1( tri( p.z.add( tri( p.y.mul( 1. ) ) ) ), tri( p.z.add( tri( p.x.mul( 1. ) ) ) ), tri( p.y.add( tri( p.x.mul( 1. ) ) ) ) );

} ).setLayout( {
	name: 'tri3',
	type: 'vec3',
	inputs: [
		{ name: 'p', type: 'vec3' }
	]
} );

const triNoise3D = /*@__PURE__*/ Fn$1( ( [ p_immutable, spd, time ] ) => {

	const p = vec3$1( p_immutable ).toVar();
	const z = float$1( 1.4 ).toVar();
	const rz = float$1( 0.0 ).toVar();
	const bp = vec3$1( p ).toVar();

	Loop( { start: float$1( 0.0 ), end: float$1( 3.0 ), type: 'float', condition: '<=' }, () => {

		const dg = vec3$1( tri3( bp.mul( 2.0 ) ) ).toVar();
		p.addAssign( dg.add( time.mul( float$1( 0.1 ).mul( spd ) ) ) );
		bp.mulAssign( 1.8 );
		z.mulAssign( 1.5 );
		p.mulAssign( 1.2 );

		const t = float$1( tri( p.z.add( tri( p.x.add( tri( p.y ) ) ) ) ) ).toVar();
		rz.addAssign( t.div( z ) );
		bp.addAssign( 0.14 );

	} );

	return rz;

} ).setLayout( {
	name: 'triNoise3D',
	type: 'float',
	inputs: [
		{ name: 'p', type: 'vec3' },
		{ name: 'spd', type: 'float' },
		{ name: 'time', type: 'float' }
	]
} );

class FunctionOverloadingNode extends Node {

	static get type() {

		return 'FunctionOverloadingNode';

	}

	constructor( functionNodes = [], ...parametersNodes ) {

		super();

		this.functionNodes = functionNodes;
		this.parametersNodes = parametersNodes;

		this._candidateFnCall = null;

		this.global = true;

	}

	getNodeType() {

		return this.functionNodes[ 0 ].shaderNode.layout.type;

	}

	setup( builder ) {

		const params = this.parametersNodes;

		let candidateFnCall = this._candidateFnCall;

		if ( candidateFnCall === null ) {

			let candidateFn = null;
			let candidateScore = -1;

			for ( const functionNode of this.functionNodes ) {

				const shaderNode = functionNode.shaderNode;
				const layout = shaderNode.layout;

				if ( layout === null ) {

					throw new Error( 'FunctionOverloadingNode: FunctionNode must be a layout.' );

				}

				const inputs = layout.inputs;

				if ( params.length === inputs.length ) {

					let score = 0;

					for ( let i = 0; i < params.length; i ++ ) {

						const param = params[ i ];
						const input = inputs[ i ];

						if ( param.getNodeType( builder ) === input.type ) {

							score ++;

						} else {

							score = 0;

						}

					}

					if ( score > candidateScore ) {

						candidateFn = functionNode;
						candidateScore = score;

					}

				}

			}

			this._candidateFnCall = candidateFnCall = candidateFn( ...params );

		}

		return candidateFnCall;

	}

}

const overloadingBaseFn = /*@__PURE__*/ nodeProxy( FunctionOverloadingNode );

const overloadingFn = ( functionNodes ) => ( ...params ) => overloadingBaseFn( functionNodes, ...params );

const time$1 = /*@__PURE__*/ uniform$1( 0 ).setGroup( renderGroup ).onRenderUpdate( ( frame ) => frame.time );
const deltaTime = /*@__PURE__*/ uniform$1( 0 ).setGroup( renderGroup ).onRenderUpdate( ( frame ) => frame.deltaTime );
const frameId = /*@__PURE__*/ uniform$1( 0, 'uint' ).setGroup( renderGroup ).onRenderUpdate( ( frame ) => frame.frameId );

// Deprecated

const timerLocal = ( timeScale = 1 ) => { // @deprecated, r170

	console.warn( 'TSL: timerLocal() is deprecated. Use "time" instead.' );
	return time$1.mul( timeScale );

};

const timerGlobal = ( timeScale = 1 ) => { // @deprecated, r170

	console.warn( 'TSL: timerGlobal() is deprecated. Use "time" instead.' );
	return time$1.mul( timeScale );

};

const timerDelta = ( timeScale = 1 ) => { // @deprecated, r170

	console.warn( 'TSL: timerDelta() is deprecated. Use "deltaTime" instead.' );
	return deltaTime.mul( timeScale );

};

const oscSine = ( t = time$1 ) => t.add( 0.75 ).mul( Math.PI * 2 ).sin().mul( 0.5 ).add( 0.5 );
const oscSquare = ( t = time$1 ) => t.fract().round();
const oscTriangle = ( t = time$1 ) => t.add( 0.5 ).fract().mul( 2 ).sub( 1 ).abs();
const oscSawtooth = ( t = time$1 ) => t.fract();

const rotateUV = /*@__PURE__*/ Fn$1( ( [ uv, rotation, center = vec2$1( 0.5 ) ] ) => {

	return rotate( uv.sub( center ), rotation ).add( center );

} );

const spherizeUV = /*@__PURE__*/ Fn$1( ( [ uv, strength, center = vec2$1( 0.5 ) ] ) => {

	const delta = uv.sub( center );
	const delta2 = delta.dot( delta );
	const delta4 = delta2.mul( delta2 );
	const deltaOffset = delta4.mul( strength );

	return uv.add( delta.mul( deltaOffset ) );

} );

const billboarding = /*@__PURE__*/ Fn$1( ( { position = null, horizontal = true, vertical = false } ) => {

	let worldMatrix;

	if ( position !== null ) {

		worldMatrix = modelWorldMatrix.toVar();
		worldMatrix[ 3 ][ 0 ] = position.x;
		worldMatrix[ 3 ][ 1 ] = position.y;
		worldMatrix[ 3 ][ 2 ] = position.z;

	} else {

		worldMatrix = modelWorldMatrix;

	}

	const modelViewMatrix = cameraViewMatrix.mul( worldMatrix );

	if ( defined( horizontal ) ) {

		modelViewMatrix[ 0 ][ 0 ] = modelWorldMatrix[ 0 ].length();
		modelViewMatrix[ 0 ][ 1 ] = 0;
		modelViewMatrix[ 0 ][ 2 ] = 0;

	}

	if ( defined( vertical ) ) {

		modelViewMatrix[ 1 ][ 0 ] = 0;
		modelViewMatrix[ 1 ][ 1 ] = modelWorldMatrix[ 1 ].length();
		modelViewMatrix[ 1 ][ 2 ] = 0;

	}

	modelViewMatrix[ 2 ][ 0 ] = 0;
	modelViewMatrix[ 2 ][ 1 ] = 0;
	modelViewMatrix[ 2 ][ 2 ] = 1;

	return cameraProjectionMatrix.mul( modelViewMatrix ).mul( positionLocal$1 );

} );

const viewportSafeUV = /*@__PURE__*/ Fn$1( ( [ uv = null ] ) => {

	const depth = linearDepth();
	const depthDiff = linearDepth( viewportDepthTexture( uv ) ).sub( depth );
	const finalUV = depthDiff.lessThan( 0 ).select( screenUV, uv );

	return finalUV;

} );

class SpriteSheetUVNode extends Node {

	static get type() {

		return 'SpriteSheetUVNode';

	}

	constructor( countNode, uvNode = uv$1(), frameNode = float$1( 0 ) ) {

		super( 'vec2' );

		this.countNode = countNode;
		this.uvNode = uvNode;
		this.frameNode = frameNode;

	}

	setup() {

		const { frameNode, uvNode, countNode } = this;

		const { width, height } = countNode;

		const frameNum = frameNode.mod( width.mul( height ) ).floor();

		const column = frameNum.mod( width );
		const row = height.sub( frameNum.add( 1 ).div( width ).ceil() );

		const scale = countNode.reciprocal();
		const uvFrameOffset = vec2$1( column, row );

		return uvNode.add( uvFrameOffset ).mul( scale );

	}

}

const spritesheetUV = /*@__PURE__*/ nodeProxy( SpriteSheetUVNode );

class TriplanarTexturesNode extends Node {

	static get type() {

		return 'TriplanarTexturesNode';

	}

	constructor( textureXNode, textureYNode = null, textureZNode = null, scaleNode = float$1( 1 ), positionNode = positionLocal$1, normalNode = normalLocal ) {

		super( 'vec4' );

		this.textureXNode = textureXNode;
		this.textureYNode = textureYNode;
		this.textureZNode = textureZNode;

		this.scaleNode = scaleNode;

		this.positionNode = positionNode;
		this.normalNode = normalNode;

	}

	setup() {

		const { textureXNode, textureYNode, textureZNode, scaleNode, positionNode, normalNode } = this;

		// Ref: https://github.com/keijiro/StandardTriplanar

		// Blending factor of triplanar mapping
		let bf = normalNode.abs().normalize();
		bf = bf.div( bf.dot( vec3$1( 1.0 ) ) );

		// Triplanar mapping
		const tx = positionNode.yz.mul( scaleNode );
		const ty = positionNode.zx.mul( scaleNode );
		const tz = positionNode.xy.mul( scaleNode );

		// Base color
		const textureX = textureXNode.value;
		const textureY = textureYNode !== null ? textureYNode.value : textureX;
		const textureZ = textureZNode !== null ? textureZNode.value : textureX;

		const cx = texture( textureX, tx ).mul( bf.x );
		const cy = texture( textureY, ty ).mul( bf.y );
		const cz = texture( textureZ, tz ).mul( bf.z );

		return add$1( cx, cy, cz );

	}

}

const triplanarTextures = /*@__PURE__*/ nodeProxy( TriplanarTexturesNode );
const triplanarTexture = ( ...params ) => triplanarTextures( ...params );

const _reflectorPlane = new Plane();
const _normal = new Vector3();
const _reflectorWorldPosition = new Vector3();
const _cameraWorldPosition = new Vector3();
const _rotationMatrix = new Matrix4();
const _lookAtPosition = new Vector3( 0, 0, -1 );
const clipPlane = new Vector4();

const _view = new Vector3();
const _target = new Vector3();
const _q = new Vector4();

const _size$2 = new Vector2();

const _defaultRT = new RenderTarget();
const _defaultUV = screenUV.flipX();

_defaultRT.depthTexture = new DepthTexture( 1, 1 );

let _inReflector = false;

class ReflectorNode extends TextureNode {

	static get type() {

		return 'ReflectorNode';

	}

	constructor( parameters = {} ) {

		super( parameters.defaultTexture || _defaultRT.texture, _defaultUV );

		this._reflectorBaseNode = parameters.reflector || new ReflectorBaseNode( this, parameters );
		this._depthNode = null;

		this.setUpdateMatrix( false );

	}

	get reflector() {

		return this._reflectorBaseNode;

	}

	get target() {

		return this._reflectorBaseNode.target;

	}

	getDepthNode() {

		if ( this._depthNode === null ) {

			if ( this._reflectorBaseNode.depth !== true ) {

				throw new Error( 'THREE.ReflectorNode: Depth node can only be requested when the reflector is created with { depth: true }. ' );

			}

			this._depthNode = nodeObject( new ReflectorNode( {
				defaultTexture: _defaultRT.depthTexture,
				reflector: this._reflectorBaseNode
			} ) );

		}

		return this._depthNode;

	}

	setup( builder ) {

		// ignore if used in post-processing
		if ( ! builder.object.isQuadMesh ) this._reflectorBaseNode.build( builder );

		return super.setup( builder );

	}

	clone() {

		const texture = new this.constructor( this.reflectorNode );
		texture._reflectorBaseNode = this._reflectorBaseNode;

		return texture;

	}

}


class ReflectorBaseNode extends Node {

	static get type() {

		return 'ReflectorBaseNode';

	}

	constructor( textureNode, parameters = {} ) {

		super();

		const {
			target = new Object3D(),
			resolution = 1,
			generateMipmaps = false,
			bounces = true,
			depth = false
		} = parameters;

		//

		this.textureNode = textureNode;

		this.target = target;
		this.resolution = resolution;
		this.generateMipmaps = generateMipmaps;
		this.bounces = bounces;
		this.depth = depth;

		this.updateBeforeType = bounces ? NodeUpdateType.RENDER : NodeUpdateType.FRAME;

		this.virtualCameras = new WeakMap();
		this.renderTargets = new WeakMap();

	}

	_updateResolution( renderTarget, renderer ) {

		const resolution = this.resolution;

		renderer.getDrawingBufferSize( _size$2 );

		renderTarget.setSize( Math.round( _size$2.width * resolution ), Math.round( _size$2.height * resolution ) );

	}

	setup( builder ) {

		this._updateResolution( _defaultRT, builder.renderer );

		return super.setup( builder );

	}

	getVirtualCamera( camera ) {

		let virtualCamera = this.virtualCameras.get( camera );

		if ( virtualCamera === undefined ) {

			virtualCamera = camera.clone();

			this.virtualCameras.set( camera, virtualCamera );

		}

		return virtualCamera;

	}

	getRenderTarget( camera ) {

		let renderTarget = this.renderTargets.get( camera );

		if ( renderTarget === undefined ) {

			renderTarget = new RenderTarget( 0, 0, { type: HalfFloatType } );

			if ( this.generateMipmaps === true ) {

				renderTarget.texture.minFilter = LinearMipMapLinearFilter;
				renderTarget.texture.generateMipmaps = true;

			}

			if ( this.depth === true ) {

				renderTarget.depthTexture = new DepthTexture();

			}

			this.renderTargets.set( camera, renderTarget );

		}

		return renderTarget;

	}

	updateBefore( frame ) {

		if ( this.bounces === false && _inReflector ) return;

		_inReflector = true;

		const { scene, camera, renderer, material } = frame;
		const { target } = this;

		const virtualCamera = this.getVirtualCamera( camera );
		const renderTarget = this.getRenderTarget( virtualCamera );

		renderer.getDrawingBufferSize( _size$2 );

		this._updateResolution( renderTarget, renderer );

		//

		_reflectorWorldPosition.setFromMatrixPosition( target.matrixWorld );
		_cameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );

		_rotationMatrix.extractRotation( target.matrixWorld );

		_normal.set( 0, 0, 1 );
		_normal.applyMatrix4( _rotationMatrix );

		_view.subVectors( _reflectorWorldPosition, _cameraWorldPosition );

		// Avoid rendering when reflector is facing away

		if ( _view.dot( _normal ) > 0 ) return;

		_view.reflect( _normal ).negate();
		_view.add( _reflectorWorldPosition );

		_rotationMatrix.extractRotation( camera.matrixWorld );

		_lookAtPosition.set( 0, 0, -1 );
		_lookAtPosition.applyMatrix4( _rotationMatrix );
		_lookAtPosition.add( _cameraWorldPosition );

		_target.subVectors( _reflectorWorldPosition, _lookAtPosition );
		_target.reflect( _normal ).negate();
		_target.add( _reflectorWorldPosition );

		//

		virtualCamera.coordinateSystem = camera.coordinateSystem;
		virtualCamera.position.copy( _view );
		virtualCamera.up.set( 0, 1, 0 );
		virtualCamera.up.applyMatrix4( _rotationMatrix );
		virtualCamera.up.reflect( _normal );
		virtualCamera.lookAt( _target );

		virtualCamera.near = camera.near;
		virtualCamera.far = camera.far;

		virtualCamera.updateMatrixWorld();
		virtualCamera.projectionMatrix.copy( camera.projectionMatrix );

		// Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html
		// Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf
		_reflectorPlane.setFromNormalAndCoplanarPoint( _normal, _reflectorWorldPosition );
		_reflectorPlane.applyMatrix4( virtualCamera.matrixWorldInverse );

		clipPlane.set( _reflectorPlane.normal.x, _reflectorPlane.normal.y, _reflectorPlane.normal.z, _reflectorPlane.constant );

		const projectionMatrix = virtualCamera.projectionMatrix;

		_q.x = ( Math.sign( clipPlane.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];
		_q.y = ( Math.sign( clipPlane.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];
		_q.z = -1;
		_q.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];

		// Calculate the scaled plane vector
		clipPlane.multiplyScalar( 1.0 / clipPlane.dot( _q ) );

		const clipBias = 0;

		// Replacing the third row of the projection matrix
		projectionMatrix.elements[ 2 ] = clipPlane.x;
		projectionMatrix.elements[ 6 ] = clipPlane.y;
		projectionMatrix.elements[ 10 ] = ( renderer.coordinateSystem === WebGPUCoordinateSystem ) ? ( clipPlane.z - clipBias ) : ( clipPlane.z + 1.0 - clipBias );
		projectionMatrix.elements[ 14 ] = clipPlane.w;

		//

		this.textureNode.value = renderTarget.texture;

		if ( this.depth === true ) {

			this.textureNode.getDepthNode().value = renderTarget.depthTexture;

		}

		material.visible = false;

		const currentRenderTarget = renderer.getRenderTarget();
		const currentMRT = renderer.getMRT();

		renderer.setMRT( null );
		renderer.setRenderTarget( renderTarget );

		renderer.render( scene, virtualCamera );

		renderer.setMRT( currentMRT );
		renderer.setRenderTarget( currentRenderTarget );

		material.visible = true;

		_inReflector = false;

	}

}

const reflector = ( parameters ) => nodeObject( new ReflectorNode( parameters ) );

// Helper for passes that need to fill the viewport with a single quad.

const _camera = /*@__PURE__*/ new OrthographicCamera( -1, 1, 1, -1, 0, 1 );

// https://github.com/mrdoob/three.js/pull/21358

class QuadGeometry extends BufferGeometry {

	constructor( flipY = false ) {

		super();

		const uv = flipY === false ? [ 0, -1, 0, 1, 2, 1 ] : [ 0, 2, 0, 0, 2, 0 ];

		this.setAttribute( 'position', new Float32BufferAttribute( [ -1, 3, 0, -1, -1, 0, 3, -1, 0 ], 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uv, 2 ) );

	}

}

const _geometry = /*@__PURE__*/ new QuadGeometry();

class QuadMesh extends Mesh {

	constructor( material = null ) {

		super( _geometry, material );

		this.camera = _camera;

		this.isQuadMesh = true;

	}

	renderAsync( renderer ) {

		return renderer.renderAsync( this, _camera );

	}

	render( renderer ) {

		renderer.render( this, _camera );

	}

}

const _size$1 = /*@__PURE__*/ new Vector2();

class RTTNode extends TextureNode {

	static get type() {

		return 'RTTNode';

	}

	constructor( node, width = null, height = null, options = { type: HalfFloatType } ) {

		const renderTarget = new RenderTarget( width, height, options );

		super( renderTarget.texture, uv$1() );

		this.node = node;
		this.width = width;
		this.height = height;

		this.renderTarget = renderTarget;

		this.textureNeedsUpdate = true;
		this.autoUpdate = true;

		this.updateMap = new WeakMap();

		this._rttNode = null;
		this._quadMesh = new QuadMesh( new NodeMaterial() );

		this.updateBeforeType = NodeUpdateType.RENDER;

	}

	get autoSize() {

		return this.width === null;

	}

	setup( builder ) {

		this._rttNode = this.node.context( builder.getSharedContext() );
		this._quadMesh.material.name = 'RTT';
		this._quadMesh.material.needsUpdate = true;

		return super.setup( builder );

	}

	setSize( width, height ) {

		this.width = width;
		this.height = height;

		const effectiveWidth = width * this.pixelRatio;
		const effectiveHeight = height * this.pixelRatio;

		this.renderTarget.setSize( effectiveWidth, effectiveHeight );

		this.textureNeedsUpdate = true;

	}

	setPixelRatio( pixelRatio ) {

		this.pixelRatio = pixelRatio;

		this.setSize( this.width, this.height );

	}

	updateBefore( { renderer } ) {

		if ( this.textureNeedsUpdate === false && this.autoUpdate === false ) return;

		this.textureNeedsUpdate = false;

		//

		if ( this.autoSize === true ) {

			this.pixelRatio = renderer.getPixelRatio();

			const size = renderer.getSize( _size$1 );

			this.setSize( size.width, size.height );

		}

		//

		this._quadMesh.material.fragmentNode = this._rttNode;

		//

		const currentRenderTarget = renderer.getRenderTarget();

		renderer.setRenderTarget( this.renderTarget );

		this._quadMesh.render( renderer );

		renderer.setRenderTarget( currentRenderTarget );

	}

	clone() {

		const newNode = new TextureNode( this.value, this.uvNode, this.levelNode );
		newNode.sampler = this.sampler;
		newNode.referenceNode = this;

		return newNode;

	}

}

const rtt = ( node, ...params ) => nodeObject( new RTTNode( nodeObject( node ), ...params ) );

const convertToTexture = ( node, ...params ) => {

	if ( node.isTextureNode ) return node;
	if ( node.isPassNode ) return node.getTextureNode();

	return rtt( node, ...params );

};

/**
* Computes a position in view space based on a fragment's screen position expressed as uv coordinates, the fragments
* depth value and the camera's inverse projection matrix.
*
* @param {vec2} screenPosition - The fragment's screen position expressed as uv coordinates.
* @param {float} depth - The fragment's depth value.
* @param {mat4} projectionMatrixInverse - The camera's inverse projection matrix.
* @return {vec3} The fragments position in view space.
*/
const getViewPosition = /*@__PURE__*/ Fn$1( ( [ screenPosition, depth, projectionMatrixInverse ], builder ) => {

	let clipSpacePosition;

	if ( builder.renderer.coordinateSystem === WebGPUCoordinateSystem ) {

		screenPosition = vec2$1( screenPosition.x, screenPosition.y.oneMinus() ).mul( 2.0 ).sub( 1.0 );
		clipSpacePosition = vec4$1( vec3$1( screenPosition, depth ), 1.0 );

	} else {

		clipSpacePosition = vec4$1( vec3$1( screenPosition.x, screenPosition.y.oneMinus(), depth ).mul( 2.0 ).sub( 1.0 ), 1.0 );

	}

	const viewSpacePosition = vec4$1( projectionMatrixInverse.mul( clipSpacePosition ) );

	return viewSpacePosition.xyz.div( viewSpacePosition.w );

} );

/**
* Computes a screen position expressed as uv coordinates based on a fragment's position in view space
* and the camera's projection matrix
*
* @param {vec3} viewPosition - The fragments position in view space.
* @param {mat4} projectionMatrix - The camera's projection matrix.
* @return {vec2} The fragment's screen position expressed as uv coordinates.
*/
const getScreenPosition = /*@__PURE__*/ Fn$1( ( [ viewPosition, projectionMatrix ] ) => {

	const sampleClipPos = projectionMatrix.mul( vec4$1( viewPosition, 1.0 ) );
	const sampleUv = sampleClipPos.xy.div( sampleClipPos.w ).mul( 0.5 ).add( 0.5 ).toVar();
	return vec2$1( sampleUv.x, sampleUv.y.oneMinus() );

} );

/**
* Computes a normal vector based on depth data. Can be used as a fallback when no normal render
* target is available or if flat surface normals are required.
*
* @param {vec2} uv - The texture coordinate.
* @param {DepthTexture} depthTexture - The depth texture.
* @param {mat4} projectionMatrixInverse - The camera's inverse projection matrix.
* @return {vec3} The computed normal vector.
*/
const getNormalFromDepth = /*@__PURE__*/ Fn$1( ( [ uv, depthTexture, projectionMatrixInverse ] ) => {

	const size = textureSize( textureLoad( depthTexture ) );
	const p = ivec2( uv.mul( size ) ).toVar();

	const c0 = textureLoad( depthTexture, p ).toVar();

	const l2 = textureLoad( depthTexture, p.sub( ivec2( 2, 0 ) ) ).toVar();
	const l1 = textureLoad( depthTexture, p.sub( ivec2( 1, 0 ) ) ).toVar();
	const r1 = textureLoad( depthTexture, p.add( ivec2( 1, 0 ) ) ).toVar();
	const r2 = textureLoad( depthTexture, p.add( ivec2( 2, 0 ) ) ).toVar();
	const b2 = textureLoad( depthTexture, p.add( ivec2( 0, 2 ) ) ).toVar();
	const b1 = textureLoad( depthTexture, p.add( ivec2( 0, 1 ) ) ).toVar();
	const t1 = textureLoad( depthTexture, p.sub( ivec2( 0, 1 ) ) ).toVar();
	const t2 = textureLoad( depthTexture, p.sub( ivec2( 0, 2 ) ) ).toVar();

	const dl = abs$1( sub$1( float$1( 2 ).mul( l1 ).sub( l2 ), c0 ) ).toVar();
	const dr = abs$1( sub$1( float$1( 2 ).mul( r1 ).sub( r2 ), c0 ) ).toVar();
	const db = abs$1( sub$1( float$1( 2 ).mul( b1 ).sub( b2 ), c0 ) ).toVar();
	const dt = abs$1( sub$1( float$1( 2 ).mul( t1 ).sub( t2 ), c0 ) ).toVar();

	const ce = getViewPosition( uv, c0, projectionMatrixInverse ).toVar();

	const dpdx = dl.lessThan( dr ).select( ce.sub( getViewPosition( uv.sub( vec2$1( float$1( 1 ).div( size.x ), 0 ) ), l1, projectionMatrixInverse ) ), ce.negate().add( getViewPosition( uv.add( vec2$1( float$1( 1 ).div( size.x ), 0 ) ), r1, projectionMatrixInverse ) ) );
	const dpdy = db.lessThan( dt ).select( ce.sub( getViewPosition( uv.add( vec2$1( 0, float$1( 1 ).div( size.y ) ) ), b1, projectionMatrixInverse ) ), ce.negate().add( getViewPosition( uv.sub( vec2$1( 0, float$1( 1 ).div( size.y ) ) ), t1, projectionMatrixInverse ) ) );

	return normalize$1( cross( dpdx, dpdy ) );

} );

class StorageInstancedBufferAttribute extends InstancedBufferAttribute {

	constructor( array, itemSize, typeClass = Float32Array ) {

		if ( ArrayBuffer.isView( array ) === false ) array = new typeClass( array * itemSize );

		super( array, itemSize );

		this.isStorageInstancedBufferAttribute = true;

	}

}

class StorageBufferAttribute extends BufferAttribute {

	constructor( array, itemSize, typeClass = Float32Array ) {

		if ( ArrayBuffer.isView( array ) === false ) array = new typeClass( array * itemSize );

		super( array, itemSize );

		this.isStorageBufferAttribute = true;

	}

}

class StorageArrayElementNode extends ArrayElementNode {

	static get type() {

		return 'StorageArrayElementNode';

	}

	constructor( storageBufferNode, indexNode ) {

		super( storageBufferNode, indexNode );

		this.isStorageArrayElementNode = true;

	}

	set storageBufferNode( value ) {

		this.node = value;

	}

	get storageBufferNode() {

		return this.node;

	}

	setup( builder ) {

		if ( builder.isAvailable( 'storageBuffer' ) === false ) {

			if ( this.node.isPBO === true ) {

				builder.setupPBO( this.node );

			}

		}

		return super.setup( builder );

	}

	generate( builder, output ) {

		let snippet;

		const isAssignContext = builder.context.assign;

		//

		if ( builder.isAvailable( 'storageBuffer' ) === false ) {

			if ( this.node.isPBO === true && isAssignContext !== true && ( this.node.value.isInstancedBufferAttribute || builder.shaderStage !== 'compute' ) ) {

				snippet = builder.generatePBO( this );

			} else {

				snippet = this.node.build( builder );

			}

		} else {

			snippet = super.generate( builder );

		}

		if ( isAssignContext !== true ) {

			const type = this.getNodeType( builder );

			snippet = builder.format( snippet, type, output );

		}

		return snippet;

	}

}

const storageElement = /*@__PURE__*/ nodeProxy( StorageArrayElementNode );

class StorageBufferNode extends BufferNode {

	static get type() {

		return 'StorageBufferNode';

	}

	constructor( value, bufferType = null, bufferCount = 0 ) {

		if ( bufferType === null && ( value.isStorageBufferAttribute || value.isStorageInstancedBufferAttribute ) ) {

			bufferType = getTypeFromLength( value.itemSize );
			bufferCount = value.count;

		}

		super( value, bufferType, bufferCount );

		this.isStorageBufferNode = true;

		this.access = NodeAccess.READ_WRITE;
		this.isAtomic = false;
		this.isPBO = false;

		this.bufferCount = bufferCount;

		this._attribute = null;
		this._varying = null;

		this.global = true;

		if ( value.isStorageBufferAttribute !== true && value.isStorageInstancedBufferAttribute !== true ) {

			// TOOD: Improve it, possibly adding a new property to the BufferAttribute to identify it as a storage buffer read-only attribute in Renderer

			if ( value.isInstancedBufferAttribute ) value.isStorageInstancedBufferAttribute = true;
			else value.isStorageBufferAttribute = true;

		}

	}

	getHash( builder ) {

		if ( this.bufferCount === 0 ) {

			let bufferData = builder.globalCache.getData( this.value );

			if ( bufferData === undefined ) {

				bufferData = {
					node: this
				};

				builder.globalCache.setData( this.value, bufferData );

			}

			return bufferData.node.uuid;

		}

		return this.uuid;

	}

	getInputType( /*builder*/ ) {

		return this.value.isIndirectStorageBufferAttribute ? 'indirectStorageBuffer' : 'storageBuffer';

	}

	element( indexNode ) {

		return storageElement( this, indexNode );

	}

	setPBO( value ) {

		this.isPBO = value;

		return this;

	}

	getPBO() {

		return this.isPBO;

	}

	setAccess( value ) {

		this.access = value;

		return this;

	}

	toReadOnly() {

		return this.setAccess( NodeAccess.READ_ONLY );

	}

	setAtomic( value ) {

		this.isAtomic = value;

		return this;

	}

	toAtomic() {

		return this.setAtomic( true );

	}

	getAttributeData() {

		if ( this._attribute === null ) {

			this._attribute = bufferAttribute( this.value );
			this._varying = varying( this._attribute );

		}

		return {
			attribute: this._attribute,
			varying: this._varying
		};

	}

	getNodeType( builder ) {

		if ( builder.isAvailable( 'storageBuffer' ) || builder.isAvailable( 'indirectStorageBuffer' ) ) {

			return super.getNodeType( builder );

		}

		const { attribute } = this.getAttributeData();

		return attribute.getNodeType( builder );

	}

	generate( builder ) {

		if ( builder.isAvailable( 'storageBuffer' ) || builder.isAvailable( 'indirectStorageBuffer' ) ) {

			return super.generate( builder );

		}

		const { attribute, varying } = this.getAttributeData();

		const output = varying.build( builder );

		builder.registerTransform( output, attribute );

		return output;

	}

}

const storage = ( value, type, count ) => nodeObject( new StorageBufferNode( value, type, count ) );

const storageObject = ( value, type, count ) => { // @deprecated, r171

	console.warn( 'THREE.TSL: "storageObject()" is deprecated. Use "storage().setPBO( true )" instead.' );

	return storage( value, type, count ).setPBO( true );

};

const attributeArray = ( count, type = 'float' ) => {

	const itemSize = getLengthFromType( type );

	const buffer = new StorageBufferAttribute( count, itemSize );
	const node = storage( buffer, type, count );

	return node;

};


const instancedArray = ( count, type = 'float' ) => {

	const itemSize = getLengthFromType( type );

	const buffer = new StorageInstancedBufferAttribute( count, itemSize );
	const node = storage( buffer, type, count );

	return node;

};

class VertexColorNode extends AttributeNode {

	static get type() {

		return 'VertexColorNode';

	}

	constructor( index = 0 ) {

		super( null, 'vec4' );

		this.isVertexColorNode = true;

		this.index = index;

	}

	getAttributeName( /*builder*/ ) {

		const index = this.index;

		return 'color' + ( index > 0 ? index : '' );

	}

	generate( builder ) {

		const attributeName = this.getAttributeName( builder );
		const geometryAttribute = builder.hasGeometryAttribute( attributeName );

		let result;

		if ( geometryAttribute === true ) {

			result = super.generate( builder );

		} else {

			// Vertex color fallback should be white
			result = builder.generateConst( this.nodeType, new Vector4( 1, 1, 1, 1 ) );

		}

		return result;

	}

	serialize( data ) {

		super.serialize( data );

		data.index = this.index;

	}

	deserialize( data ) {

		super.deserialize( data );

		this.index = data.index;

	}

}

const vertexColor = ( ...params ) => nodeObject( new VertexColorNode( ...params ) );

class PointUVNode extends Node {

	static get type() {

		return 'PointUVNode';

	}

	constructor() {

		super( 'vec2' );

		this.isPointUVNode = true;

	}

	generate( /*builder*/ ) {

		return 'vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y )';

	}

}

const pointUV = /*@__PURE__*/ nodeImmutable( PointUVNode );

const _e1 = /*@__PURE__*/ new Euler();
const _m1 = /*@__PURE__*/ new Matrix4();

class SceneNode extends Node {

	static get type() {

		return 'SceneNode';

	}

	constructor( scope = SceneNode.BACKGROUND_BLURRINESS, scene = null ) {

		super();

		this.scope = scope;
		this.scene = scene;

	}

	setup( builder ) {

		const scope = this.scope;
		const scene = this.scene !== null ? this.scene : builder.scene;

		let output;

		if ( scope === SceneNode.BACKGROUND_BLURRINESS ) {

			output = reference( 'backgroundBlurriness', 'float', scene );

		} else if ( scope === SceneNode.BACKGROUND_INTENSITY ) {

			output = reference( 'backgroundIntensity', 'float', scene );

		} else if ( scope === SceneNode.BACKGROUND_ROTATION ) {

			output = uniform$1( 'mat4' ).label( 'backgroundRotation' ).setGroup( renderGroup ).onRenderUpdate( () => {

				const background = scene.background;

				if ( background !== null && background.isTexture && background.mapping !== UVMapping ) {

					_e1.copy( scene.backgroundRotation );

					// accommodate left-handed frame
					_e1.x *= -1; _e1.y *= -1; _e1.z *= -1;

					_m1.makeRotationFromEuler( _e1 );

				} else {

					_m1.identity();

				}

				return _m1;

			} );

		} else {

			console.error( 'THREE.SceneNode: Unknown scope:', scope );

		}

		return output;

	}

}

SceneNode.BACKGROUND_BLURRINESS = 'backgroundBlurriness';
SceneNode.BACKGROUND_INTENSITY = 'backgroundIntensity';
SceneNode.BACKGROUND_ROTATION = 'backgroundRotation';

const backgroundBlurriness = /*@__PURE__*/ nodeImmutable( SceneNode, SceneNode.BACKGROUND_BLURRINESS );
const backgroundIntensity = /*@__PURE__*/ nodeImmutable( SceneNode, SceneNode.BACKGROUND_INTENSITY );
const backgroundRotation = /*@__PURE__*/ nodeImmutable( SceneNode, SceneNode.BACKGROUND_ROTATION );

class StorageTextureNode extends TextureNode {

	static get type() {

		return 'StorageTextureNode';

	}

	constructor( value, uvNode, storeNode = null ) {

		super( value, uvNode );

		this.storeNode = storeNode;

		this.isStorageTextureNode = true;

		this.access = NodeAccess.WRITE_ONLY;

	}

	getInputType( /*builder*/ ) {

		return 'storageTexture';

	}

	setup( builder ) {

		super.setup( builder );

		const properties = builder.getNodeProperties( this );
		properties.storeNode = this.storeNode;

	}

	setAccess( value ) {

		this.access = value;
		return this;

	}

	generate( builder, output ) {

		let snippet;

		if ( this.storeNode !== null ) {

			snippet = this.generateStore( builder );

		} else {

			snippet = super.generate( builder, output );

		}

		return snippet;

	}

	toReadWrite() {

		return this.setAccess( NodeAccess.READ_WRITE );

	}

	toReadOnly() {

		return this.setAccess( NodeAccess.READ_ONLY );

	}

	toWriteOnly() {

		return this.setAccess( NodeAccess.WRITE_ONLY );

	}

	generateStore( builder ) {

		const properties = builder.getNodeProperties( this );

		const { uvNode, storeNode } = properties;

		const textureProperty = super.generate( builder, 'property' );
		const uvSnippet = uvNode.build( builder, 'uvec2' );
		const storeSnippet = storeNode.build( builder, 'vec4' );

		const snippet = builder.generateTextureStore( builder, textureProperty, uvSnippet, storeSnippet );

		builder.addLineFlowCode( snippet, this );

	}

}

const storageTexture = /*@__PURE__*/ nodeProxy( StorageTextureNode );

const textureStore = ( value, uvNode, storeNode ) => {

	const node = storageTexture( value, uvNode, storeNode );

	if ( storeNode !== null ) node.append();

	return node;

};

class UserDataNode extends ReferenceNode {

	static get type() {

		return 'UserDataNode';

	}

	constructor( property, inputType, userData = null ) {

		super( property, inputType, userData );

		this.userData = userData;

	}

	updateReference( state ) {

		this.reference = this.userData !== null ? this.userData : state.object.userData;

		return this.reference;

	}

}

const userData = ( name, inputType, userData ) => nodeObject( new UserDataNode( name, inputType, userData ) );

const _objectData = new WeakMap();

class VelocityNode extends TempNode {

	static get type() {

		return 'VelocityNode';

	}

	constructor() {

		super( 'vec2' );

		this.projectionMatrix = null;

		this.updateType = NodeUpdateType.OBJECT;
		this.updateAfterType = NodeUpdateType.OBJECT;

		this.previousModelWorldMatrix = uniform$1( new Matrix4() );
		this.previousProjectionMatrix = uniform$1( new Matrix4() ).setGroup( renderGroup );
		this.previousCameraViewMatrix = uniform$1( new Matrix4() );

	}

	setProjectionMatrix( projectionMatrix ) {

		this.projectionMatrix = projectionMatrix;

	}

	update( { frameId, camera, object } ) {

		const previousModelMatrix = getPreviousMatrix( object );

		this.previousModelWorldMatrix.value.copy( previousModelMatrix );

		//

		const cameraData = getData( camera );

		if ( cameraData.frameId !== frameId ) {

			cameraData.frameId = frameId;

			if ( cameraData.previousProjectionMatrix === undefined ) {

				cameraData.previousProjectionMatrix = new Matrix4();
				cameraData.previousCameraViewMatrix = new Matrix4();

				cameraData.currentProjectionMatrix = new Matrix4();
				cameraData.currentCameraViewMatrix = new Matrix4();

				cameraData.previousProjectionMatrix.copy( this.projectionMatrix || camera.projectionMatrix );
				cameraData.previousCameraViewMatrix.copy( camera.matrixWorldInverse );

			} else {

				cameraData.previousProjectionMatrix.copy( cameraData.currentProjectionMatrix );
				cameraData.previousCameraViewMatrix.copy( cameraData.currentCameraViewMatrix );

			}

			cameraData.currentProjectionMatrix.copy( this.projectionMatrix || camera.projectionMatrix );
			cameraData.currentCameraViewMatrix.copy( camera.matrixWorldInverse );

			this.previousProjectionMatrix.value.copy( cameraData.previousProjectionMatrix );
			this.previousCameraViewMatrix.value.copy( cameraData.previousCameraViewMatrix );

		}

	}

	updateAfter( { object } ) {

		getPreviousMatrix( object ).copy( object.matrixWorld );

	}

	setup( /*builder*/ ) {

		const projectionMatrix = ( this.projectionMatrix === null ) ? cameraProjectionMatrix : uniform$1( this.projectionMatrix );

		const previousModelViewMatrix = this.previousCameraViewMatrix.mul( this.previousModelWorldMatrix );

		const clipPositionCurrent = projectionMatrix.mul( modelViewMatrix ).mul( positionLocal$1 );
		const clipPositionPrevious = this.previousProjectionMatrix.mul( previousModelViewMatrix ).mul( positionPrevious );

		const ndcPositionCurrent = clipPositionCurrent.xy.div( clipPositionCurrent.w );
		const ndcPositionPrevious = clipPositionPrevious.xy.div( clipPositionPrevious.w );

		const velocity = sub$1( ndcPositionCurrent, ndcPositionPrevious );

		return velocity;

	}

}

function getData( object ) {

	let objectData = _objectData.get( object );

	if ( objectData === undefined ) {

		objectData = {};
		_objectData.set( object, objectData );

	}

	return objectData;

}

function getPreviousMatrix( object, index = 0 ) {

	const objectData = getData( object );

	let matrix = objectData[ index ];

	if ( matrix === undefined ) {

		objectData[ index ] = matrix = new Matrix4();

	}

	return matrix;

}

const velocity = /*@__PURE__*/ nodeImmutable( VelocityNode );

const blendBurn = /*@__PURE__*/ Fn$1( ( [ base, blend ] ) => {

	return min$1( 1.0, base.oneMinus().div( blend ) ).oneMinus();

} ).setLayout( {
	name: 'blendBurn',
	type: 'vec3',
	inputs: [
		{ name: 'base', type: 'vec3' },
		{ name: 'blend', type: 'vec3' }
	]
} );

const blendDodge = /*@__PURE__*/ Fn$1( ( [ base, blend ] ) => {

	return min$1( base.div( blend.oneMinus() ), 1.0 );

} ).setLayout( {
	name: 'blendDodge',
	type: 'vec3',
	inputs: [
		{ name: 'base', type: 'vec3' },
		{ name: 'blend', type: 'vec3' }
	]
} );

const blendScreen = /*@__PURE__*/ Fn$1( ( [ base, blend ] ) => {

	return base.oneMinus().mul( blend.oneMinus() ).oneMinus();

} ).setLayout( {
	name: 'blendScreen',
	type: 'vec3',
	inputs: [
		{ name: 'base', type: 'vec3' },
		{ name: 'blend', type: 'vec3' }
	]
} );

const blendOverlay = /*@__PURE__*/ Fn$1( ( [ base, blend ] ) => {

	return mix$1( base.mul( 2.0 ).mul( blend ), base.oneMinus().mul( 2.0 ).mul( blend.oneMinus() ).oneMinus(), step( 0.5, base ) );

} ).setLayout( {
	name: 'blendOverlay',
	type: 'vec3',
	inputs: [
		{ name: 'base', type: 'vec3' },
		{ name: 'blend', type: 'vec3' }
	]
} );

const blendColor = /*@__PURE__*/ Fn$1( ( [ base, blend ] ) => {

	const outAlpha = blend.a.add( base.a.mul( blend.a.oneMinus() ) );

	return vec4$1( blend.rgb.mul( blend.a ).add( base.rgb.mul( base.a ).mul( blend.a.oneMinus() ) ).div( outAlpha ), outAlpha );

} ).setLayout( {
	name: 'blendColor',
	type: 'vec4',
	inputs: [
		{ name: 'base', type: 'vec4' },
		{ name: 'blend', type: 'vec4' }
	]
} );

// deprecated

const burn = ( ...params ) => { // @deprecated, r171

	console.warn( 'THREE.TSL: "burn" has been renamed. Use "blendBurn" instead.' );
	return blendBurn( params );

};

const dodge = ( ...params ) => { // @deprecated, r171

	console.warn( 'THREE.TSL: "dodge" has been renamed. Use "blendDodge" instead.' );
	return blendDodge( params );

};

const screen = ( ...params ) => { // @deprecated, r171

	console.warn( 'THREE.TSL: "screen" has been renamed. Use "blendScreen" instead.' );
	return blendScreen( params );

};

const overlay = ( ...params ) => { // @deprecated, r171

	console.warn( 'THREE.TSL: "overlay" has been renamed. Use "blendOverlay" instead.' );
	return blendOverlay( params );

};

const grayscale = /*@__PURE__*/ Fn$1( ( [ color ] ) => {

	return luminance( color.rgb );

} );

const saturation = /*@__PURE__*/ Fn$1( ( [ color, adjustment = float$1( 1 ) ] ) => {

	return adjustment.mix( luminance( color.rgb ), color.rgb );

} );

const vibrance = /*@__PURE__*/ Fn$1( ( [ color, adjustment = float$1( 1 ) ] ) => {

	const average = add$1( color.r, color.g, color.b ).div( 3.0 );

	const mx = color.r.max( color.g.max( color.b ) );
	const amt = mx.sub( average ).mul( adjustment ).mul( -3 );

	return mix$1( color.rgb, mx, amt );

} );

const hue = /*@__PURE__*/ Fn$1( ( [ color, adjustment = float$1( 1 ) ] ) => {

	const k = vec3$1( 0.57735, 0.57735, 0.57735 );

	const cosAngle = adjustment.cos();

	return vec3$1( color.rgb.mul( cosAngle ).add( k.cross( color.rgb ).mul( adjustment.sin() ).add( k.mul( dot$1( k, color.rgb ).mul( cosAngle.oneMinus() ) ) ) ) );

} );

const luminance = (
	color,
	luminanceCoefficients = vec3$1( ColorManagement.getLuminanceCoefficients( new Vector3() ) )
) => dot$1( color, luminanceCoefficients );

const threshold = ( color, threshold ) => mix$1( vec3$1( 0.0 ), color, luminance( color ).sub( threshold ).max( 0 ) );

/**
 * Color Decision List (CDL) v1.2
 *
 * Compact representation of color grading information, defined by slope, offset, power, and
 * saturation. The CDL should be typically be given input in a log space (such as LogC, ACEScc,
 * or AgX Log), and will return output in the same space. Output may require clamping >=0.
 *
 * @param {vec4} color Input (-Infinity < input < +Infinity)
 * @param {number | vec3} slope Slope (0  slope < +Infinity)
 * @param {number | vec3} offset Offset (-Infinity < offset < +Infinity; typically -1 < offset < 1)
 * @param {number | vec3} power Power (0 < power < +Infinity)
 * @param {number} saturation Saturation (0  saturation < +Infinity; typically 0  saturation < 4)
 * @param {vec3} luminanceCoefficients Luminance coefficients for saturation term, typically Rec. 709
 * @return Output, -Infinity < output < +Infinity
 *
 * References:
 * - ASC CDL v1.2
 * - https://blender.stackexchange.com/a/55239/43930
 * - https://docs.acescentral.com/specifications/acescc/
 */
const cdl = /*@__PURE__*/ Fn$1( ( [
	color,
	slope = vec3$1( 1 ),
	offset = vec3$1( 0 ),
	power = vec3$1( 1 ),
	saturation = float$1( 1 ),
	// ASC CDL v1.2 explicitly requires Rec. 709 luminance coefficients.
	luminanceCoefficients = vec3$1( ColorManagement.getLuminanceCoefficients( new Vector3(), LinearSRGBColorSpace ) )
] ) => {

	// NOTE: The ASC CDL v1.2 defines a [0, 1] clamp on the slope+offset term, and another on the
	// saturation term. Per the ACEScc specification and Filament, limits may be omitted to support
	// values outside [0, 1], requiring a workaround for negative values in the power expression.

	const luma = color.rgb.dot( vec3$1( luminanceCoefficients ) );

	const v = max$1( color.rgb.mul( slope ).add( offset ), 0.0 ).toVar();
	const pv = v.pow( power ).toVar();

	If( v.r.greaterThan( 0.0 ), () => { v.r.assign( pv.r ); } ); // eslint-disable-line
	If( v.g.greaterThan( 0.0 ), () => { v.g.assign( pv.g ); } ); // eslint-disable-line
	If( v.b.greaterThan( 0.0 ), () => { v.b.assign( pv.b ); } ); // eslint-disable-line

	v.assign( luma.add( v.sub( luma ).mul( saturation ) ) );

	return vec4$1( v.rgb, color.a );

} );

class PosterizeNode extends TempNode {

	static get type() {

		return 'PosterizeNode';

	}

	constructor( sourceNode, stepsNode ) {

		super();

		this.sourceNode = sourceNode;
		this.stepsNode = stepsNode;

	}

	setup() {

		const { sourceNode, stepsNode } = this;

		return sourceNode.mul( stepsNode ).floor().div( stepsNode );

	}

}

const posterize = /*@__PURE__*/ nodeProxy( PosterizeNode );

const _size = /*@__PURE__*/ new Vector2();

class PassTextureNode extends TextureNode {

	static get type() {

		return 'PassTextureNode';

	}

	constructor( passNode, texture ) {

		super( texture );

		this.passNode = passNode;

		this.setUpdateMatrix( false );

	}

	setup( builder ) {

		if ( builder.object.isQuadMesh ) this.passNode.build( builder );

		return super.setup( builder );

	}

	clone() {

		return new this.constructor( this.passNode, this.value );

	}

}

class PassMultipleTextureNode extends PassTextureNode {

	static get type() {

		return 'PassMultipleTextureNode';

	}

	constructor( passNode, textureName, previousTexture = false ) {

		super( passNode, null );

		this.textureName = textureName;
		this.previousTexture = previousTexture;

	}

	updateTexture() {

		this.value = this.previousTexture ? this.passNode.getPreviousTexture( this.textureName ) : this.passNode.getTexture( this.textureName );

	}

	setup( builder ) {

		this.updateTexture();

		return super.setup( builder );

	}

	clone() {

		return new this.constructor( this.passNode, this.textureName, this.previousTexture );

	}

}

class PassNode extends TempNode {

	static get type() {

		return 'PassNode';

	}

	constructor( scope, scene, camera, options = {} ) {

		super( 'vec4' );

		this.scope = scope;
		this.scene = scene;
		this.camera = camera;
		this.options = options;

		this._pixelRatio = 1;
		this._width = 1;
		this._height = 1;

		const depthTexture = new DepthTexture();
		depthTexture.isRenderTargetTexture = true;
		//depthTexture.type = FloatType;
		depthTexture.name = 'depth';

		const renderTarget = new RenderTarget( this._width * this._pixelRatio, this._height * this._pixelRatio, { type: HalfFloatType, ...options, } );
		renderTarget.texture.name = 'output';
		renderTarget.depthTexture = depthTexture;

		this.renderTarget = renderTarget;

		this.updateBeforeType = NodeUpdateType.FRAME;

		this._textures = {
			output: renderTarget.texture,
			depth: depthTexture
		};

		this._textureNodes = {};
		this._linearDepthNodes = {};
		this._viewZNodes = {};

		this._previousTextures = {};
		this._previousTextureNodes = {};

		this._cameraNear = uniform$1( 0 );
		this._cameraFar = uniform$1( 0 );

		this._mrt = null;

		this.isPassNode = true;

	}

	setMRT( mrt ) {

		this._mrt = mrt;

		return this;

	}

	getMRT() {

		return this._mrt;

	}

	isGlobal() {

		return true;

	}

	getTexture( name ) {

		let texture = this._textures[ name ];

		if ( texture === undefined ) {

			const refTexture = this.renderTarget.texture;

			texture = refTexture.clone();
			texture.isRenderTargetTexture = true;
			texture.name = name;

			this._textures[ name ] = texture;

			this.renderTarget.textures.push( texture );

		}

		return texture;

	}

	getPreviousTexture( name ) {

		let texture = this._previousTextures[ name ];

		if ( texture === undefined ) {

			texture = this.getTexture( name ).clone();
			texture.isRenderTargetTexture = true;

			this._previousTextures[ name ] = texture;

		}

		return texture;

	}

	toggleTexture( name ) {

		const prevTexture = this._previousTextures[ name ];

		if ( prevTexture !== undefined ) {

			const texture = this._textures[ name ];

			const index = this.renderTarget.textures.indexOf( texture );
			this.renderTarget.textures[ index ] = prevTexture;

			this._textures[ name ] = prevTexture;
			this._previousTextures[ name ] = texture;

			this._textureNodes[ name ].updateTexture();
			this._previousTextureNodes[ name ].updateTexture();

		}

	}

	getTextureNode( name = 'output' ) {

		let textureNode = this._textureNodes[ name ];

		if ( textureNode === undefined ) {

			textureNode = nodeObject( new PassMultipleTextureNode( this, name ) );
			textureNode.updateTexture();
			this._textureNodes[ name ] = textureNode;

		}

		return textureNode;

	}

	getPreviousTextureNode( name = 'output' ) {

		let textureNode = this._previousTextureNodes[ name ];

		if ( textureNode === undefined ) {

			if ( this._textureNodes[ name ] === undefined ) this.getTextureNode( name );

			textureNode = nodeObject( new PassMultipleTextureNode( this, name, true ) );
			textureNode.updateTexture();
			this._previousTextureNodes[ name ] = textureNode;

		}

		return textureNode;

	}

	getViewZNode( name = 'depth' ) {

		let viewZNode = this._viewZNodes[ name ];

		if ( viewZNode === undefined ) {

			const cameraNear = this._cameraNear;
			const cameraFar = this._cameraFar;

			this._viewZNodes[ name ] = viewZNode = perspectiveDepthToViewZ( this.getTextureNode( name ), cameraNear, cameraFar );

		}

		return viewZNode;

	}

	getLinearDepthNode( name = 'depth' ) {

		let linearDepthNode = this._linearDepthNodes[ name ];

		if ( linearDepthNode === undefined ) {

			const cameraNear = this._cameraNear;
			const cameraFar = this._cameraFar;
			const viewZNode = this.getViewZNode( name );

			// TODO: just if ( builder.camera.isPerspectiveCamera )

			this._linearDepthNodes[ name ] = linearDepthNode = viewZToOrthographicDepth( viewZNode, cameraNear, cameraFar );

		}

		return linearDepthNode;

	}

	setup( { renderer } ) {

		this.renderTarget.samples = this.options.samples === undefined ? renderer.samples : this.options.samples;

		// Disable MSAA for WebGL backend for now
		if ( renderer.backend.isWebGLBackend === true ) {

			this.renderTarget.samples = 0;

		}

		this.renderTarget.depthTexture.isMultisampleRenderTargetTexture = this.renderTarget.samples > 1;

		return this.scope === PassNode.COLOR ? this.getTextureNode() : this.getLinearDepthNode();

	}

	updateBefore( frame ) {

		const { renderer } = frame;
		const { scene, camera } = this;

		this._pixelRatio = renderer.getPixelRatio();

		const size = renderer.getSize( _size );

		this.setSize( size.width, size.height );

		const currentRenderTarget = renderer.getRenderTarget();
		const currentMRT = renderer.getMRT();

		this._cameraNear.value = camera.near;
		this._cameraFar.value = camera.far;

		for ( const name in this._previousTextures ) {

			this.toggleTexture( name );

		}

		renderer.setRenderTarget( this.renderTarget );
		renderer.setMRT( this._mrt );

		renderer.render( scene, camera );

		renderer.setRenderTarget( currentRenderTarget );
		renderer.setMRT( currentMRT );

	}

	setSize( width, height ) {

		this._width = width;
		this._height = height;

		const effectiveWidth = this._width * this._pixelRatio;
		const effectiveHeight = this._height * this._pixelRatio;

		this.renderTarget.setSize( effectiveWidth, effectiveHeight );

	}

	setPixelRatio( pixelRatio ) {

		this._pixelRatio = pixelRatio;

		this.setSize( this._width, this._height );

	}

	dispose() {

		this.renderTarget.dispose();

	}


}

PassNode.COLOR = 'color';
PassNode.DEPTH = 'depth';

const pass = ( scene, camera, options ) => nodeObject( new PassNode( PassNode.COLOR, scene, camera, options ) );
const passTexture = ( pass, texture ) => nodeObject( new PassTextureNode( pass, texture ) );
const depthPass = ( scene, camera ) => nodeObject( new PassNode( PassNode.DEPTH, scene, camera ) );

class ToonOutlinePassNode extends PassNode {

	static get type() {

		return 'ToonOutlinePassNode';

	}

	constructor( scene, camera, colorNode, thicknessNode, alphaNode ) {

		super( PassNode.COLOR, scene, camera );

		this.colorNode = colorNode;
		this.thicknessNode = thicknessNode;
		this.alphaNode = alphaNode;

		this._materialCache = new WeakMap();

	}

	updateBefore( frame ) {

		const { renderer } = frame;

		const currentRenderObjectFunction = renderer.getRenderObjectFunction();

		renderer.setRenderObjectFunction( ( object, scene, camera, geometry, material, group, lightsNode, clippingContext ) => {

			// only render outline for supported materials

			if ( material.isMeshToonMaterial || material.isMeshToonNodeMaterial ) {

				if ( material.wireframe === false ) {

					const outlineMaterial = this._getOutlineMaterial( material );
					renderer.renderObject( object, scene, camera, geometry, outlineMaterial, group, lightsNode, clippingContext );

				}

			}

			// default

			renderer.renderObject( object, scene, camera, geometry, material, group, lightsNode, clippingContext );

		} );

		super.updateBefore( frame );

		renderer.setRenderObjectFunction( currentRenderObjectFunction );

	}

	_createMaterial() {

		const material = new NodeMaterial();
		material.isMeshToonOutlineMaterial = true;
		material.name = 'Toon_Outline';
		material.side = BackSide;

		// vertex node

		const outlineNormal = normalLocal.negate();
		const mvp = cameraProjectionMatrix.mul( modelViewMatrix );

		const ratio = float$1( 1.0 ); // TODO: support outline thickness ratio for each vertex
		const pos = mvp.mul( vec4$1( positionLocal$1, 1.0 ) );
		const pos2 = mvp.mul( vec4$1( positionLocal$1.add( outlineNormal ), 1.0 ) );
		const norm = normalize$1( pos.sub( pos2 ) ); // NOTE: subtract pos2 from pos because BackSide objectNormal is negative

		material.vertexNode = pos.add( norm.mul( this.thicknessNode ).mul( pos.w ).mul( ratio ) );

		// color node

		material.colorNode = vec4$1( this.colorNode, this.alphaNode );

		return material;

	}

	_getOutlineMaterial( originalMaterial ) {

		let outlineMaterial = this._materialCache.get( originalMaterial );

		if ( outlineMaterial === undefined ) {

			outlineMaterial = this._createMaterial();

			this._materialCache.set( originalMaterial, outlineMaterial );

		}

		return outlineMaterial;

	}

}

const toonOutlinePass = ( scene, camera, color = new Color( 0, 0, 0 ), thickness = 0.003, alpha = 1 ) => nodeObject( new ToonOutlinePassNode( scene, camera, nodeObject( color ), nodeObject( thickness ), nodeObject( alpha ) ) );

// exposure only

const linearToneMapping = /*@__PURE__*/ Fn$1( ( [ color, exposure ] ) => {

	return color.mul( exposure ).clamp();

} ).setLayout( {
	name: 'linearToneMapping',
	type: 'vec3',
	inputs: [
		{ name: 'color', type: 'vec3' },
		{ name: 'exposure', type: 'float' }
	]
} );

// source: https://www.cs.utah.edu/docs/techreports/2002/pdf/UUCS-02-001.pdf

const reinhardToneMapping = /*@__PURE__*/ Fn$1( ( [ color, exposure ] ) => {

	color = color.mul( exposure );

	return color.div( color.add( 1.0 ) ).clamp();

} ).setLayout( {
	name: 'reinhardToneMapping',
	type: 'vec3',
	inputs: [
		{ name: 'color', type: 'vec3' },
		{ name: 'exposure', type: 'float' }
	]
} );

// source: http://filmicworlds.com/blog/filmic-tonemapping-operators/

const cineonToneMapping = /*@__PURE__*/ Fn$1( ( [ color, exposure ] ) => {

	// filmic operator by Jim Hejl and Richard Burgess-Dawson
	color = color.mul( exposure );
	color = color.sub( 0.004 ).max( 0.0 );

	const a = color.mul( color.mul( 6.2 ).add( 0.5 ) );
	const b = color.mul( color.mul( 6.2 ).add( 1.7 ) ).add( 0.06 );

	return a.div( b ).pow( 2.2 );

} ).setLayout( {
	name: 'cineonToneMapping',
	type: 'vec3',
	inputs: [
		{ name: 'color', type: 'vec3' },
		{ name: 'exposure', type: 'float' }
	]
} );

// source: https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs

const RRTAndODTFit = /*@__PURE__*/ Fn$1( ( [ color ] ) => {

	const a = color.mul( color.add( 0.0245786 ) ).sub( 0.000090537 );
	const b = color.mul( color.add( 0.4329510 ).mul( 0.983729 ) ).add( 0.238081 );

	return a.div( b );

} );

// source: https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs

const acesFilmicToneMapping = /*@__PURE__*/ Fn$1( ( [ color, exposure ] ) => {

	// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT
	const ACESInputMat = mat3(
		0.59719, 0.35458, 0.04823,
		0.07600, 0.90834, 0.01566,
		0.02840, 0.13383, 0.83777
	);

	// ODT_SAT => XYZ => D60_2_D65 => sRGB
	const ACESOutputMat = mat3(
		1.60475, -0.53108, -0.07367,
		-0.10208, 1.10813, -605e-5,
		-327e-5, -0.07276, 1.07602
	);

	color = color.mul( exposure ).div( 0.6 );

	color = ACESInputMat.mul( color );

	// Apply RRT and ODT
	color = RRTAndODTFit( color );

	color = ACESOutputMat.mul( color );

	// Clamp to [0, 1]
	return color.clamp();

} ).setLayout( {
	name: 'acesFilmicToneMapping',
	type: 'vec3',
	inputs: [
		{ name: 'color', type: 'vec3' },
		{ name: 'exposure', type: 'float' }
	]
} );

const LINEAR_REC2020_TO_LINEAR_SRGB = /*@__PURE__*/ mat3( vec3$1( 1.6605, -0.1246, -0.0182 ), vec3$1( -0.5876, 1.1329, -0.1006 ), vec3$1( -0.0728, -83e-4, 1.1187 ) );
const LINEAR_SRGB_TO_LINEAR_REC2020 = /*@__PURE__*/ mat3( vec3$1( 0.6274, 0.0691, 0.0164 ), vec3$1( 0.3293, 0.9195, 0.0880 ), vec3$1( 0.0433, 0.0113, 0.8956 ) );

const agxDefaultContrastApprox = /*@__PURE__*/ Fn$1( ( [ x_immutable ] ) => {

	const x = vec3$1( x_immutable ).toVar();
	const x2 = vec3$1( x.mul( x ) ).toVar();
	const x4 = vec3$1( x2.mul( x2 ) ).toVar();

	return float$1( 15.5 ).mul( x4.mul( x2 ) ).sub( mul$1( 40.14, x4.mul( x ) ) ).add( mul$1( 31.96, x4 ).sub( mul$1( 6.868, x2.mul( x ) ) ).add( mul$1( 0.4298, x2 ).add( mul$1( 0.1191, x ).sub( 0.00232 ) ) ) );

} );

const agxToneMapping = /*@__PURE__*/ Fn$1( ( [ color, exposure ] ) => {

	const colortone = vec3$1( color ).toVar();
	const AgXInsetMatrix = mat3( vec3$1( 0.856627153315983, 0.137318972929847, 0.11189821299995 ), vec3$1( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ), vec3$1( 0.0482516061458583, 0.101439036467562, 0.811302368396859 ) );
	const AgXOutsetMatrix = mat3( vec3$1( 1.1271005818144368, -0.1413297634984383, -0.14132976349843826 ), vec3$1( -0.11060664309660323, 1.157823702216272, -0.11060664309660294 ), vec3$1( -0.016493938717834573, -0.016493938717834257, 1.2519364065950405 ) );
	const AgxMinEv = float$1( -12.47393 );
	const AgxMaxEv = float$1( 4.026069 );
	colortone.mulAssign( exposure );
	colortone.assign( LINEAR_SRGB_TO_LINEAR_REC2020.mul( colortone ) );
	colortone.assign( AgXInsetMatrix.mul( colortone ) );
	colortone.assign( max$1( colortone, 1e-10 ) );
	colortone.assign( log2( colortone ) );
	colortone.assign( colortone.sub( AgxMinEv ).div( AgxMaxEv.sub( AgxMinEv ) ) );
	colortone.assign( clamp( colortone, 0.0, 1.0 ) );
	colortone.assign( agxDefaultContrastApprox( colortone ) );
	colortone.assign( AgXOutsetMatrix.mul( colortone ) );
	colortone.assign( pow$1( max$1( vec3$1( 0.0 ), colortone ), vec3$1( 2.2 ) ) );
	colortone.assign( LINEAR_REC2020_TO_LINEAR_SRGB.mul( colortone ) );
	colortone.assign( clamp( colortone, 0.0, 1.0 ) );

	return colortone;

} ).setLayout( {
	name: 'agxToneMapping',
	type: 'vec3',
	inputs: [
		{ name: 'color', type: 'vec3' },
		{ name: 'exposure', type: 'float' }
	]
} );

// https://modelviewer.dev/examples/tone-mapping

const neutralToneMapping = /*@__PURE__*/ Fn$1( ( [ color, exposure ] ) => {

	const StartCompression = float$1( 0.8 - 0.04 );
	const Desaturation = float$1( 0.15 );

	color = color.mul( exposure );

	const x = min$1( color.r, min$1( color.g, color.b ) );
	const offset = select( x.lessThan( 0.08 ), x.sub( mul$1( 6.25, x.mul( x ) ) ), 0.04 );

	color.subAssign( offset );

	const peak = max$1( color.r, max$1( color.g, color.b ) );

	If( peak.lessThan( StartCompression ), () => {

		return color;

	} );

	const d = sub$1( 1, StartCompression );
	const newPeak = sub$1( 1, d.mul( d ).div( peak.add( d.sub( StartCompression ) ) ) );
	color.mulAssign( newPeak.div( peak ) );
	const g = sub$1( 1, div$1( 1, Desaturation.mul( peak.sub( newPeak ) ).add( 1 ) ) );

	return mix$1( color, vec3$1( newPeak ), g );

} ).setLayout( {
	name: 'neutralToneMapping',
	type: 'vec3',
	inputs: [
		{ name: 'color', type: 'vec3' },
		{ name: 'exposure', type: 'float' }
	]
} );

class CodeNode extends Node {

	static get type() {

		return 'CodeNode';

	}

	constructor( code = '', includes = [], language = '' ) {

		super( 'code' );

		this.isCodeNode = true;

		this.code = code;
		this.language = language;

		this.includes = includes;

	}

	isGlobal() {

		return true;

	}

	setIncludes( includes ) {

		this.includes = includes;

		return this;

	}

	getIncludes( /*builder*/ ) {

		return this.includes;

	}

	generate( builder ) {

		const includes = this.getIncludes( builder );

		for ( const include of includes ) {

			include.build( builder );

		}

		const nodeCode = builder.getCodeFromNode( this, this.getNodeType( builder ) );
		nodeCode.code = this.code;

		return nodeCode.code;

	}

	serialize( data ) {

		super.serialize( data );

		data.code = this.code;
		data.language = this.language;

	}

	deserialize( data ) {

		super.deserialize( data );

		this.code = data.code;
		this.language = data.language;

	}

}

const code = /*@__PURE__*/ nodeProxy( CodeNode );

const js = ( src, includes ) => code( src, includes, 'js' );
const wgsl = ( src, includes ) => code( src, includes, 'wgsl' );
const glsl = ( src, includes ) => code( src, includes, 'glsl' );

class FunctionNode extends CodeNode {

	static get type() {

		return 'FunctionNode';

	}

	constructor( code = '', includes = [], language = '' ) {

		super( code, includes, language );

	}

	getNodeType( builder ) {

		return this.getNodeFunction( builder ).type;

	}

	getInputs( builder ) {

		return this.getNodeFunction( builder ).inputs;

	}

	getNodeFunction( builder ) {

		const nodeData = builder.getDataFromNode( this );

		let nodeFunction = nodeData.nodeFunction;

		if ( nodeFunction === undefined ) {

			nodeFunction = builder.parser.parseFunction( this.code );

			nodeData.nodeFunction = nodeFunction;

		}

		return nodeFunction;

	}

	generate( builder, output ) {

		super.generate( builder );

		const nodeFunction = this.getNodeFunction( builder );

		const name = nodeFunction.name;
		const type = nodeFunction.type;

		const nodeCode = builder.getCodeFromNode( this, type );

		if ( name !== '' ) {

			// use a custom property name

			nodeCode.name = name;

		}

		const propertyName = builder.getPropertyName( nodeCode );

		const code = this.getNodeFunction( builder ).getCode( propertyName );

		nodeCode.code = code + '\n';

		if ( output === 'property' ) {

			return propertyName;

		} else {

			return builder.format( `${ propertyName }()`, type, output );

		}

	}

}

const nativeFn = ( code, includes = [], language = '' ) => {

	for ( let i = 0; i < includes.length; i ++ ) {

		const include = includes[ i ];

		// TSL Function: glslFn, wgslFn

		if ( typeof include === 'function' ) {

			includes[ i ] = include.functionNode;

		}

	}

	const functionNode = nodeObject( new FunctionNode( code, includes, language ) );

	const fn = ( ...params ) => functionNode.call( ...params );
	fn.functionNode = functionNode;

	return fn;

};

const glslFn = ( code, includes ) => nativeFn( code, includes, 'glsl' );
const wgslFn = ( code, includes ) => nativeFn( code, includes, 'wgsl' );

class ScriptableValueNode extends Node {

	static get type() {

		return 'ScriptableValueNode';

	}

	constructor( value = null ) {

		super();

		this._value = value;
		this._cache = null;

		this.inputType = null;
		this.outpuType = null;

		this.events = new EventDispatcher();

		this.isScriptableValueNode = true;

	}

	get isScriptableOutputNode() {

		return this.outputType !== null;

	}

	set value( val ) {

		if ( this._value === val ) return;

		if ( this._cache && this.inputType === 'URL' && this.value.value instanceof ArrayBuffer ) {

			URL.revokeObjectURL( this._cache );

			this._cache = null;

		}

		this._value = val;

		this.events.dispatchEvent( { type: 'change' } );

		this.refresh();

	}

	get value() {

		return this._value;

	}

	refresh() {

		this.events.dispatchEvent( { type: 'refresh' } );

	}

	getValue() {

		const value = this.value;

		if ( value && this._cache === null && this.inputType === 'URL' && value.value instanceof ArrayBuffer ) {

			this._cache = URL.createObjectURL( new Blob( [ value.value ] ) );

		} else if ( value && value.value !== null && value.value !== undefined && (
			( ( this.inputType === 'URL' || this.inputType === 'String' ) && typeof value.value === 'string' ) ||
			( this.inputType === 'Number' && typeof value.value === 'number' ) ||
			( this.inputType === 'Vector2' && value.value.isVector2 ) ||
			( this.inputType === 'Vector3' && value.value.isVector3 ) ||
			( this.inputType === 'Vector4' && value.value.isVector4 ) ||
			( this.inputType === 'Color' && value.value.isColor ) ||
			( this.inputType === 'Matrix3' && value.value.isMatrix3 ) ||
			( this.inputType === 'Matrix4' && value.value.isMatrix4 )
		) ) {

			return value.value;

		}

		return this._cache || value;

	}

	getNodeType( builder ) {

		return this.value && this.value.isNode ? this.value.getNodeType( builder ) : 'float';

	}

	setup() {

		return this.value && this.value.isNode ? this.value : float$1();

	}

	serialize( data ) {

		super.serialize( data );

		if ( this.value !== null ) {

			if ( this.inputType === 'ArrayBuffer' ) {

				data.value = arrayBufferToBase64( this.value );

			} else {

				data.value = this.value ? this.value.toJSON( data.meta ).uuid : null;

			}

		} else {

			data.value = null;

		}

		data.inputType = this.inputType;
		data.outputType = this.outputType;

	}

	deserialize( data ) {

		super.deserialize( data );

		let value = null;

		if ( data.value !== null ) {

			if ( data.inputType === 'ArrayBuffer' ) {

				value = base64ToArrayBuffer( data.value );

			} else if ( data.inputType === 'Texture' ) {

				value = data.meta.textures[ data.value ];

			} else {

				value = data.meta.nodes[ data.value ] || null;

			}

		}

		this.value = value;

		this.inputType = data.inputType;
		this.outputType = data.outputType;

	}

}

const scriptableValue = /*@__PURE__*/ nodeProxy( ScriptableValueNode );

class Resources extends Map {

	get( key, callback = null, ...params ) {

		if ( this.has( key ) ) return super.get( key );

		if ( callback !== null ) {

			const value = callback( ...params );
			this.set( key, value );
			return value;

		}

	}

}

class Parameters {

	constructor( scriptableNode ) {

		this.scriptableNode = scriptableNode;

	}

	get parameters() {

		return this.scriptableNode.parameters;

	}

	get layout() {

		return this.scriptableNode.getLayout();

	}

	getInputLayout( id ) {

		return this.scriptableNode.getInputLayout( id );

	}

	get( name ) {

		const param = this.parameters[ name ];
		const value = param ? param.getValue() : null;

		return value;

	}

}

const ScriptableNodeResources = new Resources();

class ScriptableNode extends Node {

	static get type() {

		return 'ScriptableNode';

	}

	constructor( codeNode = null, parameters = {} ) {

		super();

		this.codeNode = codeNode;
		this.parameters = parameters;

		this._local = new Resources();
		this._output = scriptableValue();
		this._outputs = {};
		this._source = this.source;
		this._method = null;
		this._object = null;
		this._value = null;
		this._needsOutputUpdate = true;

		this.onRefresh = this.onRefresh.bind( this );

		this.isScriptableNode = true;

	}

	get source() {

		return this.codeNode ? this.codeNode.code : '';

	}

	setLocal( name, value ) {

		return this._local.set( name, value );

	}

	getLocal( name ) {

		return this._local.get( name );

	}

	onRefresh() {

		this._refresh();

	}

	getInputLayout( id ) {

		for ( const element of this.getLayout() ) {

			if ( element.inputType && ( element.id === id || element.name === id ) ) {

				return element;

			}

		}

	}

	getOutputLayout( id ) {

		for ( const element of this.getLayout() ) {

			if ( element.outputType && ( element.id === id || element.name === id ) ) {

				return element;

			}

		}

	}

	setOutput( name, value ) {

		const outputs = this._outputs;

		if ( outputs[ name ] === undefined ) {

			outputs[ name ] = scriptableValue( value );

		} else {

			outputs[ name ].value = value;

		}

		return this;

	}

	getOutput( name ) {

		return this._outputs[ name ];

	}

	getParameter( name ) {

		return this.parameters[ name ];

	}

	setParameter( name, value ) {

		const parameters = this.parameters;

		if ( value && value.isScriptableNode ) {

			this.deleteParameter( name );

			parameters[ name ] = value;
			parameters[ name ].getDefaultOutput().events.addEventListener( 'refresh', this.onRefresh );

		} else if ( value && value.isScriptableValueNode ) {

			this.deleteParameter( name );

			parameters[ name ] = value;
			parameters[ name ].events.addEventListener( 'refresh', this.onRefresh );

		} else if ( parameters[ name ] === undefined ) {

			parameters[ name ] = scriptableValue( value );
			parameters[ name ].events.addEventListener( 'refresh', this.onRefresh );

		} else {

			parameters[ name ].value = value;

		}

		return this;

	}

	getValue() {

		return this.getDefaultOutput().getValue();

	}

	deleteParameter( name ) {

		let valueNode = this.parameters[ name ];

		if ( valueNode ) {

			if ( valueNode.isScriptableNode ) valueNode = valueNode.getDefaultOutput();

			valueNode.events.removeEventListener( 'refresh', this.onRefresh );

		}

		return this;

	}

	clearParameters() {

		for ( const name of Object.keys( this.parameters ) ) {

			this.deleteParameter( name );

		}

		this.needsUpdate = true;

		return this;

	}

	call( name, ...params ) {

		const object = this.getObject();
		const method = object[ name ];

		if ( typeof method === 'function' ) {

			return method( ...params );

		}

	}

	async callAsync( name, ...params ) {

		const object = this.getObject();
		const method = object[ name ];

		if ( typeof method === 'function' ) {

			return method.constructor.name === 'AsyncFunction' ? await method( ...params ) : method( ...params );

		}

	}

	getNodeType( builder ) {

		return this.getDefaultOutputNode().getNodeType( builder );

	}

	refresh( output = null ) {

		if ( output !== null ) {

			this.getOutput( output ).refresh();

		} else {

			this._refresh();

		}

	}

	getObject() {

		if ( this.needsUpdate ) this.dispose();
		if ( this._object !== null ) return this._object;

		//

		const refresh = () => this.refresh();
		const setOutput = ( id, value ) => this.setOutput( id, value );

		const parameters = new Parameters( this );

		const THREE = ScriptableNodeResources.get( 'THREE' );
		const TSL = ScriptableNodeResources.get( 'TSL' );

		const method = this.getMethod( this.codeNode );
		const params = [ parameters, this._local, ScriptableNodeResources, refresh, setOutput, THREE, TSL ];

		this._object = method( ...params );

		const layout = this._object.layout;

		if ( layout ) {

			if ( layout.cache === false ) {

				this._local.clear();

			}

			// default output
			this._output.outputType = layout.outputType || null;

			if ( Array.isArray( layout.elements ) ) {

				for ( const element of layout.elements ) {

					const id = element.id || element.name;

					if ( element.inputType ) {

						if ( this.getParameter( id ) === undefined ) this.setParameter( id, null );

						this.getParameter( id ).inputType = element.inputType;

					}

					if ( element.outputType ) {

						if ( this.getOutput( id ) === undefined ) this.setOutput( id, null );

						this.getOutput( id ).outputType = element.outputType;

					}

				}

			}

		}

		return this._object;

	}

	deserialize( data ) {

		super.deserialize( data );

		for ( const name in this.parameters ) {

			let valueNode = this.parameters[ name ];

			if ( valueNode.isScriptableNode ) valueNode = valueNode.getDefaultOutput();

			valueNode.events.addEventListener( 'refresh', this.onRefresh );

		}

	}

	getLayout() {

		return this.getObject().layout;

	}

	getDefaultOutputNode() {

		const output = this.getDefaultOutput().value;

		if ( output && output.isNode ) {

			return output;

		}

		return float$1();

	}

	getDefaultOutput()	{

		return this._exec()._output;

	}

	getMethod() {

		if ( this.needsUpdate ) this.dispose();
		if ( this._method !== null ) return this._method;

		//

		const parametersProps = [ 'parameters', 'local', 'global', 'refresh', 'setOutput', 'THREE', 'TSL' ];
		const interfaceProps = [ 'layout', 'init', 'main', 'dispose' ];

		const properties = interfaceProps.join( ', ' );
		const declarations = 'var ' + properties + '; var output = {};\n';
		const returns = '\nreturn { ...output, ' + properties + ' };';

		const code = declarations + this.codeNode.code + returns;

		//

		this._method = new Function( ...parametersProps, code );

		return this._method;

	}

	dispose() {

		if ( this._method === null ) return;

		if ( this._object && typeof this._object.dispose === 'function' ) {

			this._object.dispose();

		}

		this._method = null;
		this._object = null;
		this._source = null;
		this._value = null;
		this._needsOutputUpdate = true;
		this._output.value = null;
		this._outputs = {};

	}

	setup() {

		return this.getDefaultOutputNode();

	}

	getCacheKey( force ) {

		const values = [ hashString( this.source ), this.getDefaultOutputNode().getCacheKey( force ) ];

		for ( const param in this.parameters ) {

			values.push( this.parameters[ param ].getCacheKey( force ) );

		}

		return hashArray( values );

	}

	set needsUpdate( value ) {

		if ( value === true ) this.dispose();

	}

	get needsUpdate() {

		return this.source !== this._source;

	}

	_exec()	{

		if ( this.codeNode === null ) return this;

		if ( this._needsOutputUpdate === true ) {

			this._value = this.call( 'main' );

			this._needsOutputUpdate = false;

		}

		this._output.value = this._value;

		return this;

	}

	_refresh() {

		this.needsUpdate = true;

		this._exec();

		this._output.refresh();

	}

}

const scriptable = /*@__PURE__*/ nodeProxy( ScriptableNode );

class FogNode extends Node {

	static get type() {

		return 'FogNode';

	}

	constructor( colorNode, factorNode ) {

		super( 'float' );

		this.isFogNode = true;

		this.colorNode = colorNode;
		this.factorNode = factorNode;

	}

	getViewZNode( builder ) {

		let viewZ;

		const getViewZ = builder.context.getViewZ;

		if ( getViewZ !== undefined ) {

			viewZ = getViewZ( this );

		}

		return ( viewZ || positionView$1.z ).negate();

	}

	setup() {

		return this.factorNode;

	}

}

const fog = /*@__PURE__*/ nodeProxy( FogNode );

class FogRangeNode extends FogNode {

	static get type() {

		return 'FogRangeNode';

	}

	constructor( colorNode, nearNode, farNode ) {

		super( colorNode );

		this.isFogRangeNode = true;

		this.nearNode = nearNode;
		this.farNode = farNode;

	}

	setup( builder ) {

		const viewZ = this.getViewZNode( builder );

		return smoothstep$1( this.nearNode, this.farNode, viewZ );

	}

}

const rangeFog = /*@__PURE__*/ nodeProxy( FogRangeNode );

class FogExp2Node extends FogNode {

	static get type() {

		return 'FogExp2Node';

	}

	constructor( colorNode, densityNode ) {

		super( colorNode );

		this.isFogExp2Node = true;

		this.densityNode = densityNode;

	}

	setup( builder ) {

		const viewZ = this.getViewZNode( builder );
		const density = this.densityNode;

		return density.mul( density, viewZ, viewZ ).negate().exp().oneMinus();

	}

}

const densityFog = /*@__PURE__*/ nodeProxy( FogExp2Node );

let min = null;
let max$2 = null;

class RangeNode extends Node {

	static get type() {

		return 'RangeNode';

	}

	constructor( minNode = float$1(), maxNode = float$1() ) {

		super();

		this.minNode = minNode;
		this.maxNode = maxNode;

	}

	getVectorLength( builder ) {

		const minLength = builder.getTypeLength( getValueType( this.minNode.value ) );
		const maxLength = builder.getTypeLength( getValueType( this.maxNode.value ) );

		return minLength > maxLength ? minLength : maxLength;

	}

	getNodeType( builder ) {

		return builder.object.count > 1 ? builder.getTypeFromLength( this.getVectorLength( builder ) ) : 'float';

	}

	setup( builder ) {

		const object = builder.object;

		let output = null;

		if ( object.count > 1 ) {

			const minValue = this.minNode.value;
			const maxValue = this.maxNode.value;

			const minLength = builder.getTypeLength( getValueType( minValue ) );
			const maxLength = builder.getTypeLength( getValueType( maxValue ) );

			min = min || new Vector4();
			max$2 = max$2 || new Vector4();

			min.setScalar( 0 );
			max$2.setScalar( 0 );

			if ( minLength === 1 ) min.setScalar( minValue );
			else if ( minValue.isColor ) min.set( minValue.r, minValue.g, minValue.b );
			else min.set( minValue.x, minValue.y, minValue.z || 0, minValue.w || 0 );

			if ( maxLength === 1 ) max$2.setScalar( maxValue );
			else if ( maxValue.isColor ) max$2.set( maxValue.r, maxValue.g, maxValue.b );
			else max$2.set( maxValue.x, maxValue.y, maxValue.z || 0, maxValue.w || 0 );

			const stride = 4;

			const length = stride * object.count;
			const array = new Float32Array( length );

			for ( let i = 0; i < length; i ++ ) {

				const index = i % stride;

				const minElementValue = min.getComponent( index );
				const maxElementValue = max$2.getComponent( index );

				array[ i ] = MathUtils.lerp( minElementValue, maxElementValue, Math.random() );

			}

			const nodeType = this.getNodeType( builder );

			if ( object.count <= 4096 ) {

				output = buffer( array, 'vec4', object.count ).element( instanceIndex ).convert( nodeType );

			} else {

				// TODO: Improve anonymous buffer attribute creation removing this part
				const bufferAttribute = new InstancedBufferAttribute( array, 4 );
				builder.geometry.setAttribute( '__range' + this.id, bufferAttribute );

				output = instancedBufferAttribute( bufferAttribute ).convert( nodeType );

			}

		} else {

			output = float$1( 0 );

		}

		return output;

	}

}

const range = /*@__PURE__*/ nodeProxy( RangeNode );

class ComputeBuiltinNode extends Node {

	static get type() {

		return 'ComputeBuiltinNode';

	}

	constructor( builtinName, nodeType ) {

		super( nodeType );

		this._builtinName = builtinName;

	}

	getHash( builder ) {

		return this.getBuiltinName( builder );

	}

	getNodeType( /*builder*/ ) {

		return this.nodeType;

	}

	setBuiltinName( builtinName ) {

		this._builtinName = builtinName;

		return this;

	}

	getBuiltinName( /*builder*/ ) {

		return this._builtinName;

	}

	hasBuiltin( builder ) {

		builder.hasBuiltin( this._builtinName );

	}

	generate( builder, output ) {

		const builtinName = this.getBuiltinName( builder );
		const nodeType = this.getNodeType( builder );

		if ( builder.shaderStage === 'compute' ) {

			return builder.format( builtinName, nodeType, output );

		} else {

			console.warn( `ComputeBuiltinNode: Compute built-in value ${builtinName} can not be accessed in the ${builder.shaderStage} stage` );
			return builder.generateConst( nodeType );

		}

	}

	serialize( data ) {

		super.serialize( data );

		data.global = this.global;
		data._builtinName = this._builtinName;

	}

	deserialize( data ) {

		super.deserialize( data );

		this.global = data.global;
		this._builtinName = data._builtinName;

	}

}

const computeBuiltin = ( name, nodeType ) => nodeObject( new ComputeBuiltinNode( name, nodeType ) );

const numWorkgroups = /*@__PURE__*/ computeBuiltin( 'numWorkgroups', 'uvec3' );
const workgroupId = /*@__PURE__*/ computeBuiltin( 'workgroupId', 'uvec3' );
const localId = /*@__PURE__*/ computeBuiltin( 'localId', 'uvec3' );
const subgroupSize = /*@__PURE__*/ computeBuiltin( 'subgroupSize', 'uint' );

class BarrierNode extends Node {

	constructor( scope ) {

		super();

		this.scope = scope;

	}

	generate( builder ) {

		const { scope } = this;
		const { renderer } = builder;

		if ( renderer.backend.isWebGLBackend === true ) {

			builder.addFlowCode( `\t// ${scope}Barrier \n` );

		} else {

			builder.addLineFlowCode( `${scope}Barrier()`, this );

		}

	}

}

const barrier = nodeProxy( BarrierNode );

const workgroupBarrier = () => barrier( 'workgroup' ).append();
const storageBarrier = () => barrier( 'storage' ).append();
const textureBarrier = () => barrier( 'texture' ).append();

class WorkgroupInfoElementNode extends ArrayElementNode {

	constructor( workgroupInfoNode, indexNode ) {

		super( workgroupInfoNode, indexNode );

		this.isWorkgroupInfoElementNode = true;

	}

	generate( builder, output ) {

		let snippet;

		const isAssignContext = builder.context.assign;
		snippet = super.generate( builder );

		if ( isAssignContext !== true ) {

			const type = this.getNodeType( builder );

			snippet = builder.format( snippet, type, output );

		}

		// TODO: Possibly activate clip distance index on index access rather than from clipping context

		return snippet;

	}

}


class WorkgroupInfoNode extends Node {

	constructor( scope, bufferType, bufferCount = 0 ) {

		super( bufferType );

		this.bufferType = bufferType;
		this.bufferCount = bufferCount;

		this.isWorkgroupInfoNode = true;

		this.scope = scope;

	}

	label( name ) {

		this.name = name;

		return this;

	}

	getHash() {

		return this.uuid;

	}

	setScope( scope ) {

		this.scope = scope;

		return this;

	}

	getInputType( /*builder*/ ) {

		return `${this.scope}Array`;

	}

	element( indexNode ) {

		return nodeObject( new WorkgroupInfoElementNode( this, indexNode ) );

	}

	generate( builder ) {

		return builder.getScopedArray( this.name || `${this.scope}Array_${this.id}`, this.scope.toLowerCase(), this.bufferType, this.bufferCount );

	}

}

const workgroupArray = ( type, count ) => nodeObject( new WorkgroupInfoNode( 'Workgroup', type, count ) );

class AtomicFunctionNode extends TempNode {

	static get type() {

		return 'AtomicFunctionNode';

	}

	constructor( method, pointerNode, valueNode, storeNode = null ) {

		super( 'uint' );

		this.method = method;

		this.pointerNode = pointerNode;
		this.valueNode = valueNode;
		this.storeNode = storeNode;

	}

	getInputType( builder ) {

		return this.pointerNode.getNodeType( builder );

	}

	getNodeType( builder ) {

		return this.getInputType( builder );

	}

	generate( builder ) {

		const method = this.method;

		const type = this.getNodeType( builder );
		const inputType = this.getInputType( builder );

		const a = this.pointerNode;
		const b = this.valueNode;

		const params = [];

		params.push( `&${ a.build( builder, inputType ) }` );
		params.push( b.build( builder, inputType ) );

		const methodSnippet = `${ builder.getMethod( method, type ) }( ${params.join( ', ' )} )`;

		if ( this.storeNode !== null ) {

			const varSnippet = this.storeNode.build( builder, inputType );

			builder.addLineFlowCode( `${varSnippet} = ${methodSnippet}`, this );

		} else {

			builder.addLineFlowCode( methodSnippet, this );

		}

	}

}

AtomicFunctionNode.ATOMIC_LOAD = 'atomicLoad';
AtomicFunctionNode.ATOMIC_STORE = 'atomicStore';
AtomicFunctionNode.ATOMIC_ADD = 'atomicAdd';
AtomicFunctionNode.ATOMIC_SUB = 'atomicSub';
AtomicFunctionNode.ATOMIC_MAX = 'atomicMax';
AtomicFunctionNode.ATOMIC_MIN = 'atomicMin';
AtomicFunctionNode.ATOMIC_AND = 'atomicAnd';
AtomicFunctionNode.ATOMIC_OR = 'atomicOr';
AtomicFunctionNode.ATOMIC_XOR = 'atomicXor';

const atomicNode = nodeProxy( AtomicFunctionNode );

const atomicFunc = ( method, pointerNode, valueNode, storeNode ) => {

	const node = atomicNode( method, pointerNode, valueNode, storeNode );
	node.append();

	return node;

};

const atomicStore = ( pointerNode, valueNode, storeNode = null ) => atomicFunc( AtomicFunctionNode.ATOMIC_STORE, pointerNode, valueNode, storeNode );
const atomicAdd = ( pointerNode, valueNode, storeNode = null ) => atomicFunc( AtomicFunctionNode.ATOMIC_ADD, pointerNode, valueNode, storeNode );
const atomicSub = ( pointerNode, valueNode, storeNode = null ) => atomicFunc( AtomicFunctionNode.ATOMIC_SUB, pointerNode, valueNode, storeNode );
const atomicMax = ( pointerNode, valueNode, storeNode = null ) => atomicFunc( AtomicFunctionNode.ATOMIC_MAX, pointerNode, valueNode, storeNode );
const atomicMin = ( pointerNode, valueNode, storeNode = null ) => atomicFunc( AtomicFunctionNode.ATOMIC_MIN, pointerNode, valueNode, storeNode );
const atomicAnd = ( pointerNode, valueNode, storeNode = null ) => atomicFunc( AtomicFunctionNode.ATOMIC_AND, pointerNode, valueNode, storeNode );
const atomicOr = ( pointerNode, valueNode, storeNode = null ) => atomicFunc( AtomicFunctionNode.ATOMIC_OR, pointerNode, valueNode, storeNode );
const atomicXor = ( pointerNode, valueNode, storeNode = null ) => atomicFunc( AtomicFunctionNode.ATOMIC_XOR, pointerNode, valueNode, storeNode );

let uniformsLib;

function getLightData( light ) {

	uniformsLib = uniformsLib || new WeakMap();

	let uniforms = uniformsLib.get( light );

	if ( uniforms === undefined ) uniformsLib.set( light, uniforms = {} );

	return uniforms;

}

function lightShadowMatrix( light ) {

	const data = getLightData( light );

	return data.shadowMatrix || ( data.shadowMatrix = uniform$1( 'mat4' ).setGroup( renderGroup ).onRenderUpdate( () => {

		light.shadow.updateMatrices( light );

		return light.shadow.matrix;

	} ) );

}

function lightProjectionUV( light ) {

	const data = getLightData( light );

	if ( data.projectionUV === undefined ) {

		const spotLightCoord = lightShadowMatrix( light ).mul( positionWorld$1 );

		data.projectionUV = spotLightCoord.xyz.div( spotLightCoord.w );


	}

	return data.projectionUV;

}

function lightPosition( light ) {

	const data = getLightData( light );

	return data.position || ( data.position = uniform$1( new Vector3() ).setGroup( renderGroup ).onRenderUpdate( ( _, self ) => self.value.setFromMatrixPosition( light.matrixWorld ) ) );

}

function lightTargetPosition( light ) {

	const data = getLightData( light );

	return data.targetPosition || ( data.targetPosition = uniform$1( new Vector3() ).setGroup( renderGroup ).onRenderUpdate( ( _, self ) => self.value.setFromMatrixPosition( light.target.matrixWorld ) ) );

}

function lightViewPosition( light ) {

	const data = getLightData( light );

	return data.viewPosition || ( data.viewPosition = uniform$1( new Vector3() ).setGroup( renderGroup ).onRenderUpdate( ( { camera }, self ) => {

		self.value = self.value || new Vector3();
		self.value.setFromMatrixPosition( light.matrixWorld );

		self.value.applyMatrix4( camera.matrixWorldInverse );

	} ) );

}

const lightTargetDirection = ( light ) => cameraViewMatrix.transformDirection( lightPosition( light ).sub( lightTargetPosition( light ) ) );

const sortLights = ( lights ) => {

	return lights.sort( ( a, b ) => a.id - b.id );

};

const getLightNodeById = ( id, lightNodes ) => {

	for ( const lightNode of lightNodes ) {

		if ( lightNode.isAnalyticLightNode && lightNode.light.id === id ) {

			return lightNode;

		}

	}

	return null;

};

const _lightsNodeRef = /*@__PURE__*/ new WeakMap();

class LightsNode extends Node {

	static get type() {

		return 'LightsNode';

	}

	constructor() {

		super( 'vec3' );

		this.totalDiffuseNode = vec3$1().toVar( 'totalDiffuse' );
		this.totalSpecularNode = vec3$1().toVar( 'totalSpecular' );

		this.outgoingLightNode = vec3$1().toVar( 'outgoingLight' );

		this._lights = [];

		this._lightNodes = null;
		this._lightNodesHash = null;

		this.global = true;

	}

	getHash( builder ) {

		if ( this._lightNodesHash === null ) {

			if ( this._lightNodes === null ) this.setupLightsNode( builder );

			const hash = [];

			for ( const lightNode of this._lightNodes ) {

				hash.push( lightNode.getSelf().getHash() );

			}

			this._lightNodesHash = 'lights-' + hash.join( ',' );

		}

		return this._lightNodesHash;

	}

	analyze( builder ) {

		const properties = builder.getDataFromNode( this );

		for ( const node of properties.nodes ) {

			node.build( builder );

		}

	}

	setupLightsNode( builder ) {

		const lightNodes = [];

		const previousLightNodes = this._lightNodes;

		const lights = sortLights( this._lights );
		const nodeLibrary = builder.renderer.library;

		for ( const light of lights ) {

			if ( light.isNode ) {

				lightNodes.push( nodeObject( light ) );

			} else {

				let lightNode = null;

				if ( previousLightNodes !== null ) {

					lightNode = getLightNodeById( light.id, previousLightNodes ); // resuse existing light node

				}

				if ( lightNode === null ) {

					const lightNodeClass = nodeLibrary.getLightNodeClass( light.constructor );

					if ( lightNodeClass === null ) {

						console.warn( `LightsNode.setupNodeLights: Light node not found for ${ light.constructor.name }` );
						continue;

					}

					let lightNode = null;

					if ( ! _lightsNodeRef.has( light ) ) {

						lightNode = nodeObject( new lightNodeClass( light ) );
						_lightsNodeRef.set( light, lightNode );

					} else {

						lightNode = _lightsNodeRef.get( light );

					}

					lightNodes.push( lightNode );

				}

			}

		}

		this._lightNodes = lightNodes;

	}

	setupLights( builder, lightNodes ) {

		for ( const lightNode of lightNodes ) {

			lightNode.build( builder );

		}

	}

	setup( builder ) {

		if ( this._lightNodes === null ) this.setupLightsNode( builder );

		const context = builder.context;
		const lightingModel = context.lightingModel;

		let outgoingLightNode = this.outgoingLightNode;

		if ( lightingModel ) {

			const { _lightNodes, totalDiffuseNode, totalSpecularNode } = this;

			context.outgoingLight = outgoingLightNode;

			const stack = builder.addStack();

			//

			const properties = builder.getDataFromNode( this );
			properties.nodes = stack.nodes;

			//

			lightingModel.start( context, stack, builder );

			// lights

			this.setupLights( builder, _lightNodes );

			//

			lightingModel.indirect( context, stack, builder );

			//

			const { backdrop, backdropAlpha } = context;
			const { directDiffuse, directSpecular, indirectDiffuse, indirectSpecular } = context.reflectedLight;

			let totalDiffuse = directDiffuse.add( indirectDiffuse );

			if ( backdrop !== null ) {

				if ( backdropAlpha !== null ) {

					totalDiffuse = vec3$1( backdropAlpha.mix( totalDiffuse, backdrop ) );

				} else {

					totalDiffuse = vec3$1( backdrop );

				}

				context.material.transparent = true;

			}

			totalDiffuseNode.assign( totalDiffuse );
			totalSpecularNode.assign( directSpecular.add( indirectSpecular ) );

			outgoingLightNode.assign( totalDiffuseNode.add( totalSpecularNode ) );

			//

			lightingModel.finish( context, stack, builder );

			//

			outgoingLightNode = outgoingLightNode.bypass( builder.removeStack() );

		}

		return outgoingLightNode;

	}

	setLights( lights ) {

		this._lights = lights;

		this._lightNodes = null;
		this._lightNodesHash = null;

		return this;

	}

	getLights() {

		return this._lights;

	}

	get hasLights() {

		return this._lights.length > 0;

	}

}

const lights = ( lights = [] ) => nodeObject( new LightsNode() ).setLights( lights );

const shadowMaterialLib = /*@__PURE__*/ new WeakMap();
const shadowWorldPosition = /*@__PURE__*/ vec3$1().toVar( 'shadowWorldPosition' );

const linearDistance = /*@__PURE__*/ Fn$1( ( [ position, cameraNear, cameraFar ] ) => {

	let dist = positionWorld$1.sub( position ).length();
	dist = dist.sub( cameraNear ).div( cameraFar.sub( cameraNear ) );
	dist = dist.saturate(); // clamp to [ 0, 1 ]

	return dist;

} );

const linearShadowDistance = ( light ) => {

	const camera = light.shadow.camera;

	const nearDistance = reference( 'near', 'float', camera ).setGroup( renderGroup );
	const farDistance = reference( 'far', 'float', camera ).setGroup( renderGroup );

	const referencePosition = objectPosition( light );

	return linearDistance( referencePosition, nearDistance, farDistance );

};

const getShadowMaterial = ( light ) => {

	let material = shadowMaterialLib.get( light );

	if ( material === undefined ) {

		const depthNode = light.isPointLight ? linearShadowDistance( light ) : null;

		material = new NodeMaterial();
		material.colorNode = vec4$1( 0, 0, 0, 1 );
		material.depthNode = depthNode;
		material.isShadowNodeMaterial = true; // Use to avoid other overrideMaterial override material.colorNode unintentionally when using material.shadowNode
		material.blending = NoBlending;
		material.name = 'ShadowMaterial';

		shadowMaterialLib.set( light, material );

	}

	return material;

};

const BasicShadowFilter = /*@__PURE__*/ Fn$1( ( { depthTexture, shadowCoord } ) => {

	return texture( depthTexture, shadowCoord.xy ).compare( shadowCoord.z );

} );

const PCFShadowFilter = /*@__PURE__*/ Fn$1( ( { depthTexture, shadowCoord, shadow } ) => {

	const depthCompare = ( uv, compare ) => texture( depthTexture, uv ).compare( compare );

	const mapSize = reference( 'mapSize', 'vec2', shadow ).setGroup( renderGroup );
	const radius = reference( 'radius', 'float', shadow ).setGroup( renderGroup );

	const texelSize = vec2$1( 1 ).div( mapSize );
	const dx0 = texelSize.x.negate().mul( radius );
	const dy0 = texelSize.y.negate().mul( radius );
	const dx1 = texelSize.x.mul( radius );
	const dy1 = texelSize.y.mul( radius );
	const dx2 = dx0.div( 2 );
	const dy2 = dy0.div( 2 );
	const dx3 = dx1.div( 2 );
	const dy3 = dy1.div( 2 );

	return add$1(
		depthCompare( shadowCoord.xy.add( vec2$1( dx0, dy0 ) ), shadowCoord.z ),
		depthCompare( shadowCoord.xy.add( vec2$1( 0, dy0 ) ), shadowCoord.z ),
		depthCompare( shadowCoord.xy.add( vec2$1( dx1, dy0 ) ), shadowCoord.z ),
		depthCompare( shadowCoord.xy.add( vec2$1( dx2, dy2 ) ), shadowCoord.z ),
		depthCompare( shadowCoord.xy.add( vec2$1( 0, dy2 ) ), shadowCoord.z ),
		depthCompare( shadowCoord.xy.add( vec2$1( dx3, dy2 ) ), shadowCoord.z ),
		depthCompare( shadowCoord.xy.add( vec2$1( dx0, 0 ) ), shadowCoord.z ),
		depthCompare( shadowCoord.xy.add( vec2$1( dx2, 0 ) ), shadowCoord.z ),
		depthCompare( shadowCoord.xy, shadowCoord.z ),
		depthCompare( shadowCoord.xy.add( vec2$1( dx3, 0 ) ), shadowCoord.z ),
		depthCompare( shadowCoord.xy.add( vec2$1( dx1, 0 ) ), shadowCoord.z ),
		depthCompare( shadowCoord.xy.add( vec2$1( dx2, dy3 ) ), shadowCoord.z ),
		depthCompare( shadowCoord.xy.add( vec2$1( 0, dy3 ) ), shadowCoord.z ),
		depthCompare( shadowCoord.xy.add( vec2$1( dx3, dy3 ) ), shadowCoord.z ),
		depthCompare( shadowCoord.xy.add( vec2$1( dx0, dy1 ) ), shadowCoord.z ),
		depthCompare( shadowCoord.xy.add( vec2$1( 0, dy1 ) ), shadowCoord.z ),
		depthCompare( shadowCoord.xy.add( vec2$1( dx1, dy1 ) ), shadowCoord.z )
	).mul( 1 / 17 );

} );

const PCFSoftShadowFilter = /*@__PURE__*/ Fn$1( ( { depthTexture, shadowCoord, shadow } ) => {

	const depthCompare = ( uv, compare ) => texture( depthTexture, uv ).compare( compare );

	const mapSize = reference( 'mapSize', 'vec2', shadow ).setGroup( renderGroup );

	const texelSize = vec2$1( 1 ).div( mapSize );
	const dx = texelSize.x;
	const dy = texelSize.y;

	const uv = shadowCoord.xy;
	const f = fract$1( uv.mul( mapSize ).add( 0.5 ) );
	uv.subAssign( f.mul( texelSize ) );

	return add$1(
		depthCompare( uv, shadowCoord.z ),
		depthCompare( uv.add( vec2$1( dx, 0 ) ), shadowCoord.z ),
		depthCompare( uv.add( vec2$1( 0, dy ) ), shadowCoord.z ),
		depthCompare( uv.add( texelSize ), shadowCoord.z ),
		mix$1(
			depthCompare( uv.add( vec2$1( dx.negate(), 0 ) ), shadowCoord.z ),
			depthCompare( uv.add( vec2$1( dx.mul( 2 ), 0 ) ), shadowCoord.z ),
			f.x
		),
		mix$1(
			depthCompare( uv.add( vec2$1( dx.negate(), dy ) ), shadowCoord.z ),
			depthCompare( uv.add( vec2$1( dx.mul( 2 ), dy ) ), shadowCoord.z ),
			f.x
		),
		mix$1(
			depthCompare( uv.add( vec2$1( 0, dy.negate() ) ), shadowCoord.z ),
			depthCompare( uv.add( vec2$1( 0, dy.mul( 2 ) ) ), shadowCoord.z ),
			f.y
		),
		mix$1(
			depthCompare( uv.add( vec2$1( dx, dy.negate() ) ), shadowCoord.z ),
			depthCompare( uv.add( vec2$1( dx, dy.mul( 2 ) ) ), shadowCoord.z ),
			f.y
		),
		mix$1(
			mix$1(
				depthCompare( uv.add( vec2$1( dx.negate(), dy.negate() ) ), shadowCoord.z ),
				depthCompare( uv.add( vec2$1( dx.mul( 2 ), dy.negate() ) ), shadowCoord.z ),
				f.x
			),
			mix$1(
				depthCompare( uv.add( vec2$1( dx.negate(), dy.mul( 2 ) ) ), shadowCoord.z ),
				depthCompare( uv.add( vec2$1( dx.mul( 2 ), dy.mul( 2 ) ) ), shadowCoord.z ),
				f.x
			),
			f.y
		)
	).mul( 1 / 9 );

} );

// VSM

const VSMShadowFilter = /*@__PURE__*/ Fn$1( ( { depthTexture, shadowCoord } ) => {

	const occlusion = float$1( 1 ).toVar();

	const distribution = texture( depthTexture ).uv( shadowCoord.xy ).rg;

	const hardShadow = step( shadowCoord.z, distribution.x );

	If( hardShadow.notEqual( float$1( 1.0 ) ), () => {

		const distance = shadowCoord.z.sub( distribution.x );
		const variance = max$1( 0, distribution.y.mul( distribution.y ) );
		let softnessProbability = variance.div( variance.add( distance.mul( distance ) ) ); // Chebeyshevs inequality
		softnessProbability = clamp( sub$1( softnessProbability, 0.3 ).div( 0.95 - 0.3 ) );
		occlusion.assign( clamp( max$1( hardShadow, softnessProbability ) ) );

	} );

	return occlusion;

} );

const VSMPassVertical = /*@__PURE__*/ Fn$1( ( { samples, radius, size, shadowPass } ) => {

	const mean = float$1( 0 ).toVar();
	const squaredMean = float$1( 0 ).toVar();

	const uvStride = samples.lessThanEqual( float$1( 1 ) ).select( float$1( 0 ), float$1( 2 ).div( samples.sub( 1 ) ) );
	const uvStart = samples.lessThanEqual( float$1( 1 ) ).select( float$1( 0 ), float$1( -1 ) );

	Loop( { start: int( 0 ), end: int( samples ), type: 'int', condition: '<' }, ( { i } ) => {

		const uvOffset = uvStart.add( float$1( i ).mul( uvStride ) );

		const depth = shadowPass.uv( add$1( screenCoordinate.xy, vec2$1( 0, uvOffset ).mul( radius ) ).div( size ) ).x;
		mean.addAssign( depth );
		squaredMean.addAssign( depth.mul( depth ) );

	} );

	mean.divAssign( samples );
	squaredMean.divAssign( samples );

	const std_dev = sqrt( squaredMean.sub( mean.mul( mean ) ) );
	return vec2$1( mean, std_dev );

} );

const VSMPassHorizontal = /*@__PURE__*/ Fn$1( ( { samples, radius, size, shadowPass } ) => {

	const mean = float$1( 0 ).toVar();
	const squaredMean = float$1( 0 ).toVar();

	const uvStride = samples.lessThanEqual( float$1( 1 ) ).select( float$1( 0 ), float$1( 2 ).div( samples.sub( 1 ) ) );
	const uvStart = samples.lessThanEqual( float$1( 1 ) ).select( float$1( 0 ), float$1( -1 ) );

	Loop( { start: int( 0 ), end: int( samples ), type: 'int', condition: '<' }, ( { i } ) => {

		const uvOffset = uvStart.add( float$1( i ).mul( uvStride ) );

		const distribution = shadowPass.uv( add$1( screenCoordinate.xy, vec2$1( uvOffset, 0 ).mul( radius ) ).div( size ) );
		mean.addAssign( distribution.x );
		squaredMean.addAssign( add$1( distribution.y.mul( distribution.y ), distribution.x.mul( distribution.x ) ) );

	} );

	mean.divAssign( samples );
	squaredMean.divAssign( samples );

	const std_dev = sqrt( squaredMean.sub( mean.mul( mean ) ) );
	return vec2$1( mean, std_dev );

} );

const _shadowFilterLib = [ BasicShadowFilter, PCFShadowFilter, PCFSoftShadowFilter, VSMShadowFilter ];

//

const _quadMesh$1 = /*@__PURE__*/ new QuadMesh();

class ShadowNode extends Node {

	static get type() {

		return 'ShadowNode';

	}

	constructor( light, shadow = null ) {

		super();

		this.light = light;
		this.shadow = shadow || light.shadow;

		this.shadowMap = null;

		this.vsmShadowMapVertical = null;
		this.vsmShadowMapHorizontal = null;

		this.vsmMaterialVertical = null;
		this.vsmMaterialHorizontal = null;

		this.updateBeforeType = NodeUpdateType.RENDER;
		this._node = null;

		this.isShadowNode = true;

	}

	setupShadowFilter( builder, { filterFn, depthTexture, shadowCoord, shadow } ) {

		const frustumTest = shadowCoord.x.greaterThanEqual( 0 )
			.and( shadowCoord.x.lessThanEqual( 1 ) )
			.and( shadowCoord.y.greaterThanEqual( 0 ) )
			.and( shadowCoord.y.lessThanEqual( 1 ) )
			.and( shadowCoord.z.lessThanEqual( 1 ) );

		const shadowNode = filterFn( { depthTexture, shadowCoord, shadow } );

		return frustumTest.select( shadowNode, float$1( 1 ) );

	}

	setupShadowCoord( builder, shadowPosition ) {

		const { shadow } = this;
		const { renderer } = builder;

		const bias = reference( 'bias', 'float', shadow ).setGroup( renderGroup );

		let shadowCoord = shadowPosition;
		let coordZ;

		if ( shadow.camera.isOrthographicCamera || renderer.logarithmicDepthBuffer !== true ) {

			shadowCoord = shadowCoord.xyz.div( shadowCoord.w );

			coordZ = shadowCoord.z;

			if ( renderer.coordinateSystem === WebGPUCoordinateSystem ) {

				coordZ = coordZ.mul( 2 ).sub( 1 ); // WebGPU: Conversion [ 0, 1 ] to [ - 1, 1 ]

			}

		} else {

			const w = shadowCoord.w;
			shadowCoord = shadowCoord.xy.div( w ); // <-- Only divide X/Y coords since we don't need Z

			// The normally available "cameraNear" and "cameraFar" nodes cannot be used here because they do not get
			// updated to use the shadow camera. So, we have to declare our own "local" ones here.
			// TODO: How do we get the cameraNear/cameraFar nodes to use the shadow camera so we don't have to declare local ones here?
			const cameraNearLocal = reference( 'near', 'float', shadow.camera ).setGroup( renderGroup );
			const cameraFarLocal = reference( 'far', 'float', shadow.camera ).setGroup( renderGroup );

			coordZ = viewZToLogarithmicDepth( w.negate(), cameraNearLocal, cameraFarLocal );

		}

		shadowCoord = vec3$1(
			shadowCoord.x,
			shadowCoord.y.oneMinus(), // follow webgpu standards
			coordZ.add( bias )
		);

		return shadowCoord;

	}

	getShadowFilterFn( type ) {

		return _shadowFilterLib[ type ];

	}

	setupShadow( builder ) {

		const { renderer } = builder;

		const { light, shadow } = this;

		const shadowMapType = renderer.shadowMap.type;

		const depthTexture = new DepthTexture( shadow.mapSize.width, shadow.mapSize.height );
		depthTexture.compareFunction = LessCompare;

		const shadowMap = builder.createRenderTarget( shadow.mapSize.width, shadow.mapSize.height );
		shadowMap.depthTexture = depthTexture;

		shadow.camera.updateProjectionMatrix();

		// VSM

		if ( shadowMapType === VSMShadowMap ) {

			depthTexture.compareFunction = null; // VSM does not use textureSampleCompare()/texture2DCompare()

			this.vsmShadowMapVertical = builder.createRenderTarget( shadow.mapSize.width, shadow.mapSize.height, { format: RGFormat, type: HalfFloatType } );
			this.vsmShadowMapHorizontal = builder.createRenderTarget( shadow.mapSize.width, shadow.mapSize.height, { format: RGFormat, type: HalfFloatType } );

			const shadowPassVertical = texture( depthTexture );
			const shadowPassHorizontal = texture( this.vsmShadowMapVertical.texture );

			const samples = reference( 'blurSamples', 'float', shadow ).setGroup( renderGroup );
			const radius = reference( 'radius', 'float', shadow ).setGroup( renderGroup );
			const size = reference( 'mapSize', 'vec2', shadow ).setGroup( renderGroup );

			let material = this.vsmMaterialVertical || ( this.vsmMaterialVertical = new NodeMaterial() );
			material.fragmentNode = VSMPassVertical( { samples, radius, size, shadowPass: shadowPassVertical } ).context( builder.getSharedContext() );
			material.name = 'VSMVertical';

			material = this.vsmMaterialHorizontal || ( this.vsmMaterialHorizontal = new NodeMaterial() );
			material.fragmentNode = VSMPassHorizontal( { samples, radius, size, shadowPass: shadowPassHorizontal } ).context( builder.getSharedContext() );
			material.name = 'VSMHorizontal';

		}

		//

		const shadowIntensity = reference( 'intensity', 'float', shadow ).setGroup( renderGroup );
		const normalBias = reference( 'normalBias', 'float', shadow ).setGroup( renderGroup );

		const shadowPosition = lightShadowMatrix( light ).mul( shadowWorldPosition.add( transformedNormalWorld.mul( normalBias ) ) );
		const shadowCoord = this.setupShadowCoord( builder, shadowPosition );

		//

		const filterFn = shadow.filterNode || this.getShadowFilterFn( renderer.shadowMap.type ) || null;

		if ( filterFn === null ) {

			throw new Error( 'THREE.WebGPURenderer: Shadow map type not supported yet.' );

		}

		const shadowDepthTexture = ( shadowMapType === VSMShadowMap ) ? this.vsmShadowMapHorizontal.texture : depthTexture;

		const shadowNode = this.setupShadowFilter( builder, { filterFn, shadowTexture: shadowMap.texture, depthTexture: shadowDepthTexture, shadowCoord, shadow } );

		const shadowColor = texture( shadowMap.texture, shadowCoord );
		const shadowOutput = mix$1( 1, shadowNode.rgb.mix( shadowColor, 1 ), shadowIntensity.mul( shadowColor.a ) ).toVar();

		this.shadowMap = shadowMap;
		this.shadow.map = shadowMap;

		return shadowOutput;

	}

	setup( builder ) {

		if ( builder.renderer.shadowMap.enabled === false ) return;

		return Fn$1( ( { material } ) => {

			shadowWorldPosition.assign( material.shadowPositionNode || positionWorld$1 );

			let node = this._node;

			if ( node === null ) {

				this._node = node = this.setupShadow( builder );

			}

			if ( builder.material.shadowNode ) { // @deprecated, r171

				console.warn( 'THREE.NodeMaterial: ".shadowNode" is deprecated. Use ".castShadowNode" instead.' );

			}

			if ( builder.material.receivedShadowNode ) {

				node = builder.material.receivedShadowNode( node );

			}

			return node;

		} )();

	}

	renderShadow( frame ) {

		const { shadow, shadowMap } = this;
		const { renderer, scene } = frame;

		shadowMap.setSize( shadow.mapSize.width, shadow.mapSize.height );

		renderer.render( scene, shadow.camera );

	}

	updateShadow( frame ) {

		const { shadowMap, light, shadow } = this;
		const { renderer, scene, camera } = frame;

		const shadowType = renderer.shadowMap.type;

		const depthVersion = shadowMap.depthTexture.version;
		this._depthVersionCached = depthVersion;

		const currentOverrideMaterial = scene.overrideMaterial;

		scene.overrideMaterial = getShadowMaterial( light );

		shadow.camera.layers.mask = camera.layers.mask;

		const currentRenderTarget = renderer.getRenderTarget();
		const currentRenderObjectFunction = renderer.getRenderObjectFunction();
		const currentMRT = renderer.getMRT();

		renderer.setMRT( null );

		renderer.setRenderObjectFunction( ( object, ...params ) => {

			if ( object.castShadow === true || ( object.receiveShadow && shadowType === VSMShadowMap ) ) {

				renderer.renderObject( object, ...params );

			}

		} );

		renderer.setRenderTarget( shadowMap );

		this.renderShadow( frame );

		renderer.setRenderObjectFunction( currentRenderObjectFunction );

		// vsm blur pass

		if ( light.isPointLight !== true && shadowType === VSMShadowMap ) {

			this.vsmPass( renderer );

		}

		renderer.setRenderTarget( currentRenderTarget );

		renderer.setMRT( currentMRT );

		scene.overrideMaterial = currentOverrideMaterial;

	}

	vsmPass( renderer ) {

		const { shadow } = this;

		this.vsmShadowMapVertical.setSize( shadow.mapSize.width, shadow.mapSize.height );
		this.vsmShadowMapHorizontal.setSize( shadow.mapSize.width, shadow.mapSize.height );

		renderer.setRenderTarget( this.vsmShadowMapVertical );
		_quadMesh$1.material = this.vsmMaterialVertical;
		_quadMesh$1.render( renderer );

		renderer.setRenderTarget( this.vsmShadowMapHorizontal );
		_quadMesh$1.material = this.vsmMaterialHorizontal;
		_quadMesh$1.render( renderer );

	}

	dispose() {

		this.shadowMap.dispose();
		this.shadowMap = null;

		if ( this.vsmShadowMapVertical !== null ) {

			this.vsmShadowMapVertical.dispose();
			this.vsmShadowMapVertical = null;

			this.vsmMaterialVertical.dispose();
			this.vsmMaterialVertical = null;

		}

		if ( this.vsmShadowMapHorizontal !== null ) {

			this.vsmShadowMapHorizontal.dispose();
			this.vsmShadowMapHorizontal = null;

			this.vsmMaterialHorizontal.dispose();
			this.vsmMaterialHorizontal = null;

		}

		this.updateBeforeType = NodeUpdateType.NONE;

	}

	updateBefore( frame ) {

		const { shadow } = this;

		const needsUpdate = shadow.needsUpdate || shadow.autoUpdate;

		if ( needsUpdate ) {

			this.updateShadow( frame );

			if ( this.shadowMap.depthTexture.version === this._depthVersionCached ) {

				shadow.needsUpdate = false;

			}

		}

	}

}

const shadow = ( light, shadow ) => nodeObject( new ShadowNode( light, shadow ) );

class AnalyticLightNode extends LightingNode {

	static get type() {

		return 'AnalyticLightNode';

	}

	constructor( light = null ) {

		super();

		this.light = light;

		this.color = new Color();
		this.colorNode = ( light && light.colorNode ) || uniform$1( this.color ).setGroup( renderGroup );

		this.baseColorNode = null;

		this.shadowNode = null;
		this.shadowColorNode = null;

		this.isAnalyticLightNode = true;

		this.updateType = NodeUpdateType.FRAME;

	}

	getCacheKey() {

		return hash$1( super.getCacheKey(), this.light.id, this.light.castShadow ? 1 : 0 );

	}

	getHash() {

		return this.light.uuid;

	}

	setupShadowNode() {

		return shadow( this.light );

	}

	setupShadow( builder ) {

		const { renderer } = builder;

		if ( renderer.shadowMap.enabled === false ) return;

		let shadowColorNode = this.shadowColorNode;

		if ( shadowColorNode === null ) {

			const customShadowNode = this.light.shadow.shadowNode;

			let shadowNode;

			if ( customShadowNode !== undefined ) {

				shadowNode = nodeObject( customShadowNode );

			} else {

				shadowNode = this.setupShadowNode( builder );

			}

			this.shadowNode = shadowNode;

			this.shadowColorNode = shadowColorNode = this.colorNode.mul( shadowNode );

			this.baseColorNode = this.colorNode;

		}

		//

		this.colorNode = shadowColorNode;

	}

	setup( builder ) {

		this.colorNode = this.baseColorNode || this.colorNode;

		if ( this.light.castShadow ) {

			if ( builder.object.receiveShadow ) {

				this.setupShadow( builder );

			}

		} else if ( this.shadowNode !== null ) {

			this.shadowNode.dispose();
			this.shadowNode = null;
			this.shadowColorNode = null;

		}

	}

	update( /*frame*/ ) {

		const { light } = this;

		this.color.copy( light.color ).multiplyScalar( light.intensity );

	}

}

const getDistanceAttenuation = /*@__PURE__*/ Fn$1( ( inputs ) => {

	const { lightDistance, cutoffDistance, decayExponent } = inputs;

	// based upon Frostbite 3 Moving to Physically-based Rendering
	// page 32, equation 26: E[window1]
	// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
	const distanceFalloff = lightDistance.pow( decayExponent ).max( 0.01 ).reciprocal();

	return cutoffDistance.greaterThan( 0 ).select(
		distanceFalloff.mul( lightDistance.div( cutoffDistance ).pow4().oneMinus().clamp().pow2() ),
		distanceFalloff
	);

} ); // validated

const _clearColor$2 = /*@__PURE__*/ new Color();

// cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D
// vector suitable for 2D texture mapping. This code uses the following layout for the
// 2D texture:
//
// xzXZ
//  y Y
//
// Y - Positive y direction
// y - Negative y direction
// X - Positive x direction
// x - Negative x direction
// Z - Positive z direction
// z - Negative z direction
//
// Source and test bed:
// https://gist.github.com/tschw/da10c43c467ce8afd0c4

const cubeToUV = /*@__PURE__*/ Fn$1( ( [ pos, texelSizeY ] ) => {

	const v = pos.toVar();

	// Number of texels to avoid at the edge of each square

	const absV = abs$1( v );

	// Intersect unit cube

	const scaleToCube = div$1( 1.0, max$1( absV.x, max$1( absV.y, absV.z ) ) );
	absV.mulAssign( scaleToCube );

	// Apply scale to avoid seams

	// two texels less per square (one texel will do for NEAREST)
	v.mulAssign( scaleToCube.mul( texelSizeY.mul( 2 ).oneMinus() ) );

	// Unwrap

	// space: -1 ... 1 range for each square
	//
	// #X##		dim    := ( 4 , 2 )
	//  # #		center := ( 1 , 1 )

	const planar = vec2$1( v.xy ).toVar();

	const almostATexel = texelSizeY.mul( 1.5 );
	const almostOne = almostATexel.oneMinus();

	If( absV.z.greaterThanEqual( almostOne ), () => {

		If( v.z.greaterThan( 0.0 ), () => {

			planar.x.assign( sub$1( 4.0, v.x ) );

		} );

	} ).ElseIf( absV.x.greaterThanEqual( almostOne ), () => {

		const signX = sign( v.x );
		planar.x.assign( v.z.mul( signX ).add( signX.mul( 2.0 ) ) );

	} ).ElseIf( absV.y.greaterThanEqual( almostOne ), () => {

		const signY = sign( v.y );
		planar.x.assign( v.x.add( signY.mul( 2.0 ) ).add( 2.0 ) );
		planar.y.assign( v.z.mul( signY ).sub( 2.0 ) );

	} );

	// Transform to UV space

	// scale := 0.5 / dim
	// translate := ( center + 0.5 ) / dim
	return vec2$1( 0.125, 0.25 ).mul( planar ).add( vec2$1( 0.375, 0.75 ) ).flipY();

} ).setLayout( {
	name: 'cubeToUV',
	type: 'vec2',
	inputs: [
		{ name: 'pos', type: 'vec3' },
		{ name: 'texelSizeY', type: 'float' }
	]
} );

const BasicPointShadowFilter = /*@__PURE__*/ Fn$1( ( { depthTexture, bd3D, dp, texelSize } ) => {

	return texture( depthTexture, cubeToUV( bd3D, texelSize.y ) ).compare( dp );

} );

const PointShadowFilter = /*@__PURE__*/ Fn$1( ( { depthTexture, bd3D, dp, texelSize, shadow } ) => {

	const radius = reference( 'radius', 'float', shadow ).setGroup( renderGroup );
	const offset = vec2$1( -1, 1.0 ).mul( radius ).mul( texelSize.y );

	return texture( depthTexture, cubeToUV( bd3D.add( offset.xyy ), texelSize.y ) ).compare( dp )
		.add( texture( depthTexture, cubeToUV( bd3D.add( offset.yyy ), texelSize.y ) ).compare( dp ) )
		.add( texture( depthTexture, cubeToUV( bd3D.add( offset.xyx ), texelSize.y ) ).compare( dp ) )
		.add( texture( depthTexture, cubeToUV( bd3D.add( offset.yyx ), texelSize.y ) ).compare( dp ) )
		.add( texture( depthTexture, cubeToUV( bd3D, texelSize.y ) ).compare( dp ) )
		.add( texture( depthTexture, cubeToUV( bd3D.add( offset.xxy ), texelSize.y ) ).compare( dp ) )
		.add( texture( depthTexture, cubeToUV( bd3D.add( offset.yxy ), texelSize.y ) ).compare( dp ) )
		.add( texture( depthTexture, cubeToUV( bd3D.add( offset.xxx ), texelSize.y ) ).compare( dp ) )
		.add( texture( depthTexture, cubeToUV( bd3D.add( offset.yxx ), texelSize.y ) ).compare( dp ) )
		.mul( 1.0 / 9.0 );

} );

const pointShadowFilter = /*@__PURE__*/ Fn$1( ( { filterFn, depthTexture, shadowCoord, shadow } ) => {

	// for point lights, the uniform @vShadowCoord is re-purposed to hold
	// the vector from the light to the world-space position of the fragment.
	const lightToPosition = shadowCoord.xyz.toVar();
	const lightToPositionLength = lightToPosition.length();

	const cameraNearLocal = uniform$1( 'float' ).setGroup( renderGroup ).onRenderUpdate( () => shadow.camera.near );
	const cameraFarLocal = uniform$1( 'float' ).setGroup( renderGroup ).onRenderUpdate( () => shadow.camera.far );
	const bias = reference( 'bias', 'float', shadow ).setGroup( renderGroup );
	const mapSize = uniform$1( shadow.mapSize ).setGroup( renderGroup );

	const result = float$1( 1.0 ).toVar();

	If( lightToPositionLength.sub( cameraFarLocal ).lessThanEqual( 0.0 ).and( lightToPositionLength.sub( cameraNearLocal ).greaterThanEqual( 0.0 ) ), () => {

		// dp = normalized distance from light to fragment position
		const dp = lightToPositionLength.sub( cameraNearLocal ).div( cameraFarLocal.sub( cameraNearLocal ) ).toVar(); // need to clamp?
		dp.addAssign( bias );

		// bd3D = base direction 3D
		const bd3D = lightToPosition.normalize();
		const texelSize = vec2$1( 1.0 ).div( mapSize.mul( vec2$1( 4.0, 2.0 ) ) );

		// percentage-closer filtering
		result.assign( filterFn( { depthTexture, bd3D, dp, texelSize, shadow } ) );

	} );

	return result;

} );

const _viewport = /*@__PURE__*/ new Vector4();
const _viewportSize = /*@__PURE__*/ new Vector2();
const _shadowMapSize = /*@__PURE__*/ new Vector2();

//

class PointShadowNode extends ShadowNode {

	static get type() {

		return 'PointShadowNode';

	}

	constructor( light, shadow = null ) {

		super( light, shadow );

	}

	getShadowFilterFn( type ) {

		return type === BasicShadowMap ? BasicPointShadowFilter : PointShadowFilter;

	}

	setupShadowCoord( builder, shadowPosition ) {

		return shadowPosition;

	}

	setupShadowFilter( builder, { filterFn, shadowTexture, depthTexture, shadowCoord, shadow } ) {

		return pointShadowFilter( { filterFn, shadowTexture, depthTexture, shadowCoord, shadow } );

	}

	renderShadow( frame ) {

		const { shadow, shadowMap, light } = this;
		const { renderer, scene } = frame;

		const shadowFrameExtents = shadow.getFrameExtents();

		_shadowMapSize.copy( shadow.mapSize );
		_shadowMapSize.multiply( shadowFrameExtents );

		shadowMap.setSize( _shadowMapSize.width, _shadowMapSize.height );

		_viewportSize.copy( shadow.mapSize );

		//

		const previousAutoClear = renderer.autoClear;

		const previousClearColor = renderer.getClearColor( _clearColor$2 );
		const previousClearAlpha = renderer.getClearAlpha();

		renderer.autoClear = false;
		renderer.setClearColor( shadow.clearColor, shadow.clearAlpha );
		renderer.clear();

		const viewportCount = shadow.getViewportCount();

		for ( let vp = 0; vp < viewportCount; vp ++ ) {

			const viewport = shadow.getViewport( vp );

			const x = _viewportSize.x * viewport.x;
			const y = _shadowMapSize.y - _viewportSize.y - ( _viewportSize.y * viewport.y );

			_viewport.set(
				x,
				y,
				_viewportSize.x * viewport.z,
				_viewportSize.y * viewport.w
			);

			shadowMap.viewport.copy( _viewport );

			shadow.updateMatrices( light, vp );

			renderer.render( scene, shadow.camera );

		}

		//

		renderer.autoClear = previousAutoClear;
		renderer.setClearColor( previousClearColor, previousClearAlpha );

	}

}

const pointShadow = ( light, shadow ) => nodeObject( new PointShadowNode( light, shadow ) );

const directPointLight = Fn$1( ( { color, lightViewPosition, cutoffDistance, decayExponent }, builder ) => {

	const lightingModel = builder.context.lightingModel;

	const lVector = lightViewPosition.sub( positionView$1 ); // @TODO: Add it into LightNode

	const lightDirection = lVector.normalize();
	const lightDistance = lVector.length();

	const lightAttenuation = getDistanceAttenuation( {
		lightDistance,
		cutoffDistance,
		decayExponent
	} );

	const lightColor = color.mul( lightAttenuation );

	const reflectedLight = builder.context.reflectedLight;

	lightingModel.direct( {
		lightDirection,
		lightColor,
		reflectedLight
	}, builder.stack, builder );

} );

class PointLightNode extends AnalyticLightNode {

	static get type() {

		return 'PointLightNode';

	}

	constructor( light = null ) {

		super( light );

		this.cutoffDistanceNode = uniform$1( 0 ).setGroup( renderGroup );
		this.decayExponentNode = uniform$1( 0 ).setGroup( renderGroup );

	}

	update( frame ) {

		const { light } = this;

		super.update( frame );

		this.cutoffDistanceNode.value = light.distance;
		this.decayExponentNode.value = light.decay;

	}

	setupShadowNode() {

		return pointShadow( this.light );

	}

	setup( builder ) {

		super.setup( builder );

		directPointLight( {
			color: this.colorNode,
			lightViewPosition: lightViewPosition( this.light ),
			cutoffDistance: this.cutoffDistanceNode,
			decayExponent: this.decayExponentNode
		} ).append();

	}

}

const checker = /*@__PURE__*/ Fn$1( ( [ coord = uv$1() ] ) => {

	const uv = coord.mul( 2.0 );

	const cx = uv.x.floor();
	const cy = uv.y.floor();
	const result = cx.add( cy ).mod( 2.0 );

	return result.sign();

} );

// Three.js Transpiler
// https://raw.githubusercontent.com/AcademySoftwareFoundation/MaterialX/main/libraries/stdlib/genglsl/lib/mx_noise.glsl



const mx_select = /*@__PURE__*/ Fn$1( ( [ b_immutable, t_immutable, f_immutable ] ) => {

	const f = float$1( f_immutable ).toVar();
	const t = float$1( t_immutable ).toVar();
	const b = bool( b_immutable ).toVar();

	return select( b, t, f );

} ).setLayout( {
	name: 'mx_select',
	type: 'float',
	inputs: [
		{ name: 'b', type: 'bool' },
		{ name: 't', type: 'float' },
		{ name: 'f', type: 'float' }
	]
} );

const mx_negate_if = /*@__PURE__*/ Fn$1( ( [ val_immutable, b_immutable ] ) => {

	const b = bool( b_immutable ).toVar();
	const val = float$1( val_immutable ).toVar();

	return select( b, val.negate(), val );

} ).setLayout( {
	name: 'mx_negate_if',
	type: 'float',
	inputs: [
		{ name: 'val', type: 'float' },
		{ name: 'b', type: 'bool' }
	]
} );

const mx_floor = /*@__PURE__*/ Fn$1( ( [ x_immutable ] ) => {

	const x = float$1( x_immutable ).toVar();

	return int( floor$1( x ) );

} ).setLayout( {
	name: 'mx_floor',
	type: 'int',
	inputs: [
		{ name: 'x', type: 'float' }
	]
} );

const mx_floorfrac = /*@__PURE__*/ Fn$1( ( [ x_immutable, i ] ) => {

	const x = float$1( x_immutable ).toVar();
	i.assign( mx_floor( x ) );

	return x.sub( float$1( i ) );

} );

const mx_bilerp_0 = /*@__PURE__*/ Fn$1( ( [ v0_immutable, v1_immutable, v2_immutable, v3_immutable, s_immutable, t_immutable ] ) => {

	const t = float$1( t_immutable ).toVar();
	const s = float$1( s_immutable ).toVar();
	const v3 = float$1( v3_immutable ).toVar();
	const v2 = float$1( v2_immutable ).toVar();
	const v1 = float$1( v1_immutable ).toVar();
	const v0 = float$1( v0_immutable ).toVar();
	const s1 = float$1( sub$1( 1.0, s ) ).toVar();

	return sub$1( 1.0, t ).mul( v0.mul( s1 ).add( v1.mul( s ) ) ).add( t.mul( v2.mul( s1 ).add( v3.mul( s ) ) ) );

} ).setLayout( {
	name: 'mx_bilerp_0',
	type: 'float',
	inputs: [
		{ name: 'v0', type: 'float' },
		{ name: 'v1', type: 'float' },
		{ name: 'v2', type: 'float' },
		{ name: 'v3', type: 'float' },
		{ name: 's', type: 'float' },
		{ name: 't', type: 'float' }
	]
} );

const mx_bilerp_1 = /*@__PURE__*/ Fn$1( ( [ v0_immutable, v1_immutable, v2_immutable, v3_immutable, s_immutable, t_immutable ] ) => {

	const t = float$1( t_immutable ).toVar();
	const s = float$1( s_immutable ).toVar();
	const v3 = vec3$1( v3_immutable ).toVar();
	const v2 = vec3$1( v2_immutable ).toVar();
	const v1 = vec3$1( v1_immutable ).toVar();
	const v0 = vec3$1( v0_immutable ).toVar();
	const s1 = float$1( sub$1( 1.0, s ) ).toVar();

	return sub$1( 1.0, t ).mul( v0.mul( s1 ).add( v1.mul( s ) ) ).add( t.mul( v2.mul( s1 ).add( v3.mul( s ) ) ) );

} ).setLayout( {
	name: 'mx_bilerp_1',
	type: 'vec3',
	inputs: [
		{ name: 'v0', type: 'vec3' },
		{ name: 'v1', type: 'vec3' },
		{ name: 'v2', type: 'vec3' },
		{ name: 'v3', type: 'vec3' },
		{ name: 's', type: 'float' },
		{ name: 't', type: 'float' }
	]
} );

const mx_bilerp = /*@__PURE__*/ overloadingFn( [ mx_bilerp_0, mx_bilerp_1 ] );

const mx_trilerp_0 = /*@__PURE__*/ Fn$1( ( [ v0_immutable, v1_immutable, v2_immutable, v3_immutable, v4_immutable, v5_immutable, v6_immutable, v7_immutable, s_immutable, t_immutable, r_immutable ] ) => {

	const r = float$1( r_immutable ).toVar();
	const t = float$1( t_immutable ).toVar();
	const s = float$1( s_immutable ).toVar();
	const v7 = float$1( v7_immutable ).toVar();
	const v6 = float$1( v6_immutable ).toVar();
	const v5 = float$1( v5_immutable ).toVar();
	const v4 = float$1( v4_immutable ).toVar();
	const v3 = float$1( v3_immutable ).toVar();
	const v2 = float$1( v2_immutable ).toVar();
	const v1 = float$1( v1_immutable ).toVar();
	const v0 = float$1( v0_immutable ).toVar();
	const s1 = float$1( sub$1( 1.0, s ) ).toVar();
	const t1 = float$1( sub$1( 1.0, t ) ).toVar();
	const r1 = float$1( sub$1( 1.0, r ) ).toVar();

	return r1.mul( t1.mul( v0.mul( s1 ).add( v1.mul( s ) ) ).add( t.mul( v2.mul( s1 ).add( v3.mul( s ) ) ) ) ).add( r.mul( t1.mul( v4.mul( s1 ).add( v5.mul( s ) ) ).add( t.mul( v6.mul( s1 ).add( v7.mul( s ) ) ) ) ) );

} ).setLayout( {
	name: 'mx_trilerp_0',
	type: 'float',
	inputs: [
		{ name: 'v0', type: 'float' },
		{ name: 'v1', type: 'float' },
		{ name: 'v2', type: 'float' },
		{ name: 'v3', type: 'float' },
		{ name: 'v4', type: 'float' },
		{ name: 'v5', type: 'float' },
		{ name: 'v6', type: 'float' },
		{ name: 'v7', type: 'float' },
		{ name: 's', type: 'float' },
		{ name: 't', type: 'float' },
		{ name: 'r', type: 'float' }
	]
} );

const mx_trilerp_1 = /*@__PURE__*/ Fn$1( ( [ v0_immutable, v1_immutable, v2_immutable, v3_immutable, v4_immutable, v5_immutable, v6_immutable, v7_immutable, s_immutable, t_immutable, r_immutable ] ) => {

	const r = float$1( r_immutable ).toVar();
	const t = float$1( t_immutable ).toVar();
	const s = float$1( s_immutable ).toVar();
	const v7 = vec3$1( v7_immutable ).toVar();
	const v6 = vec3$1( v6_immutable ).toVar();
	const v5 = vec3$1( v5_immutable ).toVar();
	const v4 = vec3$1( v4_immutable ).toVar();
	const v3 = vec3$1( v3_immutable ).toVar();
	const v2 = vec3$1( v2_immutable ).toVar();
	const v1 = vec3$1( v1_immutable ).toVar();
	const v0 = vec3$1( v0_immutable ).toVar();
	const s1 = float$1( sub$1( 1.0, s ) ).toVar();
	const t1 = float$1( sub$1( 1.0, t ) ).toVar();
	const r1 = float$1( sub$1( 1.0, r ) ).toVar();

	return r1.mul( t1.mul( v0.mul( s1 ).add( v1.mul( s ) ) ).add( t.mul( v2.mul( s1 ).add( v3.mul( s ) ) ) ) ).add( r.mul( t1.mul( v4.mul( s1 ).add( v5.mul( s ) ) ).add( t.mul( v6.mul( s1 ).add( v7.mul( s ) ) ) ) ) );

} ).setLayout( {
	name: 'mx_trilerp_1',
	type: 'vec3',
	inputs: [
		{ name: 'v0', type: 'vec3' },
		{ name: 'v1', type: 'vec3' },
		{ name: 'v2', type: 'vec3' },
		{ name: 'v3', type: 'vec3' },
		{ name: 'v4', type: 'vec3' },
		{ name: 'v5', type: 'vec3' },
		{ name: 'v6', type: 'vec3' },
		{ name: 'v7', type: 'vec3' },
		{ name: 's', type: 'float' },
		{ name: 't', type: 'float' },
		{ name: 'r', type: 'float' }
	]
} );

const mx_trilerp = /*@__PURE__*/ overloadingFn( [ mx_trilerp_0, mx_trilerp_1 ] );

const mx_gradient_float_0 = /*@__PURE__*/ Fn$1( ( [ hash_immutable, x_immutable, y_immutable ] ) => {

	const y = float$1( y_immutable ).toVar();
	const x = float$1( x_immutable ).toVar();
	const hash = uint( hash_immutable ).toVar();
	const h = uint( hash.bitAnd( uint( 7 ) ) ).toVar();
	const u = float$1( mx_select( h.lessThan( uint( 4 ) ), x, y ) ).toVar();
	const v = float$1( mul$1( 2.0, mx_select( h.lessThan( uint( 4 ) ), y, x ) ) ).toVar();

	return mx_negate_if( u, bool( h.bitAnd( uint( 1 ) ) ) ).add( mx_negate_if( v, bool( h.bitAnd( uint( 2 ) ) ) ) );

} ).setLayout( {
	name: 'mx_gradient_float_0',
	type: 'float',
	inputs: [
		{ name: 'hash', type: 'uint' },
		{ name: 'x', type: 'float' },
		{ name: 'y', type: 'float' }
	]
} );

const mx_gradient_float_1 = /*@__PURE__*/ Fn$1( ( [ hash_immutable, x_immutable, y_immutable, z_immutable ] ) => {

	const z = float$1( z_immutable ).toVar();
	const y = float$1( y_immutable ).toVar();
	const x = float$1( x_immutable ).toVar();
	const hash = uint( hash_immutable ).toVar();
	const h = uint( hash.bitAnd( uint( 15 ) ) ).toVar();
	const u = float$1( mx_select( h.lessThan( uint( 8 ) ), x, y ) ).toVar();
	const v = float$1( mx_select( h.lessThan( uint( 4 ) ), y, mx_select( h.equal( uint( 12 ) ).or( h.equal( uint( 14 ) ) ), x, z ) ) ).toVar();

	return mx_negate_if( u, bool( h.bitAnd( uint( 1 ) ) ) ).add( mx_negate_if( v, bool( h.bitAnd( uint( 2 ) ) ) ) );

} ).setLayout( {
	name: 'mx_gradient_float_1',
	type: 'float',
	inputs: [
		{ name: 'hash', type: 'uint' },
		{ name: 'x', type: 'float' },
		{ name: 'y', type: 'float' },
		{ name: 'z', type: 'float' }
	]
} );

const mx_gradient_float = /*@__PURE__*/ overloadingFn( [ mx_gradient_float_0, mx_gradient_float_1 ] );

const mx_gradient_vec3_0 = /*@__PURE__*/ Fn$1( ( [ hash_immutable, x_immutable, y_immutable ] ) => {

	const y = float$1( y_immutable ).toVar();
	const x = float$1( x_immutable ).toVar();
	const hash = uvec3( hash_immutable ).toVar();

	return vec3$1( mx_gradient_float( hash.x, x, y ), mx_gradient_float( hash.y, x, y ), mx_gradient_float( hash.z, x, y ) );

} ).setLayout( {
	name: 'mx_gradient_vec3_0',
	type: 'vec3',
	inputs: [
		{ name: 'hash', type: 'uvec3' },
		{ name: 'x', type: 'float' },
		{ name: 'y', type: 'float' }
	]
} );

const mx_gradient_vec3_1 = /*@__PURE__*/ Fn$1( ( [ hash_immutable, x_immutable, y_immutable, z_immutable ] ) => {

	const z = float$1( z_immutable ).toVar();
	const y = float$1( y_immutable ).toVar();
	const x = float$1( x_immutable ).toVar();
	const hash = uvec3( hash_immutable ).toVar();

	return vec3$1( mx_gradient_float( hash.x, x, y, z ), mx_gradient_float( hash.y, x, y, z ), mx_gradient_float( hash.z, x, y, z ) );

} ).setLayout( {
	name: 'mx_gradient_vec3_1',
	type: 'vec3',
	inputs: [
		{ name: 'hash', type: 'uvec3' },
		{ name: 'x', type: 'float' },
		{ name: 'y', type: 'float' },
		{ name: 'z', type: 'float' }
	]
} );

const mx_gradient_vec3 = /*@__PURE__*/ overloadingFn( [ mx_gradient_vec3_0, mx_gradient_vec3_1 ] );

const mx_gradient_scale2d_0 = /*@__PURE__*/ Fn$1( ( [ v_immutable ] ) => {

	const v = float$1( v_immutable ).toVar();

	return mul$1( 0.6616, v );

} ).setLayout( {
	name: 'mx_gradient_scale2d_0',
	type: 'float',
	inputs: [
		{ name: 'v', type: 'float' }
	]
} );

const mx_gradient_scale3d_0 = /*@__PURE__*/ Fn$1( ( [ v_immutable ] ) => {

	const v = float$1( v_immutable ).toVar();

	return mul$1( 0.9820, v );

} ).setLayout( {
	name: 'mx_gradient_scale3d_0',
	type: 'float',
	inputs: [
		{ name: 'v', type: 'float' }
	]
} );

const mx_gradient_scale2d_1 = /*@__PURE__*/ Fn$1( ( [ v_immutable ] ) => {

	const v = vec3$1( v_immutable ).toVar();

	return mul$1( 0.6616, v );

} ).setLayout( {
	name: 'mx_gradient_scale2d_1',
	type: 'vec3',
	inputs: [
		{ name: 'v', type: 'vec3' }
	]
} );

const mx_gradient_scale2d = /*@__PURE__*/ overloadingFn( [ mx_gradient_scale2d_0, mx_gradient_scale2d_1 ] );

const mx_gradient_scale3d_1 = /*@__PURE__*/ Fn$1( ( [ v_immutable ] ) => {

	const v = vec3$1( v_immutable ).toVar();

	return mul$1( 0.9820, v );

} ).setLayout( {
	name: 'mx_gradient_scale3d_1',
	type: 'vec3',
	inputs: [
		{ name: 'v', type: 'vec3' }
	]
} );

const mx_gradient_scale3d = /*@__PURE__*/ overloadingFn( [ mx_gradient_scale3d_0, mx_gradient_scale3d_1 ] );

const mx_rotl32 = /*@__PURE__*/ Fn$1( ( [ x_immutable, k_immutable ] ) => {

	const k = int( k_immutable ).toVar();
	const x = uint( x_immutable ).toVar();

	return x.shiftLeft( k ).bitOr( x.shiftRight( int( 32 ).sub( k ) ) );

} ).setLayout( {
	name: 'mx_rotl32',
	type: 'uint',
	inputs: [
		{ name: 'x', type: 'uint' },
		{ name: 'k', type: 'int' }
	]
} );

const mx_bjmix = /*@__PURE__*/ Fn$1( ( [ a, b, c ] ) => {

	a.subAssign( c );
	a.bitXorAssign( mx_rotl32( c, int( 4 ) ) );
	c.addAssign( b );
	b.subAssign( a );
	b.bitXorAssign( mx_rotl32( a, int( 6 ) ) );
	a.addAssign( c );
	c.subAssign( b );
	c.bitXorAssign( mx_rotl32( b, int( 8 ) ) );
	b.addAssign( a );
	a.subAssign( c );
	a.bitXorAssign( mx_rotl32( c, int( 16 ) ) );
	c.addAssign( b );
	b.subAssign( a );
	b.bitXorAssign( mx_rotl32( a, int( 19 ) ) );
	a.addAssign( c );
	c.subAssign( b );
	c.bitXorAssign( mx_rotl32( b, int( 4 ) ) );
	b.addAssign( a );

} );

const mx_bjfinal = /*@__PURE__*/ Fn$1( ( [ a_immutable, b_immutable, c_immutable ] ) => {

	const c = uint( c_immutable ).toVar();
	const b = uint( b_immutable ).toVar();
	const a = uint( a_immutable ).toVar();
	c.bitXorAssign( b );
	c.subAssign( mx_rotl32( b, int( 14 ) ) );
	a.bitXorAssign( c );
	a.subAssign( mx_rotl32( c, int( 11 ) ) );
	b.bitXorAssign( a );
	b.subAssign( mx_rotl32( a, int( 25 ) ) );
	c.bitXorAssign( b );
	c.subAssign( mx_rotl32( b, int( 16 ) ) );
	a.bitXorAssign( c );
	a.subAssign( mx_rotl32( c, int( 4 ) ) );
	b.bitXorAssign( a );
	b.subAssign( mx_rotl32( a, int( 14 ) ) );
	c.bitXorAssign( b );
	c.subAssign( mx_rotl32( b, int( 24 ) ) );

	return c;

} ).setLayout( {
	name: 'mx_bjfinal',
	type: 'uint',
	inputs: [
		{ name: 'a', type: 'uint' },
		{ name: 'b', type: 'uint' },
		{ name: 'c', type: 'uint' }
	]
} );

const mx_bits_to_01 = /*@__PURE__*/ Fn$1( ( [ bits_immutable ] ) => {

	const bits = uint( bits_immutable ).toVar();

	return float$1( bits ).div( float$1( uint( int( 0xffffffff ) ) ) );

} ).setLayout( {
	name: 'mx_bits_to_01',
	type: 'float',
	inputs: [
		{ name: 'bits', type: 'uint' }
	]
} );

const mx_fade = /*@__PURE__*/ Fn$1( ( [ t_immutable ] ) => {

	const t = float$1( t_immutable ).toVar();

	return t.mul( t ).mul( t ).mul( t.mul( t.mul( 6.0 ).sub( 15.0 ) ).add( 10.0 ) );

} ).setLayout( {
	name: 'mx_fade',
	type: 'float',
	inputs: [
		{ name: 't', type: 'float' }
	]
} );

const mx_hash_int_0 = /*@__PURE__*/ Fn$1( ( [ x_immutable ] ) => {

	const x = int( x_immutable ).toVar();
	const len = uint( uint( 1 ) ).toVar();
	const seed = uint( uint( int( 0xdeadbeef ) ).add( len.shiftLeft( uint( 2 ) ) ).add( uint( 13 ) ) ).toVar();

	return mx_bjfinal( seed.add( uint( x ) ), seed, seed );

} ).setLayout( {
	name: 'mx_hash_int_0',
	type: 'uint',
	inputs: [
		{ name: 'x', type: 'int' }
	]
} );

const mx_hash_int_1 = /*@__PURE__*/ Fn$1( ( [ x_immutable, y_immutable ] ) => {

	const y = int( y_immutable ).toVar();
	const x = int( x_immutable ).toVar();
	const len = uint( uint( 2 ) ).toVar();
	const a = uint().toVar(), b = uint().toVar(), c = uint().toVar();
	a.assign( b.assign( c.assign( uint( int( 0xdeadbeef ) ).add( len.shiftLeft( uint( 2 ) ) ).add( uint( 13 ) ) ) ) );
	a.addAssign( uint( x ) );
	b.addAssign( uint( y ) );

	return mx_bjfinal( a, b, c );

} ).setLayout( {
	name: 'mx_hash_int_1',
	type: 'uint',
	inputs: [
		{ name: 'x', type: 'int' },
		{ name: 'y', type: 'int' }
	]
} );

const mx_hash_int_2 = /*@__PURE__*/ Fn$1( ( [ x_immutable, y_immutable, z_immutable ] ) => {

	const z = int( z_immutable ).toVar();
	const y = int( y_immutable ).toVar();
	const x = int( x_immutable ).toVar();
	const len = uint( uint( 3 ) ).toVar();
	const a = uint().toVar(), b = uint().toVar(), c = uint().toVar();
	a.assign( b.assign( c.assign( uint( int( 0xdeadbeef ) ).add( len.shiftLeft( uint( 2 ) ) ).add( uint( 13 ) ) ) ) );
	a.addAssign( uint( x ) );
	b.addAssign( uint( y ) );
	c.addAssign( uint( z ) );

	return mx_bjfinal( a, b, c );

} ).setLayout( {
	name: 'mx_hash_int_2',
	type: 'uint',
	inputs: [
		{ name: 'x', type: 'int' },
		{ name: 'y', type: 'int' },
		{ name: 'z', type: 'int' }
	]
} );

const mx_hash_int_3 = /*@__PURE__*/ Fn$1( ( [ x_immutable, y_immutable, z_immutable, xx_immutable ] ) => {

	const xx = int( xx_immutable ).toVar();
	const z = int( z_immutable ).toVar();
	const y = int( y_immutable ).toVar();
	const x = int( x_immutable ).toVar();
	const len = uint( uint( 4 ) ).toVar();
	const a = uint().toVar(), b = uint().toVar(), c = uint().toVar();
	a.assign( b.assign( c.assign( uint( int( 0xdeadbeef ) ).add( len.shiftLeft( uint( 2 ) ) ).add( uint( 13 ) ) ) ) );
	a.addAssign( uint( x ) );
	b.addAssign( uint( y ) );
	c.addAssign( uint( z ) );
	mx_bjmix( a, b, c );
	a.addAssign( uint( xx ) );

	return mx_bjfinal( a, b, c );

} ).setLayout( {
	name: 'mx_hash_int_3',
	type: 'uint',
	inputs: [
		{ name: 'x', type: 'int' },
		{ name: 'y', type: 'int' },
		{ name: 'z', type: 'int' },
		{ name: 'xx', type: 'int' }
	]
} );

const mx_hash_int_4 = /*@__PURE__*/ Fn$1( ( [ x_immutable, y_immutable, z_immutable, xx_immutable, yy_immutable ] ) => {

	const yy = int( yy_immutable ).toVar();
	const xx = int( xx_immutable ).toVar();
	const z = int( z_immutable ).toVar();
	const y = int( y_immutable ).toVar();
	const x = int( x_immutable ).toVar();
	const len = uint( uint( 5 ) ).toVar();
	const a = uint().toVar(), b = uint().toVar(), c = uint().toVar();
	a.assign( b.assign( c.assign( uint( int( 0xdeadbeef ) ).add( len.shiftLeft( uint( 2 ) ) ).add( uint( 13 ) ) ) ) );
	a.addAssign( uint( x ) );
	b.addAssign( uint( y ) );
	c.addAssign( uint( z ) );
	mx_bjmix( a, b, c );
	a.addAssign( uint( xx ) );
	b.addAssign( uint( yy ) );

	return mx_bjfinal( a, b, c );

} ).setLayout( {
	name: 'mx_hash_int_4',
	type: 'uint',
	inputs: [
		{ name: 'x', type: 'int' },
		{ name: 'y', type: 'int' },
		{ name: 'z', type: 'int' },
		{ name: 'xx', type: 'int' },
		{ name: 'yy', type: 'int' }
	]
} );

const mx_hash_int = /*@__PURE__*/ overloadingFn( [ mx_hash_int_0, mx_hash_int_1, mx_hash_int_2, mx_hash_int_3, mx_hash_int_4 ] );

const mx_hash_vec3_0 = /*@__PURE__*/ Fn$1( ( [ x_immutable, y_immutable ] ) => {

	const y = int( y_immutable ).toVar();
	const x = int( x_immutable ).toVar();
	const h = uint( mx_hash_int( x, y ) ).toVar();
	const result = uvec3().toVar();
	result.x.assign( h.bitAnd( int( 0xFF ) ) );
	result.y.assign( h.shiftRight( int( 8 ) ).bitAnd( int( 0xFF ) ) );
	result.z.assign( h.shiftRight( int( 16 ) ).bitAnd( int( 0xFF ) ) );

	return result;

} ).setLayout( {
	name: 'mx_hash_vec3_0',
	type: 'uvec3',
	inputs: [
		{ name: 'x', type: 'int' },
		{ name: 'y', type: 'int' }
	]
} );

const mx_hash_vec3_1 = /*@__PURE__*/ Fn$1( ( [ x_immutable, y_immutable, z_immutable ] ) => {

	const z = int( z_immutable ).toVar();
	const y = int( y_immutable ).toVar();
	const x = int( x_immutable ).toVar();
	const h = uint( mx_hash_int( x, y, z ) ).toVar();
	const result = uvec3().toVar();
	result.x.assign( h.bitAnd( int( 0xFF ) ) );
	result.y.assign( h.shiftRight( int( 8 ) ).bitAnd( int( 0xFF ) ) );
	result.z.assign( h.shiftRight( int( 16 ) ).bitAnd( int( 0xFF ) ) );

	return result;

} ).setLayout( {
	name: 'mx_hash_vec3_1',
	type: 'uvec3',
	inputs: [
		{ name: 'x', type: 'int' },
		{ name: 'y', type: 'int' },
		{ name: 'z', type: 'int' }
	]
} );

const mx_hash_vec3 = /*@__PURE__*/ overloadingFn( [ mx_hash_vec3_0, mx_hash_vec3_1 ] );

const mx_perlin_noise_float_0 = /*@__PURE__*/ Fn$1( ( [ p_immutable ] ) => {

	const p = vec2$1( p_immutable ).toVar();
	const X = int().toVar(), Y = int().toVar();
	const fx = float$1( mx_floorfrac( p.x, X ) ).toVar();
	const fy = float$1( mx_floorfrac( p.y, Y ) ).toVar();
	const u = float$1( mx_fade( fx ) ).toVar();
	const v = float$1( mx_fade( fy ) ).toVar();
	const result = float$1( mx_bilerp( mx_gradient_float( mx_hash_int( X, Y ), fx, fy ), mx_gradient_float( mx_hash_int( X.add( int( 1 ) ), Y ), fx.sub( 1.0 ), fy ), mx_gradient_float( mx_hash_int( X, Y.add( int( 1 ) ) ), fx, fy.sub( 1.0 ) ), mx_gradient_float( mx_hash_int( X.add( int( 1 ) ), Y.add( int( 1 ) ) ), fx.sub( 1.0 ), fy.sub( 1.0 ) ), u, v ) ).toVar();

	return mx_gradient_scale2d( result );

} ).setLayout( {
	name: 'mx_perlin_noise_float_0',
	type: 'float',
	inputs: [
		{ name: 'p', type: 'vec2' }
	]
} );

const mx_perlin_noise_float_1 = /*@__PURE__*/ Fn$1( ( [ p_immutable ] ) => {

	const p = vec3$1( p_immutable ).toVar();
	const X = int().toVar(), Y = int().toVar(), Z = int().toVar();
	const fx = float$1( mx_floorfrac( p.x, X ) ).toVar();
	const fy = float$1( mx_floorfrac( p.y, Y ) ).toVar();
	const fz = float$1( mx_floorfrac( p.z, Z ) ).toVar();
	const u = float$1( mx_fade( fx ) ).toVar();
	const v = float$1( mx_fade( fy ) ).toVar();
	const w = float$1( mx_fade( fz ) ).toVar();
	const result = float$1( mx_trilerp( mx_gradient_float( mx_hash_int( X, Y, Z ), fx, fy, fz ), mx_gradient_float( mx_hash_int( X.add( int( 1 ) ), Y, Z ), fx.sub( 1.0 ), fy, fz ), mx_gradient_float( mx_hash_int( X, Y.add( int( 1 ) ), Z ), fx, fy.sub( 1.0 ), fz ), mx_gradient_float( mx_hash_int( X.add( int( 1 ) ), Y.add( int( 1 ) ), Z ), fx.sub( 1.0 ), fy.sub( 1.0 ), fz ), mx_gradient_float( mx_hash_int( X, Y, Z.add( int( 1 ) ) ), fx, fy, fz.sub( 1.0 ) ), mx_gradient_float( mx_hash_int( X.add( int( 1 ) ), Y, Z.add( int( 1 ) ) ), fx.sub( 1.0 ), fy, fz.sub( 1.0 ) ), mx_gradient_float( mx_hash_int( X, Y.add( int( 1 ) ), Z.add( int( 1 ) ) ), fx, fy.sub( 1.0 ), fz.sub( 1.0 ) ), mx_gradient_float( mx_hash_int( X.add( int( 1 ) ), Y.add( int( 1 ) ), Z.add( int( 1 ) ) ), fx.sub( 1.0 ), fy.sub( 1.0 ), fz.sub( 1.0 ) ), u, v, w ) ).toVar();

	return mx_gradient_scale3d( result );

} ).setLayout( {
	name: 'mx_perlin_noise_float_1',
	type: 'float',
	inputs: [
		{ name: 'p', type: 'vec3' }
	]
} );

const mx_perlin_noise_float = /*@__PURE__*/ overloadingFn( [ mx_perlin_noise_float_0, mx_perlin_noise_float_1 ] );

const mx_perlin_noise_vec3_0 = /*@__PURE__*/ Fn$1( ( [ p_immutable ] ) => {

	const p = vec2$1( p_immutable ).toVar();
	const X = int().toVar(), Y = int().toVar();
	const fx = float$1( mx_floorfrac( p.x, X ) ).toVar();
	const fy = float$1( mx_floorfrac( p.y, Y ) ).toVar();
	const u = float$1( mx_fade( fx ) ).toVar();
	const v = float$1( mx_fade( fy ) ).toVar();
	const result = vec3$1( mx_bilerp( mx_gradient_vec3( mx_hash_vec3( X, Y ), fx, fy ), mx_gradient_vec3( mx_hash_vec3( X.add( int( 1 ) ), Y ), fx.sub( 1.0 ), fy ), mx_gradient_vec3( mx_hash_vec3( X, Y.add( int( 1 ) ) ), fx, fy.sub( 1.0 ) ), mx_gradient_vec3( mx_hash_vec3( X.add( int( 1 ) ), Y.add( int( 1 ) ) ), fx.sub( 1.0 ), fy.sub( 1.0 ) ), u, v ) ).toVar();

	return mx_gradient_scale2d( result );

} ).setLayout( {
	name: 'mx_perlin_noise_vec3_0',
	type: 'vec3',
	inputs: [
		{ name: 'p', type: 'vec2' }
	]
} );

const mx_perlin_noise_vec3_1 = /*@__PURE__*/ Fn$1( ( [ p_immutable ] ) => {

	const p = vec3$1( p_immutable ).toVar();
	const X = int().toVar(), Y = int().toVar(), Z = int().toVar();
	const fx = float$1( mx_floorfrac( p.x, X ) ).toVar();
	const fy = float$1( mx_floorfrac( p.y, Y ) ).toVar();
	const fz = float$1( mx_floorfrac( p.z, Z ) ).toVar();
	const u = float$1( mx_fade( fx ) ).toVar();
	const v = float$1( mx_fade( fy ) ).toVar();
	const w = float$1( mx_fade( fz ) ).toVar();
	const result = vec3$1( mx_trilerp( mx_gradient_vec3( mx_hash_vec3( X, Y, Z ), fx, fy, fz ), mx_gradient_vec3( mx_hash_vec3( X.add( int( 1 ) ), Y, Z ), fx.sub( 1.0 ), fy, fz ), mx_gradient_vec3( mx_hash_vec3( X, Y.add( int( 1 ) ), Z ), fx, fy.sub( 1.0 ), fz ), mx_gradient_vec3( mx_hash_vec3( X.add( int( 1 ) ), Y.add( int( 1 ) ), Z ), fx.sub( 1.0 ), fy.sub( 1.0 ), fz ), mx_gradient_vec3( mx_hash_vec3( X, Y, Z.add( int( 1 ) ) ), fx, fy, fz.sub( 1.0 ) ), mx_gradient_vec3( mx_hash_vec3( X.add( int( 1 ) ), Y, Z.add( int( 1 ) ) ), fx.sub( 1.0 ), fy, fz.sub( 1.0 ) ), mx_gradient_vec3( mx_hash_vec3( X, Y.add( int( 1 ) ), Z.add( int( 1 ) ) ), fx, fy.sub( 1.0 ), fz.sub( 1.0 ) ), mx_gradient_vec3( mx_hash_vec3( X.add( int( 1 ) ), Y.add( int( 1 ) ), Z.add( int( 1 ) ) ), fx.sub( 1.0 ), fy.sub( 1.0 ), fz.sub( 1.0 ) ), u, v, w ) ).toVar();

	return mx_gradient_scale3d( result );

} ).setLayout( {
	name: 'mx_perlin_noise_vec3_1',
	type: 'vec3',
	inputs: [
		{ name: 'p', type: 'vec3' }
	]
} );

const mx_perlin_noise_vec3 = /*@__PURE__*/ overloadingFn( [ mx_perlin_noise_vec3_0, mx_perlin_noise_vec3_1 ] );

const mx_cell_noise_float_0 = /*@__PURE__*/ Fn$1( ( [ p_immutable ] ) => {

	const p = float$1( p_immutable ).toVar();
	const ix = int( mx_floor( p ) ).toVar();

	return mx_bits_to_01( mx_hash_int( ix ) );

} ).setLayout( {
	name: 'mx_cell_noise_float_0',
	type: 'float',
	inputs: [
		{ name: 'p', type: 'float' }
	]
} );

const mx_cell_noise_float_1 = /*@__PURE__*/ Fn$1( ( [ p_immutable ] ) => {

	const p = vec2$1( p_immutable ).toVar();
	const ix = int( mx_floor( p.x ) ).toVar();
	const iy = int( mx_floor( p.y ) ).toVar();

	return mx_bits_to_01( mx_hash_int( ix, iy ) );

} ).setLayout( {
	name: 'mx_cell_noise_float_1',
	type: 'float',
	inputs: [
		{ name: 'p', type: 'vec2' }
	]
} );

const mx_cell_noise_float_2 = /*@__PURE__*/ Fn$1( ( [ p_immutable ] ) => {

	const p = vec3$1( p_immutable ).toVar();
	const ix = int( mx_floor( p.x ) ).toVar();
	const iy = int( mx_floor( p.y ) ).toVar();
	const iz = int( mx_floor( p.z ) ).toVar();

	return mx_bits_to_01( mx_hash_int( ix, iy, iz ) );

} ).setLayout( {
	name: 'mx_cell_noise_float_2',
	type: 'float',
	inputs: [
		{ name: 'p', type: 'vec3' }
	]
} );

const mx_cell_noise_float_3 = /*@__PURE__*/ Fn$1( ( [ p_immutable ] ) => {

	const p = vec4$1( p_immutable ).toVar();
	const ix = int( mx_floor( p.x ) ).toVar();
	const iy = int( mx_floor( p.y ) ).toVar();
	const iz = int( mx_floor( p.z ) ).toVar();
	const iw = int( mx_floor( p.w ) ).toVar();

	return mx_bits_to_01( mx_hash_int( ix, iy, iz, iw ) );

} ).setLayout( {
	name: 'mx_cell_noise_float_3',
	type: 'float',
	inputs: [
		{ name: 'p', type: 'vec4' }
	]
} );

const mx_cell_noise_float$1 = /*@__PURE__*/ overloadingFn( [ mx_cell_noise_float_0, mx_cell_noise_float_1, mx_cell_noise_float_2, mx_cell_noise_float_3 ] );

const mx_cell_noise_vec3_0 = /*@__PURE__*/ Fn$1( ( [ p_immutable ] ) => {

	const p = float$1( p_immutable ).toVar();
	const ix = int( mx_floor( p ) ).toVar();

	return vec3$1( mx_bits_to_01( mx_hash_int( ix, int( 0 ) ) ), mx_bits_to_01( mx_hash_int( ix, int( 1 ) ) ), mx_bits_to_01( mx_hash_int( ix, int( 2 ) ) ) );

} ).setLayout( {
	name: 'mx_cell_noise_vec3_0',
	type: 'vec3',
	inputs: [
		{ name: 'p', type: 'float' }
	]
} );

const mx_cell_noise_vec3_1 = /*@__PURE__*/ Fn$1( ( [ p_immutable ] ) => {

	const p = vec2$1( p_immutable ).toVar();
	const ix = int( mx_floor( p.x ) ).toVar();
	const iy = int( mx_floor( p.y ) ).toVar();

	return vec3$1( mx_bits_to_01( mx_hash_int( ix, iy, int( 0 ) ) ), mx_bits_to_01( mx_hash_int( ix, iy, int( 1 ) ) ), mx_bits_to_01( mx_hash_int( ix, iy, int( 2 ) ) ) );

} ).setLayout( {
	name: 'mx_cell_noise_vec3_1',
	type: 'vec3',
	inputs: [
		{ name: 'p', type: 'vec2' }
	]
} );

const mx_cell_noise_vec3_2 = /*@__PURE__*/ Fn$1( ( [ p_immutable ] ) => {

	const p = vec3$1( p_immutable ).toVar();
	const ix = int( mx_floor( p.x ) ).toVar();
	const iy = int( mx_floor( p.y ) ).toVar();
	const iz = int( mx_floor( p.z ) ).toVar();

	return vec3$1( mx_bits_to_01( mx_hash_int( ix, iy, iz, int( 0 ) ) ), mx_bits_to_01( mx_hash_int( ix, iy, iz, int( 1 ) ) ), mx_bits_to_01( mx_hash_int( ix, iy, iz, int( 2 ) ) ) );

} ).setLayout( {
	name: 'mx_cell_noise_vec3_2',
	type: 'vec3',
	inputs: [
		{ name: 'p', type: 'vec3' }
	]
} );

const mx_cell_noise_vec3_3 = /*@__PURE__*/ Fn$1( ( [ p_immutable ] ) => {

	const p = vec4$1( p_immutable ).toVar();
	const ix = int( mx_floor( p.x ) ).toVar();
	const iy = int( mx_floor( p.y ) ).toVar();
	const iz = int( mx_floor( p.z ) ).toVar();
	const iw = int( mx_floor( p.w ) ).toVar();

	return vec3$1( mx_bits_to_01( mx_hash_int( ix, iy, iz, iw, int( 0 ) ) ), mx_bits_to_01( mx_hash_int( ix, iy, iz, iw, int( 1 ) ) ), mx_bits_to_01( mx_hash_int( ix, iy, iz, iw, int( 2 ) ) ) );

} ).setLayout( {
	name: 'mx_cell_noise_vec3_3',
	type: 'vec3',
	inputs: [
		{ name: 'p', type: 'vec4' }
	]
} );

const mx_cell_noise_vec3 = /*@__PURE__*/ overloadingFn( [ mx_cell_noise_vec3_0, mx_cell_noise_vec3_1, mx_cell_noise_vec3_2, mx_cell_noise_vec3_3 ] );

const mx_fractal_noise_float$1 = /*@__PURE__*/ Fn$1( ( [ p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable ] ) => {

	const diminish = float$1( diminish_immutable ).toVar();
	const lacunarity = float$1( lacunarity_immutable ).toVar();
	const octaves = int( octaves_immutable ).toVar();
	const p = vec3$1( p_immutable ).toVar();
	const result = float$1( 0.0 ).toVar();
	const amplitude = float$1( 1.0 ).toVar();

	Loop( octaves, () => {

		result.addAssign( amplitude.mul( mx_perlin_noise_float( p ) ) );
		amplitude.mulAssign( diminish );
		p.mulAssign( lacunarity );

	} );

	return result;

} ).setLayout( {
	name: 'mx_fractal_noise_float',
	type: 'float',
	inputs: [
		{ name: 'p', type: 'vec3' },
		{ name: 'octaves', type: 'int' },
		{ name: 'lacunarity', type: 'float' },
		{ name: 'diminish', type: 'float' }
	]
} );

const mx_fractal_noise_vec3$1 = /*@__PURE__*/ Fn$1( ( [ p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable ] ) => {

	const diminish = float$1( diminish_immutable ).toVar();
	const lacunarity = float$1( lacunarity_immutable ).toVar();
	const octaves = int( octaves_immutable ).toVar();
	const p = vec3$1( p_immutable ).toVar();
	const result = vec3$1( 0.0 ).toVar();
	const amplitude = float$1( 1.0 ).toVar();

	Loop( octaves, () => {

		result.addAssign( amplitude.mul( mx_perlin_noise_vec3( p ) ) );
		amplitude.mulAssign( diminish );
		p.mulAssign( lacunarity );

	} );

	return result;

} ).setLayout( {
	name: 'mx_fractal_noise_vec3',
	type: 'vec3',
	inputs: [
		{ name: 'p', type: 'vec3' },
		{ name: 'octaves', type: 'int' },
		{ name: 'lacunarity', type: 'float' },
		{ name: 'diminish', type: 'float' }
	]
} );

const mx_fractal_noise_vec2$1 = /*@__PURE__*/ Fn$1( ( [ p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable ] ) => {

	const diminish = float$1( diminish_immutable ).toVar();
	const lacunarity = float$1( lacunarity_immutable ).toVar();
	const octaves = int( octaves_immutable ).toVar();
	const p = vec3$1( p_immutable ).toVar();

	return vec2$1( mx_fractal_noise_float$1( p, octaves, lacunarity, diminish ), mx_fractal_noise_float$1( p.add( vec3$1( int( 19 ), int( 193 ), int( 17 ) ) ), octaves, lacunarity, diminish ) );

} ).setLayout( {
	name: 'mx_fractal_noise_vec2',
	type: 'vec2',
	inputs: [
		{ name: 'p', type: 'vec3' },
		{ name: 'octaves', type: 'int' },
		{ name: 'lacunarity', type: 'float' },
		{ name: 'diminish', type: 'float' }
	]
} );

const mx_fractal_noise_vec4$1 = /*@__PURE__*/ Fn$1( ( [ p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable ] ) => {

	const diminish = float$1( diminish_immutable ).toVar();
	const lacunarity = float$1( lacunarity_immutable ).toVar();
	const octaves = int( octaves_immutable ).toVar();
	const p = vec3$1( p_immutable ).toVar();
	const c = vec3$1( mx_fractal_noise_vec3$1( p, octaves, lacunarity, diminish ) ).toVar();
	const f = float$1( mx_fractal_noise_float$1( p.add( vec3$1( int( 19 ), int( 193 ), int( 17 ) ) ), octaves, lacunarity, diminish ) ).toVar();

	return vec4$1( c, f );

} ).setLayout( {
	name: 'mx_fractal_noise_vec4',
	type: 'vec4',
	inputs: [
		{ name: 'p', type: 'vec3' },
		{ name: 'octaves', type: 'int' },
		{ name: 'lacunarity', type: 'float' },
		{ name: 'diminish', type: 'float' }
	]
} );

const mx_worley_distance_0 = /*@__PURE__*/ Fn$1( ( [ p_immutable, x_immutable, y_immutable, xoff_immutable, yoff_immutable, jitter_immutable, metric_immutable ] ) => {

	const metric = int( metric_immutable ).toVar();
	const jitter = float$1( jitter_immutable ).toVar();
	const yoff = int( yoff_immutable ).toVar();
	const xoff = int( xoff_immutable ).toVar();
	const y = int( y_immutable ).toVar();
	const x = int( x_immutable ).toVar();
	const p = vec2$1( p_immutable ).toVar();
	const tmp = vec3$1( mx_cell_noise_vec3( vec2$1( x.add( xoff ), y.add( yoff ) ) ) ).toVar();
	const off = vec2$1( tmp.x, tmp.y ).toVar();
	off.subAssign( 0.5 );
	off.mulAssign( jitter );
	off.addAssign( 0.5 );
	const cellpos = vec2$1( vec2$1( float$1( x ), float$1( y ) ).add( off ) ).toVar();
	const diff = vec2$1( cellpos.sub( p ) ).toVar();

	If( metric.equal( int( 2 ) ), () => {

		return abs$1( diff.x ).add( abs$1( diff.y ) );

	} );

	If( metric.equal( int( 3 ) ), () => {

		return max$1( abs$1( diff.x ), abs$1( diff.y ) );

	} );

	return dot$1( diff, diff );

} ).setLayout( {
	name: 'mx_worley_distance_0',
	type: 'float',
	inputs: [
		{ name: 'p', type: 'vec2' },
		{ name: 'x', type: 'int' },
		{ name: 'y', type: 'int' },
		{ name: 'xoff', type: 'int' },
		{ name: 'yoff', type: 'int' },
		{ name: 'jitter', type: 'float' },
		{ name: 'metric', type: 'int' }
	]
} );

const mx_worley_distance_1 = /*@__PURE__*/ Fn$1( ( [ p_immutable, x_immutable, y_immutable, z_immutable, xoff_immutable, yoff_immutable, zoff_immutable, jitter_immutable, metric_immutable ] ) => {

	const metric = int( metric_immutable ).toVar();
	const jitter = float$1( jitter_immutable ).toVar();
	const zoff = int( zoff_immutable ).toVar();
	const yoff = int( yoff_immutable ).toVar();
	const xoff = int( xoff_immutable ).toVar();
	const z = int( z_immutable ).toVar();
	const y = int( y_immutable ).toVar();
	const x = int( x_immutable ).toVar();
	const p = vec3$1( p_immutable ).toVar();
	const off = vec3$1( mx_cell_noise_vec3( vec3$1( x.add( xoff ), y.add( yoff ), z.add( zoff ) ) ) ).toVar();
	off.subAssign( 0.5 );
	off.mulAssign( jitter );
	off.addAssign( 0.5 );
	const cellpos = vec3$1( vec3$1( float$1( x ), float$1( y ), float$1( z ) ).add( off ) ).toVar();
	const diff = vec3$1( cellpos.sub( p ) ).toVar();

	If( metric.equal( int( 2 ) ), () => {

		return abs$1( diff.x ).add( abs$1( diff.y ) ).add( abs$1( diff.z ) );

	} );

	If( metric.equal( int( 3 ) ), () => {

		return max$1( max$1( abs$1( diff.x ), abs$1( diff.y ) ), abs$1( diff.z ) );

	} );

	return dot$1( diff, diff );

} ).setLayout( {
	name: 'mx_worley_distance_1',
	type: 'float',
	inputs: [
		{ name: 'p', type: 'vec3' },
		{ name: 'x', type: 'int' },
		{ name: 'y', type: 'int' },
		{ name: 'z', type: 'int' },
		{ name: 'xoff', type: 'int' },
		{ name: 'yoff', type: 'int' },
		{ name: 'zoff', type: 'int' },
		{ name: 'jitter', type: 'float' },
		{ name: 'metric', type: 'int' }
	]
} );

const mx_worley_distance = /*@__PURE__*/ overloadingFn( [ mx_worley_distance_0, mx_worley_distance_1 ] );

const mx_worley_noise_float_0 = /*@__PURE__*/ Fn$1( ( [ p_immutable, jitter_immutable, metric_immutable ] ) => {

	const metric = int( metric_immutable ).toVar();
	const jitter = float$1( jitter_immutable ).toVar();
	const p = vec2$1( p_immutable ).toVar();
	const X = int().toVar(), Y = int().toVar();
	const localpos = vec2$1( mx_floorfrac( p.x, X ), mx_floorfrac( p.y, Y ) ).toVar();
	const sqdist = float$1( 1e6 ).toVar();

	Loop( { start: -1, end: int( 1 ), name: 'x', condition: '<=' }, ( { x } ) => {

		Loop( { start: -1, end: int( 1 ), name: 'y', condition: '<=' }, ( { y } ) => {

			const dist = float$1( mx_worley_distance( localpos, x, y, X, Y, jitter, metric ) ).toVar();
			sqdist.assign( min$1( sqdist, dist ) );

		} );

	} );

	If( metric.equal( int( 0 ) ), () => {

		sqdist.assign( sqrt( sqdist ) );

	} );

	return sqdist;

} ).setLayout( {
	name: 'mx_worley_noise_float_0',
	type: 'float',
	inputs: [
		{ name: 'p', type: 'vec2' },
		{ name: 'jitter', type: 'float' },
		{ name: 'metric', type: 'int' }
	]
} );

const mx_worley_noise_vec2_0 = /*@__PURE__*/ Fn$1( ( [ p_immutable, jitter_immutable, metric_immutable ] ) => {

	const metric = int( metric_immutable ).toVar();
	const jitter = float$1( jitter_immutable ).toVar();
	const p = vec2$1( p_immutable ).toVar();
	const X = int().toVar(), Y = int().toVar();
	const localpos = vec2$1( mx_floorfrac( p.x, X ), mx_floorfrac( p.y, Y ) ).toVar();
	const sqdist = vec2$1( 1e6, 1e6 ).toVar();

	Loop( { start: -1, end: int( 1 ), name: 'x', condition: '<=' }, ( { x } ) => {

		Loop( { start: -1, end: int( 1 ), name: 'y', condition: '<=' }, ( { y } ) => {

			const dist = float$1( mx_worley_distance( localpos, x, y, X, Y, jitter, metric ) ).toVar();

			If( dist.lessThan( sqdist.x ), () => {

				sqdist.y.assign( sqdist.x );
				sqdist.x.assign( dist );

			} ).ElseIf( dist.lessThan( sqdist.y ), () => {

				sqdist.y.assign( dist );

			} );

		} );

	} );

	If( metric.equal( int( 0 ) ), () => {

		sqdist.assign( sqrt( sqdist ) );

	} );

	return sqdist;

} ).setLayout( {
	name: 'mx_worley_noise_vec2_0',
	type: 'vec2',
	inputs: [
		{ name: 'p', type: 'vec2' },
		{ name: 'jitter', type: 'float' },
		{ name: 'metric', type: 'int' }
	]
} );

const mx_worley_noise_vec3_0 = /*@__PURE__*/ Fn$1( ( [ p_immutable, jitter_immutable, metric_immutable ] ) => {

	const metric = int( metric_immutable ).toVar();
	const jitter = float$1( jitter_immutable ).toVar();
	const p = vec2$1( p_immutable ).toVar();
	const X = int().toVar(), Y = int().toVar();
	const localpos = vec2$1( mx_floorfrac( p.x, X ), mx_floorfrac( p.y, Y ) ).toVar();
	const sqdist = vec3$1( 1e6, 1e6, 1e6 ).toVar();

	Loop( { start: -1, end: int( 1 ), name: 'x', condition: '<=' }, ( { x } ) => {

		Loop( { start: -1, end: int( 1 ), name: 'y', condition: '<=' }, ( { y } ) => {

			const dist = float$1( mx_worley_distance( localpos, x, y, X, Y, jitter, metric ) ).toVar();

			If( dist.lessThan( sqdist.x ), () => {

				sqdist.z.assign( sqdist.y );
				sqdist.y.assign( sqdist.x );
				sqdist.x.assign( dist );

			} ).ElseIf( dist.lessThan( sqdist.y ), () => {

				sqdist.z.assign( sqdist.y );
				sqdist.y.assign( dist );

			} ).ElseIf( dist.lessThan( sqdist.z ), () => {

				sqdist.z.assign( dist );

			} );

		} );

	} );

	If( metric.equal( int( 0 ) ), () => {

		sqdist.assign( sqrt( sqdist ) );

	} );

	return sqdist;

} ).setLayout( {
	name: 'mx_worley_noise_vec3_0',
	type: 'vec3',
	inputs: [
		{ name: 'p', type: 'vec2' },
		{ name: 'jitter', type: 'float' },
		{ name: 'metric', type: 'int' }
	]
} );

const mx_worley_noise_float_1 = /*@__PURE__*/ Fn$1( ( [ p_immutable, jitter_immutable, metric_immutable ] ) => {

	const metric = int( metric_immutable ).toVar();
	const jitter = float$1( jitter_immutable ).toVar();
	const p = vec3$1( p_immutable ).toVar();
	const X = int().toVar(), Y = int().toVar(), Z = int().toVar();
	const localpos = vec3$1( mx_floorfrac( p.x, X ), mx_floorfrac( p.y, Y ), mx_floorfrac( p.z, Z ) ).toVar();
	const sqdist = float$1( 1e6 ).toVar();

	Loop( { start: -1, end: int( 1 ), name: 'x', condition: '<=' }, ( { x } ) => {

		Loop( { start: -1, end: int( 1 ), name: 'y', condition: '<=' }, ( { y } ) => {

			Loop( { start: -1, end: int( 1 ), name: 'z', condition: '<=' }, ( { z } ) => {

				const dist = float$1( mx_worley_distance( localpos, x, y, z, X, Y, Z, jitter, metric ) ).toVar();
				sqdist.assign( min$1( sqdist, dist ) );

			} );

		} );

	} );

	If( metric.equal( int( 0 ) ), () => {

		sqdist.assign( sqrt( sqdist ) );

	} );

	return sqdist;

} ).setLayout( {
	name: 'mx_worley_noise_float_1',
	type: 'float',
	inputs: [
		{ name: 'p', type: 'vec3' },
		{ name: 'jitter', type: 'float' },
		{ name: 'metric', type: 'int' }
	]
} );

const mx_worley_noise_float$1 = /*@__PURE__*/ overloadingFn( [ mx_worley_noise_float_0, mx_worley_noise_float_1 ] );

const mx_worley_noise_vec2_1 = /*@__PURE__*/ Fn$1( ( [ p_immutable, jitter_immutable, metric_immutable ] ) => {

	const metric = int( metric_immutable ).toVar();
	const jitter = float$1( jitter_immutable ).toVar();
	const p = vec3$1( p_immutable ).toVar();
	const X = int().toVar(), Y = int().toVar(), Z = int().toVar();
	const localpos = vec3$1( mx_floorfrac( p.x, X ), mx_floorfrac( p.y, Y ), mx_floorfrac( p.z, Z ) ).toVar();
	const sqdist = vec2$1( 1e6, 1e6 ).toVar();

	Loop( { start: -1, end: int( 1 ), name: 'x', condition: '<=' }, ( { x } ) => {

		Loop( { start: -1, end: int( 1 ), name: 'y', condition: '<=' }, ( { y } ) => {

			Loop( { start: -1, end: int( 1 ), name: 'z', condition: '<=' }, ( { z } ) => {

				const dist = float$1( mx_worley_distance( localpos, x, y, z, X, Y, Z, jitter, metric ) ).toVar();

				If( dist.lessThan( sqdist.x ), () => {

					sqdist.y.assign( sqdist.x );
					sqdist.x.assign( dist );

				} ).ElseIf( dist.lessThan( sqdist.y ), () => {

					sqdist.y.assign( dist );

				} );

			} );

		} );

	} );

	If( metric.equal( int( 0 ) ), () => {

		sqdist.assign( sqrt( sqdist ) );

	} );

	return sqdist;

} ).setLayout( {
	name: 'mx_worley_noise_vec2_1',
	type: 'vec2',
	inputs: [
		{ name: 'p', type: 'vec3' },
		{ name: 'jitter', type: 'float' },
		{ name: 'metric', type: 'int' }
	]
} );

const mx_worley_noise_vec2$1 = /*@__PURE__*/ overloadingFn( [ mx_worley_noise_vec2_0, mx_worley_noise_vec2_1 ] );

const mx_worley_noise_vec3_1 = /*@__PURE__*/ Fn$1( ( [ p_immutable, jitter_immutable, metric_immutable ] ) => {

	const metric = int( metric_immutable ).toVar();
	const jitter = float$1( jitter_immutable ).toVar();
	const p = vec3$1( p_immutable ).toVar();
	const X = int().toVar(), Y = int().toVar(), Z = int().toVar();
	const localpos = vec3$1( mx_floorfrac( p.x, X ), mx_floorfrac( p.y, Y ), mx_floorfrac( p.z, Z ) ).toVar();
	const sqdist = vec3$1( 1e6, 1e6, 1e6 ).toVar();

	Loop( { start: -1, end: int( 1 ), name: 'x', condition: '<=' }, ( { x } ) => {

		Loop( { start: -1, end: int( 1 ), name: 'y', condition: '<=' }, ( { y } ) => {

			Loop( { start: -1, end: int( 1 ), name: 'z', condition: '<=' }, ( { z } ) => {

				const dist = float$1( mx_worley_distance( localpos, x, y, z, X, Y, Z, jitter, metric ) ).toVar();

				If( dist.lessThan( sqdist.x ), () => {

					sqdist.z.assign( sqdist.y );
					sqdist.y.assign( sqdist.x );
					sqdist.x.assign( dist );

				} ).ElseIf( dist.lessThan( sqdist.y ), () => {

					sqdist.z.assign( sqdist.y );
					sqdist.y.assign( dist );

				} ).ElseIf( dist.lessThan( sqdist.z ), () => {

					sqdist.z.assign( dist );

				} );

			} );

		} );

	} );

	If( metric.equal( int( 0 ) ), () => {

		sqdist.assign( sqrt( sqdist ) );

	} );

	return sqdist;

} ).setLayout( {
	name: 'mx_worley_noise_vec3_1',
	type: 'vec3',
	inputs: [
		{ name: 'p', type: 'vec3' },
		{ name: 'jitter', type: 'float' },
		{ name: 'metric', type: 'int' }
	]
} );

const mx_worley_noise_vec3$1 = /*@__PURE__*/ overloadingFn( [ mx_worley_noise_vec3_0, mx_worley_noise_vec3_1 ] );

// Three.js Transpiler
// https://github.com/AcademySoftwareFoundation/MaterialX/blob/main/libraries/stdlib/genglsl/lib/mx_hsv.glsl


const mx_hsvtorgb = /*@__PURE__*/ Fn$1( ( [ hsv ] ) => {

	const s = hsv.y;
	const v = hsv.z;

	const result = vec3$1().toVar();

	If( s.lessThan( 0.0001 ), () => {

		result.assign( vec3$1( v, v, v ) );

	} ).Else( () => {

		let h = hsv.x;
		h = h.sub( floor$1( h ) ).mul( 6.0 ).toVar(); // TODO: check what .toVar() is needed in node system cache
		const hi = int( trunc( h ) );
		const f = h.sub( float$1( hi ) );
		const p = v.mul( s.oneMinus() );
		const q = v.mul( s.mul( f ).oneMinus() );
		const t = v.mul( s.mul( f.oneMinus() ).oneMinus() );

		If( hi.equal( int( 0 ) ), () => {

			result.assign( vec3$1( v, t, p ) );

		} ).ElseIf( hi.equal( int( 1 ) ), () => {

			result.assign( vec3$1( q, v, p ) );

		} ).ElseIf( hi.equal( int( 2 ) ), () => {

			result.assign( vec3$1( p, v, t ) );

		} ).ElseIf( hi.equal( int( 3 ) ), () => {

			result.assign( vec3$1( p, q, v ) );

		} ).ElseIf( hi.equal( int( 4 ) ), () => {

			result.assign( vec3$1( t, p, v ) );

		} ).Else( () => {

			result.assign( vec3$1( v, p, q ) );

		} );

	} );

	return result;

} ).setLayout( {
	name: 'mx_hsvtorgb',
	type: 'vec3',
	inputs: [
		{ name: 'hsv', type: 'vec3' }
	]
} );

const mx_rgbtohsv = /*@__PURE__*/ Fn$1( ( [ c_immutable ] ) => {

	const c = vec3$1( c_immutable ).toVar();
	const r = float$1( c.x ).toVar();
	const g = float$1( c.y ).toVar();
	const b = float$1( c.z ).toVar();
	const mincomp = float$1( min$1( r, min$1( g, b ) ) ).toVar();
	const maxcomp = float$1( max$1( r, max$1( g, b ) ) ).toVar();
	const delta = float$1( maxcomp.sub( mincomp ) ).toVar();
	const h = float$1().toVar(), s = float$1().toVar(), v = float$1().toVar();
	v.assign( maxcomp );

	If( maxcomp.greaterThan( 0.0 ), () => {

		s.assign( delta.div( maxcomp ) );

	} ).Else( () => {

		s.assign( 0.0 );

	} );

	If( s.lessThanEqual( 0.0 ), () => {

		h.assign( 0.0 );

	} ).Else( () => {

		If( r.greaterThanEqual( maxcomp ), () => {

			h.assign( g.sub( b ).div( delta ) );

		} ).ElseIf( g.greaterThanEqual( maxcomp ), () => {

			h.assign( add$1( 2.0, b.sub( r ).div( delta ) ) );

		} ).Else( () => {

			h.assign( add$1( 4.0, r.sub( g ).div( delta ) ) );

		} );

		h.mulAssign( 1.0 / 6.0 );

		If( h.lessThan( 0.0 ), () => {

			h.addAssign( 1.0 );

		} );

	} );

	return vec3$1( h, s, v );

} ).setLayout( {
	name: 'mx_rgbtohsv',
	type: 'vec3',
	inputs: [
		{ name: 'c', type: 'vec3' }
	]
} );

// Three.js Transpiler
// https://github.com/AcademySoftwareFoundation/MaterialX/blob/main/libraries/stdlib/genglsl/lib/mx_transform_color.glsl


const mx_srgb_texture_to_lin_rec709 = /*@__PURE__*/ Fn$1( ( [ color_immutable ] ) => {

	const color = vec3$1( color_immutable ).toVar();
	const isAbove = bvec3( greaterThan( color, vec3$1( 0.04045 ) ) ).toVar();
	const linSeg = vec3$1( color.div( 12.92 ) ).toVar();
	const powSeg = vec3$1( pow$1( max$1( color.add( vec3$1( 0.055 ) ), vec3$1( 0.0 ) ).div( 1.055 ), vec3$1( 2.4 ) ) ).toVar();

	return mix$1( linSeg, powSeg, isAbove );

} ).setLayout( {
	name: 'mx_srgb_texture_to_lin_rec709',
	type: 'vec3',
	inputs: [
		{ name: 'color', type: 'vec3' }
	]
} );

const mx_aastep = ( threshold, value ) => {

	threshold = float$1( threshold );
	value = float$1( value );

	const afwidth = vec2$1( value.dFdx(), value.dFdy() ).length().mul( 0.70710678118654757 );

	return smoothstep$1( threshold.sub( afwidth ), threshold.add( afwidth ), value );

};

const _ramp = ( a, b, uv, p ) => mix$1( a, b, uv[ p ].clamp() );
const mx_ramplr = ( valuel, valuer, texcoord = uv$1() ) => _ramp( valuel, valuer, texcoord, 'x' );
const mx_ramptb = ( valuet, valueb, texcoord = uv$1() ) => _ramp( valuet, valueb, texcoord, 'y' );

const _split = ( a, b, center, uv, p ) => mix$1( a, b, mx_aastep( center, uv[ p ] ) );
const mx_splitlr = ( valuel, valuer, center, texcoord = uv$1() ) => _split( valuel, valuer, center, texcoord, 'x' );
const mx_splittb = ( valuet, valueb, center, texcoord = uv$1() ) => _split( valuet, valueb, center, texcoord, 'y' );

const mx_transform_uv = ( uv_scale = 1, uv_offset = 0, uv_geo = uv$1() ) => uv_geo.mul( uv_scale ).add( uv_offset );

const mx_safepower = ( in1, in2 = 1 ) => {

	in1 = float$1( in1 );

	return in1.abs().pow( in2 ).mul( in1.sign() );

};

const mx_contrast = ( input, amount = 1, pivot = .5 ) => float$1( input ).sub( pivot ).mul( amount ).add( pivot );

const mx_noise_float$1 = ( texcoord = uv$1(), amplitude = 1, pivot = 0 ) => mx_perlin_noise_float( texcoord.convert( 'vec2|vec3' ) ).mul( amplitude ).add( pivot );
//export const mx_noise_vec2 = ( texcoord = uv(), amplitude = 1, pivot = 0 ) => mx_perlin_noise_vec3( texcoord.convert( 'vec2|vec3' ) ).mul( amplitude ).add( pivot );
const mx_noise_vec3 = ( texcoord = uv$1(), amplitude = 1, pivot = 0 ) => mx_perlin_noise_vec3( texcoord.convert( 'vec2|vec3' ) ).mul( amplitude ).add( pivot );
const mx_noise_vec4 = ( texcoord = uv$1(), amplitude = 1, pivot = 0 ) => {

	texcoord = texcoord.convert( 'vec2|vec3' ); // overloading type

	const noise_vec4 = vec4$1( mx_perlin_noise_vec3( texcoord ), mx_perlin_noise_float( texcoord.add( vec2$1( 19, 73 ) ) ) );

	return noise_vec4.mul( amplitude ).add( pivot );

};

const mx_worley_noise_float = ( texcoord = uv$1(), jitter = 1 ) => mx_worley_noise_float$1( texcoord.convert( 'vec2|vec3' ), jitter, int( 1 ) );
const mx_worley_noise_vec2 = ( texcoord = uv$1(), jitter = 1 ) => mx_worley_noise_vec2$1( texcoord.convert( 'vec2|vec3' ), jitter, int( 1 ) );
const mx_worley_noise_vec3 = ( texcoord = uv$1(), jitter = 1 ) => mx_worley_noise_vec3$1( texcoord.convert( 'vec2|vec3' ), jitter, int( 1 ) );

const mx_cell_noise_float = ( texcoord = uv$1() ) => mx_cell_noise_float$1( texcoord.convert( 'vec2|vec3' ) );

const mx_fractal_noise_float = ( position = uv$1(), octaves = 3, lacunarity = 2, diminish = .5, amplitude = 1 ) => mx_fractal_noise_float$1( position, int( octaves ), lacunarity, diminish ).mul( amplitude );
const mx_fractal_noise_vec2 = ( position = uv$1(), octaves = 3, lacunarity = 2, diminish = .5, amplitude = 1 ) => mx_fractal_noise_vec2$1( position, int( octaves ), lacunarity, diminish ).mul( amplitude );
const mx_fractal_noise_vec3 = ( position = uv$1(), octaves = 3, lacunarity = 2, diminish = .5, amplitude = 1 ) => mx_fractal_noise_vec3$1( position, int( octaves ), lacunarity, diminish ).mul( amplitude );
const mx_fractal_noise_vec4 = ( position = uv$1(), octaves = 3, lacunarity = 2, diminish = .5, amplitude = 1 ) => mx_fractal_noise_vec4$1( position, int( octaves ), lacunarity, diminish ).mul( amplitude );

// https://devlog-martinsh.blogspot.com/2011/09/box-projected-cube-environment-mapping.html

const getParallaxCorrectNormal = /*@__PURE__*/ Fn$1( ( [ normal, cubeSize, cubePos ] ) => {

	const nDir = normalize$1( normal ).toVar( 'nDir' );
	const rbmax = sub$1( float$1( 0.5 ).mul( cubeSize.sub( cubePos ) ), positionWorld$1 ).div( nDir ).toVar( 'rbmax' );
	const rbmin = sub$1( float$1( -0.5 ).mul( cubeSize.sub( cubePos ) ), positionWorld$1 ).div( nDir ).toVar( 'rbmin' );
	const rbminmax = vec3$1().toVar( 'rbminmax' );
	rbminmax.x = nDir.x.greaterThan( float$1( 0 ) ).select( rbmax.x, rbmin.x );
	rbminmax.y = nDir.y.greaterThan( float$1( 0 ) ).select( rbmax.y, rbmin.y );
	rbminmax.z = nDir.z.greaterThan( float$1( 0 ) ).select( rbmax.z, rbmin.z );

	const correction = min$1( min$1( rbminmax.x, rbminmax.y ), rbminmax.z ).toVar( 'correction' );
	const boxIntersection = positionWorld$1.add( nDir.mul( correction ) ).toVar( 'boxIntersection' );
	return boxIntersection.sub( cubePos );

} );

const getShIrradianceAt = /*@__PURE__*/ Fn$1( ( [ normal, shCoefficients ] ) => {

	// normal is assumed to have unit length

	const x = normal.x, y = normal.y, z = normal.z;

	// band 0
	let result = shCoefficients.element( 0 ).mul( 0.886227 );

	// band 1
	result = result.add( shCoefficients.element( 1 ).mul( 2.0 * 0.511664 ).mul( y ) );
	result = result.add( shCoefficients.element( 2 ).mul( 2.0 * 0.511664 ).mul( z ) );
	result = result.add( shCoefficients.element( 3 ).mul( 2.0 * 0.511664 ).mul( x ) );

	// band 2
	result = result.add( shCoefficients.element( 4 ).mul( 2.0 * 0.429043 ).mul( x ).mul( y ) );
	result = result.add( shCoefficients.element( 5 ).mul( 2.0 * 0.429043 ).mul( y ).mul( z ) );
	result = result.add( shCoefficients.element( 6 ).mul( z.mul( z ).mul( 0.743125 ).sub( 0.247708 ) ) );
	result = result.add( shCoefficients.element( 7 ).mul( 2.0 * 0.429043 ).mul( x ).mul( z ) );
	result = result.add( shCoefficients.element( 8 ).mul( 0.429043 ).mul( mul$1( x, x ).sub( mul$1( y, y ) ) ) );

	return result;

} );

// constants

var TSL = /*#__PURE__*/Object.freeze({
	__proto__: null,
	BRDF_GGX: BRDF_GGX,
	BRDF_Lambert: BRDF_Lambert,
	BasicShadowFilter: BasicShadowFilter,
	Break: Break,
	Continue: Continue,
	DFGApprox: DFGApprox,
	D_GGX: D_GGX,
	Discard: Discard,
	EPSILON: EPSILON,
	F_Schlick: F_Schlick,
	Fn: Fn$1,
	INFINITY: INFINITY,
	If: If,
	Loop: Loop,
	NodeAccess: NodeAccess,
	NodeShaderStage: NodeShaderStage,
	NodeType: NodeType,
	NodeUpdateType: NodeUpdateType,
	PCFShadowFilter: PCFShadowFilter,
	PCFSoftShadowFilter: PCFSoftShadowFilter,
	PI: PI,
	PI2: PI2,
	Return: Return,
	Schlick_to_F0: Schlick_to_F0,
	ScriptableNodeResources: ScriptableNodeResources,
	ShaderNode: ShaderNode,
	TBNViewMatrix: TBNViewMatrix,
	VSMShadowFilter: VSMShadowFilter,
	V_GGX_SmithCorrelated: V_GGX_SmithCorrelated,
	abs: abs$1,
	acesFilmicToneMapping: acesFilmicToneMapping,
	acos: acos,
	add: add$1,
	addMethodChaining: addMethodChaining,
	addNodeElement: addNodeElement,
	agxToneMapping: agxToneMapping,
	all: all,
	alphaT: alphaT,
	and: and,
	anisotropy: anisotropy,
	anisotropyB: anisotropyB,
	anisotropyT: anisotropyT,
	any: any,
	append: append,
	arrayBuffer: arrayBuffer,
	asin: asin,
	assign: assign,
	atan: atan,
	atan2: atan2,
	atomicAdd: atomicAdd,
	atomicAnd: atomicAnd,
	atomicFunc: atomicFunc,
	atomicMax: atomicMax,
	atomicMin: atomicMin,
	atomicOr: atomicOr,
	atomicStore: atomicStore,
	atomicSub: atomicSub,
	atomicXor: atomicXor,
	attenuationColor: attenuationColor,
	attenuationDistance: attenuationDistance,
	attribute: attribute$1,
	attributeArray: attributeArray,
	backgroundBlurriness: backgroundBlurriness,
	backgroundIntensity: backgroundIntensity,
	backgroundRotation: backgroundRotation,
	batch: batch,
	billboarding: billboarding,
	bitAnd: bitAnd,
	bitNot: bitNot,
	bitOr: bitOr,
	bitXor: bitXor,
	bitangentGeometry: bitangentGeometry,
	bitangentLocal: bitangentLocal,
	bitangentView: bitangentView,
	bitangentWorld: bitangentWorld,
	bitcast: bitcast,
	blendBurn: blendBurn,
	blendColor: blendColor,
	blendDodge: blendDodge,
	blendOverlay: blendOverlay,
	blendScreen: blendScreen,
	blur: blur,
	bool: bool,
	buffer: buffer,
	bufferAttribute: bufferAttribute,
	bumpMap: bumpMap,
	burn: burn,
	bvec2: bvec2,
	bvec3: bvec3,
	bvec4: bvec4,
	bypass: bypass,
	cache: cache,
	call: call,
	cameraFar: cameraFar,
	cameraNear: cameraNear,
	cameraNormalMatrix: cameraNormalMatrix,
	cameraPosition: cameraPosition$1,
	cameraProjectionMatrix: cameraProjectionMatrix,
	cameraProjectionMatrixInverse: cameraProjectionMatrixInverse,
	cameraViewMatrix: cameraViewMatrix,
	cameraWorldMatrix: cameraWorldMatrix,
	cbrt: cbrt,
	cdl: cdl,
	ceil: ceil,
	checker: checker,
	cineonToneMapping: cineonToneMapping,
	clamp: clamp,
	clearcoat: clearcoat,
	clearcoatRoughness: clearcoatRoughness,
	code: code,
	color: color$1,
	colorSpaceToWorking: colorSpaceToWorking,
	colorToDirection: colorToDirection,
	compute: compute,
	cond: cond,
	context: context,
	convert: convert,
	convertColorSpace: convertColorSpace,
	convertToTexture: convertToTexture,
	cos: cos$1,
	cross: cross,
	cubeTexture: cubeTexture,
	dFdx: dFdx,
	dFdy: dFdy,
	dashSize: dashSize,
	defaultBuildStages: defaultBuildStages,
	defaultShaderStages: defaultShaderStages,
	defined: defined,
	degrees: degrees,
	deltaTime: deltaTime,
	densityFog: densityFog,
	depth: depth,
	depthPass: depthPass,
	difference: difference,
	diffuseColor: diffuseColor,
	directPointLight: directPointLight,
	directionToColor: directionToColor,
	dispersion: dispersion,
	distance: distance$1,
	div: div$1,
	dodge: dodge,
	dot: dot$1,
	drawIndex: drawIndex,
	dynamicBufferAttribute: dynamicBufferAttribute,
	element: element,
	emissive: emissive,
	equal: equal,
	equals: equals,
	equirectUV: equirectUV,
	exp: exp$1,
	exp2: exp2,
	expression: expression,
	faceDirection: faceDirection,
	faceForward: faceForward,
	float: float$1,
	floor: floor$1,
	fog: fog,
	fract: fract$1,
	frameGroup: frameGroup,
	frameId: frameId,
	frontFacing: frontFacing,
	fwidth: fwidth,
	gain: gain,
	gapSize: gapSize,
	getConstNodeType: getConstNodeType,
	getCurrentStack: getCurrentStack,
	getDirection: getDirection,
	getDistanceAttenuation: getDistanceAttenuation,
	getGeometryRoughness: getGeometryRoughness,
	getNormalFromDepth: getNormalFromDepth,
	getParallaxCorrectNormal: getParallaxCorrectNormal,
	getRoughness: getRoughness,
	getScreenPosition: getScreenPosition,
	getShIrradianceAt: getShIrradianceAt,
	getTextureIndex: getTextureIndex,
	getViewPosition: getViewPosition,
	glsl: glsl,
	glslFn: glslFn,
	grayscale: grayscale,
	greaterThan: greaterThan,
	greaterThanEqual: greaterThanEqual,
	hash: hash,
	highPrecisionModelNormalViewMatrix: highPrecisionModelNormalViewMatrix,
	highPrecisionModelViewMatrix: highPrecisionModelViewMatrix,
	hue: hue,
	instance: instance,
	instanceIndex: instanceIndex,
	instancedArray: instancedArray,
	instancedBufferAttribute: instancedBufferAttribute,
	instancedDynamicBufferAttribute: instancedDynamicBufferAttribute,
	instancedMesh: instancedMesh,
	int: int,
	inverseSqrt: inverseSqrt,
	invocationLocalIndex: invocationLocalIndex,
	invocationSubgroupIndex: invocationSubgroupIndex,
	ior: ior,
	iridescence: iridescence,
	iridescenceIOR: iridescenceIOR,
	iridescenceThickness: iridescenceThickness,
	ivec2: ivec2,
	ivec3: ivec3,
	ivec4: ivec4,
	js: js,
	label: label,
	length: length,
	lengthSq: lengthSq,
	lessThan: lessThan,
	lessThanEqual: lessThanEqual,
	lightPosition: lightPosition,
	lightProjectionUV: lightProjectionUV,
	lightShadowMatrix: lightShadowMatrix,
	lightTargetDirection: lightTargetDirection,
	lightTargetPosition: lightTargetPosition,
	lightViewPosition: lightViewPosition,
	lightingContext: lightingContext,
	lights: lights,
	linearDepth: linearDepth,
	linearToneMapping: linearToneMapping,
	localId: localId,
	log: log,
	log2: log2,
	logarithmicDepthToViewZ: logarithmicDepthToViewZ,
	loop: loop,
	luminance: luminance,
	mat2: mat2,
	mat3: mat3,
	mat4: mat4,
	matcapUV: matcapUV,
	materialAOMap: materialAOMap,
	materialAlphaTest: materialAlphaTest,
	materialAnisotropy: materialAnisotropy,
	materialAnisotropyVector: materialAnisotropyVector,
	materialAttenuationColor: materialAttenuationColor,
	materialAttenuationDistance: materialAttenuationDistance,
	materialClearcoat: materialClearcoat,
	materialClearcoatNormal: materialClearcoatNormal,
	materialClearcoatRoughness: materialClearcoatRoughness,
	materialColor: materialColor,
	materialDispersion: materialDispersion,
	materialEmissive: materialEmissive,
	materialIOR: materialIOR,
	materialIridescence: materialIridescence,
	materialIridescenceIOR: materialIridescenceIOR,
	materialIridescenceThickness: materialIridescenceThickness,
	materialLightMap: materialLightMap,
	materialLineDashOffset: materialLineDashOffset,
	materialLineDashSize: materialLineDashSize,
	materialLineGapSize: materialLineGapSize,
	materialLineScale: materialLineScale,
	materialLineWidth: materialLineWidth,
	materialMetalness: materialMetalness,
	materialNormal: materialNormal,
	materialOpacity: materialOpacity,
	materialPointWidth: materialPointWidth,
	materialReference: materialReference,
	materialReflectivity: materialReflectivity,
	materialRefractionRatio: materialRefractionRatio,
	materialRotation: materialRotation,
	materialRoughness: materialRoughness,
	materialSheen: materialSheen,
	materialSheenRoughness: materialSheenRoughness,
	materialShininess: materialShininess,
	materialSpecular: materialSpecular,
	materialSpecularColor: materialSpecularColor,
	materialSpecularIntensity: materialSpecularIntensity,
	materialSpecularStrength: materialSpecularStrength,
	materialThickness: materialThickness,
	materialTransmission: materialTransmission,
	max: max$1,
	maxMipLevel: maxMipLevel,
	metalness: metalness,
	min: min$1,
	mix: mix$1,
	mixElement: mixElement,
	mod: mod,
	modInt: modInt,
	modelDirection: modelDirection,
	modelNormalMatrix: modelNormalMatrix,
	modelPosition: modelPosition,
	modelScale: modelScale,
	modelViewMatrix: modelViewMatrix,
	modelViewPosition: modelViewPosition,
	modelViewProjection: modelViewProjection,
	modelWorldMatrix: modelWorldMatrix,
	modelWorldMatrixInverse: modelWorldMatrixInverse,
	morphReference: morphReference,
	mrt: mrt,
	mul: mul$1,
	mx_aastep: mx_aastep,
	mx_cell_noise_float: mx_cell_noise_float,
	mx_contrast: mx_contrast,
	mx_fractal_noise_float: mx_fractal_noise_float,
	mx_fractal_noise_vec2: mx_fractal_noise_vec2,
	mx_fractal_noise_vec3: mx_fractal_noise_vec3,
	mx_fractal_noise_vec4: mx_fractal_noise_vec4,
	mx_hsvtorgb: mx_hsvtorgb,
	mx_noise_float: mx_noise_float$1,
	mx_noise_vec3: mx_noise_vec3,
	mx_noise_vec4: mx_noise_vec4,
	mx_ramplr: mx_ramplr,
	mx_ramptb: mx_ramptb,
	mx_rgbtohsv: mx_rgbtohsv,
	mx_safepower: mx_safepower,
	mx_splitlr: mx_splitlr,
	mx_splittb: mx_splittb,
	mx_srgb_texture_to_lin_rec709: mx_srgb_texture_to_lin_rec709,
	mx_transform_uv: mx_transform_uv,
	mx_worley_noise_float: mx_worley_noise_float,
	mx_worley_noise_vec2: mx_worley_noise_vec2,
	mx_worley_noise_vec3: mx_worley_noise_vec3,
	negate: negate,
	neutralToneMapping: neutralToneMapping,
	nodeArray: nodeArray,
	nodeImmutable: nodeImmutable,
	nodeObject: nodeObject,
	nodeObjects: nodeObjects,
	nodeProxy: nodeProxy,
	normalFlat: normalFlat,
	normalGeometry: normalGeometry,
	normalLocal: normalLocal,
	normalMap: normalMap,
	normalView: normalView$1,
	normalWorld: normalWorld$1,
	normalize: normalize$1,
	not: not,
	notEqual: notEqual,
	numWorkgroups: numWorkgroups,
	objectDirection: objectDirection,
	objectGroup: objectGroup,
	objectPosition: objectPosition,
	objectScale: objectScale,
	objectViewPosition: objectViewPosition,
	objectWorldMatrix: objectWorldMatrix,
	oneMinus: oneMinus,
	or: or,
	orthographicDepthToViewZ: orthographicDepthToViewZ,
	oscSawtooth: oscSawtooth,
	oscSine: oscSine,
	oscSquare: oscSquare,
	oscTriangle: oscTriangle,
	output: output,
	outputStruct: outputStruct,
	overlay: overlay,
	overloadingFn: overloadingFn,
	parabola: parabola,
	parallaxDirection: parallaxDirection,
	parallaxUV: parallaxUV,
	parameter: parameter,
	pass: pass,
	passTexture: passTexture,
	pcurve: pcurve,
	perspectiveDepthToViewZ: perspectiveDepthToViewZ,
	pmremTexture: pmremTexture,
	pointUV: pointUV,
	pointWidth: pointWidth,
	positionGeometry: positionGeometry,
	positionLocal: positionLocal$1,
	positionPrevious: positionPrevious,
	positionView: positionView$1,
	positionViewDirection: positionViewDirection,
	positionWorld: positionWorld$1,
	positionWorldDirection: positionWorldDirection,
	posterize: posterize,
	pow: pow$1,
	pow2: pow2,
	pow3: pow3,
	pow4: pow4,
	property: property,
	radians: radians,
	rand: rand,
	range: range,
	rangeFog: rangeFog,
	reciprocal: reciprocal,
	reference: reference,
	referenceBuffer: referenceBuffer,
	reflect: reflect,
	reflectVector: reflectVector,
	reflectView: reflectView,
	reflector: reflector,
	refract: refract,
	refractVector: refractVector,
	refractView: refractView,
	reinhardToneMapping: reinhardToneMapping,
	remainder: remainder,
	remap: remap,
	remapClamp: remapClamp,
	renderGroup: renderGroup,
	renderOutput: renderOutput,
	rendererReference: rendererReference,
	rotate: rotate,
	rotateUV: rotateUV,
	roughness: roughness,
	round: round,
	rtt: rtt,
	sRGBTransferEOTF: sRGBTransferEOTF,
	sRGBTransferOETF: sRGBTransferOETF,
	sampler: sampler,
	saturate: saturate,
	saturation: saturation,
	screen: screen,
	screenCoordinate: screenCoordinate,
	screenSize: screenSize,
	screenUV: screenUV,
	scriptable: scriptable,
	scriptableValue: scriptableValue,
	select: select,
	setCurrentStack: setCurrentStack,
	shaderStages: shaderStages,
	shadow: shadow,
	sharedUniformGroup: sharedUniformGroup,
	sheen: sheen,
	sheenRoughness: sheenRoughness,
	shiftLeft: shiftLeft,
	shiftRight: shiftRight,
	shininess: shininess,
	sign: sign,
	sin: sin$1,
	sinc: sinc,
	skinning: skinning,
	skinningReference: skinningReference,
	smoothstep: smoothstep$1,
	smoothstepElement: smoothstepElement,
	specularColor: specularColor,
	specularF90: specularF90,
	spherizeUV: spherizeUV,
	split: split,
	spritesheetUV: spritesheetUV,
	sqrt: sqrt,
	stack: stack,
	step: step,
	storage: storage,
	storageBarrier: storageBarrier,
	storageObject: storageObject,
	storageTexture: storageTexture,
	string: string,
	sub: sub$1,
	subgroupIndex: subgroupIndex,
	subgroupSize: subgroupSize,
	tan: tan,
	tangentGeometry: tangentGeometry,
	tangentLocal: tangentLocal,
	tangentView: tangentView,
	tangentWorld: tangentWorld,
	temp: temp,
	texture: texture,
	texture3D: texture3D,
	textureBarrier: textureBarrier,
	textureBicubic: textureBicubic,
	textureCubeUV: textureCubeUV,
	textureLoad: textureLoad,
	textureSize: textureSize,
	textureStore: textureStore,
	thickness: thickness,
	threshold: threshold,
	time: time$1,
	timerDelta: timerDelta,
	timerGlobal: timerGlobal,
	timerLocal: timerLocal,
	toOutputColorSpace: toOutputColorSpace,
	toWorkingColorSpace: toWorkingColorSpace,
	toneMapping: toneMapping,
	toneMappingExposure: toneMappingExposure,
	toonOutlinePass: toonOutlinePass,
	transformDirection: transformDirection,
	transformNormal: transformNormal,
	transformNormalToView: transformNormalToView,
	transformedBentNormalView: transformedBentNormalView,
	transformedBitangentView: transformedBitangentView,
	transformedBitangentWorld: transformedBitangentWorld,
	transformedClearcoatNormalView: transformedClearcoatNormalView,
	transformedNormalView: transformedNormalView,
	transformedNormalWorld: transformedNormalWorld,
	transformedTangentView: transformedTangentView,
	transformedTangentWorld: transformedTangentWorld,
	transmission: transmission,
	transpose: transpose,
	tri: tri,
	tri3: tri3,
	triNoise3D: triNoise3D,
	triplanarTexture: triplanarTexture,
	triplanarTextures: triplanarTextures,
	trunc: trunc,
	tslFn: tslFn,
	uint: uint,
	uniform: uniform$1,
	uniformArray: uniformArray,
	uniformGroup: uniformGroup,
	uniforms: uniforms,
	userData: userData,
	uv: uv$1,
	uvec2: uvec2,
	uvec3: uvec3,
	uvec4: uvec4,
	varying: varying,
	varyingProperty: varyingProperty,
	vec2: vec2$1,
	vec3: vec3$1,
	vec4: vec4$1,
	vectorComponents: vectorComponents,
	velocity: velocity,
	vertexColor: vertexColor,
	vertexIndex: vertexIndex,
	vibrance: vibrance,
	viewZToLogarithmicDepth: viewZToLogarithmicDepth,
	viewZToOrthographicDepth: viewZToOrthographicDepth,
	viewZToPerspectiveDepth: viewZToPerspectiveDepth,
	viewport: viewport,
	viewportBottomLeft: viewportBottomLeft,
	viewportCoordinate: viewportCoordinate,
	viewportDepthTexture: viewportDepthTexture,
	viewportLinearDepth: viewportLinearDepth,
	viewportMipTexture: viewportMipTexture,
	viewportResolution: viewportResolution,
	viewportSafeUV: viewportSafeUV,
	viewportSharedTexture: viewportSharedTexture,
	viewportSize: viewportSize,
	viewportTexture: viewportTexture,
	viewportTopLeft: viewportTopLeft,
	viewportUV: viewportUV,
	wgsl: wgsl,
	wgslFn: wgslFn,
	workgroupArray: workgroupArray,
	workgroupBarrier: workgroupBarrier,
	workgroupId: workgroupId,
	workingToColorSpace: workingToColorSpace,
	xor: xor
});

const _clearColor$1 = /*@__PURE__*/ new Color4();

class Background extends DataMap {

	constructor( renderer, nodes ) {

		super();

		this.renderer = renderer;
		this.nodes = nodes;

	}

	update( scene, renderList, renderContext ) {

		const renderer = this.renderer;
		const background = this.nodes.getBackgroundNode( scene ) || scene.background;

		let forceClear = false;

		if ( background === null ) {

			// no background settings, use clear color configuration from the renderer

			renderer._clearColor.getRGB( _clearColor$1, LinearSRGBColorSpace );
			_clearColor$1.a = renderer._clearColor.a;

		} else if ( background.isColor === true ) {

			// background is an opaque color

			background.getRGB( _clearColor$1, LinearSRGBColorSpace );
			_clearColor$1.a = 1;

			forceClear = true;

		} else if ( background.isNode === true ) {

			const sceneData = this.get( scene );
			const backgroundNode = background;

			_clearColor$1.copy( renderer._clearColor );

			let backgroundMesh = sceneData.backgroundMesh;

			if ( backgroundMesh === undefined ) {

				const backgroundMeshNode = context( vec4$1( backgroundNode ).mul( backgroundIntensity ), {
					// @TODO: Add Texture2D support using node context
					getUV: () => backgroundRotation.mul( normalWorld$1 ),
					getTextureLevel: () => backgroundBlurriness
				} );

				let viewProj = modelViewProjection();
				viewProj = viewProj.setZ( viewProj.w );

				const nodeMaterial = new NodeMaterial();
				nodeMaterial.name = 'Background.material';
				nodeMaterial.side = BackSide;
				nodeMaterial.depthTest = false;
				nodeMaterial.depthWrite = false;
				nodeMaterial.fog = false;
				nodeMaterial.lights = false;
				nodeMaterial.vertexNode = viewProj;
				nodeMaterial.colorNode = backgroundMeshNode;

				sceneData.backgroundMeshNode = backgroundMeshNode;
				sceneData.backgroundMesh = backgroundMesh = new Mesh( new SphereGeometry( 1, 32, 32 ), nodeMaterial );
				backgroundMesh.frustumCulled = false;
				backgroundMesh.name = 'Background.mesh';

				backgroundMesh.onBeforeRender = function ( renderer, scene, camera ) {

					this.matrixWorld.copyPosition( camera.matrixWorld );

				};

			}

			const backgroundCacheKey = backgroundNode.getCacheKey();

			if ( sceneData.backgroundCacheKey !== backgroundCacheKey ) {

				sceneData.backgroundMeshNode.node = vec4$1( backgroundNode ).mul( backgroundIntensity );
				sceneData.backgroundMeshNode.needsUpdate = true;

				backgroundMesh.material.needsUpdate = true;

				sceneData.backgroundCacheKey = backgroundCacheKey;

			}

			renderList.unshift( backgroundMesh, backgroundMesh.geometry, backgroundMesh.material, 0, 0, null, null );

		} else {

			console.error( 'THREE.Renderer: Unsupported background configuration.', background );

		}

		//

		if ( renderer.autoClear === true || forceClear === true ) {

			const clearColorValue = renderContext.clearColorValue;

			clearColorValue.r = _clearColor$1.r;
			clearColorValue.g = _clearColor$1.g;
			clearColorValue.b = _clearColor$1.b;
			clearColorValue.a = _clearColor$1.a;

			// premultiply alpha

			if ( renderer.backend.isWebGLBackend === true || renderer.alpha === true ) {

				clearColorValue.r *= clearColorValue.a;
				clearColorValue.g *= clearColorValue.a;
				clearColorValue.b *= clearColorValue.a;

			}

			//

			renderContext.depthClearValue = renderer._clearDepth;
			renderContext.stencilClearValue = renderer._clearStencil;

			renderContext.clearColor = renderer.autoClearColor === true;
			renderContext.clearDepth = renderer.autoClearDepth === true;
			renderContext.clearStencil = renderer.autoClearStencil === true;

		} else {

			renderContext.clearColor = false;
			renderContext.clearDepth = false;
			renderContext.clearStencil = false;

		}

	}

}

let _id$5 = 0;

class BindGroup {

	constructor( name = '', bindings = [], index = 0, bindingsReference = [] ) {

		this.name = name;
		this.bindings = bindings;
		this.index = index;
		this.bindingsReference = bindingsReference;

		this.id = _id$5 ++;

	}

}

class NodeBuilderState {

	constructor( vertexShader, fragmentShader, computeShader, nodeAttributes, bindings, updateNodes, updateBeforeNodes, updateAfterNodes, monitor, transforms = [] ) {

		this.vertexShader = vertexShader;
		this.fragmentShader = fragmentShader;
		this.computeShader = computeShader;
		this.transforms = transforms;

		this.nodeAttributes = nodeAttributes;
		this.bindings = bindings;

		this.updateNodes = updateNodes;
		this.updateBeforeNodes = updateBeforeNodes;
		this.updateAfterNodes = updateAfterNodes;

		this.monitor = monitor;

		this.usedTimes = 0;

	}

	createBindings() {

		const bindings = [];

		for ( const instanceGroup of this.bindings ) {

			const shared = instanceGroup.bindings[ 0 ].groupNode.shared;

			if ( shared !== true ) {

				const bindingsGroup = new BindGroup( instanceGroup.name, [], instanceGroup.index, instanceGroup );
				bindings.push( bindingsGroup );

				for ( const instanceBinding of instanceGroup.bindings ) {

					bindingsGroup.bindings.push( instanceBinding.clone() );

				}

			} else {

				bindings.push( instanceGroup );

			}

		}

		return bindings;

	}

}

class NodeAttribute {

	constructor( name, type, node = null ) {

		this.isNodeAttribute = true;

		this.name = name;
		this.type = type;
		this.node = node;

	}

}

class NodeUniform {

	constructor( name, type, node ) {

		this.isNodeUniform = true;

		this.name = name;
		this.type = type;
		this.node = node.getSelf();

	}

	get value() {

		return this.node.value;

	}

	set value( val ) {

		this.node.value = val;

	}

	get id() {

		return this.node.id;

	}

	get groupNode() {

		return this.node.groupNode;

	}

}

class NodeVar {

	constructor( name, type ) {

		this.isNodeVar = true;

		this.name = name;
		this.type = type;

	}

}

class NodeVarying extends NodeVar {

	constructor( name, type ) {

		super( name, type );

		this.needsInterpolation = false;

		this.isNodeVarying = true;

	}

}

class NodeCode {

	constructor( name, type, code = '' ) {

		this.name = name;
		this.type = type;
		this.code = code;

		Object.defineProperty( this, 'isNodeCode', { value: true } );

	}

}

let id = 0;

class NodeCache {

	constructor( parent = null ) {

		this.id = id ++;
		this.nodesData = new WeakMap();

		this.parent = parent;

	}

	getData( node ) {

		let data = this.nodesData.get( node );

		if ( data === undefined && this.parent !== null ) {

			data = this.parent.getData( node );

		}

		return data;

	}

	setData( node, data ) {

		this.nodesData.set( node, data );

	}

}

class Uniform {

	constructor( name, value ) {

		this.name = name;
		this.value = value;

		this.boundary = 0; // used to build the uniform buffer according to the STD140 layout
		this.itemSize = 0;

		this.offset = 0; // this property is set by WebGPUUniformsGroup and marks the start position in the uniform buffer

	}

	setValue( value ) {

		this.value = value;

	}

	getValue() {

		return this.value;

	}

}

class NumberUniform extends Uniform {

	constructor( name, value = 0 ) {

		super( name, value );

		this.isNumberUniform = true;

		this.boundary = 4;
		this.itemSize = 1;

	}

}

class Vector2Uniform extends Uniform {

	constructor( name, value = new Vector2() ) {

		super( name, value );

		this.isVector2Uniform = true;

		this.boundary = 8;
		this.itemSize = 2;

	}

}

class Vector3Uniform extends Uniform {

	constructor( name, value = new Vector3() ) {

		super( name, value );

		this.isVector3Uniform = true;

		this.boundary = 16;
		this.itemSize = 3;

	}

}

class Vector4Uniform extends Uniform {

	constructor( name, value = new Vector4() ) {

		super( name, value );

		this.isVector4Uniform = true;

		this.boundary = 16;
		this.itemSize = 4;

	}

}

class ColorUniform extends Uniform {

	constructor( name, value = new Color() ) {

		super( name, value );

		this.isColorUniform = true;

		this.boundary = 16;
		this.itemSize = 3;

	}

}

class Matrix3Uniform extends Uniform {

	constructor( name, value = new Matrix3() ) {

		super( name, value );

		this.isMatrix3Uniform = true;

		this.boundary = 48;
		this.itemSize = 12;

	}

}

class Matrix4Uniform extends Uniform {

	constructor( name, value = new Matrix4() ) {

		super( name, value );

		this.isMatrix4Uniform = true;

		this.boundary = 64;
		this.itemSize = 16;

	}

}

class NumberNodeUniform extends NumberUniform {

	constructor( nodeUniform ) {

		super( nodeUniform.name, nodeUniform.value );

		this.nodeUniform = nodeUniform;

	}

	getValue() {

		return this.nodeUniform.value;

	}

	getType() {

		return this.nodeUniform.type;

	}

}

class Vector2NodeUniform extends Vector2Uniform {

	constructor( nodeUniform ) {

		super( nodeUniform.name, nodeUniform.value );

		this.nodeUniform = nodeUniform;

	}

	getValue() {

		return this.nodeUniform.value;

	}

	getType() {

		return this.nodeUniform.type;

	}

}

class Vector3NodeUniform extends Vector3Uniform {

	constructor( nodeUniform ) {

		super( nodeUniform.name, nodeUniform.value );

		this.nodeUniform = nodeUniform;

	}

	getValue() {

		return this.nodeUniform.value;

	}

	getType() {

		return this.nodeUniform.type;

	}

}

class Vector4NodeUniform extends Vector4Uniform {

	constructor( nodeUniform ) {

		super( nodeUniform.name, nodeUniform.value );

		this.nodeUniform = nodeUniform;

	}

	getValue() {

		return this.nodeUniform.value;

	}

	getType() {

		return this.nodeUniform.type;

	}

}

class ColorNodeUniform extends ColorUniform {

	constructor( nodeUniform ) {

		super( nodeUniform.name, nodeUniform.value );

		this.nodeUniform = nodeUniform;

	}

	getValue() {

		return this.nodeUniform.value;

	}

	getType() {

		return this.nodeUniform.type;

	}

}

class Matrix3NodeUniform extends Matrix3Uniform {

	constructor( nodeUniform ) {

		super( nodeUniform.name, nodeUniform.value );

		this.nodeUniform = nodeUniform;

	}

	getValue() {

		return this.nodeUniform.value;

	}

	getType() {

		return this.nodeUniform.type;

	}

}

class Matrix4NodeUniform extends Matrix4Uniform {

	constructor( nodeUniform ) {

		super( nodeUniform.name, nodeUniform.value );

		this.nodeUniform = nodeUniform;

	}

	getValue() {

		return this.nodeUniform.value;

	}

	getType() {

		return this.nodeUniform.type;

	}

}

const LOD_MIN = 4;

// The standard deviations (radians) associated with the extra mips. These are
// chosen to approximate a Trowbridge-Reitz distribution function times the
// geometric shadowing function. These sigma values squared must match the
// variance #defines in cube_uv_reflection_fragment.glsl.js.
const EXTRA_LOD_SIGMA = [ 0.125, 0.215, 0.35, 0.446, 0.526, 0.582 ];

// The maximum length of the blur for loop. Smaller sigmas will use fewer
// samples and exit early, but not recompile the shader.
const MAX_SAMPLES = 20;

const _flatCamera = /*@__PURE__*/ new OrthographicCamera( -1, 1, 1, -1, 0, 1 );
const _cubeCamera = /*@__PURE__*/ new PerspectiveCamera( 90, 1 );
const _clearColor = /*@__PURE__*/ new Color();
let _oldTarget = null;
let _oldActiveCubeFace = 0;
let _oldActiveMipmapLevel = 0;

// Golden Ratio
const PHI = ( 1 + Math.sqrt( 5 ) ) / 2;
const INV_PHI = 1 / PHI;

// Vertices of a dodecahedron (except the opposites, which represent the
// same axis), used as axis directions evenly spread on a sphere.
const _axisDirections = [
	/*@__PURE__*/ new Vector3( - PHI, INV_PHI, 0 ),
	/*@__PURE__*/ new Vector3( PHI, INV_PHI, 0 ),
	/*@__PURE__*/ new Vector3( - INV_PHI, 0, PHI ),
	/*@__PURE__*/ new Vector3( INV_PHI, 0, PHI ),
	/*@__PURE__*/ new Vector3( 0, PHI, - INV_PHI ),
	/*@__PURE__*/ new Vector3( 0, PHI, INV_PHI ),
	/*@__PURE__*/ new Vector3( -1, 1, -1 ),
	/*@__PURE__*/ new Vector3( 1, 1, -1 ),
	/*@__PURE__*/ new Vector3( -1, 1, 1 ),
	/*@__PURE__*/ new Vector3( 1, 1, 1 )
];

//

// WebGPU Face indices
const _faceLib = [
	3, 1, 5,
	0, 4, 2
];

const direction = getDirection( uv$1(), attribute$1( 'faceIndex' ) ).normalize();
const outputDirection = vec3$1( direction.x, direction.y.negate(), direction.z );

/**
 * This class generates a Prefiltered, Mipmapped Radiance Environment Map
 * (PMREM) from a cubeMap environment texture. This allows different levels of
 * blur to be quickly accessed based on material roughness. It is packed into a
 * special CubeUV format that allows us to perform custom interpolation so that
 * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
 * chain, it only goes down to the LOD_MIN level (above), and then creates extra
 * even more filtered 'mips' at the same LOD_MIN resolution, associated with
 * higher roughness levels. In this way we maintain resolution to smoothly
 * interpolate diffuse lighting while limiting sampling computation.
 *
 * Paper: Fast, Accurate Image-Based Lighting
 * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view
*/

class PMREMGenerator {

	constructor( renderer ) {

		this._renderer = renderer;
		this._pingPongRenderTarget = null;

		this._lodMax = 0;
		this._cubeSize = 0;
		this._lodPlanes = [];
		this._sizeLods = [];
		this._sigmas = [];
		this._lodMeshes = [];

		this._blurMaterial = null;
		this._cubemapMaterial = null;
		this._equirectMaterial = null;
		this._backgroundBox = null;

	}

	get _hasInitialized() {

		return this._renderer.hasInitialized();

	}

	/**
	 * Generates a PMREM from a supplied Scene, which can be faster than using an
	 * image if networking bandwidth is low. Optional sigma specifies a blur radius
	 * in radians to be applied to the scene before PMREM generation. Optional near
	 * and far planes ensure the scene is rendered in its entirety (the cubeCamera
	 * is placed at the origin).
	 */
	fromScene( scene, sigma = 0, near = 0.1, far = 100, renderTarget = null ) {

		this._setSize( 256 );

		if ( this._hasInitialized === false ) {

			console.warn( 'THREE.PMREMGenerator: .fromScene() called before the backend is initialized. Try using .fromSceneAsync() instead.' );

			const cubeUVRenderTarget = renderTarget || this._allocateTargets();

			this.fromSceneAsync( scene, sigma, near, far, cubeUVRenderTarget );

			return cubeUVRenderTarget;

		}

		_oldTarget = this._renderer.getRenderTarget();
		_oldActiveCubeFace = this._renderer.getActiveCubeFace();
		_oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();

		const cubeUVRenderTarget = renderTarget || this._allocateTargets();
		cubeUVRenderTarget.depthBuffer = true;

		this._sceneToCubeUV( scene, near, far, cubeUVRenderTarget );

		if ( sigma > 0 ) {

			this._blur( cubeUVRenderTarget, 0, 0, sigma );

		}

		this._applyPMREM( cubeUVRenderTarget );

		this._cleanup( cubeUVRenderTarget );

		return cubeUVRenderTarget;

	}

	async fromSceneAsync( scene, sigma = 0, near = 0.1, far = 100, renderTarget = null ) {

		if ( this._hasInitialized === false ) await this._renderer.init();

		return this.fromScene( scene, sigma, near, far, renderTarget );

	}

	/**
	 * Generates a PMREM from an equirectangular texture, which can be either LDR
	 * or HDR. The ideal input image size is 1k (1024 x 512),
	 * as this matches best with the 256 x 256 cubemap output.
	 */
	fromEquirectangular( equirectangular, renderTarget = null ) {

		if ( this._hasInitialized === false ) {

			console.warn( 'THREE.PMREMGenerator: .fromEquirectangular() called before the backend is initialized. Try using .fromEquirectangularAsync() instead.' );

			this._setSizeFromTexture( equirectangular );

			const cubeUVRenderTarget = renderTarget || this._allocateTargets();

			this.fromEquirectangularAsync( equirectangular, cubeUVRenderTarget );

			return cubeUVRenderTarget;

		}

		return this._fromTexture( equirectangular, renderTarget );

	}

	async fromEquirectangularAsync( equirectangular, renderTarget = null ) {

		if ( this._hasInitialized === false ) await this._renderer.init();

		return this._fromTexture( equirectangular, renderTarget );

	}

	/**
	 * Generates a PMREM from an cubemap texture, which can be either LDR
	 * or HDR. The ideal input cube size is 256 x 256,
	 * as this matches best with the 256 x 256 cubemap output.
	 */
	fromCubemap( cubemap, renderTarget = null ) {

		if ( this._hasInitialized === false ) {

			console.warn( 'THREE.PMREMGenerator: .fromCubemap() called before the backend is initialized. Try using .fromCubemapAsync() instead.' );

			this._setSizeFromTexture( cubemap );

			const cubeUVRenderTarget = renderTarget || this._allocateTargets();

			this.fromCubemapAsync( cubemap, renderTarget );

			return cubeUVRenderTarget;

		}

		return this._fromTexture( cubemap, renderTarget );

	}

	async fromCubemapAsync( cubemap, renderTarget = null ) {

		if ( this._hasInitialized === false ) await this._renderer.init();

		return this._fromTexture( cubemap, renderTarget );

	}

	/**
	 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */
	async compileCubemapShader() {

		if ( this._cubemapMaterial === null ) {

			this._cubemapMaterial = _getCubemapMaterial();
			await this._compileMaterial( this._cubemapMaterial );

		}

	}

	/**
	 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */
	async compileEquirectangularShader() {

		if ( this._equirectMaterial === null ) {

			this._equirectMaterial = _getEquirectMaterial();
			await this._compileMaterial( this._equirectMaterial );

		}

	}

	/**
	 * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
	 * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
	 * one of them will cause any others to also become unusable.
	 */
	dispose() {

		this._dispose();

		if ( this._cubemapMaterial !== null ) this._cubemapMaterial.dispose();
		if ( this._equirectMaterial !== null ) this._equirectMaterial.dispose();
		if ( this._backgroundBox !== null ) {

			this._backgroundBox.geometry.dispose();
			this._backgroundBox.material.dispose();

		}

	}

	// private interface

	_setSizeFromTexture( texture ) {

		if ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping ) {

			this._setSize( texture.image.length === 0 ? 16 : ( texture.image[ 0 ].width || texture.image[ 0 ].image.width ) );

		} else { // Equirectangular

			this._setSize( texture.image.width / 4 );

		}

	}

	_setSize( cubeSize ) {

		this._lodMax = Math.floor( Math.log2( cubeSize ) );
		this._cubeSize = Math.pow( 2, this._lodMax );

	}

	_dispose() {

		if ( this._blurMaterial !== null ) this._blurMaterial.dispose();

		if ( this._pingPongRenderTarget !== null ) this._pingPongRenderTarget.dispose();

		for ( let i = 0; i < this._lodPlanes.length; i ++ ) {

			this._lodPlanes[ i ].dispose();

		}

	}

	_cleanup( outputTarget ) {

		this._renderer.setRenderTarget( _oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel );
		outputTarget.scissorTest = false;
		_setViewport( outputTarget, 0, 0, outputTarget.width, outputTarget.height );

	}

	_fromTexture( texture, renderTarget ) {

		this._setSizeFromTexture( texture );

		_oldTarget = this._renderer.getRenderTarget();
		_oldActiveCubeFace = this._renderer.getActiveCubeFace();
		_oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();

		const cubeUVRenderTarget = renderTarget || this._allocateTargets();
		this._textureToCubeUV( texture, cubeUVRenderTarget );
		this._applyPMREM( cubeUVRenderTarget );
		this._cleanup( cubeUVRenderTarget );

		return cubeUVRenderTarget;

	}

	_allocateTargets() {

		const width = 3 * Math.max( this._cubeSize, 16 * 7 );
		const height = 4 * this._cubeSize;

		const params = {
			magFilter: LinearFilter,
			minFilter: LinearFilter,
			generateMipmaps: false,
			type: HalfFloatType,
			format: RGBAFormat,
			colorSpace: LinearSRGBColorSpace,
			//depthBuffer: false
		};

		const cubeUVRenderTarget = _createRenderTarget( width, height, params );

		if ( this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width || this._pingPongRenderTarget.height !== height ) {

			if ( this._pingPongRenderTarget !== null ) {

				this._dispose();

			}

			this._pingPongRenderTarget = _createRenderTarget( width, height, params );

			const { _lodMax } = this;
			( { sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas, lodMeshes: this._lodMeshes } = _createPlanes( _lodMax ) );

			this._blurMaterial = _getBlurShader( _lodMax, width, height );

		}

		return cubeUVRenderTarget;

	}

	async _compileMaterial( material ) {

		const tmpMesh = new Mesh( this._lodPlanes[ 0 ], material );
		await this._renderer.compile( tmpMesh, _flatCamera );

	}

	_sceneToCubeUV( scene, near, far, cubeUVRenderTarget ) {

		const cubeCamera = _cubeCamera;
		cubeCamera.near = near;
		cubeCamera.far = far;

		// px, py, pz, nx, ny, nz
		const upSign = [ -1, 1, -1, -1, -1, -1 ];
		const forwardSign = [ 1, 1, 1, -1, -1, -1 ];

		const renderer = this._renderer;

		const originalAutoClear = renderer.autoClear;

		renderer.getClearColor( _clearColor );

		renderer.autoClear = false;

		let backgroundBox = this._backgroundBox;

		if ( backgroundBox === null ) {

			const backgroundMaterial = new MeshBasicMaterial( {
				name: 'PMREM.Background',
				side: BackSide,
				depthWrite: false,
				depthTest: false
			} );

			backgroundBox = new Mesh( new BoxGeometry(), backgroundMaterial );

		}

		let useSolidColor = false;
		const background = scene.background;

		if ( background ) {

			if ( background.isColor ) {

				backgroundBox.material.color.copy( background );
				scene.background = null;
				useSolidColor = true;

			}

		} else {

			backgroundBox.material.color.copy( _clearColor );
			useSolidColor = true;

		}

		renderer.setRenderTarget( cubeUVRenderTarget );

		renderer.clear();

		if ( useSolidColor ) {

			renderer.render( backgroundBox, cubeCamera );

		}

		for ( let i = 0; i < 6; i ++ ) {

			const col = i % 3;

			if ( col === 0 ) {

				cubeCamera.up.set( 0, upSign[ i ], 0 );
				cubeCamera.lookAt( forwardSign[ i ], 0, 0 );

			} else if ( col === 1 ) {

				cubeCamera.up.set( 0, 0, upSign[ i ] );
				cubeCamera.lookAt( 0, forwardSign[ i ], 0 );

			} else {

				cubeCamera.up.set( 0, upSign[ i ], 0 );
				cubeCamera.lookAt( 0, 0, forwardSign[ i ] );

			}

			const size = this._cubeSize;

			_setViewport( cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size );

			renderer.render( scene, cubeCamera );

		}

		renderer.autoClear = originalAutoClear;
		scene.background = background;

	}

	_textureToCubeUV( texture, cubeUVRenderTarget ) {

		const renderer = this._renderer;

		const isCubeTexture = ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping );

		if ( isCubeTexture ) {

			if ( this._cubemapMaterial === null ) {

				this._cubemapMaterial = _getCubemapMaterial( texture );

			}

		} else {

			if ( this._equirectMaterial === null ) {

				this._equirectMaterial = _getEquirectMaterial( texture );

			}

		}

		const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
		material.fragmentNode.value = texture;

		const mesh = this._lodMeshes[ 0 ];
		mesh.material = material;

		const size = this._cubeSize;

		_setViewport( cubeUVRenderTarget, 0, 0, 3 * size, 2 * size );

		renderer.setRenderTarget( cubeUVRenderTarget );
		renderer.render( mesh, _flatCamera );

	}

	_applyPMREM( cubeUVRenderTarget ) {

		const renderer = this._renderer;
		const autoClear = renderer.autoClear;
		renderer.autoClear = false;
		const n = this._lodPlanes.length;

		for ( let i = 1; i < n; i ++ ) {

			const sigma = Math.sqrt( this._sigmas[ i ] * this._sigmas[ i ] - this._sigmas[ i - 1 ] * this._sigmas[ i - 1 ] );

			const poleAxis = _axisDirections[ ( n - i - 1 ) % _axisDirections.length ];

			this._blur( cubeUVRenderTarget, i - 1, i, sigma, poleAxis );

		}

		renderer.autoClear = autoClear;

	}

	/**
	 * This is a two-pass Gaussian blur for a cubemap. Normally this is done
	 * vertically and horizontally, but this breaks down on a cube. Here we apply
	 * the blur latitudinally (around the poles), and then longitudinally (towards
	 * the poles) to approximate the orthogonally-separable blur. It is least
	 * accurate at the poles, but still does a decent job.
	 */
	_blur( cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis ) {

		const pingPongRenderTarget = this._pingPongRenderTarget;

		this._halfBlur(
			cubeUVRenderTarget,
			pingPongRenderTarget,
			lodIn,
			lodOut,
			sigma,
			'latitudinal',
			poleAxis );

		this._halfBlur(
			pingPongRenderTarget,
			cubeUVRenderTarget,
			lodOut,
			lodOut,
			sigma,
			'longitudinal',
			poleAxis );

	}

	_halfBlur( targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis ) {

		const renderer = this._renderer;
		const blurMaterial = this._blurMaterial;

		if ( direction !== 'latitudinal' && direction !== 'longitudinal' ) {

			console.error( 'blur direction must be either latitudinal or longitudinal!' );

		}

		// Number of standard deviations at which to cut off the discrete approximation.
		const STANDARD_DEVIATIONS = 3;

		const blurMesh = this._lodMeshes[ lodOut ];
		blurMesh.material = blurMaterial;

		const blurUniforms = blurMaterial.uniforms;

		const pixels = this._sizeLods[ lodIn ] - 1;
		const radiansPerPixel = isFinite( sigmaRadians ) ? Math.PI / ( 2 * pixels ) : 2 * Math.PI / ( 2 * MAX_SAMPLES - 1 );
		const sigmaPixels = sigmaRadians / radiansPerPixel;
		const samples = isFinite( sigmaRadians ) ? 1 + Math.floor( STANDARD_DEVIATIONS * sigmaPixels ) : MAX_SAMPLES;

		if ( samples > MAX_SAMPLES ) {

			console.warn( `sigmaRadians, ${
				sigmaRadians}, is too large and will clip, as it requested ${
				samples} samples when the maximum is set to ${MAX_SAMPLES}` );

		}

		const weights = [];
		let sum = 0;

		for ( let i = 0; i < MAX_SAMPLES; ++ i ) {

			const x = i / sigmaPixels;
			const weight = Math.exp( - x * x / 2 );
			weights.push( weight );

			if ( i === 0 ) {

				sum += weight;

			} else if ( i < samples ) {

				sum += 2 * weight;

			}

		}

		for ( let i = 0; i < weights.length; i ++ ) {

			weights[ i ] = weights[ i ] / sum;

		}

		targetIn.texture.frame = ( targetIn.texture.frame || 0 ) + 1;

		blurUniforms.envMap.value = targetIn.texture;
		blurUniforms.samples.value = samples;
		blurUniforms.weights.array = weights;
		blurUniforms.latitudinal.value = direction === 'latitudinal' ? 1 : 0;

		if ( poleAxis ) {

			blurUniforms.poleAxis.value = poleAxis;

		}

		const { _lodMax } = this;
		blurUniforms.dTheta.value = radiansPerPixel;
		blurUniforms.mipInt.value = _lodMax - lodIn;

		const outputSize = this._sizeLods[ lodOut ];
		const x = 3 * outputSize * ( lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0 );
		const y = 4 * ( this._cubeSize - outputSize );

		_setViewport( targetOut, x, y, 3 * outputSize, 2 * outputSize );
		renderer.setRenderTarget( targetOut );
		renderer.render( blurMesh, _flatCamera );

	}

}

function _createPlanes( lodMax ) {

	const lodPlanes = [];
	const sizeLods = [];
	const sigmas = [];
	const lodMeshes = [];

	let lod = lodMax;

	const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;

	for ( let i = 0; i < totalLods; i ++ ) {

		const sizeLod = Math.pow( 2, lod );
		sizeLods.push( sizeLod );
		let sigma = 1.0 / sizeLod;

		if ( i > lodMax - LOD_MIN ) {

			sigma = EXTRA_LOD_SIGMA[ i - lodMax + LOD_MIN - 1 ];

		} else if ( i === 0 ) {

			sigma = 0;

		}

		sigmas.push( sigma );

		const texelSize = 1.0 / ( sizeLod - 2 );
		const min = - texelSize;
		const max = 1 + texelSize;
		const uv1 = [ min, min, max, min, max, max, min, min, max, max, min, max ];

		const cubeFaces = 6;
		const vertices = 6;
		const positionSize = 3;
		const uvSize = 2;
		const faceIndexSize = 1;

		const position = new Float32Array( positionSize * vertices * cubeFaces );
		const uv = new Float32Array( uvSize * vertices * cubeFaces );
		const faceIndex = new Float32Array( faceIndexSize * vertices * cubeFaces );

		for ( let face = 0; face < cubeFaces; face ++ ) {

			const x = ( face % 3 ) * 2 / 3 - 1;
			const y = face > 2 ? 0 : -1;
			const coordinates = [
				x, y, 0,
				x + 2 / 3, y, 0,
				x + 2 / 3, y + 1, 0,
				x, y, 0,
				x + 2 / 3, y + 1, 0,
				x, y + 1, 0
			];

			const faceIdx = _faceLib[ face ];
			position.set( coordinates, positionSize * vertices * faceIdx );
			uv.set( uv1, uvSize * vertices * faceIdx );
			const fill = [ faceIdx, faceIdx, faceIdx, faceIdx, faceIdx, faceIdx ];
			faceIndex.set( fill, faceIndexSize * vertices * faceIdx );

		}

		const planes = new BufferGeometry();
		planes.setAttribute( 'position', new BufferAttribute( position, positionSize ) );
		planes.setAttribute( 'uv', new BufferAttribute( uv, uvSize ) );
		planes.setAttribute( 'faceIndex', new BufferAttribute( faceIndex, faceIndexSize ) );
		lodPlanes.push( planes );
		lodMeshes.push( new Mesh( planes, null ) );

		if ( lod > LOD_MIN ) {

			lod --;

		}

	}

	return { lodPlanes, sizeLods, sigmas, lodMeshes };

}

function _createRenderTarget( width, height, params ) {

	const cubeUVRenderTarget = new RenderTarget( width, height, params );
	cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
	cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
	cubeUVRenderTarget.texture.isPMREMTexture = true;
	cubeUVRenderTarget.scissorTest = true;
	return cubeUVRenderTarget;

}

function _setViewport( target, x, y, width, height ) {

	target.viewport.set( x, y, width, height );
	target.scissor.set( x, y, width, height );

}

function _getMaterial( type ) {

	const material = new NodeMaterial();
	material.depthTest = false;
	material.depthWrite = false;
	material.blending = NoBlending;
	material.name = `PMREM_${ type }`;

	return material;

}

function _getBlurShader( lodMax, width, height ) {

	const weights = uniformArray( new Array( MAX_SAMPLES ).fill( 0 ) );
	const poleAxis = uniform$1( new Vector3( 0, 1, 0 ) );
	const dTheta = uniform$1( 0 );
	const n = float$1( MAX_SAMPLES );
	const latitudinal = uniform$1( 0 ); // false, bool
	const samples = uniform$1( 1 ); // int
	const envMap = texture( null );
	const mipInt = uniform$1( 0 ); // int
	const CUBEUV_TEXEL_WIDTH = float$1( 1 / width );
	const CUBEUV_TEXEL_HEIGHT = float$1( 1 / height );
	const CUBEUV_MAX_MIP = float$1( lodMax );

	const materialUniforms = {
		n,
		latitudinal,
		weights,
		poleAxis,
		outputDirection,
		dTheta,
		samples,
		envMap,
		mipInt,
		CUBEUV_TEXEL_WIDTH,
		CUBEUV_TEXEL_HEIGHT,
		CUBEUV_MAX_MIP
	};

	const material = _getMaterial( 'blur' );
	material.uniforms = materialUniforms; // TODO: Move to outside of the material
	material.fragmentNode = blur( { ...materialUniforms, latitudinal: latitudinal.equal( 1 ) } );

	return material;

}

function _getCubemapMaterial( envTexture ) {

	const material = _getMaterial( 'cubemap' );
	material.fragmentNode = cubeTexture( envTexture, outputDirection );

	return material;

}

function _getEquirectMaterial( envTexture ) {

	const material = _getMaterial( 'equirect' );
	material.fragmentNode = texture( envTexture, equirectUV( outputDirection ), 0 );

	return material;

}

const rendererCache = new WeakMap();

const typeFromArray = new Map( [
	[ Int8Array, 'int' ],
	[ Int16Array, 'int' ],
	[ Int32Array, 'int' ],
	[ Uint8Array, 'uint' ],
	[ Uint16Array, 'uint' ],
	[ Uint32Array, 'uint' ],
	[ Float32Array, 'float' ]
] );

const toFloat = ( value ) => {

	if ( /e/g.test( value ) ) {

		return String( value ).replace( /\+/g, '' );

	} else {

		value = Number( value );

		return value + ( value % 1 ? '' : '.0' );

	}

};

class NodeBuilder {

	constructor( object, renderer, parser ) {

		this.object = object;
		this.material = ( object && object.material ) || null;
		this.geometry = ( object && object.geometry ) || null;
		this.renderer = renderer;
		this.parser = parser;
		this.scene = null;
		this.camera = null;

		this.nodes = [];
		this.sequentialNodes = [];
		this.updateNodes = [];
		this.updateBeforeNodes = [];
		this.updateAfterNodes = [];
		this.hashNodes = {};

		this.monitor = null;

		this.lightsNode = null;
		this.environmentNode = null;
		this.fogNode = null;

		this.clippingContext = null;

		this.vertexShader = null;
		this.fragmentShader = null;
		this.computeShader = null;

		this.flowNodes = { vertex: [], fragment: [], compute: [] };
		this.flowCode = { vertex: '', fragment: '', compute: '' };
		this.uniforms = { vertex: [], fragment: [], compute: [], index: 0 };
		this.structs = { vertex: [], fragment: [], compute: [], index: 0 };
		this.bindings = { vertex: {}, fragment: {}, compute: {} };
		this.bindingsIndexes = {};
		this.bindGroups = null;
		this.attributes = [];
		this.bufferAttributes = [];
		this.varyings = [];
		this.codes = {};
		this.vars = {};
		this.flow = { code: '' };
		this.chaining = [];
		this.stack = stack();
		this.stacks = [];
		this.tab = '\t';

		this.currentFunctionNode = null;

		this.context = {
			material: this.material
		};

		this.cache = new NodeCache();
		this.globalCache = this.cache;

		this.flowsData = new WeakMap();

		this.shaderStage = null;
		this.buildStage = null;

		this.useComparisonMethod = false;

	}

	getBindGroupsCache() {

		let bindGroupsCache = rendererCache.get( this.renderer );

		if ( bindGroupsCache === undefined ) {

			bindGroupsCache = new ChainMap();

			rendererCache.set( this.renderer, bindGroupsCache );

		}

		return bindGroupsCache;

	}

	createRenderTarget( width, height, options ) {

		return new RenderTarget( width, height, options );

	}

	createCubeRenderTarget( size, options ) {

		return new CubeRenderTarget( size, options );

	}

	createPMREMGenerator() {

		// TODO: Move Materials.js to outside of the Nodes.js in order to remove this function and improve tree-shaking support

		return new PMREMGenerator( this.renderer );

	}

	includes( node ) {

		return this.nodes.includes( node );

	}

	_getBindGroup( groupName, bindings ) {

		const bindGroupsCache = this.getBindGroupsCache();

		//

		const bindingsArray = [];

		let sharedGroup = true;

		for ( const binding of bindings ) {

			bindingsArray.push( binding );

			sharedGroup = sharedGroup && binding.groupNode.shared !== true;

		}

		//

		let bindGroup;

		if ( sharedGroup ) {

			bindGroup = bindGroupsCache.get( bindingsArray );

			if ( bindGroup === undefined ) {

				bindGroup = new BindGroup( groupName, bindingsArray, this.bindingsIndexes[ groupName ].group, bindingsArray );

				bindGroupsCache.set( bindingsArray, bindGroup );

			}

		} else {

			bindGroup = new BindGroup( groupName, bindingsArray, this.bindingsIndexes[ groupName ].group, bindingsArray );

		}

		return bindGroup;

	}

	getBindGroupArray( groupName, shaderStage ) {

		const bindings = this.bindings[ shaderStage ];

		let bindGroup = bindings[ groupName ];

		if ( bindGroup === undefined ) {

			if ( this.bindingsIndexes[ groupName ] === undefined ) {

				this.bindingsIndexes[ groupName ] = { binding: 0, group: Object.keys( this.bindingsIndexes ).length };

			}

			bindings[ groupName ] = bindGroup = [];

		}

		return bindGroup;

	}

	getBindings() {

		let bindingsGroups = this.bindGroups;

		if ( bindingsGroups === null ) {

			const groups = {};
			const bindings = this.bindings;

			for ( const shaderStage of shaderStages ) {

				for ( const groupName in bindings[ shaderStage ] ) {

					const uniforms = bindings[ shaderStage ][ groupName ];

					const groupUniforms = groups[ groupName ] || ( groups[ groupName ] = [] );
					groupUniforms.push( ...uniforms );

				}

			}

			bindingsGroups = [];

			for ( const groupName in groups ) {

				const group = groups[ groupName ];

				const bindingsGroup = this._getBindGroup( groupName, group );

				bindingsGroups.push( bindingsGroup );

			}

			this.bindGroups = bindingsGroups;

		}

		return bindingsGroups;

	}

	sortBindingGroups() {

		const bindingsGroups = this.getBindings();

		bindingsGroups.sort( ( a, b ) => ( a.bindings[ 0 ].groupNode.order - b.bindings[ 0 ].groupNode.order ) );

		for ( let i = 0; i < bindingsGroups.length; i ++ ) {

			const bindingGroup = bindingsGroups[ i ];
			this.bindingsIndexes[ bindingGroup.name ].group = i;

			bindingGroup.index = i;

		}

	}

	setHashNode( node, hash ) {

		this.hashNodes[ hash ] = node;

	}

	addNode( node ) {

		if ( this.nodes.includes( node ) === false ) {

			this.nodes.push( node );

			this.setHashNode( node, node.getHash( this ) );

		}

	}

	addSequentialNode( node ) {

		if ( this.sequentialNodes.includes( node ) === false ) {

			this.sequentialNodes.push( node );

		}

	}

	buildUpdateNodes() {

		for ( const node of this.nodes ) {

			const updateType = node.getUpdateType();

			if ( updateType !== NodeUpdateType.NONE ) {

				this.updateNodes.push( node.getSelf() );

			}

		}

		for ( const node of this.sequentialNodes ) {

			const updateBeforeType = node.getUpdateBeforeType();
			const updateAfterType = node.getUpdateAfterType();

			if ( updateBeforeType !== NodeUpdateType.NONE ) {

				this.updateBeforeNodes.push( node.getSelf() );

			}

			if ( updateAfterType !== NodeUpdateType.NONE ) {

				this.updateAfterNodes.push( node.getSelf() );

			}

		}

	}

	get currentNode() {

		return this.chaining[ this.chaining.length - 1 ];

	}

	isFilteredTexture( texture ) {

		return ( texture.magFilter === LinearFilter || texture.magFilter === LinearMipmapNearestFilter || texture.magFilter === NearestMipmapLinearFilter || texture.magFilter === LinearMipmapLinearFilter ||
			texture.minFilter === LinearFilter || texture.minFilter === LinearMipmapNearestFilter || texture.minFilter === NearestMipmapLinearFilter || texture.minFilter === LinearMipmapLinearFilter );

	}

	addChain( node ) {

		/*
		if ( this.chaining.indexOf( node ) !== - 1 ) {

			console.warn( 'Recursive node: ', node );

		}
		*/

		this.chaining.push( node );

	}

	removeChain( node ) {

		const lastChain = this.chaining.pop();

		if ( lastChain !== node ) {

			throw new Error( 'NodeBuilder: Invalid node chaining!' );

		}

	}

	getMethod( method ) {

		return method;

	}

	getNodeFromHash( hash ) {

		return this.hashNodes[ hash ];

	}

	addFlow( shaderStage, node ) {

		this.flowNodes[ shaderStage ].push( node );

		return node;

	}

	setContext( context ) {

		this.context = context;

	}

	getContext() {

		return this.context;

	}

	getSharedContext() {

		({ ...this.context });

		return this.context;

	}

	setCache( cache ) {

		this.cache = cache;

	}

	getCache() {

		return this.cache;

	}

	getCacheFromNode( node, parent = true ) {

		const data = this.getDataFromNode( node );
		if ( data.cache === undefined ) data.cache = new NodeCache( parent ? this.getCache() : null );

		return data.cache;

	}

	isAvailable( /*name*/ ) {

		return false;

	}

	getVertexIndex() {

		console.warn( 'Abstract function.' );

	}

	getInstanceIndex() {

		console.warn( 'Abstract function.' );

	}

	getDrawIndex() {

		console.warn( 'Abstract function.' );

	}

	getFrontFacing() {

		console.warn( 'Abstract function.' );

	}

	getFragCoord() {

		console.warn( 'Abstract function.' );

	}

	isFlipY() {

		return false;

	}

	increaseUsage( node ) {

		const nodeData = this.getDataFromNode( node );
		nodeData.usageCount = nodeData.usageCount === undefined ? 1 : nodeData.usageCount + 1;

		return nodeData.usageCount;

	}

	generateTexture( /* texture, textureProperty, uvSnippet */ ) {

		console.warn( 'Abstract function.' );

	}

	generateTextureLod( /* texture, textureProperty, uvSnippet, levelSnippet */ ) {

		console.warn( 'Abstract function.' );

	}

	generateConst( type, value = null ) {

		if ( value === null ) {

			if ( type === 'float' || type === 'int' || type === 'uint' ) value = 0;
			else if ( type === 'bool' ) value = false;
			else if ( type === 'color' ) value = new Color();
			else if ( type === 'vec2' ) value = new Vector2();
			else if ( type === 'vec3' ) value = new Vector3();
			else if ( type === 'vec4' ) value = new Vector4();

		}

		if ( type === 'float' ) return toFloat( value );
		if ( type === 'int' ) return `${ Math.round( value ) }`;
		if ( type === 'uint' ) return value >= 0 ? `${ Math.round( value ) }u` : '0u';
		if ( type === 'bool' ) return value ? 'true' : 'false';
		if ( type === 'color' ) return `${ this.getType( 'vec3' ) }( ${ toFloat( value.r ) }, ${ toFloat( value.g ) }, ${ toFloat( value.b ) } )`;

		const typeLength = this.getTypeLength( type );

		const componentType = this.getComponentType( type );

		const generateConst = value => this.generateConst( componentType, value );

		if ( typeLength === 2 ) {

			return `${ this.getType( type ) }( ${ generateConst( value.x ) }, ${ generateConst( value.y ) } )`;

		} else if ( typeLength === 3 ) {

			return `${ this.getType( type ) }( ${ generateConst( value.x ) }, ${ generateConst( value.y ) }, ${ generateConst( value.z ) } )`;

		} else if ( typeLength === 4 ) {

			return `${ this.getType( type ) }( ${ generateConst( value.x ) }, ${ generateConst( value.y ) }, ${ generateConst( value.z ) }, ${ generateConst( value.w ) } )`;

		} else if ( typeLength > 4 && value && ( value.isMatrix3 || value.isMatrix4 ) ) {

			return `${ this.getType( type ) }( ${ value.elements.map( generateConst ).join( ', ' ) } )`;

		} else if ( typeLength > 4 ) {

			return `${ this.getType( type ) }()`;

		}

		throw new Error( `NodeBuilder: Type '${type}' not found in generate constant attempt.` );

	}

	getType( type ) {

		if ( type === 'color' ) return 'vec3';

		return type;

	}

	hasGeometryAttribute( name ) {

		return this.geometry && this.geometry.getAttribute( name ) !== undefined;

	}

	getAttribute( name, type ) {

		const attributes = this.attributes;

		// find attribute

		for ( const attribute of attributes ) {

			if ( attribute.name === name ) {

				return attribute;

			}

		}

		// create a new if no exist

		const attribute = new NodeAttribute( name, type );

		attributes.push( attribute );

		return attribute;

	}

	getPropertyName( node/*, shaderStage*/ ) {

		return node.name;

	}

	isVector( type ) {

		return /vec\d/.test( type );

	}

	isMatrix( type ) {

		return /mat\d/.test( type );

	}

	isReference( type ) {

		return type === 'void' || type === 'property' || type === 'sampler' || type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'depthTexture' || type === 'texture3D';

	}

	needsToWorkingColorSpace( /*texture*/ ) {

		return false;

	}

	getComponentTypeFromTexture( texture ) {

		const type = texture.type;

		if ( texture.isDataTexture ) {

			if ( type === IntType ) return 'int';
			if ( type === UnsignedIntType ) return 'uint';

		}

		return 'float';

	}

	getElementType( type ) {

		if ( type === 'mat2' ) return 'vec2';
		if ( type === 'mat3' ) return 'vec3';
		if ( type === 'mat4' ) return 'vec4';

		return this.getComponentType( type );

	}

	getComponentType( type ) {

		type = this.getVectorType( type );

		if ( type === 'float' || type === 'bool' || type === 'int' || type === 'uint' ) return type;

		const componentType = /(b|i|u|)(vec|mat)([2-4])/.exec( type );

		if ( componentType === null ) return null;

		if ( componentType[ 1 ] === 'b' ) return 'bool';
		if ( componentType[ 1 ] === 'i' ) return 'int';
		if ( componentType[ 1 ] === 'u' ) return 'uint';

		return 'float';

	}

	getVectorType( type ) {

		if ( type === 'color' ) return 'vec3';
		if ( type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D' ) return 'vec4';

		return type;

	}

	getTypeFromLength( length, componentType = 'float' ) {

		if ( length === 1 ) return componentType;

		const baseType = getTypeFromLength( length );
		const prefix = componentType === 'float' ? '' : componentType[ 0 ];

		return prefix + baseType;

	}

	getTypeFromArray( array ) {

		return typeFromArray.get( array.constructor );

	}

	getTypeFromAttribute( attribute ) {

		let dataAttribute = attribute;

		if ( attribute.isInterleavedBufferAttribute ) dataAttribute = attribute.data;

		const array = dataAttribute.array;
		const itemSize = attribute.itemSize;
		const normalized = attribute.normalized;

		let arrayType;

		if ( ! ( attribute instanceof Float16BufferAttribute ) && normalized !== true ) {

			arrayType = this.getTypeFromArray( array );

		}

		return this.getTypeFromLength( itemSize, arrayType );

	}

	getTypeLength( type ) {

		const vecType = this.getVectorType( type );
		const vecNum = /vec([2-4])/.exec( vecType );

		if ( vecNum !== null ) return Number( vecNum[ 1 ] );
		if ( vecType === 'float' || vecType === 'bool' || vecType === 'int' || vecType === 'uint' ) return 1;
		if ( /mat2/.test( type ) === true ) return 4;
		if ( /mat3/.test( type ) === true ) return 9;
		if ( /mat4/.test( type ) === true ) return 16;

		return 0;

	}

	getVectorFromMatrix( type ) {

		return type.replace( 'mat', 'vec' );

	}

	changeComponentType( type, newComponentType ) {

		return this.getTypeFromLength( this.getTypeLength( type ), newComponentType );

	}

	getIntegerType( type ) {

		const componentType = this.getComponentType( type );

		if ( componentType === 'int' || componentType === 'uint' ) return type;

		return this.changeComponentType( type, 'int' );

	}

	addStack() {

		this.stack = stack( this.stack );

		this.stacks.push( getCurrentStack() || this.stack );
		setCurrentStack( this.stack );

		return this.stack;

	}

	removeStack() {

		const lastStack = this.stack;
		this.stack = lastStack.parent;

		setCurrentStack( this.stacks.pop() );

		return lastStack;

	}

	getDataFromNode( node, shaderStage = this.shaderStage, cache = null ) {

		cache = cache === null ? ( node.isGlobal( this ) ? this.globalCache : this.cache ) : cache;

		let nodeData = cache.getData( node );

		if ( nodeData === undefined ) {

			nodeData = {};

			cache.setData( node, nodeData );

		}

		if ( nodeData[ shaderStage ] === undefined ) nodeData[ shaderStage ] = {};

		return nodeData[ shaderStage ];

	}

	getNodeProperties( node, shaderStage = 'any' ) {

		const nodeData = this.getDataFromNode( node, shaderStage );

		return nodeData.properties || ( nodeData.properties = { outputNode: null } );

	}

	getBufferAttributeFromNode( node, type ) {

		const nodeData = this.getDataFromNode( node );

		let bufferAttribute = nodeData.bufferAttribute;

		if ( bufferAttribute === undefined ) {

			const index = this.uniforms.index ++;

			bufferAttribute = new NodeAttribute( 'nodeAttribute' + index, type, node );

			this.bufferAttributes.push( bufferAttribute );

			nodeData.bufferAttribute = bufferAttribute;

		}

		return bufferAttribute;

	}

	getStructTypeFromNode( node, shaderStage = this.shaderStage ) {

		const nodeData = this.getDataFromNode( node, shaderStage );

		if ( nodeData.structType === undefined ) {

			const index = this.structs.index ++;

			node.name = `StructType${ index }`;
			this.structs[ shaderStage ].push( node );

			nodeData.structType = node;

		}

		return node;

	}

	getUniformFromNode( node, type, shaderStage = this.shaderStage, name = null ) {

		const nodeData = this.getDataFromNode( node, shaderStage, this.globalCache );

		let nodeUniform = nodeData.uniform;

		if ( nodeUniform === undefined ) {

			const index = this.uniforms.index ++;

			nodeUniform = new NodeUniform( name || ( 'nodeUniform' + index ), type, node );

			this.uniforms[ shaderStage ].push( nodeUniform );

			nodeData.uniform = nodeUniform;

		}

		return nodeUniform;

	}

	getVarFromNode( node, name = null, type = node.getNodeType( this ), shaderStage = this.shaderStage ) {

		const nodeData = this.getDataFromNode( node, shaderStage );

		let nodeVar = nodeData.variable;

		if ( nodeVar === undefined ) {

			const vars = this.vars[ shaderStage ] || ( this.vars[ shaderStage ] = [] );

			if ( name === null ) name = 'nodeVar' + vars.length;

			nodeVar = new NodeVar( name, type );

			vars.push( nodeVar );

			nodeData.variable = nodeVar;

		}

		return nodeVar;

	}

	getVaryingFromNode( node, name = null, type = node.getNodeType( this ) ) {

		const nodeData = this.getDataFromNode( node, 'any' );

		let nodeVarying = nodeData.varying;

		if ( nodeVarying === undefined ) {

			const varyings = this.varyings;
			const index = varyings.length;

			if ( name === null ) name = 'nodeVarying' + index;

			nodeVarying = new NodeVarying( name, type );

			varyings.push( nodeVarying );

			nodeData.varying = nodeVarying;

		}

		return nodeVarying;

	}

	getCodeFromNode( node, type, shaderStage = this.shaderStage ) {

		const nodeData = this.getDataFromNode( node );

		let nodeCode = nodeData.code;

		if ( nodeCode === undefined ) {

			const codes = this.codes[ shaderStage ] || ( this.codes[ shaderStage ] = [] );
			const index = codes.length;

			nodeCode = new NodeCode( 'nodeCode' + index, type );

			codes.push( nodeCode );

			nodeData.code = nodeCode;

		}

		return nodeCode;

	}

	addFlowCodeHierarchy( node, nodeBlock ) {

		const { flowCodes, flowCodeBlock } = this.getDataFromNode( node );

		let needsFlowCode = true;
		let nodeBlockHierarchy = nodeBlock;

		while ( nodeBlockHierarchy ) {

			if ( flowCodeBlock.get( nodeBlockHierarchy ) === true ) {

				needsFlowCode = false;
				break;

			}

			nodeBlockHierarchy = this.getDataFromNode( nodeBlockHierarchy ).parentNodeBlock;

		}

		if ( needsFlowCode ) {

			for ( const flowCode of flowCodes ) {

				this.addLineFlowCode( flowCode );

			}

		}

	}

	addLineFlowCodeBlock( node, code, nodeBlock ) {

		const nodeData = this.getDataFromNode( node );
		const flowCodes = nodeData.flowCodes || ( nodeData.flowCodes = [] );
		const codeBlock = nodeData.flowCodeBlock || ( nodeData.flowCodeBlock = new WeakMap() );

		flowCodes.push( code );
		codeBlock.set( nodeBlock, true );

	}

	addLineFlowCode( code, node = null ) {

		if ( code === '' ) return this;

		if ( node !== null && this.context.nodeBlock ) {

			this.addLineFlowCodeBlock( node, code, this.context.nodeBlock );

		}

		code = this.tab + code;

		if ( ! /;\s*$/.test( code ) ) {

			code = code + ';\n';

		}

		this.flow.code += code;

		return this;

	}

	addFlowCode( code ) {

		this.flow.code += code;

		return this;

	}

	addFlowTab() {

		this.tab += '\t';

		return this;

	}

	removeFlowTab() {

		this.tab = this.tab.slice( 0, -1 );

		return this;

	}

	getFlowData( node/*, shaderStage*/ ) {

		return this.flowsData.get( node );

	}

	flowNode( node ) {

		const output = node.getNodeType( this );

		const flowData = this.flowChildNode( node, output );

		this.flowsData.set( node, flowData );

		return flowData;

	}

	buildFunctionNode( shaderNode ) {

		const fn = new FunctionNode();

		const previous = this.currentFunctionNode;

		this.currentFunctionNode = fn;

		fn.code = this.buildFunctionCode( shaderNode );

		this.currentFunctionNode = previous;

		return fn;

	}

	flowShaderNode( shaderNode ) {

		const layout = shaderNode.layout;

		const inputs = {
			[ Symbol.iterator ]() {

				let index = 0;
				const values = Object.values( this );
				return {
					next: () => ( {
						value: values[ index ],
						done: index ++ >= values.length
					} )
				};

			}
		};

		for ( const input of layout.inputs ) {

			inputs[ input.name ] = new ParameterNode( input.type, input.name );

		}

		//

		shaderNode.layout = null;

		const callNode = shaderNode.call( inputs );
		const flowData = this.flowStagesNode( callNode, layout.type );

		shaderNode.layout = layout;

		return flowData;

	}

	flowStagesNode( node, output = null ) {

		const previousFlow = this.flow;
		const previousVars = this.vars;
		const previousCache = this.cache;
		const previousBuildStage = this.buildStage;
		const previousStack = this.stack;

		const flow = {
			code: ''
		};

		this.flow = flow;
		this.vars = {};
		this.cache = new NodeCache();
		this.stack = stack();

		for ( const buildStage of defaultBuildStages ) {

			this.setBuildStage( buildStage );

			flow.result = node.build( this, output );

		}

		flow.vars = this.getVars( this.shaderStage );

		this.flow = previousFlow;
		this.vars = previousVars;
		this.cache = previousCache;
		this.stack = previousStack;

		this.setBuildStage( previousBuildStage );

		return flow;

	}

	getFunctionOperator() {

		return null;

	}

	flowChildNode( node, output = null ) {

		const previousFlow = this.flow;

		const flow = {
			code: ''
		};

		this.flow = flow;

		flow.result = node.build( this, output );

		this.flow = previousFlow;

		return flow;

	}

	flowNodeFromShaderStage( shaderStage, node, output = null, propertyName = null ) {

		const previousShaderStage = this.shaderStage;

		this.setShaderStage( shaderStage );

		const flowData = this.flowChildNode( node, output );

		if ( propertyName !== null ) {

			flowData.code += `${ this.tab + propertyName } = ${ flowData.result };\n`;

		}

		this.flowCode[ shaderStage ] = this.flowCode[ shaderStage ] + flowData.code;

		this.setShaderStage( previousShaderStage );

		return flowData;

	}

	getAttributesArray() {

		return this.attributes.concat( this.bufferAttributes );

	}

	getAttributes( /*shaderStage*/ ) {

		console.warn( 'Abstract function.' );

	}

	getVaryings( /*shaderStage*/ ) {

		console.warn( 'Abstract function.' );

	}

	getVar( type, name ) {

		return `${ this.getType( type ) } ${ name }`;

	}

	getVars( shaderStage ) {

		let snippet = '';

		const vars = this.vars[ shaderStage ];

		if ( vars !== undefined ) {

			for ( const variable of vars ) {

				snippet += `${ this.getVar( variable.type, variable.name ) }; `;

			}

		}

		return snippet;

	}

	getUniforms( /*shaderStage*/ ) {

		console.warn( 'Abstract function.' );

	}

	getCodes( shaderStage ) {

		const codes = this.codes[ shaderStage ];

		let code = '';

		if ( codes !== undefined ) {

			for ( const nodeCode of codes ) {

				code += nodeCode.code + '\n';

			}

		}

		return code;

	}

	getHash() {

		return this.vertexShader + this.fragmentShader + this.computeShader;

	}

	setShaderStage( shaderStage ) {

		this.shaderStage = shaderStage;

	}

	getShaderStage() {

		return this.shaderStage;

	}

	setBuildStage( buildStage ) {

		this.buildStage = buildStage;

	}

	getBuildStage() {

		return this.buildStage;

	}

	buildCode() {

		console.warn( 'Abstract function.' );

	}

	build() {

		const { object, material, renderer } = this;

		if ( material !== null ) {

			let nodeMaterial = renderer.library.fromMaterial( material );

			if ( nodeMaterial === null ) {

				console.error( `NodeMaterial: Material "${ material.type }" is not compatible.` );

				nodeMaterial = new NodeMaterial();

			}

			nodeMaterial.build( this );

		} else {

			this.addFlow( 'compute', object );

		}

		// setup() -> stage 1: create possible new nodes and returns an output reference node
		// analyze()   -> stage 2: analyze nodes to possible optimization and validation
		// generate()  -> stage 3: generate shader

		for ( const buildStage of defaultBuildStages ) {

			this.setBuildStage( buildStage );

			if ( this.context.vertex && this.context.vertex.isNode ) {

				this.flowNodeFromShaderStage( 'vertex', this.context.vertex );

			}

			for ( const shaderStage of shaderStages ) {

				this.setShaderStage( shaderStage );

				const flowNodes = this.flowNodes[ shaderStage ];

				for ( const node of flowNodes ) {

					if ( buildStage === 'generate' ) {

						this.flowNode( node );

					} else {

						node.build( this );

					}

				}

			}

		}

		this.setBuildStage( null );
		this.setShaderStage( null );

		// stage 4: build code for a specific output

		this.buildCode();
		this.buildUpdateNodes();

		return this;

	}

	getNodeUniform( uniformNode, type ) {

		if ( type === 'float' || type === 'int' || type === 'uint' ) return new NumberNodeUniform( uniformNode );
		if ( type === 'vec2' || type === 'ivec2' || type === 'uvec2' ) return new Vector2NodeUniform( uniformNode );
		if ( type === 'vec3' || type === 'ivec3' || type === 'uvec3' ) return new Vector3NodeUniform( uniformNode );
		if ( type === 'vec4' || type === 'ivec4' || type === 'uvec4' ) return new Vector4NodeUniform( uniformNode );
		if ( type === 'color' ) return new ColorNodeUniform( uniformNode );
		if ( type === 'mat3' ) return new Matrix3NodeUniform( uniformNode );
		if ( type === 'mat4' ) return new Matrix4NodeUniform( uniformNode );

		throw new Error( `Uniform "${type}" not declared.` );

	}

	createNodeMaterial( type = 'NodeMaterial' ) { // @deprecated, r168

		throw new Error( `THREE.NodeBuilder: createNodeMaterial() was deprecated. Use new ${ type }() instead.` );

	}

	format( snippet, fromType, toType ) {

		fromType = this.getVectorType( fromType );
		toType = this.getVectorType( toType );

		if ( fromType === toType || toType === null || this.isReference( toType ) ) {

			return snippet;

		}

		const fromTypeLength = this.getTypeLength( fromType );
		const toTypeLength = this.getTypeLength( toType );

		if ( fromTypeLength === 16 && toTypeLength === 9 ) {

			return `${ this.getType( toType ) }(${ snippet }[0].xyz, ${ snippet }[1].xyz, ${ snippet }[2].xyz)`;

		}

		if ( fromTypeLength === 9 && toTypeLength === 4 ) {

			return `${ this.getType( toType ) }(${ snippet }[0].xy, ${ snippet }[1].xy)`;

		}


		if ( fromTypeLength > 4 ) { // fromType is matrix-like

			// @TODO: ignore for now

			return snippet;

		}

		if ( toTypeLength > 4 || toTypeLength === 0 ) { // toType is matrix-like or unknown

			// @TODO: ignore for now

			return snippet;

		}

		if ( fromTypeLength === toTypeLength ) {

			return `${ this.getType( toType ) }( ${ snippet } )`;

		}

		if ( fromTypeLength > toTypeLength ) {

			return this.format( `${ snippet }.${ 'xyz'.slice( 0, toTypeLength ) }`, this.getTypeFromLength( toTypeLength, this.getComponentType( fromType ) ), toType );

		}

		if ( toTypeLength === 4 && fromTypeLength > 1 ) { // toType is vec4-like

			return `${ this.getType( toType ) }( ${ this.format( snippet, fromType, 'vec3' ) }, 1.0 )`;

		}

		if ( fromTypeLength === 2 ) { // fromType is vec2-like and toType is vec3-like

			return `${ this.getType( toType ) }( ${ this.format( snippet, fromType, 'vec2' ) }, 0.0 )`;

		}

		if ( fromTypeLength === 1 && toTypeLength > 1 && fromType !== this.getComponentType( toType ) ) { // fromType is float-like

			// convert a number value to vector type, e.g:
			// vec3( 1u ) -> vec3( float( 1u ) )

			snippet = `${ this.getType( this.getComponentType( toType ) ) }( ${ snippet } )`;

		}

		return `${ this.getType( toType ) }( ${ snippet } )`; // fromType is float-like

	}

	getSignature() {

		return `// Three.js r${ REVISION } - Node System\n`;

	}

}

class NodeFrame {

	constructor() {

		this.time = 0;
		this.deltaTime = 0;

		this.frameId = 0;
		this.renderId = 0;

		this.startTime = null;

		this.updateMap = new WeakMap();
		this.updateBeforeMap = new WeakMap();
		this.updateAfterMap = new WeakMap();

		this.renderer = null;
		this.material = null;
		this.camera = null;
		this.object = null;
		this.scene = null;

	}

	_getMaps( referenceMap, nodeRef ) {

		let maps = referenceMap.get( nodeRef );

		if ( maps === undefined ) {

			maps = {
				renderMap: new WeakMap(),
				frameMap: new WeakMap()
			};

			referenceMap.set( nodeRef, maps );

		}

		return maps;

	}

	updateBeforeNode( node ) {

		const updateType = node.getUpdateBeforeType();
		const reference = node.updateReference( this );

		if ( updateType === NodeUpdateType.FRAME ) {

			const { frameMap } = this._getMaps( this.updateBeforeMap, reference );

			if ( frameMap.get( reference ) !== this.frameId ) {

				if ( node.updateBefore( this ) !== false ) {

					frameMap.set( reference, this.frameId );

				}

			}

		} else if ( updateType === NodeUpdateType.RENDER ) {

			const { renderMap } = this._getMaps( this.updateBeforeMap, reference );

			if ( renderMap.get( reference ) !== this.renderId ) {

				if ( node.updateBefore( this ) !== false ) {

					renderMap.set( reference, this.renderId );

				}

			}

		} else if ( updateType === NodeUpdateType.OBJECT ) {

			node.updateBefore( this );

		}

	}

	updateAfterNode( node ) {

		const updateType = node.getUpdateAfterType();
		const reference = node.updateReference( this );

		if ( updateType === NodeUpdateType.FRAME ) {

			const { frameMap } = this._getMaps( this.updateAfterMap, reference );

			if ( frameMap.get( reference ) !== this.frameId ) {

				if ( node.updateAfter( this ) !== false ) {

					frameMap.set( reference, this.frameId );

				}

			}

		} else if ( updateType === NodeUpdateType.RENDER ) {

			const { renderMap } = this._getMaps( this.updateAfterMap, reference );

			if ( renderMap.get( reference ) !== this.renderId ) {

				if ( node.updateAfter( this ) !== false ) {

					renderMap.set( reference, this.renderId );

				}

			}

		} else if ( updateType === NodeUpdateType.OBJECT ) {

			node.updateAfter( this );

		}

	}

	updateNode( node ) {

		const updateType = node.getUpdateType();
		const reference = node.updateReference( this );

		if ( updateType === NodeUpdateType.FRAME ) {

			const { frameMap } = this._getMaps( this.updateMap, reference );

			if ( frameMap.get( reference ) !== this.frameId ) {

				if ( node.update( this ) !== false ) {

					frameMap.set( reference, this.frameId );

				}

			}

		} else if ( updateType === NodeUpdateType.RENDER ) {

			const { renderMap } = this._getMaps( this.updateMap, reference );

			if ( renderMap.get( reference ) !== this.renderId ) {

				if ( node.update( this ) !== false ) {

					renderMap.set( reference, this.renderId );

				}

			}

		} else if ( updateType === NodeUpdateType.OBJECT ) {

			node.update( this );

		}

	}

	update() {

		this.frameId ++;

		if ( this.lastTime === undefined ) this.lastTime = performance.now();

		this.deltaTime = ( performance.now() - this.lastTime ) / 1000;

		this.lastTime = performance.now();

		this.time += this.deltaTime;

	}

}

class NodeFunctionInput {

	constructor( type, name, count = null, qualifier = '', isConst = false ) {

		this.type = type;
		this.name = name;
		this.count = count;
		this.qualifier = qualifier;
		this.isConst = isConst;

	}

}

NodeFunctionInput.isNodeFunctionInput = true;

class DirectionalLightNode extends AnalyticLightNode {

	static get type() {

		return 'DirectionalLightNode';

	}

	constructor( light = null ) {

		super( light );

	}

	setup( builder ) {

		super.setup( builder );

		const lightingModel = builder.context.lightingModel;

		const lightColor = this.colorNode;
		const lightDirection = lightTargetDirection( this.light );
		const reflectedLight = builder.context.reflectedLight;

		lightingModel.direct( {
			lightDirection,
			lightColor,
			reflectedLight
		}, builder.stack, builder );

	}

}

const _matrix41 = /*@__PURE__*/ new Matrix4();
const _matrix42 = /*@__PURE__*/ new Matrix4();

let ltcLib = null;

class RectAreaLightNode extends AnalyticLightNode {

	static get type() {

		return 'RectAreaLightNode';

	}

	constructor( light = null ) {

		super( light );

		this.halfHeight = uniform$1( new Vector3() ).setGroup( renderGroup );
		this.halfWidth = uniform$1( new Vector3() ).setGroup( renderGroup );

		this.updateType = NodeUpdateType.RENDER;

	}

	update( frame ) {

		super.update( frame );

		const { light } = this;

		const viewMatrix = frame.camera.matrixWorldInverse;

		_matrix42.identity();
		_matrix41.copy( light.matrixWorld );
		_matrix41.premultiply( viewMatrix );
		_matrix42.extractRotation( _matrix41 );

		this.halfWidth.value.set( light.width * 0.5, 0.0, 0.0 );
		this.halfHeight.value.set( 0.0, light.height * 0.5, 0.0 );

		this.halfWidth.value.applyMatrix4( _matrix42 );
		this.halfHeight.value.applyMatrix4( _matrix42 );

	}

	setup( builder ) {

		super.setup( builder );

		let ltc_1, ltc_2;

		if ( builder.isAvailable( 'float32Filterable' ) ) {

			ltc_1 = texture( ltcLib.LTC_FLOAT_1 );
			ltc_2 = texture( ltcLib.LTC_FLOAT_2 );

		} else {

			ltc_1 = texture( ltcLib.LTC_HALF_1 );
			ltc_2 = texture( ltcLib.LTC_HALF_2 );

		}

		const { colorNode, light } = this;
		const lightingModel = builder.context.lightingModel;

		const lightPosition = lightViewPosition( light );
		const reflectedLight = builder.context.reflectedLight;

		lightingModel.directRectArea( {
			lightColor: colorNode,
			lightPosition,
			halfWidth: this.halfWidth,
			halfHeight: this.halfHeight,
			reflectedLight,
			ltc_1,
			ltc_2
		}, builder.stack, builder );

	}

	static setLTC( ltc ) {

		ltcLib = ltc;

	}

}

class SpotLightNode extends AnalyticLightNode {

	static get type() {

		return 'SpotLightNode';

	}

	constructor( light = null ) {

		super( light );

		this.coneCosNode = uniform$1( 0 ).setGroup( renderGroup );
		this.penumbraCosNode = uniform$1( 0 ).setGroup( renderGroup );

		this.cutoffDistanceNode = uniform$1( 0 ).setGroup( renderGroup );
		this.decayExponentNode = uniform$1( 0 ).setGroup( renderGroup );

	}

	update( frame ) {

		super.update( frame );

		const { light } = this;

		this.coneCosNode.value = Math.cos( light.angle );
		this.penumbraCosNode.value = Math.cos( light.angle * ( 1 - light.penumbra ) );

		this.cutoffDistanceNode.value = light.distance;
		this.decayExponentNode.value = light.decay;

	}

	getSpotAttenuation( angleCosine ) {

		const { coneCosNode, penumbraCosNode } = this;

		return smoothstep$1( coneCosNode, penumbraCosNode, angleCosine );

	}

	setup( builder ) {

		super.setup( builder );

		const lightingModel = builder.context.lightingModel;

		const { colorNode, cutoffDistanceNode, decayExponentNode, light } = this;

		const lVector = lightViewPosition( light ).sub( positionView$1 ); // @TODO: Add it into LightNode

		const lightDirection = lVector.normalize();
		const angleCos = lightDirection.dot( lightTargetDirection( light ) );
		const spotAttenuation = this.getSpotAttenuation( angleCos );

		const lightDistance = lVector.length();

		const lightAttenuation = getDistanceAttenuation( {
			lightDistance,
			cutoffDistance: cutoffDistanceNode,
			decayExponent: decayExponentNode
		} );

		let lightColor = colorNode.mul( spotAttenuation ).mul( lightAttenuation );

		if ( light.map ) {

			const spotLightCoord = lightProjectionUV( light );
			const projectedTexture = texture( light.map, spotLightCoord.xy ).onRenderUpdate( () => light.map );

			const inSpotLightMap = spotLightCoord.mul( 2. ).sub( 1. ).abs().lessThan( 1. ).all();

			lightColor = inSpotLightMap.select( lightColor.mul( projectedTexture ), lightColor );

		}

		const reflectedLight = builder.context.reflectedLight;

		lightingModel.direct( {
			lightDirection,
			lightColor,
			reflectedLight
		}, builder.stack, builder );

	}

}

class IESSpotLightNode extends SpotLightNode {

	static get type() {

		return 'IESSpotLightNode';

	}

	getSpotAttenuation( angleCosine ) {

		const iesMap = this.light.iesMap;

		let spotAttenuation = null;

		if ( iesMap && iesMap.isTexture === true ) {

			const angle = angleCosine.acos().mul( 1.0 / Math.PI );

			spotAttenuation = texture( iesMap, vec2$1( angle, 0 ), 0 ).r;

		} else {

			spotAttenuation = super.getSpotAttenuation( angleCosine );

		}

		return spotAttenuation;

	}

}

class AmbientLightNode extends AnalyticLightNode {

	static get type() {

		return 'AmbientLightNode';

	}

	constructor( light = null ) {

		super( light );

	}

	setup( { context } ) {

		context.irradiance.addAssign( this.colorNode );

	}

}

class HemisphereLightNode extends AnalyticLightNode {

	static get type() {

		return 'HemisphereLightNode';

	}

	constructor( light = null ) {

		super( light );

		this.lightPositionNode = lightPosition( light );
		this.lightDirectionNode = this.lightPositionNode.normalize();

		this.groundColorNode = uniform$1( new Color() ).setGroup( renderGroup );

	}

	update( frame ) {

		const { light } = this;

		super.update( frame );

		this.lightPositionNode.object3d = light;

		this.groundColorNode.value.copy( light.groundColor ).multiplyScalar( light.intensity );

	}

	setup( builder ) {

		const { colorNode, groundColorNode, lightDirectionNode } = this;

		const dotNL = normalView$1.dot( lightDirectionNode );
		const hemiDiffuseWeight = dotNL.mul( 0.5 ).add( 0.5 );

		const irradiance = mix$1( groundColorNode, colorNode, hemiDiffuseWeight );

		builder.context.irradiance.addAssign( irradiance );

	}

}

class LightProbeNode extends AnalyticLightNode {

	static get type() {

		return 'LightProbeNode';

	}

	constructor( light = null ) {

		super( light );

		const array = [];

		for ( let i = 0; i < 9; i ++ ) array.push( new Vector3() );

		this.lightProbe = uniformArray( array );

	}

	update( frame ) {

		const { light } = this;

		super.update( frame );

		//

		for ( let i = 0; i < 9; i ++ ) {

			this.lightProbe.array[ i ].copy( light.sh.coefficients[ i ] ).multiplyScalar( light.intensity );

		}

	}

	setup( builder ) {

		const irradiance = getShIrradianceAt( normalWorld$1, this.lightProbe );

		builder.context.irradiance.addAssign( irradiance );

	}

}

class NodeParser {

	parseFunction( /*source*/ ) {

		console.warn( 'Abstract function.' );

	}

}

class NodeFunction {

	constructor( type, inputs, name = '', precision = '' ) {

		this.type = type;
		this.inputs = inputs;
		this.name = name;
		this.precision = precision;

	}

	getCode( /*name = this.name*/ ) {

		console.warn( 'Abstract function.' );

	}

}

NodeFunction.isNodeFunction = true;

const declarationRegexp$1 = /^\s*(highp|mediump|lowp)?\s*([a-z_0-9]+)\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)/i;
const propertiesRegexp$1 = /[a-z_0-9]+/ig;

const pragmaMain = '#pragma main';

const parse$1 = ( source ) => {

	source = source.trim();

	const pragmaMainIndex = source.indexOf( pragmaMain );

	const mainCode = pragmaMainIndex !== -1 ? source.slice( pragmaMainIndex + pragmaMain.length ) : source;

	const declaration = mainCode.match( declarationRegexp$1 );

	if ( declaration !== null && declaration.length === 5 ) {

		// tokenizer

		const inputsCode = declaration[ 4 ];
		const propsMatches = [];

		let nameMatch = null;

		while ( ( nameMatch = propertiesRegexp$1.exec( inputsCode ) ) !== null ) {

			propsMatches.push( nameMatch );

		}

		// parser

		const inputs = [];

		let i = 0;

		while ( i < propsMatches.length ) {

			const isConst = propsMatches[ i ][ 0 ] === 'const';

			if ( isConst === true ) {

				i ++;

			}

			let qualifier = propsMatches[ i ][ 0 ];

			if ( qualifier === 'in' || qualifier === 'out' || qualifier === 'inout' ) {

				i ++;

			} else {

				qualifier = '';

			}

			const type = propsMatches[ i ++ ][ 0 ];

			let count = Number.parseInt( propsMatches[ i ][ 0 ] );

			if ( Number.isNaN( count ) === false ) i ++;
			else count = null;

			const name = propsMatches[ i ++ ][ 0 ];

			inputs.push( new NodeFunctionInput( type, name, count, qualifier, isConst ) );

		}

		//

		const blockCode = mainCode.substring( declaration[ 0 ].length );

		const name = declaration[ 3 ] !== undefined ? declaration[ 3 ] : '';
		const type = declaration[ 2 ];

		const precision = declaration[ 1 ] !== undefined ? declaration[ 1 ] : '';

		const headerCode = pragmaMainIndex !== -1 ? source.slice( 0, pragmaMainIndex ) : '';

		return {
			type,
			inputs,
			name,
			precision,
			inputsCode,
			blockCode,
			headerCode
		};

	} else {

		throw new Error( 'FunctionNode: Function is not a GLSL code.' );

	}

};

class GLSLNodeFunction extends NodeFunction {

	constructor( source ) {

		const { type, inputs, name, precision, inputsCode, blockCode, headerCode } = parse$1( source );

		super( type, inputs, name, precision );

		this.inputsCode = inputsCode;
		this.blockCode = blockCode;
		this.headerCode = headerCode;

	}

	getCode( name = this.name ) {

		let code;

		const blockCode = this.blockCode;

		if ( blockCode !== '' ) {

			const { type, inputsCode, headerCode, precision } = this;

			let declarationCode = `${ type } ${ name } ( ${ inputsCode.trim() } )`;

			if ( precision !== '' ) {

				declarationCode = `${ precision } ${ declarationCode }`;

			}

			code = headerCode + declarationCode + blockCode;

		} else {

			// interface function

			code = '';

		}

		return code;

	}

}

class GLSLNodeParser extends NodeParser {

	parseFunction( source ) {

		return new GLSLNodeFunction( source );

	}

}

const outputNodeMap = new WeakMap();

class Nodes extends DataMap {

	constructor( renderer, backend ) {

		super();

		this.renderer = renderer;
		this.backend = backend;
		this.nodeFrame = new NodeFrame();
		this.nodeBuilderCache = new Map();
		this.callHashCache = new ChainMap();
		this.groupsData = new ChainMap();

	}

	updateGroup( nodeUniformsGroup ) {

		const groupNode = nodeUniformsGroup.groupNode;
		const name = groupNode.name;

		// objectGroup is every updated

		if ( name === objectGroup.name ) return true;

		// renderGroup is updated once per render/compute call

		if ( name === renderGroup.name ) {

			const uniformsGroupData = this.get( nodeUniformsGroup );
			const renderId = this.nodeFrame.renderId;

			if ( uniformsGroupData.renderId !== renderId ) {

				uniformsGroupData.renderId = renderId;

				return true;

			}

			return false;

		}

		// frameGroup is updated once per frame

		if ( name === frameGroup.name ) {

			const uniformsGroupData = this.get( nodeUniformsGroup );
			const frameId = this.nodeFrame.frameId;

			if ( uniformsGroupData.frameId !== frameId ) {

				uniformsGroupData.frameId = frameId;

				return true;

			}

			return false;

		}

		// other groups are updated just when groupNode.needsUpdate is true

		const groupChain = [ groupNode, nodeUniformsGroup ];

		let groupData = this.groupsData.get( groupChain );
		if ( groupData === undefined ) this.groupsData.set( groupChain, groupData = {} );

		if ( groupData.version !== groupNode.version ) {

			groupData.version = groupNode.version;

			return true;

		}

		return false;

	}

	getForRenderCacheKey( renderObject ) {

		return renderObject.initialCacheKey;

	}

	getForRender( renderObject ) {

		const renderObjectData = this.get( renderObject );

		let nodeBuilderState = renderObjectData.nodeBuilderState;

		if ( nodeBuilderState === undefined ) {

			const { nodeBuilderCache } = this;

			const cacheKey = this.getForRenderCacheKey( renderObject );

			nodeBuilderState = nodeBuilderCache.get( cacheKey );

			if ( nodeBuilderState === undefined ) {

				const nodeBuilder = this.backend.createNodeBuilder( renderObject.object, this.renderer );
				nodeBuilder.scene = renderObject.scene;
				nodeBuilder.material = renderObject.material;
				nodeBuilder.camera = renderObject.camera;
				nodeBuilder.context.material = renderObject.material;
				nodeBuilder.lightsNode = renderObject.lightsNode;
				nodeBuilder.environmentNode = this.getEnvironmentNode( renderObject.scene );
				nodeBuilder.fogNode = this.getFogNode( renderObject.scene );
				nodeBuilder.clippingContext = renderObject.clippingContext;
				nodeBuilder.build();

				nodeBuilderState = this._createNodeBuilderState( nodeBuilder );

				nodeBuilderCache.set( cacheKey, nodeBuilderState );

			}

			nodeBuilderState.usedTimes ++;

			renderObjectData.nodeBuilderState = nodeBuilderState;

		}

		return nodeBuilderState;

	}

	delete( object ) {

		if ( object.isRenderObject ) {

			const nodeBuilderState = this.get( object ).nodeBuilderState;
			nodeBuilderState.usedTimes --;

			if ( nodeBuilderState.usedTimes === 0 ) {

				this.nodeBuilderCache.delete( this.getForRenderCacheKey( object ) );

			}

		}

		return super.delete( object );

	}

	getForCompute( computeNode ) {

		const computeData = this.get( computeNode );

		let nodeBuilderState = computeData.nodeBuilderState;

		if ( nodeBuilderState === undefined ) {

			const nodeBuilder = this.backend.createNodeBuilder( computeNode, this.renderer );
			nodeBuilder.build();

			nodeBuilderState = this._createNodeBuilderState( nodeBuilder );

			computeData.nodeBuilderState = nodeBuilderState;

		}

		return nodeBuilderState;

	}

	_createNodeBuilderState( nodeBuilder ) {

		return new NodeBuilderState(
			nodeBuilder.vertexShader,
			nodeBuilder.fragmentShader,
			nodeBuilder.computeShader,
			nodeBuilder.getAttributesArray(),
			nodeBuilder.getBindings(),
			nodeBuilder.updateNodes,
			nodeBuilder.updateBeforeNodes,
			nodeBuilder.updateAfterNodes,
			nodeBuilder.monitor,
			nodeBuilder.transforms
		);

	}

	getEnvironmentNode( scene ) {

		return scene.environmentNode || this.get( scene ).environmentNode || null;

	}

	getBackgroundNode( scene ) {

		return scene.backgroundNode || this.get( scene ).backgroundNode || null;

	}

	getFogNode( scene ) {

		return scene.fogNode || this.get( scene ).fogNode || null;

	}

	getCacheKey( scene, lightsNode ) {

		const chain = [ scene, lightsNode ];
		const callId = this.renderer.info.calls;

		let cacheKeyData = this.callHashCache.get( chain );

		if ( cacheKeyData === undefined || cacheKeyData.callId !== callId ) {

			const environmentNode = this.getEnvironmentNode( scene );
			const fogNode = this.getFogNode( scene );

			const values = [];

			if ( lightsNode ) values.push( lightsNode.getCacheKey( true ) );
			if ( environmentNode ) values.push( environmentNode.getCacheKey() );
			if ( fogNode ) values.push( fogNode.getCacheKey() );

			values.push( this.renderer.shadowMap.enabled ? 1 : 0 );

			cacheKeyData = {
				callId,
				cacheKey: hashArray( values )
			};

			this.callHashCache.set( chain, cacheKeyData );

		}

		return cacheKeyData.cacheKey;

	}

	updateScene( scene ) {

		this.updateEnvironment( scene );
		this.updateFog( scene );
		this.updateBackground( scene );

	}

	get isToneMappingState() {

		return this.renderer.getRenderTarget() ? false : true;

	}

	updateBackground( scene ) {

		const sceneData = this.get( scene );
		const background = scene.background;

		if ( background ) {

			const forceUpdate = ( scene.backgroundBlurriness === 0 && sceneData.backgroundBlurriness > 0 ) || ( scene.backgroundBlurriness > 0 && sceneData.backgroundBlurriness === 0 );

			if ( sceneData.background !== background || forceUpdate ) {

				let backgroundNode = null;

				if ( background.isCubeTexture === true || ( background.mapping === EquirectangularReflectionMapping || background.mapping === EquirectangularRefractionMapping || background.mapping === CubeUVReflectionMapping ) ) {

					if ( scene.backgroundBlurriness > 0 || background.mapping === CubeUVReflectionMapping ) {

						backgroundNode = pmremTexture( background );

					} else {

						let envMap;

						if ( background.isCubeTexture === true ) {

							envMap = cubeTexture( background );

						} else {

							envMap = texture( background );

						}

						backgroundNode = cubeMapNode( envMap );

					}

				} else if ( background.isTexture === true ) {

					backgroundNode = texture( background, screenUV.flipY() ).setUpdateMatrix( true );

				} else if ( background.isColor !== true ) {

					console.error( 'WebGPUNodes: Unsupported background configuration.', background );

				}

				sceneData.backgroundNode = backgroundNode;
				sceneData.background = background;
				sceneData.backgroundBlurriness = scene.backgroundBlurriness;

			}

		} else if ( sceneData.backgroundNode ) {

			delete sceneData.backgroundNode;
			delete sceneData.background;

		}

	}

	updateFog( scene ) {

		const sceneData = this.get( scene );
		const fog = scene.fog;

		if ( fog ) {

			if ( sceneData.fog !== fog ) {

				let fogNode = null;

				if ( fog.isFogExp2 ) {

					const color = reference( 'color', 'color', fog ).setGroup( renderGroup );
					const density = reference( 'density', 'float', fog ).setGroup( renderGroup );

					fogNode = densityFog( color, density );

				} else if ( fog.isFog ) {

					const color = reference( 'color', 'color', fog ).setGroup( renderGroup );
					const near = reference( 'near', 'float', fog ).setGroup( renderGroup );
					const far = reference( 'far', 'float', fog ).setGroup( renderGroup );

					fogNode = rangeFog( color, near, far );

				} else {

					console.error( 'WebGPUNodes: Unsupported fog configuration.', fog );

				}

				sceneData.fogNode = fogNode;
				sceneData.fog = fog;

			}

		} else {

			delete sceneData.fogNode;
			delete sceneData.fog;

		}

	}

	updateEnvironment( scene ) {

		const sceneData = this.get( scene );
		const environment = scene.environment;

		if ( environment ) {

			if ( sceneData.environment !== environment ) {

				let environmentNode = null;

				if ( environment.isCubeTexture === true ) {

					environmentNode = cubeTexture( environment );

				} else if ( environment.isTexture === true ) {

					environmentNode = texture( environment );

				} else {

					console.error( 'Nodes: Unsupported environment configuration.', environment );

				}

				sceneData.environmentNode = environmentNode;
				sceneData.environment = environment;

			}

		} else if ( sceneData.environmentNode ) {

			delete sceneData.environmentNode;
			delete sceneData.environment;

		}

	}

	getNodeFrame( renderer = this.renderer, scene = null, object = null, camera = null, material = null ) {

		const nodeFrame = this.nodeFrame;
		nodeFrame.renderer = renderer;
		nodeFrame.scene = scene;
		nodeFrame.object = object;
		nodeFrame.camera = camera;
		nodeFrame.material = material;

		return nodeFrame;

	}

	getNodeFrameForRender( renderObject ) {

		return this.getNodeFrame( renderObject.renderer, renderObject.scene, renderObject.object, renderObject.camera, renderObject.material );

	}

	getOutputCacheKey() {

		const renderer = this.renderer;

		return renderer.toneMapping + ',' + renderer.currentColorSpace;

	}

	hasOutputChange( outputTarget ) {

		const cacheKey = outputNodeMap.get( outputTarget );

		return cacheKey !== this.getOutputCacheKey();

	}

	getOutputNode( outputTexture ) {

		const renderer = this.renderer;
		const cacheKey = this.getOutputCacheKey();

		const output = texture( outputTexture, screenUV ).renderOutput( renderer.toneMapping, renderer.currentColorSpace );

		outputNodeMap.set( outputTexture, cacheKey );

		return output;

	}

	updateBefore( renderObject ) {

		const nodeBuilder = renderObject.getNodeBuilderState();

		for ( const node of nodeBuilder.updateBeforeNodes ) {

			// update frame state for each node

			this.getNodeFrameForRender( renderObject ).updateBeforeNode( node );

		}

	}

	updateAfter( renderObject ) {

		const nodeBuilder = renderObject.getNodeBuilderState();

		for ( const node of nodeBuilder.updateAfterNodes ) {

			// update frame state for each node

			this.getNodeFrameForRender( renderObject ).updateAfterNode( node );

		}

	}

	updateForCompute( computeNode ) {

		const nodeFrame = this.getNodeFrame();
		const nodeBuilder = this.getForCompute( computeNode );

		for ( const node of nodeBuilder.updateNodes ) {

			nodeFrame.updateNode( node );

		}

	}

	updateForRender( renderObject ) {

		const nodeFrame = this.getNodeFrameForRender( renderObject );
		const nodeBuilder = renderObject.getNodeBuilderState();

		for ( const node of nodeBuilder.updateNodes ) {

			nodeFrame.updateNode( node );

		}

	}

	needsRefresh( renderObject ) {

		const nodeFrame = this.getNodeFrameForRender( renderObject );
		const monitor = renderObject.getMonitor();

		return monitor.needsRefresh( renderObject, nodeFrame );

	}

	dispose() {

		super.dispose();

		this.nodeFrame = new NodeFrame();
		this.nodeBuilderCache = new Map();

	}

}

const _plane = /*@__PURE__*/ new Plane();

class ClippingContext {

	constructor( parentContext = null ) {

		this.version = 0;

		this.clipIntersection = null;
		this.cacheKey = '';


		if ( parentContext === null ) {

			this.intersectionPlanes = [];
			this.unionPlanes = [];

			this.viewNormalMatrix = new Matrix3();
			this.clippingGroupContexts = new WeakMap();

			this.shadowPass = false;

		} else {

			this.viewNormalMatrix = parentContext.viewNormalMatrix;
			this.clippingGroupContexts = parentContext.clippingGroupContexts;

			this.shadowPass = parentContext.shadowPass;

			this.viewMatrix = parentContext.viewMatrix;

		}

		this.parentVersion = null;

	}

	projectPlanes( source, destination, offset ) {

		const l = source.length;

		for ( let i = 0; i < l; i ++ ) {

			_plane.copy( source[ i ] ).applyMatrix4( this.viewMatrix, this.viewNormalMatrix );

			const v = destination[ offset + i ];
			const normal = _plane.normal;

			v.x = - normal.x;
			v.y = - normal.y;
			v.z = - normal.z;
			v.w = _plane.constant;

		}

	}

	updateGlobal( scene, camera ) {

		this.shadowPass = ( scene.overrideMaterial !== null && scene.overrideMaterial.isShadowNodeMaterial );
		this.viewMatrix = camera.matrixWorldInverse;

		this.viewNormalMatrix.getNormalMatrix( this.viewMatrix );

	}

	update( parentContext, clippingGroup ) {

		let update = false;

		if ( parentContext.version !== this.parentVersion ) {

			this.intersectionPlanes = Array.from( parentContext.intersectionPlanes );
			this.unionPlanes = Array.from( parentContext.unionPlanes );
			this.parentVersion = parentContext.version;

		}

		if ( this.clipIntersection !== clippingGroup.clipIntersection ) {

			this.clipIntersection = clippingGroup.clipIntersection;

			if ( this.clipIntersection ) {

				this.unionPlanes.length = parentContext.unionPlanes.length;

			} else {

				this.intersectionPlanes.length = parentContext.intersectionPlanes.length;

			}

		}

		const srcClippingPlanes = clippingGroup.clippingPlanes;
		const l = srcClippingPlanes.length;

		let dstClippingPlanes;
		let offset;

		if ( this.clipIntersection ) {

			dstClippingPlanes = this.intersectionPlanes;
			offset = parentContext.intersectionPlanes.length;

		} else {

			dstClippingPlanes = this.unionPlanes;
			offset = parentContext.unionPlanes.length;

		}

		if ( dstClippingPlanes.length !== offset + l ) {

			dstClippingPlanes.length = offset + l;

			for ( let i = 0; i < l; i ++ ) {

				dstClippingPlanes[ offset + i ] = new Vector4();

			}

			update = true;

		}

		this.projectPlanes( srcClippingPlanes, dstClippingPlanes, offset );

		if ( update ) {

			this.version ++;
			this.cacheKey = `${ this.intersectionPlanes.length }:${ this.unionPlanes.length }`;

		}

	}

	getGroupContext( clippingGroup ) {

		if ( this.shadowPass && ! clippingGroup.clipShadows ) return this;

		let context = this.clippingGroupContexts.get( clippingGroup );

		if ( context === undefined ) {

			context = new ClippingContext( this );
			this.clippingGroupContexts.set( clippingGroup, context );

		}

		context.update( this, clippingGroup );

		return context;

	}

	get unionClippingCount() {

		return this.unionPlanes.length;

	}

}

class RenderBundle {

	constructor( scene, camera ) {

		this.scene = scene;
		this.camera = camera;

	}

	clone() {

		return Object.assign( new this.constructor(), this );

	}

}

class RenderBundles {

	constructor() {

		this.lists = new ChainMap();

	}

	get( scene, camera ) {

		const lists = this.lists;
		const keys = [ scene, camera ];

		let list = lists.get( keys );

		if ( list === undefined ) {

			list = new RenderBundle( scene, camera );
			lists.set( keys, list );

		}

		return list;

	}

	dispose() {

		this.lists = new ChainMap();

	}

}

class NodeLibrary {

	constructor() {

		this.lightNodes = new WeakMap();
		this.materialNodes = new Map();
		this.toneMappingNodes = new Map();

	}

	fromMaterial( material ) {

		if ( material.isNodeMaterial ) return material;

		let nodeMaterial = null;

		const nodeMaterialClass = this.getMaterialNodeClass( material.type );

		if ( nodeMaterialClass !== null ) {

			nodeMaterial = new nodeMaterialClass();

			for ( const key in material ) {

				nodeMaterial[ key ] = material[ key ];

			}

		}

		return nodeMaterial;

	}

	addToneMapping( toneMappingNode, toneMapping ) {

		this.addType( toneMappingNode, toneMapping, this.toneMappingNodes );

	}

	getToneMappingFunction( toneMapping ) {

		return this.toneMappingNodes.get( toneMapping ) || null;

	}

	getMaterialNodeClass( materialType ) {

		return this.materialNodes.get( materialType ) || null;

	}

	addMaterial( materialNodeClass, materialClassType ) {

		this.addType( materialNodeClass, materialClassType, this.materialNodes );

	}

	getLightNodeClass( light ) {

		return this.lightNodes.get( light ) || null;

	}

	addLight( lightNodeClass, lightClass ) {

		this.addClass( lightNodeClass, lightClass, this.lightNodes );

	}

	addType( nodeClass, type, library ) {

		if ( library.has( type ) ) {

			console.warn( `Redefinition of node ${ type }` );
			return;

		}

		if ( typeof nodeClass !== 'function' ) throw new Error( `Node class ${ nodeClass.name } is not a class.` );
		if ( typeof type === 'function' || typeof type === 'object' ) throw new Error( `Base class ${ type } is not a class.` );

		library.set( type, nodeClass );

	}

	addClass( nodeClass, baseClass, library ) {

		if ( library.has( baseClass ) ) {

			console.warn( `Redefinition of node ${ baseClass.name }` );
			return;

		}

		if ( typeof nodeClass !== 'function' ) throw new Error( `Node class ${ nodeClass.name } is not a class.` );
		if ( typeof baseClass !== 'function' ) throw new Error( `Base class ${ baseClass.name } is not a class.` );

		library.set( baseClass, nodeClass );

	}

}

const _defaultLights = /*@__PURE__*/ new LightsNode();

class Lighting extends ChainMap {

	constructor() {

		super();

	}

	createNode( lights = [] ) {

		return new LightsNode().setLights( lights );

	}

	getNode( scene, camera ) {

		// ignore post-processing

		if ( scene.isQuadMesh ) return _defaultLights;

		// tiled lighting

		const keys = [ scene, camera ];

		let node = this.get( keys );

		if ( node === undefined ) {

			node = this.createNode();
			this.set( keys, node );

		}

		return node;

	}

}

const _scene = /*@__PURE__*/ new Scene();
const _drawingBufferSize = /*@__PURE__*/ new Vector2();
const _screen = /*@__PURE__*/ new Vector4();
const _frustum$1 = /*@__PURE__*/ new Frustum();
const _projScreenMatrix$1 = /*@__PURE__*/ new Matrix4();
const _vector4 = /*@__PURE__*/ new Vector4();

class Renderer {

	constructor( backend, parameters = {} ) {

		this.isRenderer = true;

		//

		const {
			logarithmicDepthBuffer = false,
			alpha = true,
			depth = true,
			stencil = false,
			antialias = false,
			samples = 0,
			getFallback = null
		} = parameters;

		// public
		this.domElement = backend.getDomElement();

		this.backend = backend;

		this.samples = samples || ( antialias === true ) ? 4 : 0;

		this.autoClear = true;
		this.autoClearColor = true;
		this.autoClearDepth = true;
		this.autoClearStencil = true;

		this.alpha = alpha;

		this.logarithmicDepthBuffer = logarithmicDepthBuffer;

		this.outputColorSpace = SRGBColorSpace;

		this.toneMapping = NoToneMapping;
		this.toneMappingExposure = 1.0;

		this.sortObjects = true;

		this.depth = depth;
		this.stencil = stencil;

		this.info = new Info();

		this.nodes = {
			modelViewMatrix: null,
			modelNormalViewMatrix: null
		};

		this.library = new NodeLibrary();
		this.lighting = new Lighting();

		// internals

		this._getFallback = getFallback;

		this._pixelRatio = 1;
		this._width = this.domElement.width;
		this._height = this.domElement.height;

		this._viewport = new Vector4( 0, 0, this._width, this._height );
		this._scissor = new Vector4( 0, 0, this._width, this._height );
		this._scissorTest = false;

		this._attributes = null;
		this._geometries = null;
		this._nodes = null;
		this._animation = null;
		this._bindings = null;
		this._objects = null;
		this._pipelines = null;
		this._bundles = null;
		this._renderLists = null;
		this._renderContexts = null;
		this._textures = null;
		this._background = null;

		this._quad = new QuadMesh( new NodeMaterial() );
		this._quad.material.type = 'Renderer_output';

		this._currentRenderContext = null;

		this._opaqueSort = null;
		this._transparentSort = null;

		this._frameBufferTarget = null;

		const alphaClear = this.alpha === true ? 0 : 1;

		this._clearColor = new Color4( 0, 0, 0, alphaClear );
		this._clearDepth = 1;
		this._clearStencil = 0;

		this._renderTarget = null;
		this._activeCubeFace = 0;
		this._activeMipmapLevel = 0;

		this._mrt = null;

		this._renderObjectFunction = null;
		this._currentRenderObjectFunction = null;
		this._currentRenderBundle = null;

		this._handleObjectFunction = this._renderObjectDirect;

		this._isDeviceLost = false;
		this.onDeviceLost = this._onDeviceLost;

		this._initialized = false;
		this._initPromise = null;

		this._compilationPromises = null;

		this.transparent = true;
		this.opaque = true;

		this.shadowMap = {
			enabled: false,
			type: PCFShadowMap
		};

		this.xr = {
			enabled: false
		};

		this.debug = {
			checkShaderErrors: true,
			onShaderError: null,
			getShaderAsync: async ( scene, camera, object ) => {

				await this.compileAsync( scene, camera );

				const renderList = this._renderLists.get( scene, camera );
				const renderContext = this._renderContexts.get( scene, camera, this._renderTarget );

				const material = scene.overrideMaterial || object.material;

				const renderObject = this._objects.get( object, material, scene, camera, renderList.lightsNode, renderContext, renderContext.clippingContext );

				const { fragmentShader, vertexShader } = renderObject.getNodeBuilderState();

				return { fragmentShader, vertexShader };

			}
		};

	}

	async init() {

		if ( this._initialized ) {

			throw new Error( 'Renderer: Backend has already been initialized.' );

		}

		if ( this._initPromise !== null ) {

			return this._initPromise;

		}

		this._initPromise = new Promise( async ( resolve, reject ) => {

			let backend = this.backend;

			try {

				await backend.init( this );

			} catch ( error ) {

				if ( this._getFallback !== null ) {

					// try the fallback

					try {

						this.backend = backend = this._getFallback( error );
						await backend.init( this );

					} catch ( error ) {

						reject( error );
						return;

					}

				} else {

					reject( error );
					return;

				}

			}

			this._nodes = new Nodes( this, backend );
			this._animation = new Animation( this._nodes, this.info );
			this._attributes = new Attributes( backend );
			this._background = new Background( this, this._nodes );
			this._geometries = new Geometries( this._attributes, this.info );
			this._textures = new Textures( this, backend, this.info );
			this._pipelines = new Pipelines( backend, this._nodes );
			this._bindings = new Bindings( backend, this._nodes, this._textures, this._attributes, this._pipelines, this.info );
			this._objects = new RenderObjects( this, this._nodes, this._geometries, this._pipelines, this._bindings, this.info );
			this._renderLists = new RenderLists( this.lighting );
			this._bundles = new RenderBundles();
			this._renderContexts = new RenderContexts();

			//

			this._animation.start();
			this._initialized = true;

			resolve();

		} );

		return this._initPromise;

	}

	get coordinateSystem() {

		return this.backend.coordinateSystem;

	}

	async compileAsync( scene, camera, targetScene = null ) {

		if ( this._isDeviceLost === true ) return;

		if ( this._initialized === false ) await this.init();

		// preserve render tree

		const nodeFrame = this._nodes.nodeFrame;

		const previousRenderId = nodeFrame.renderId;
		const previousRenderContext = this._currentRenderContext;
		const previousRenderObjectFunction = this._currentRenderObjectFunction;
		const previousCompilationPromises = this._compilationPromises;

		//

		const sceneRef = ( scene.isScene === true ) ? scene : _scene;

		if ( targetScene === null ) targetScene = scene;

		const renderTarget = this._renderTarget;
		const renderContext = this._renderContexts.get( targetScene, camera, renderTarget );
		const activeMipmapLevel = this._activeMipmapLevel;

		const compilationPromises = [];

		this._currentRenderContext = renderContext;
		this._currentRenderObjectFunction = this.renderObject;

		this._handleObjectFunction = this._createObjectPipeline;

		this._compilationPromises = compilationPromises;

		nodeFrame.renderId ++;

		//

		nodeFrame.update();

		//

		renderContext.depth = this.depth;
		renderContext.stencil = this.stencil;

		if ( ! renderContext.clippingContext ) renderContext.clippingContext = new ClippingContext();
		renderContext.clippingContext.updateGlobal( sceneRef, camera );

		//

		sceneRef.onBeforeRender( this, scene, camera, renderTarget );

		//

		const renderList = this._renderLists.get( scene, camera );
		renderList.begin();

		this._projectObject( scene, camera, 0, renderList, renderContext.clippingContext );

		// include lights from target scene
		if ( targetScene !== scene ) {

			targetScene.traverseVisible( function ( object ) {

				if ( object.isLight && object.layers.test( camera.layers ) ) {

					renderList.pushLight( object );

				}

			} );

		}

		renderList.finish();

		//

		if ( renderTarget !== null ) {

			this._textures.updateRenderTarget( renderTarget, activeMipmapLevel );

			const renderTargetData = this._textures.get( renderTarget );

			renderContext.textures = renderTargetData.textures;
			renderContext.depthTexture = renderTargetData.depthTexture;

		} else {

			renderContext.textures = null;
			renderContext.depthTexture = null;

		}

		//

		this._nodes.updateScene( sceneRef );

		//

		this._background.update( sceneRef, renderList, renderContext );

		// process render lists

		const opaqueObjects = renderList.opaque;
		const transparentObjects = renderList.transparent;
		const transparentDoublePassObjects = renderList.transparentDoublePass;
		const lightsNode = renderList.lightsNode;

		if ( this.opaque === true && opaqueObjects.length > 0 ) this._renderObjects( opaqueObjects, camera, sceneRef, lightsNode );
		if ( this.transparent === true && transparentObjects.length > 0 ) this._renderTransparents( transparentObjects, transparentDoublePassObjects, camera, sceneRef, lightsNode );

		// restore render tree

		nodeFrame.renderId = previousRenderId;

		this._currentRenderContext = previousRenderContext;
		this._currentRenderObjectFunction = previousRenderObjectFunction;
		this._compilationPromises = previousCompilationPromises;

		this._handleObjectFunction = this._renderObjectDirect;

		// wait for all promises setup by backends awaiting compilation/linking/pipeline creation to complete

		await Promise.all( compilationPromises );

	}

	async renderAsync( scene, camera ) {

		if ( this._initialized === false ) await this.init();

		const renderContext = this._renderScene( scene, camera );

		await this.backend.resolveTimestampAsync( renderContext, 'render' );

	}

	async waitForGPU() {

		await this.backend.waitForGPU();

	}

	setMRT( mrt ) {

		this._mrt = mrt;

		return this;

	}

	getMRT() {

		return this._mrt;

	}

	_onDeviceLost( info ) {

		let errorMessage = `THREE.WebGPURenderer: ${info.api} Device Lost:\n\nMessage: ${info.message}`;

		if ( info.reason ) {

			errorMessage += `\nReason: ${info.reason}`;

		}

		console.error( errorMessage );

		this._isDeviceLost = true;

	}


	_renderBundle( bundle, sceneRef, lightsNode ) {

		const { bundleGroup, camera, renderList } = bundle;

		const renderContext = this._currentRenderContext;

		//

		const renderBundle = this._bundles.get( bundleGroup, camera );
		const renderBundleData = this.backend.get( renderBundle );

		if ( renderBundleData.renderContexts === undefined ) renderBundleData.renderContexts = new Set();

		//

		const needsUpdate = bundleGroup.version !== renderBundleData.version;
		const renderBundleNeedsUpdate = renderBundleData.renderContexts.has( renderContext ) === false || needsUpdate;

		renderBundleData.renderContexts.add( renderContext );

		if ( renderBundleNeedsUpdate ) {

			this.backend.beginBundle( renderContext );

			if ( renderBundleData.renderObjects === undefined || needsUpdate ) {

				renderBundleData.renderObjects = [];

			}

			this._currentRenderBundle = renderBundle;

			const opaqueObjects = renderList.opaque;

			if ( this.opaque === true && opaqueObjects.length > 0 ) this._renderObjects( opaqueObjects, camera, sceneRef, lightsNode );

			this._currentRenderBundle = null;

			//

			this.backend.finishBundle( renderContext, renderBundle );

			renderBundleData.version = bundleGroup.version;

		} else {

			const { renderObjects } = renderBundleData;

			for ( let i = 0, l = renderObjects.length; i < l; i ++ ) {

				const renderObject = renderObjects[ i ];

				if ( this._nodes.needsRefresh( renderObject ) ) {

					this._nodes.updateBefore( renderObject );

					this._nodes.updateForRender( renderObject );
					this._bindings.updateForRender( renderObject );

					this._nodes.updateAfter( renderObject );

				}

			}

		}

		this.backend.addBundle( renderContext, renderBundle );

	}

	render( scene, camera ) {

		if ( this._initialized === false ) {

			console.warn( 'THREE.Renderer: .render() called before the backend is initialized. Try using .renderAsync() instead.' );

			return this.renderAsync( scene, camera );

		}

		this._renderScene( scene, camera );

	}

	_getFrameBufferTarget() {

		const { currentToneMapping, currentColorSpace } = this;

		const useToneMapping = currentToneMapping !== NoToneMapping;
		const useColorSpace = currentColorSpace !== LinearSRGBColorSpace;

		if ( useToneMapping === false && useColorSpace === false ) return null;

		const { width, height } = this.getDrawingBufferSize( _drawingBufferSize );
		const { depth, stencil } = this;

		let frameBufferTarget = this._frameBufferTarget;

		if ( frameBufferTarget === null ) {

			frameBufferTarget = new RenderTarget( width, height, {
				depthBuffer: depth,
				stencilBuffer: stencil,
				type: HalfFloatType, // FloatType
				format: RGBAFormat,
				colorSpace: LinearSRGBColorSpace,
				generateMipmaps: false,
				minFilter: LinearFilter,
				magFilter: LinearFilter,
				samples: this.samples
			} );

			frameBufferTarget.isPostProcessingRenderTarget = true;

			this._frameBufferTarget = frameBufferTarget;

		}

		frameBufferTarget.depthBuffer = depth;
		frameBufferTarget.stencilBuffer = stencil;
		frameBufferTarget.setSize( width, height );
		frameBufferTarget.viewport.copy( this._viewport );
		frameBufferTarget.scissor.copy( this._scissor );
		frameBufferTarget.viewport.multiplyScalar( this._pixelRatio );
		frameBufferTarget.scissor.multiplyScalar( this._pixelRatio );
		frameBufferTarget.scissorTest = this._scissorTest;

		return frameBufferTarget;

	}

	_renderScene( scene, camera, useFrameBufferTarget = true ) {

		if ( this._isDeviceLost === true ) return;

		const frameBufferTarget = useFrameBufferTarget ? this._getFrameBufferTarget() : null;

		// preserve render tree

		const nodeFrame = this._nodes.nodeFrame;

		const previousRenderId = nodeFrame.renderId;
		const previousRenderContext = this._currentRenderContext;
		const previousRenderObjectFunction = this._currentRenderObjectFunction;

		//

		const sceneRef = ( scene.isScene === true ) ? scene : _scene;

		const outputRenderTarget = this._renderTarget;

		const activeCubeFace = this._activeCubeFace;
		const activeMipmapLevel = this._activeMipmapLevel;

		//

		let renderTarget;

		if ( frameBufferTarget !== null ) {

			renderTarget = frameBufferTarget;

			this.setRenderTarget( renderTarget );

		} else {

			renderTarget = outputRenderTarget;

		}

		//

		const renderContext = this._renderContexts.get( scene, camera, renderTarget );

		this._currentRenderContext = renderContext;
		this._currentRenderObjectFunction = this._renderObjectFunction || this.renderObject;

		//

		this.info.calls ++;
		this.info.render.calls ++;
		this.info.render.frameCalls ++;

		nodeFrame.renderId = this.info.calls;

		//

		const coordinateSystem = this.coordinateSystem;

		if ( camera.coordinateSystem !== coordinateSystem ) {

			camera.coordinateSystem = coordinateSystem;

			camera.updateProjectionMatrix();

		}

		//

		if ( scene.matrixWorldAutoUpdate === true ) scene.updateMatrixWorld();

		if ( camera.parent === null && camera.matrixWorldAutoUpdate === true ) camera.updateMatrixWorld();

		//

		let viewport = this._viewport;
		let scissor = this._scissor;
		let pixelRatio = this._pixelRatio;

		if ( renderTarget !== null ) {

			viewport = renderTarget.viewport;
			scissor = renderTarget.scissor;
			pixelRatio = 1;

		}

		this.getDrawingBufferSize( _drawingBufferSize );

		_screen.set( 0, 0, _drawingBufferSize.width, _drawingBufferSize.height );

		const minDepth = ( viewport.minDepth === undefined ) ? 0 : viewport.minDepth;
		const maxDepth = ( viewport.maxDepth === undefined ) ? 1 : viewport.maxDepth;

		renderContext.viewportValue.copy( viewport ).multiplyScalar( pixelRatio ).floor();
		renderContext.viewportValue.width >>= activeMipmapLevel;
		renderContext.viewportValue.height >>= activeMipmapLevel;
		renderContext.viewportValue.minDepth = minDepth;
		renderContext.viewportValue.maxDepth = maxDepth;
		renderContext.viewport = renderContext.viewportValue.equals( _screen ) === false;

		renderContext.scissorValue.copy( scissor ).multiplyScalar( pixelRatio ).floor();
		renderContext.scissor = this._scissorTest && renderContext.scissorValue.equals( _screen ) === false;
		renderContext.scissorValue.width >>= activeMipmapLevel;
		renderContext.scissorValue.height >>= activeMipmapLevel;

		if ( ! renderContext.clippingContext ) renderContext.clippingContext = new ClippingContext();
		renderContext.clippingContext.updateGlobal( sceneRef, camera );

		//

		sceneRef.onBeforeRender( this, scene, camera, renderTarget );

		//

		_projScreenMatrix$1.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		_frustum$1.setFromProjectionMatrix( _projScreenMatrix$1, coordinateSystem );

		const renderList = this._renderLists.get( scene, camera );
		renderList.begin();

		this._projectObject( scene, camera, 0, renderList, renderContext.clippingContext );

		renderList.finish();

		if ( this.sortObjects === true ) {

			renderList.sort( this._opaqueSort, this._transparentSort );

		}

		//

		if ( renderTarget !== null ) {

			this._textures.updateRenderTarget( renderTarget, activeMipmapLevel );

			const renderTargetData = this._textures.get( renderTarget );

			renderContext.textures = renderTargetData.textures;
			renderContext.depthTexture = renderTargetData.depthTexture;
			renderContext.width = renderTargetData.width;
			renderContext.height = renderTargetData.height;
			renderContext.renderTarget = renderTarget;
			renderContext.depth = renderTarget.depthBuffer;
			renderContext.stencil = renderTarget.stencilBuffer;

		} else {

			renderContext.textures = null;
			renderContext.depthTexture = null;
			renderContext.width = this.domElement.width;
			renderContext.height = this.domElement.height;
			renderContext.depth = this.depth;
			renderContext.stencil = this.stencil;

		}

		renderContext.width >>= activeMipmapLevel;
		renderContext.height >>= activeMipmapLevel;
		renderContext.activeCubeFace = activeCubeFace;
		renderContext.activeMipmapLevel = activeMipmapLevel;
		renderContext.occlusionQueryCount = renderList.occlusionQueryCount;

		//

		this._nodes.updateScene( sceneRef );

		//

		this._background.update( sceneRef, renderList, renderContext );

		//

		this.backend.beginRender( renderContext );

		// process render lists

		const {
			bundles,
			lightsNode,
			transparentDoublePass: transparentDoublePassObjects,
			transparent: transparentObjects,
			opaque: opaqueObjects
		} = renderList;

		if ( bundles.length > 0 ) this._renderBundles( bundles, sceneRef, lightsNode );
		if ( this.opaque === true && opaqueObjects.length > 0 ) this._renderObjects( opaqueObjects, camera, sceneRef, lightsNode );
		if ( this.transparent === true && transparentObjects.length > 0 ) this._renderTransparents( transparentObjects, transparentDoublePassObjects, camera, sceneRef, lightsNode );

		// finish render pass

		this.backend.finishRender( renderContext );

		// restore render tree

		nodeFrame.renderId = previousRenderId;

		this._currentRenderContext = previousRenderContext;
		this._currentRenderObjectFunction = previousRenderObjectFunction;

		//

		if ( frameBufferTarget !== null ) {

			this.setRenderTarget( outputRenderTarget, activeCubeFace, activeMipmapLevel );

			const quad = this._quad;

			if ( this._nodes.hasOutputChange( renderTarget.texture ) ) {

				quad.material.fragmentNode = this._nodes.getOutputNode( renderTarget.texture );
				quad.material.needsUpdate = true;

			}

			this._renderScene( quad, quad.camera, false );

		}

		//

		sceneRef.onAfterRender( this, scene, camera, renderTarget );

		//

		return renderContext;

	}

	getMaxAnisotropy() {

		return this.backend.getMaxAnisotropy();

	}

	getActiveCubeFace() {

		return this._activeCubeFace;

	}

	getActiveMipmapLevel() {

		return this._activeMipmapLevel;

	}

	async setAnimationLoop( callback ) {

		if ( this._initialized === false ) await this.init();

		this._animation.setAnimationLoop( callback );

	}

	async getArrayBufferAsync( attribute ) {

		return await this.backend.getArrayBufferAsync( attribute );

	}

	getContext() {

		return this.backend.getContext();

	}

	getPixelRatio() {

		return this._pixelRatio;

	}

	getDrawingBufferSize( target ) {

		return target.set( this._width * this._pixelRatio, this._height * this._pixelRatio ).floor();

	}

	getSize( target ) {

		return target.set( this._width, this._height );

	}

	setPixelRatio( value = 1 ) {

		if ( this._pixelRatio === value ) return;

		this._pixelRatio = value;

		this.setSize( this._width, this._height, false );

	}

	setDrawingBufferSize( width, height, pixelRatio ) {

		this._width = width;
		this._height = height;

		this._pixelRatio = pixelRatio;

		this.domElement.width = Math.floor( width * pixelRatio );
		this.domElement.height = Math.floor( height * pixelRatio );

		this.setViewport( 0, 0, width, height );

		if ( this._initialized ) this.backend.updateSize();

	}

	setSize( width, height, updateStyle = true ) {

		this._width = width;
		this._height = height;

		this.domElement.width = Math.floor( width * this._pixelRatio );
		this.domElement.height = Math.floor( height * this._pixelRatio );

		if ( updateStyle === true ) {

			this.domElement.style.width = width + 'px';
			this.domElement.style.height = height + 'px';

		}

		this.setViewport( 0, 0, width, height );

		if ( this._initialized ) this.backend.updateSize();

	}

	setOpaqueSort( method ) {

		this._opaqueSort = method;

	}

	setTransparentSort( method ) {

		this._transparentSort = method;

	}

	getScissor( target ) {

		const scissor = this._scissor;

		target.x = scissor.x;
		target.y = scissor.y;
		target.width = scissor.width;
		target.height = scissor.height;

		return target;

	}

	setScissor( x, y, width, height ) {

		const scissor = this._scissor;

		if ( x.isVector4 ) {

			scissor.copy( x );

		} else {

			scissor.set( x, y, width, height );

		}

	}

	getScissorTest() {

		return this._scissorTest;

	}

	setScissorTest( boolean ) {

		this._scissorTest = boolean;

		this.backend.setScissorTest( boolean );

	}

	getViewport( target ) {

		return target.copy( this._viewport );

	}

	setViewport( x, y, width, height, minDepth = 0, maxDepth = 1 ) {

		const viewport = this._viewport;

		if ( x.isVector4 ) {

			viewport.copy( x );

		} else {

			viewport.set( x, y, width, height );

		}

		viewport.minDepth = minDepth;
		viewport.maxDepth = maxDepth;

	}

	getClearColor( target ) {

		return target.copy( this._clearColor );

	}

	setClearColor( color, alpha = 1 ) {

		this._clearColor.set( color );
		this._clearColor.a = alpha;

	}

	getClearAlpha() {

		return this._clearColor.a;

	}

	setClearAlpha( alpha ) {

		this._clearColor.a = alpha;

	}

	getClearDepth() {

		return this._clearDepth;

	}

	setClearDepth( depth ) {

		this._clearDepth = depth;

	}

	getClearStencil() {

		return this._clearStencil;

	}

	setClearStencil( stencil ) {

		this._clearStencil = stencil;

	}

	isOccluded( object ) {

		const renderContext = this._currentRenderContext;

		return renderContext && this.backend.isOccluded( renderContext, object );

	}

	clear( color = true, depth = true, stencil = true ) {

		if ( this._initialized === false ) {

			console.warn( 'THREE.Renderer: .clear() called before the backend is initialized. Try using .clearAsync() instead.' );

			return this.clearAsync( color, depth, stencil );

		}

		const renderTarget = this._renderTarget || this._getFrameBufferTarget();

		let renderTargetData = null;

		if ( renderTarget !== null ) {

			this._textures.updateRenderTarget( renderTarget );

			renderTargetData = this._textures.get( renderTarget );

		}

		this.backend.clear( color, depth, stencil, renderTargetData );

		if ( renderTarget !== null && this._renderTarget === null ) {

			// If a color space transform or tone mapping is required,
			// the clear operation clears the intermediate renderTarget texture, but does not update the screen canvas.

			const quad = this._quad;

			if ( this._nodes.hasOutputChange( renderTarget.texture ) ) {

				quad.material.fragmentNode = this._nodes.getOutputNode( renderTarget.texture );
				quad.material.needsUpdate = true;

			}

			this._renderScene( quad, quad.camera, false );

		}

	}

	clearColor() {

		return this.clear( true, false, false );

	}

	clearDepth() {

		return this.clear( false, true, false );

	}

	clearStencil() {

		return this.clear( false, false, true );

	}

	async clearAsync( color = true, depth = true, stencil = true ) {

		if ( this._initialized === false ) await this.init();

		this.clear( color, depth, stencil );

	}

	clearColorAsync() {

		return this.clearAsync( true, false, false );

	}

	clearDepthAsync() {

		return this.clearAsync( false, true, false );

	}

	clearStencilAsync() {

		return this.clearAsync( false, false, true );

	}

	get currentToneMapping() {

		return this._renderTarget !== null ? NoToneMapping : this.toneMapping;

	}

	get currentColorSpace() {

		return this._renderTarget !== null ? LinearSRGBColorSpace : this.outputColorSpace;

	}

	dispose() {

		this.info.dispose();
		this.backend.dispose();

		this._animation.dispose();
		this._objects.dispose();
		this._pipelines.dispose();
		this._nodes.dispose();
		this._bindings.dispose();
		this._renderLists.dispose();
		this._renderContexts.dispose();
		this._textures.dispose();

		this.setRenderTarget( null );
		this.setAnimationLoop( null );

	}

	setRenderTarget( renderTarget, activeCubeFace = 0, activeMipmapLevel = 0 ) {

		this._renderTarget = renderTarget;
		this._activeCubeFace = activeCubeFace;
		this._activeMipmapLevel = activeMipmapLevel;

	}

	getRenderTarget() {

		return this._renderTarget;

	}

	setRenderObjectFunction( renderObjectFunction ) {

		this._renderObjectFunction = renderObjectFunction;

	}

	getRenderObjectFunction() {

		return this._renderObjectFunction;

	}

	compute( computeNodes ) {

		if ( this.isDeviceLost === true ) return;

		if ( this._initialized === false ) {

			console.warn( 'THREE.Renderer: .compute() called before the backend is initialized. Try using .computeAsync() instead.' );

			return this.computeAsync( computeNodes );

		}

		//

		const nodeFrame = this._nodes.nodeFrame;

		const previousRenderId = nodeFrame.renderId;

		//

		this.info.calls ++;
		this.info.compute.calls ++;
		this.info.compute.frameCalls ++;

		nodeFrame.renderId = this.info.calls;

		//

		const backend = this.backend;
		const pipelines = this._pipelines;
		const bindings = this._bindings;
		const nodes = this._nodes;

		const computeList = Array.isArray( computeNodes ) ? computeNodes : [ computeNodes ];

		if ( computeList[ 0 ] === undefined || computeList[ 0 ].isComputeNode !== true ) {

			throw new Error( 'THREE.Renderer: .compute() expects a ComputeNode.' );

		}

		backend.beginCompute( computeNodes );

		for ( const computeNode of computeList ) {

			// onInit

			if ( pipelines.has( computeNode ) === false ) {

				const dispose = () => {

					computeNode.removeEventListener( 'dispose', dispose );

					pipelines.delete( computeNode );
					bindings.delete( computeNode );
					nodes.delete( computeNode );

				};

				computeNode.addEventListener( 'dispose', dispose );

				//

				const onInitFn = computeNode.onInitFunction;

				if ( onInitFn !== null ) {

					onInitFn.call( computeNode, { renderer: this } );

				}

			}

			nodes.updateForCompute( computeNode );
			bindings.updateForCompute( computeNode );

			const computeBindings = bindings.getForCompute( computeNode );
			const computePipeline = pipelines.getForCompute( computeNode, computeBindings );

			backend.compute( computeNodes, computeNode, computeBindings, computePipeline );

		}

		backend.finishCompute( computeNodes );

		//

		nodeFrame.renderId = previousRenderId;

	}

	async computeAsync( computeNodes ) {

		if ( this._initialized === false ) await this.init();

		this.compute( computeNodes );

		await this.backend.resolveTimestampAsync( computeNodes, 'compute' );

	}

	async hasFeatureAsync( name ) {

		if ( this._initialized === false ) await this.init();

		return this.backend.hasFeature( name );

	}

	hasFeature( name ) {

		if ( this._initialized === false ) {

			console.warn( 'THREE.Renderer: .hasFeature() called before the backend is initialized. Try using .hasFeatureAsync() instead.' );

			return false;

		}

		return this.backend.hasFeature( name );

	}

	hasInitialized() {

		return this._initialized;

	}

	async initTextureAsync( texture ) {

		if ( this._initialized === false ) await this.init();

		this._textures.updateTexture( texture );

	}

	initTexture( texture ) {

		if ( this._initialized === false ) {

			console.warn( 'THREE.Renderer: .initTexture() called before the backend is initialized. Try using .initTextureAsync() instead.' );

			return false;

		}

		this._textures.updateTexture( texture );

	}

	copyFramebufferToTexture( framebufferTexture, rectangle = null ) {

		if ( rectangle !== null ) {

			if ( rectangle.isVector2 ) {

				rectangle = _vector4.set( rectangle.x, rectangle.y, framebufferTexture.image.width, framebufferTexture.image.height ).floor();

			} else if ( rectangle.isVector4 ) {

				rectangle = _vector4.copy( rectangle ).floor();

			} else {

				console.error( 'THREE.Renderer.copyFramebufferToTexture: Invalid rectangle.' );

				return;

			}

		} else {

			rectangle = _vector4.set( 0, 0, framebufferTexture.image.width, framebufferTexture.image.height );

		}

		//

		let renderContext = this._currentRenderContext;
		let renderTarget;

		if ( renderContext !== null ) {

			renderTarget = renderContext.renderTarget;

		} else {

			renderTarget = this._renderTarget || this._getFrameBufferTarget();

			if ( renderTarget !== null ) {

				this._textures.updateRenderTarget( renderTarget );

				renderContext = this._textures.get( renderTarget );

			}

		}

		//

		this._textures.updateTexture( framebufferTexture, { renderTarget } );

		this.backend.copyFramebufferToTexture( framebufferTexture, renderContext, rectangle );

	}

	copyTextureToTexture( srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0 ) {

		this._textures.updateTexture( srcTexture );
		this._textures.updateTexture( dstTexture );

		this.backend.copyTextureToTexture( srcTexture, dstTexture, srcRegion, dstPosition, level );

	}

	readRenderTargetPixelsAsync( renderTarget, x, y, width, height, index = 0, faceIndex = 0 ) {

		return this.backend.copyTextureToBuffer( renderTarget.textures[ index ], x, y, width, height, faceIndex );

	}

	_projectObject( object, camera, groupOrder, renderList, clippingContext ) {

		if ( object.visible === false ) return;

		const visible = object.layers.test( camera.layers );

		if ( visible ) {

			if ( object.isGroup ) {

				groupOrder = object.renderOrder;

				if ( object.isClippingGroup && object.enabled ) clippingContext = clippingContext.getGroupContext( object );

			} else if ( object.isLOD ) {

				if ( object.autoUpdate === true ) object.update( camera );

			} else if ( object.isLight ) {

				renderList.pushLight( object );

			} else if ( object.isSprite ) {

				if ( ! object.frustumCulled || _frustum$1.intersectsSprite( object ) ) {

					if ( this.sortObjects === true ) {

						_vector4.setFromMatrixPosition( object.matrixWorld ).applyMatrix4( _projScreenMatrix$1 );

					}

					const { geometry, material } = object;

					if ( material.visible ) {

						renderList.push( object, geometry, material, groupOrder, _vector4.z, null, clippingContext );

					}

				}

			} else if ( object.isLineLoop ) {

				console.error( 'THREE.Renderer: Objects of type THREE.LineLoop are not supported. Please use THREE.Line or THREE.LineSegments.' );

			} else if ( object.isMesh || object.isLine || object.isPoints ) {

				if ( ! object.frustumCulled || _frustum$1.intersectsObject( object ) ) {

					const { geometry, material } = object;

					if ( this.sortObjects === true ) {

						if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

						_vector4
							.copy( geometry.boundingSphere.center )
							.applyMatrix4( object.matrixWorld )
							.applyMatrix4( _projScreenMatrix$1 );

					}

					if ( Array.isArray( material ) ) {

						const groups = geometry.groups;

						for ( let i = 0, l = groups.length; i < l; i ++ ) {

							const group = groups[ i ];
							const groupMaterial = material[ group.materialIndex ];

							if ( groupMaterial && groupMaterial.visible ) {

								renderList.push( object, geometry, groupMaterial, groupOrder, _vector4.z, group, clippingContext );

							}

						}

					} else if ( material.visible ) {

						renderList.push( object, geometry, material, groupOrder, _vector4.z, null, clippingContext );

					}

				}

			}

		}

		if ( object.isBundleGroup === true && this.backend.beginBundle !== undefined ) {

			const baseRenderList = renderList;

			// replace render list
			renderList = this._renderLists.get( object, camera );

			renderList.begin();

			baseRenderList.pushBundle( {
				bundleGroup: object,
				camera,
				renderList,
			} );

			renderList.finish();

		}

		const children = object.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			this._projectObject( children[ i ], camera, groupOrder, renderList, clippingContext );

		}

	}

	_renderBundles( bundles, sceneRef, lightsNode ) {

		for ( const bundle of bundles ) {

			this._renderBundle( bundle, sceneRef, lightsNode );

		}

	}

	_renderTransparents( renderList, doublePassList, camera, scene, lightsNode ) {

		if ( doublePassList.length > 0 ) {

			// render back side

			for ( const { material } of doublePassList ) {

				material.side = BackSide;

			}

			this._renderObjects( doublePassList, camera, scene, lightsNode, 'backSide' );

			// render front side

			for ( const { material } of doublePassList ) {

				material.side = FrontSide;

			}

			this._renderObjects( renderList, camera, scene, lightsNode );

			// restore

			for ( const { material } of doublePassList ) {

				material.side = DoubleSide;

			}

		} else {

			this._renderObjects( renderList, camera, scene, lightsNode );

		}

	}

	_renderObjects( renderList, camera, scene, lightsNode, passId = null ) {

		// process renderable objects

		for ( let i = 0, il = renderList.length; i < il; i ++ ) {

			const renderItem = renderList[ i ];

			// @TODO: Add support for multiple materials per object. This will require to extract
			// the material from the renderItem object and pass it with its group data to renderObject().

			const { object, geometry, material, group, clippingContext } = renderItem;

			if ( camera.isArrayCamera ) {

				const cameras = camera.cameras;

				for ( let j = 0, jl = cameras.length; j < jl; j ++ ) {

					const camera2 = cameras[ j ];

					if ( object.layers.test( camera2.layers ) ) {

						const vp = camera2.viewport;
						const minDepth = ( vp.minDepth === undefined ) ? 0 : vp.minDepth;
						const maxDepth = ( vp.maxDepth === undefined ) ? 1 : vp.maxDepth;

						const viewportValue = this._currentRenderContext.viewportValue;
						viewportValue.copy( vp ).multiplyScalar( this._pixelRatio ).floor();
						viewportValue.minDepth = minDepth;
						viewportValue.maxDepth = maxDepth;

						this.backend.updateViewport( this._currentRenderContext );

						this._currentRenderObjectFunction( object, scene, camera2, geometry, material, group, lightsNode, clippingContext, passId );

					}

				}

			} else {

				this._currentRenderObjectFunction( object, scene, camera, geometry, material, group, lightsNode, clippingContext, passId );

			}

		}

	}

	renderObject( object, scene, camera, geometry, material, group, lightsNode, clippingContext = null, passId = null ) {

		let overridePositionNode;
		let overrideColorNode;
		let overrideDepthNode;

		//

		object.onBeforeRender( this, scene, camera, geometry, material, group );

		//

		if ( scene.overrideMaterial !== null ) {

			const overrideMaterial = scene.overrideMaterial;

			if ( material.positionNode && material.positionNode.isNode ) {

				overridePositionNode = overrideMaterial.positionNode;
				overrideMaterial.positionNode = material.positionNode;

			}

			overrideMaterial.alphaTest = material.alphaTest;
			overrideMaterial.alphaMap = material.alphaMap;

			if ( overrideMaterial.isShadowNodeMaterial ) {

				overrideMaterial.side = material.shadowSide === null ? material.side : material.shadowSide;

				if ( material.depthNode && material.depthNode.isNode ) {

					overrideDepthNode = overrideMaterial.depthNode;
					overrideMaterial.depthNode = material.depthNode;

				}

				if ( material.castShadowNode && material.castShadowNode.isNode ) {

					overrideColorNode = overrideMaterial.colorNode;
					overrideMaterial.colorNode = material.castShadowNode;

				}

			}

			material = overrideMaterial;

		}

		//

		if ( material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false ) {

			material.side = BackSide;
			this._handleObjectFunction( object, material, scene, camera, lightsNode, group, clippingContext, 'backSide' ); // create backSide pass id

			material.side = FrontSide;
			this._handleObjectFunction( object, material, scene, camera, lightsNode, group, clippingContext, passId ); // use default pass id

			material.side = DoubleSide;

		} else {

			this._handleObjectFunction( object, material, scene, camera, lightsNode, group, clippingContext, passId );

		}

		//

		if ( overridePositionNode !== undefined ) {

			scene.overrideMaterial.positionNode = overridePositionNode;

		}

		if ( overrideDepthNode !== undefined ) {

			scene.overrideMaterial.depthNode = overrideDepthNode;

		}

		if ( overrideColorNode !== undefined ) {

			scene.overrideMaterial.colorNode = overrideColorNode;

		}

		//

		object.onAfterRender( this, scene, camera, geometry, material, group );

	}

	_renderObjectDirect( object, material, scene, camera, lightsNode, group, clippingContext, passId ) {

		const renderObject = this._objects.get( object, material, scene, camera, lightsNode, this._currentRenderContext, clippingContext, passId );
		renderObject.drawRange = object.geometry.drawRange;
		renderObject.group = group;

		//

		const needsRefresh = this._nodes.needsRefresh( renderObject );

		if ( needsRefresh ) {

			this._nodes.updateBefore( renderObject );

			this._geometries.updateForRender( renderObject );

			this._nodes.updateForRender( renderObject );
			this._bindings.updateForRender( renderObject );

		}

		this._pipelines.updateForRender( renderObject );

		//

		if ( this._currentRenderBundle !== null ) {

			const renderBundleData = this.backend.get( this._currentRenderBundle );

			renderBundleData.renderObjects.push( renderObject );

			renderObject.bundle = this._currentRenderBundle.scene;

		}

		this.backend.draw( renderObject, this.info );

		if ( needsRefresh ) this._nodes.updateAfter( renderObject );

	}

	_createObjectPipeline( object, material, scene, camera, lightsNode, clippingContext, passId ) {

		const renderObject = this._objects.get( object, material, scene, camera, lightsNode, this._currentRenderContext, clippingContext, passId );

		//

		this._nodes.updateBefore( renderObject );

		this._geometries.updateForRender( renderObject );

		this._nodes.updateForRender( renderObject );
		this._bindings.updateForRender( renderObject );

		this._pipelines.getForRender( renderObject, this._compilationPromises );

		this._nodes.updateAfter( renderObject );

	}

	get compile() {

		return this.compileAsync;

	}

}

class Binding {

	constructor( name = '' ) {

		this.name = name;

		this.visibility = 0;

	}

	setVisibility( visibility ) {

		this.visibility |= visibility;

	}

	clone() {

		return Object.assign( new this.constructor(), this );

	}

}

function getFloatLength( floatLength ) {

	// ensure chunk size alignment (STD140 layout)

	return floatLength + ( ( GPU_CHUNK_BYTES - ( floatLength % GPU_CHUNK_BYTES ) ) % GPU_CHUNK_BYTES );

}

class Buffer extends Binding {

	constructor( name, buffer = null ) {

		super( name );

		this.isBuffer = true;

		this.bytesPerElement = Float32Array.BYTES_PER_ELEMENT;

		this._buffer = buffer;

	}

	get byteLength() {

		return getFloatLength( this._buffer.byteLength );

	}

	get buffer() {

		return this._buffer;

	}

	update() {

		return true;

	}

}

class UniformBuffer extends Buffer {

	constructor( name, buffer = null ) {

		super( name, buffer );

		this.isUniformBuffer = true;

	}

}

let _id$4 = 0;

class NodeUniformBuffer extends UniformBuffer {

	constructor( nodeUniform, groupNode ) {

		super( 'UniformBuffer_' + _id$4 ++, nodeUniform ? nodeUniform.value : null );

		this.nodeUniform = nodeUniform;
		this.groupNode = groupNode;

	}

	get buffer() {

		return this.nodeUniform.value;

	}

}

class UniformsGroup extends UniformBuffer {

	constructor( name ) {

		super( name );

		this.isUniformsGroup = true;

		this._values = null;

		// the order of uniforms in this array must match the order of uniforms in the shader

		this.uniforms = [];

	}

	addUniform( uniform ) {

		this.uniforms.push( uniform );

		return this;

	}

	removeUniform( uniform ) {

		const index = this.uniforms.indexOf( uniform );

		if ( index !== -1 ) {

			this.uniforms.splice( index, 1 );

		}

		return this;

	}

	get values() {

		if ( this._values === null ) {

			this._values = Array.from( this.buffer );

		}

		return this._values;

	}

	get buffer() {

		let buffer = this._buffer;

		if ( buffer === null ) {

			const byteLength = this.byteLength;

			buffer = new Float32Array( new ArrayBuffer( byteLength ) );

			this._buffer = buffer;

		}

		return buffer;

	}

	get byteLength() {

		let offset = 0; // global buffer offset in bytes

		for ( let i = 0, l = this.uniforms.length; i < l; i ++ ) {

			const uniform = this.uniforms[ i ];

			const { boundary, itemSize } = uniform;

			// offset within a single chunk in bytes

			const chunkOffset = offset % GPU_CHUNK_BYTES;
			const remainingSizeInChunk = GPU_CHUNK_BYTES - chunkOffset;

			// conformance tests

			if ( chunkOffset !== 0 && ( remainingSizeInChunk - boundary ) < 0 ) {

				// check for chunk overflow

				offset += ( GPU_CHUNK_BYTES - chunkOffset );

			} else if ( chunkOffset % boundary !== 0 ) {

				// check for correct alignment

				offset += ( chunkOffset % boundary );

			}

			uniform.offset = ( offset / this.bytesPerElement );

			offset += ( itemSize * this.bytesPerElement );

		}

		return Math.ceil( offset / GPU_CHUNK_BYTES ) * GPU_CHUNK_BYTES;

	}

	update() {

		let updated = false;

		for ( const uniform of this.uniforms ) {

			if ( this.updateByType( uniform ) === true ) {

				updated = true;

			}

		}

		return updated;

	}

	updateByType( uniform ) {

		if ( uniform.isNumberUniform ) return this.updateNumber( uniform );
		if ( uniform.isVector2Uniform ) return this.updateVector2( uniform );
		if ( uniform.isVector3Uniform ) return this.updateVector3( uniform );
		if ( uniform.isVector4Uniform ) return this.updateVector4( uniform );
		if ( uniform.isColorUniform ) return this.updateColor( uniform );
		if ( uniform.isMatrix3Uniform ) return this.updateMatrix3( uniform );
		if ( uniform.isMatrix4Uniform ) return this.updateMatrix4( uniform );

		console.error( 'THREE.WebGPUUniformsGroup: Unsupported uniform type.', uniform );

	}

	updateNumber( uniform ) {

		let updated = false;

		const a = this.values;
		const v = uniform.getValue();
		const offset = uniform.offset;
		const type = uniform.getType();

		if ( a[ offset ] !== v ) {

			const b = this._getBufferForType( type );

			b[ offset ] = a[ offset ] = v;
			updated = true;

		}

		return updated;

	}

	updateVector2( uniform ) {

		let updated = false;

		const a = this.values;
		const v = uniform.getValue();
		const offset = uniform.offset;
		const type = uniform.getType();

		if ( a[ offset + 0 ] !== v.x || a[ offset + 1 ] !== v.y ) {

			const b = this._getBufferForType( type );

			b[ offset + 0 ] = a[ offset + 0 ] = v.x;
			b[ offset + 1 ] = a[ offset + 1 ] = v.y;

			updated = true;

		}

		return updated;

	}

	updateVector3( uniform ) {

		let updated = false;

		const a = this.values;
		const v = uniform.getValue();
		const offset = uniform.offset;
		const type = uniform.getType();

		if ( a[ offset + 0 ] !== v.x || a[ offset + 1 ] !== v.y || a[ offset + 2 ] !== v.z ) {

			const b = this._getBufferForType( type );

			b[ offset + 0 ] = a[ offset + 0 ] = v.x;
			b[ offset + 1 ] = a[ offset + 1 ] = v.y;
			b[ offset + 2 ] = a[ offset + 2 ] = v.z;

			updated = true;

		}

		return updated;

	}

	updateVector4( uniform ) {

		let updated = false;

		const a = this.values;
		const v = uniform.getValue();
		const offset = uniform.offset;
		const type = uniform.getType();

		if ( a[ offset + 0 ] !== v.x || a[ offset + 1 ] !== v.y || a[ offset + 2 ] !== v.z || a[ offset + 4 ] !== v.w ) {

			const b = this._getBufferForType( type );

			b[ offset + 0 ] = a[ offset + 0 ] = v.x;
			b[ offset + 1 ] = a[ offset + 1 ] = v.y;
			b[ offset + 2 ] = a[ offset + 2 ] = v.z;
			b[ offset + 3 ] = a[ offset + 3 ] = v.w;

			updated = true;

		}

		return updated;

	}

	updateColor( uniform ) {

		let updated = false;

		const a = this.values;
		const c = uniform.getValue();
		const offset = uniform.offset;

		if ( a[ offset + 0 ] !== c.r || a[ offset + 1 ] !== c.g || a[ offset + 2 ] !== c.b ) {

			const b = this.buffer;

			b[ offset + 0 ] = a[ offset + 0 ] = c.r;
			b[ offset + 1 ] = a[ offset + 1 ] = c.g;
			b[ offset + 2 ] = a[ offset + 2 ] = c.b;

			updated = true;

		}

		return updated;

	}

	updateMatrix3( uniform ) {

		let updated = false;

		const a = this.values;
		const e = uniform.getValue().elements;
		const offset = uniform.offset;

		if ( a[ offset + 0 ] !== e[ 0 ] || a[ offset + 1 ] !== e[ 1 ] || a[ offset + 2 ] !== e[ 2 ] ||
			a[ offset + 4 ] !== e[ 3 ] || a[ offset + 5 ] !== e[ 4 ] || a[ offset + 6 ] !== e[ 5 ] ||
			a[ offset + 8 ] !== e[ 6 ] || a[ offset + 9 ] !== e[ 7 ] || a[ offset + 10 ] !== e[ 8 ] ) {

			const b = this.buffer;

			b[ offset + 0 ] = a[ offset + 0 ] = e[ 0 ];
			b[ offset + 1 ] = a[ offset + 1 ] = e[ 1 ];
			b[ offset + 2 ] = a[ offset + 2 ] = e[ 2 ];
			b[ offset + 4 ] = a[ offset + 4 ] = e[ 3 ];
			b[ offset + 5 ] = a[ offset + 5 ] = e[ 4 ];
			b[ offset + 6 ] = a[ offset + 6 ] = e[ 5 ];
			b[ offset + 8 ] = a[ offset + 8 ] = e[ 6 ];
			b[ offset + 9 ] = a[ offset + 9 ] = e[ 7 ];
			b[ offset + 10 ] = a[ offset + 10 ] = e[ 8 ];

			updated = true;

		}

		return updated;

	}

	updateMatrix4( uniform ) {

		let updated = false;

		const a = this.values;
		const e = uniform.getValue().elements;
		const offset = uniform.offset;

		if ( arraysEqual( a, e, offset ) === false ) {

			const b = this.buffer;
			b.set( e, offset );
			setArray( a, e, offset );
			updated = true;

		}

		return updated;

	}

	_getBufferForType( type ) {

		if ( type === 'int' || type === 'ivec2' || type === 'ivec3' || type === 'ivec4' ) return new Int32Array( this.buffer.buffer );
		if ( type === 'uint' || type === 'uvec2' || type === 'uvec3' || type === 'uvec4' ) return new Uint32Array( this.buffer.buffer );
		return this.buffer;

	}

}

function setArray( a, b, offset ) {

	for ( let i = 0, l = b.length; i < l; i ++ ) {

		a[ offset + i ] = b[ i ];

	}

}

function arraysEqual( a, b, offset ) {

	for ( let i = 0, l = b.length; i < l; i ++ ) {

		if ( a[ offset + i ] !== b[ i ] ) return false;

	}

	return true;

}

let _id$3 = 0;

class NodeUniformsGroup extends UniformsGroup {

	constructor( name, groupNode ) {

		super( name );

		this.id = _id$3 ++;
		this.groupNode = groupNode;

		this.isNodeUniformsGroup = true;

	}

	getNodes() {

		const nodes = [];

		for ( const uniform of this.uniforms ) {

			const node = uniform.nodeUniform.node;

			if ( ! node ) throw new Error( 'NodeUniformsGroup: Uniform has no node.' );

			nodes.push( node );

		}

		return nodes;

	}

}

let _id$2 = 0;

class SampledTexture extends Binding {

	constructor( name, texture ) {

		super( name );

		this.id = _id$2 ++;

		this.texture = texture;
		this.version = texture ? texture.version : 0;
		this.store = false;
		this.generation = null;

		this.isSampledTexture = true;

	}

	needsBindingsUpdate( generation ) {

		const { texture } = this;

		if ( generation !== this.generation ) {

			this.generation = generation;

			return true;

		}

		return texture.isVideoTexture;

	}

	update() {

		const { texture, version } = this;

		if ( version !== texture.version ) {

			this.version = texture.version;

			return true;

		}

		return false;

	}

}

class NodeSampledTexture extends SampledTexture {

	constructor( name, textureNode, groupNode, access = null ) {

		super( name, textureNode ? textureNode.value : null );

		this.textureNode = textureNode;
		this.groupNode = groupNode;

		this.access = access;

	}

	needsBindingsUpdate( generation ) {

		return this.textureNode.value !== this.texture || super.needsBindingsUpdate( generation );

	}

	update() {

		const { textureNode } = this;

		if ( this.texture !== textureNode.value ) {

			this.texture = textureNode.value;

			return true;

		}

		return super.update();

	}

}

class NodeSampledCubeTexture extends NodeSampledTexture {

	constructor( name, textureNode, groupNode, access ) {

		super( name, textureNode, groupNode, access );

		this.isSampledCubeTexture = true;

	}

}

class NodeSampledTexture3D extends NodeSampledTexture {

	constructor( name, textureNode, groupNode, access ) {

		super( name, textureNode, groupNode, access );

		this.isSampledTexture3D = true;

	}

}

const glslMethods = {
	atan2: 'atan',
	textureDimensions: 'textureSize',
	equals: 'equal'
};

const precisionLib = {
	low: 'lowp',
	medium: 'mediump',
	high: 'highp'
};

const supports$1 = {
	swizzleAssign: true,
	storageBuffer: false
};

const defaultPrecisions = `
precision highp float;
precision highp int;
precision highp sampler2D;
precision highp sampler3D;
precision highp samplerCube;
precision highp sampler2DArray;

precision highp usampler2D;
precision highp usampler3D;
precision highp usamplerCube;
precision highp usampler2DArray;

precision highp isampler2D;
precision highp isampler3D;
precision highp isamplerCube;
precision highp isampler2DArray;

precision lowp sampler2DShadow;
`;

class GLSLNodeBuilder extends NodeBuilder {

	constructor( object, renderer ) {

		super( object, renderer, new GLSLNodeParser() );

		this.uniformGroups = {};
		this.transforms = [];
		this.extensions = {};
		this.builtins = { vertex: [], fragment: [], compute: [] };

		this.useComparisonMethod = true;

	}

	needsToWorkingColorSpace( texture ) {

		return texture.isVideoTexture === true && texture.colorSpace !== NoColorSpace;

	}

	getMethod( method ) {

		return glslMethods[ method ] || method;

	}

	getOutputStructName() {

		return '';

	}

	buildFunctionCode( shaderNode ) {

		const layout = shaderNode.layout;
		const flowData = this.flowShaderNode( shaderNode );

		const parameters = [];

		for ( const input of layout.inputs ) {

			parameters.push( this.getType( input.type ) + ' ' + input.name );

		}

		//

		const code = `${ this.getType( layout.type ) } ${ layout.name }( ${ parameters.join( ', ' ) } ) {

	${ flowData.vars }

${ flowData.code }
	return ${ flowData.result };

}`;

		//

		return code;

	}

	setupPBO( storageBufferNode ) {

		const attribute = storageBufferNode.value;

		if ( attribute.pbo === undefined ) {

			const originalArray = attribute.array;
			const numElements = attribute.count * attribute.itemSize;

			const { itemSize } = attribute;

			const isInteger = attribute.array.constructor.name.toLowerCase().includes( 'int' );

			let format = isInteger ? RedIntegerFormat : RedFormat;

			if ( itemSize === 2 ) {

				format = isInteger ? RGIntegerFormat : RGFormat;

			} else if ( itemSize === 3 ) {

				format = isInteger ? RGBIntegerFormat : RGBFormat;

			} else if ( itemSize === 4 ) {

				format = isInteger ? RGBAIntegerFormat : RGBAFormat;

			}

			const typeMap = {
				Float32Array: FloatType,
				Uint8Array: UnsignedByteType,
				Uint16Array: UnsignedShortType,
				Uint32Array: UnsignedIntType,
				Int8Array: ByteType,
				Int16Array: ShortType,
				Int32Array: IntType,
				Uint8ClampedArray: UnsignedByteType,
			};

			const width = Math.pow( 2, Math.ceil( Math.log2( Math.sqrt( numElements / itemSize ) ) ) );
			let height = Math.ceil( ( numElements / itemSize ) / width );
			if ( width * height * itemSize < numElements ) height ++; // Ensure enough space

			const newSize = width * height * itemSize;

			const newArray = new originalArray.constructor( newSize );

			newArray.set( originalArray, 0 );

			attribute.array = newArray;

			const pboTexture = new DataTexture( attribute.array, width, height, format, typeMap[ attribute.array.constructor.name ] || FloatType );
			pboTexture.needsUpdate = true;
			pboTexture.isPBOTexture = true;

			const pbo = new TextureNode( pboTexture, null, null );
			pbo.setPrecision( 'high' );

			attribute.pboNode = pbo;
			attribute.pbo = pbo.value;

			this.getUniformFromNode( attribute.pboNode, 'texture', this.shaderStage, this.context.label );

		}

	}

	getPropertyName( node, shaderStage = this.shaderStage ) {

		if ( node.isNodeUniform && node.node.isTextureNode !== true && node.node.isBufferNode !== true ) {

			return shaderStage.charAt( 0 ) + '_' + node.name;

		}

		return super.getPropertyName( node, shaderStage );

	}

	generatePBO( storageArrayElementNode ) {

		const { node, indexNode } = storageArrayElementNode;
		const attribute = node.value;

		if ( this.renderer.backend.has( attribute ) ) {

			const attributeData = this.renderer.backend.get( attribute );
			attributeData.pbo = attribute.pbo;

		}

		const nodeUniform = this.getUniformFromNode( attribute.pboNode, 'texture', this.shaderStage, this.context.label );
		const textureName = this.getPropertyName( nodeUniform );

		this.increaseUsage( indexNode ); // force cache generate to be used as index in x,y
		const indexSnippet = indexNode.build( this, 'uint' );

		const elementNodeData = this.getDataFromNode( storageArrayElementNode );

		let propertyName = elementNodeData.propertyName;

		if ( propertyName === undefined ) {

			// property element

			const nodeVar = this.getVarFromNode( storageArrayElementNode );

			propertyName = this.getPropertyName( nodeVar );

			// property size

			const bufferNodeData = this.getDataFromNode( node );

			let propertySizeName = bufferNodeData.propertySizeName;

			if ( propertySizeName === undefined ) {

				propertySizeName = propertyName + 'Size';

				this.getVarFromNode( node, propertySizeName, 'uint' );

				this.addLineFlowCode( `${ propertySizeName } = uint( textureSize( ${ textureName }, 0 ).x )`, storageArrayElementNode );

				bufferNodeData.propertySizeName = propertySizeName;

			}

			//

			const { itemSize } = attribute;

			const channel = '.' + vectorComponents.join( '' ).slice( 0, itemSize );
			const uvSnippet = `ivec2(${indexSnippet} % ${ propertySizeName }, ${indexSnippet} / ${ propertySizeName })`;

			const snippet = this.generateTextureLoad( null, textureName, uvSnippet, null, '0' );

			//


			let prefix = 'vec4';

			if ( attribute.pbo.type === UnsignedIntType ) {

				prefix = 'uvec4';

			} else if ( attribute.pbo.type === IntType ) {

				prefix = 'ivec4';

			}

			this.addLineFlowCode( `${ propertyName } = ${prefix}(${ snippet })${channel}`, storageArrayElementNode );

			elementNodeData.propertyName = propertyName;

		}

		return propertyName;

	}

	generateTextureLoad( texture, textureProperty, uvIndexSnippet, depthSnippet, levelSnippet = '0' ) {

		if ( depthSnippet ) {

			return `texelFetch( ${ textureProperty }, ivec3( ${ uvIndexSnippet }, ${ depthSnippet } ), ${ levelSnippet } )`;

		} else {

			return `texelFetch( ${ textureProperty }, ${ uvIndexSnippet }, ${ levelSnippet } )`;

		}

	}

	generateTexture( texture, textureProperty, uvSnippet, depthSnippet ) {

		if ( texture.isDepthTexture ) {

			return `texture( ${ textureProperty }, ${ uvSnippet } ).x`;

		} else {

			if ( depthSnippet ) uvSnippet = `vec3( ${ uvSnippet }, ${ depthSnippet } )`;

			return `texture( ${ textureProperty }, ${ uvSnippet } )`;

		}

	}

	generateTextureLevel( texture, textureProperty, uvSnippet, levelSnippet ) {

		return `textureLod( ${ textureProperty }, ${ uvSnippet }, ${ levelSnippet } )`;

	}

	generateTextureBias( texture, textureProperty, uvSnippet, biasSnippet ) {

		return `texture( ${ textureProperty }, ${ uvSnippet }, ${ biasSnippet } )`;

	}

	generateTextureGrad( texture, textureProperty, uvSnippet, gradSnippet ) {

		return `textureGrad( ${ textureProperty }, ${ uvSnippet }, ${ gradSnippet[ 0 ] }, ${ gradSnippet[ 1 ] } )`;

	}

	generateTextureCompare( texture, textureProperty, uvSnippet, compareSnippet, depthSnippet, shaderStage = this.shaderStage ) {

		if ( shaderStage === 'fragment' ) {

			return `texture( ${ textureProperty }, vec3( ${ uvSnippet }, ${ compareSnippet } ) )`;

		} else {

			console.error( `WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${ shaderStage } shader.` );

		}

	}

	getVars( shaderStage ) {

		const snippets = [];

		const vars = this.vars[ shaderStage ];

		if ( vars !== undefined ) {

			for ( const variable of vars ) {

				snippets.push( `${ this.getVar( variable.type, variable.name ) };` );

			}

		}

		return snippets.join( '\n\t' );

	}

	getUniforms( shaderStage ) {

		const uniforms = this.uniforms[ shaderStage ];

		const bindingSnippets = [];
		const uniformGroups = {};

		for ( const uniform of uniforms ) {

			let snippet = null;
			let group = false;

			if ( uniform.type === 'texture' ) {

				const texture = uniform.node.value;

				let typePrefix = '';

				if ( texture.isDataTexture === true ) {


					if ( texture.type === UnsignedIntType ) {

						typePrefix = 'u';

					} else if ( texture.type === IntType ) {

						typePrefix = 'i';

					}

				}

				if ( texture.compareFunction ) {

					snippet = `sampler2DShadow ${ uniform.name };`;

				} else if ( texture.isDataArrayTexture === true || texture.isCompressedArrayTexture === true ) {

					snippet = `${typePrefix}sampler2DArray ${ uniform.name };`;

				} else {

					snippet = `${typePrefix}sampler2D ${ uniform.name };`;

				}

			} else if ( uniform.type === 'cubeTexture' ) {

				snippet = `samplerCube ${ uniform.name };`;

			} else if ( uniform.type === 'texture3D' ) {

				snippet = `sampler3D ${ uniform.name };`;

			} else if ( uniform.type === 'buffer' ) {

				const bufferNode = uniform.node;
				const bufferType = this.getType( bufferNode.bufferType );
				const bufferCount = bufferNode.bufferCount;

				const bufferCountSnippet = bufferCount > 0 ? bufferCount : '';
				snippet = `${bufferNode.name} {\n\t${ bufferType } ${ uniform.name }[${ bufferCountSnippet }];\n};\n`;

			} else {

				const vectorType = this.getVectorType( uniform.type );

				snippet = `${ vectorType } ${ this.getPropertyName( uniform, shaderStage ) };`;

				group = true;

			}

			const precision = uniform.node.precision;

			if ( precision !== null ) {

				snippet = precisionLib[ precision ] + ' ' + snippet;

			}

			if ( group ) {

				snippet = '\t' + snippet;

				const groupName = uniform.groupNode.name;
				const groupSnippets = uniformGroups[ groupName ] || ( uniformGroups[ groupName ] = [] );

				groupSnippets.push( snippet );

			} else {

				snippet = 'uniform ' + snippet;

				bindingSnippets.push( snippet );

			}

		}

		let output = '';

		for ( const name in uniformGroups ) {

			const groupSnippets = uniformGroups[ name ];

			output += this._getGLSLUniformStruct( shaderStage + '_' + name, groupSnippets.join( '\n' ) ) + '\n';

		}

		output += bindingSnippets.join( '\n' );

		return output;

	}

	getTypeFromAttribute( attribute ) {

		let nodeType = super.getTypeFromAttribute( attribute );

		if ( /^[iu]/.test( nodeType ) && attribute.gpuType !== IntType ) {

			let dataAttribute = attribute;

			if ( attribute.isInterleavedBufferAttribute ) dataAttribute = attribute.data;

			const array = dataAttribute.array;

			if ( ( array instanceof Uint32Array || array instanceof Int32Array ) === false ) {

				nodeType = nodeType.slice( 1 );

			}

		}

		return nodeType;

	}

	getAttributes( shaderStage ) {

		let snippet = '';

		if ( shaderStage === 'vertex' || shaderStage === 'compute' ) {

			const attributes = this.getAttributesArray();

			let location = 0;

			for ( const attribute of attributes ) {

				snippet += `layout( location = ${ location ++ } ) in ${ attribute.type } ${ attribute.name };\n`;

			}

		}

		return snippet;

	}

	getStructMembers( struct ) {

		const snippets = [];
		const members = struct.getMemberTypes();

		for ( let i = 0; i < members.length; i ++ ) {

			const member = members[ i ];
			snippets.push( `layout( location = ${i} ) out ${ member} m${i};` );

		}

		return snippets.join( '\n' );

	}

	getStructs( shaderStage ) {

		const snippets = [];
		const structs = this.structs[ shaderStage ];

		if ( structs.length === 0 ) {

			return 'layout( location = 0 ) out vec4 fragColor;\n';

		}

		for ( let index = 0, length = structs.length; index < length; index ++ ) {

			const struct = structs[ index ];

			let snippet = '\n';
			snippet += this.getStructMembers( struct );
			snippet += '\n';

			snippets.push( snippet );

		}

		return snippets.join( '\n\n' );

	}

	getVaryings( shaderStage ) {

		let snippet = '';

		const varyings = this.varyings;

		if ( shaderStage === 'vertex' || shaderStage === 'compute' ) {

			for ( const varying of varyings ) {

				if ( shaderStage === 'compute' ) varying.needsInterpolation = true;
				const type = this.getType( varying.type );
				const flat = type.includes( 'int' ) || type.includes( 'uv' ) || type.includes( 'iv' ) ? 'flat ' : '';

				snippet += `${flat}${varying.needsInterpolation ? 'out' : '/*out*/'} ${type} ${varying.name};\n`;

			}

		} else if ( shaderStage === 'fragment' ) {

			for ( const varying of varyings ) {

				if ( varying.needsInterpolation ) {

					const type = this.getType( varying.type );
					const flat = type.includes( 'int' ) || type.includes( 'uv' ) || type.includes( 'iv' ) ? 'flat ' : '';

					snippet += `${flat}in ${type} ${varying.name};\n`;

				}

			}

		}

		for ( const builtin of this.builtins[ shaderStage ] ) {

			snippet += `${builtin};\n`;

		}

		return snippet;

	}

	getVertexIndex() {

		return 'uint( gl_VertexID )';

	}

	getInstanceIndex() {

		return 'uint( gl_InstanceID )';

	}

	getInvocationLocalIndex() {

		const workgroupSize = this.object.workgroupSize;

		const size = workgroupSize.reduce( ( acc, curr ) => acc * curr, 1 );

		return `uint( gl_InstanceID ) % ${size}u`;

	}

	getDrawIndex() {

		const extensions = this.renderer.backend.extensions;

		if ( extensions.has( 'WEBGL_multi_draw' ) ) {

			return 'uint( gl_DrawID )';

		}

		return null;

	}

	getFrontFacing() {

		return 'gl_FrontFacing';

	}

	getFragCoord() {

		return 'gl_FragCoord.xy';

	}

	getFragDepth() {

		return 'gl_FragDepth';

	}

	enableExtension( name, behavior, shaderStage = this.shaderStage ) {

		const map = this.extensions[ shaderStage ] || ( this.extensions[ shaderStage ] = new Map() );

		if ( map.has( name ) === false ) {

			map.set( name, {
				name,
				behavior
			} );

		}

	}

	getExtensions( shaderStage ) {

		const snippets = [];

		if ( shaderStage === 'vertex' ) {

			const ext = this.renderer.backend.extensions;
			const isBatchedMesh = this.object.isBatchedMesh;

			if ( isBatchedMesh && ext.has( 'WEBGL_multi_draw' ) ) {

				this.enableExtension( 'GL_ANGLE_multi_draw', 'require', shaderStage );

			}

		}

		const extensions = this.extensions[ shaderStage ];

		if ( extensions !== undefined ) {

			for ( const { name, behavior } of extensions.values() ) {

				snippets.push( `#extension ${name} : ${behavior}` );

			}

		}

		return snippets.join( '\n' );

	}

	getClipDistance() {

		return 'gl_ClipDistance';

	}

	isAvailable( name ) {

		let result = supports$1[ name ];

		if ( result === undefined ) {

			let extensionName;

			result = false;

			switch ( name ) {

				case 'float32Filterable':
					extensionName = 'OES_texture_float_linear';
					break;

				case 'clipDistance':
					extensionName = 'WEBGL_clip_cull_distance';
					break;

			}

			if ( extensionName !== undefined ) {

				const extensions = this.renderer.backend.extensions;

				if ( extensions.has( extensionName ) ) {

					extensions.get( extensionName );
					result = true;

				}

			}

			supports$1[ name ] = result;

		}

		return result;

	}

	isFlipY() {

		return true;

	}

	enableHardwareClipping( planeCount ) {

		this.enableExtension( 'GL_ANGLE_clip_cull_distance', 'require' );

		this.builtins[ 'vertex' ].push( `out float gl_ClipDistance[ ${ planeCount } ]` );

	}

	registerTransform( varyingName, attributeNode ) {

		this.transforms.push( { varyingName, attributeNode } );

	}

	getTransforms( /* shaderStage  */ ) {

		const transforms = this.transforms;

		let snippet = '';

		for ( let i = 0; i < transforms.length; i ++ ) {

			const transform = transforms[ i ];

			const attributeName = this.getPropertyName( transform.attributeNode );

			snippet += `${ transform.varyingName } = ${ attributeName };\n\t`;

		}

		return snippet;

	}

	_getGLSLUniformStruct( name, vars ) {

		return `
layout( std140 ) uniform ${name} {
${vars}
};`;

	}

	_getGLSLVertexCode( shaderData ) {

		return `#version 300 es

${ this.getSignature() }

// extensions 
${shaderData.extensions}

// precision
${ defaultPrecisions }

// uniforms
${shaderData.uniforms}

// varyings
${shaderData.varyings}

// attributes
${shaderData.attributes}

// codes
${shaderData.codes}

void main() {

	// vars
	${shaderData.vars}

	// transforms
	${shaderData.transforms}

	// flow
	${shaderData.flow}

	gl_PointSize = 1.0;

}
`;

	}

	_getGLSLFragmentCode( shaderData ) {

		return `#version 300 es

${ this.getSignature() }

// precision
${ defaultPrecisions }

// uniforms
${shaderData.uniforms}

// varyings
${shaderData.varyings}

// codes
${shaderData.codes}

${shaderData.structs}

void main() {

	// vars
	${shaderData.vars}

	// flow
	${shaderData.flow}

}
`;

	}

	buildCode() {

		const shadersData = this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };

		this.sortBindingGroups();

		for ( const shaderStage in shadersData ) {

			let flow = '// code\n\n';
			flow += this.flowCode[ shaderStage ];

			const flowNodes = this.flowNodes[ shaderStage ];
			const mainNode = flowNodes[ flowNodes.length - 1 ];

			for ( const node of flowNodes ) {

				const flowSlotData = this.getFlowData( node/*, shaderStage*/ );
				const slotName = node.name;

				if ( slotName ) {

					if ( flow.length > 0 ) flow += '\n';

					flow += `\t// flow -> ${ slotName }\n\t`;

				}

				flow += `${ flowSlotData.code }\n\t`;

				if ( node === mainNode && shaderStage !== 'compute' ) {

					flow += '// result\n\t';

					if ( shaderStage === 'vertex' ) {

						flow += 'gl_Position = ';
						flow += `${ flowSlotData.result };`;

					} else if ( shaderStage === 'fragment' ) {

						if ( ! node.outputNode.isOutputStructNode ) {

							flow += 'fragColor = ';
							flow += `${ flowSlotData.result };`;

						}

					}

				}

			}

			const stageData = shadersData[ shaderStage ];

			stageData.extensions = this.getExtensions( shaderStage );
			stageData.uniforms = this.getUniforms( shaderStage );
			stageData.attributes = this.getAttributes( shaderStage );
			stageData.varyings = this.getVaryings( shaderStage );
			stageData.vars = this.getVars( shaderStage );
			stageData.structs = this.getStructs( shaderStage );
			stageData.codes = this.getCodes( shaderStage );
			stageData.transforms = this.getTransforms( shaderStage );
			stageData.flow = flow;

		}

		if ( this.material !== null ) {

			this.vertexShader = this._getGLSLVertexCode( shadersData.vertex );
			this.fragmentShader = this._getGLSLFragmentCode( shadersData.fragment );

		} else {

			this.computeShader = this._getGLSLVertexCode( shadersData.compute );

		}

	}

	getUniformFromNode( node, type, shaderStage, name = null ) {

		const uniformNode = super.getUniformFromNode( node, type, shaderStage, name );
		const nodeData = this.getDataFromNode( node, shaderStage, this.globalCache );

		let uniformGPU = nodeData.uniformGPU;

		if ( uniformGPU === undefined ) {

			const group = node.groupNode;
			const groupName = group.name;

			const bindings = this.getBindGroupArray( groupName, shaderStage );

			if ( type === 'texture' ) {

				uniformGPU = new NodeSampledTexture( uniformNode.name, uniformNode.node, group );
				bindings.push( uniformGPU );

			} else if ( type === 'cubeTexture' ) {

				uniformGPU = new NodeSampledCubeTexture( uniformNode.name, uniformNode.node, group );
				bindings.push( uniformGPU );

			} else if ( type === 'texture3D' ) {

				uniformGPU = new NodeSampledTexture3D( uniformNode.name, uniformNode.node, group );
				bindings.push( uniformGPU );

			} else if ( type === 'buffer' ) {

				node.name = `NodeBuffer_${ node.id }`;
				uniformNode.name = `buffer${ node.id }`;

				const buffer = new NodeUniformBuffer( node, group );
				buffer.name = node.name;

				bindings.push( buffer );

				uniformGPU = buffer;

			} else {

				const uniformsStage = this.uniformGroups[ shaderStage ] || ( this.uniformGroups[ shaderStage ] = {} );

				let uniformsGroup = uniformsStage[ groupName ];

				if ( uniformsGroup === undefined ) {

					uniformsGroup = new NodeUniformsGroup( shaderStage + '_' + groupName, group );
					//uniformsGroup.setVisibility( gpuShaderStageLib[ shaderStage ] );

					uniformsStage[ groupName ] = uniformsGroup;

					bindings.push( uniformsGroup );

				}

				uniformGPU = this.getNodeUniform( uniformNode, type );

				uniformsGroup.addUniform( uniformGPU );

			}

			nodeData.uniformGPU = uniformGPU;

		}

		return uniformNode;

	}

}

let vector2 = null;
let vector4 = null;
let color4 = null;

class Backend {

	constructor( parameters = {} ) {

		this.parameters = Object.assign( {}, parameters );
		this.data = new WeakMap();
		this.renderer = null;
		this.domElement = null;

	}

	async init( renderer ) {

		this.renderer = renderer;

	}

	// render context

	begin( /*renderContext*/ ) { }

	finish( /*renderContext*/ ) { }

	// render object

	draw( /*renderObject, info*/ ) { }

	// program

	createProgram( /*program*/ ) { }

	destroyProgram( /*program*/ ) { }

	// bindings

	createBindings( /*bingGroup, bindings*/ ) { }

	updateBindings( /*bingGroup, bindings*/ ) { }

	// pipeline

	createRenderPipeline( /*renderObject*/ ) { }

	createComputePipeline( /*computeNode, pipeline*/ ) { }

	destroyPipeline( /*pipeline*/ ) { }

	// cache key

	needsRenderUpdate( /*renderObject*/ ) { } // return Boolean ( fast test )

	getRenderCacheKey( /*renderObject*/ ) { } // return String

	// node builder

	createNodeBuilder( /*renderObject*/ ) { } // return NodeBuilder (ADD IT)

	// textures

	createSampler( /*texture*/ ) { }

	createDefaultTexture( /*texture*/ ) { }

	createTexture( /*texture*/ ) { }

	copyTextureToBuffer( /*texture, x, y, width, height*/ ) {}

	// attributes

	createAttribute( /*attribute*/ ) { }

	createIndexAttribute( /*attribute*/ ) { }

	updateAttribute( /*attribute*/ ) { }

	destroyAttribute( /*attribute*/ ) { }

	// canvas

	getContext() { }

	updateSize() { }

	// utils

	resolveTimestampAsync( /*renderContext, type*/ ) { }

	hasFeatureAsync( /*name*/ ) { } // return Boolean

	hasFeature( /*name*/ ) { } // return Boolean

	getInstanceCount( renderObject ) {

		const { object, geometry } = renderObject;

		return geometry.isInstancedBufferGeometry ? geometry.instanceCount : ( object.count > 1 ? object.count : 1 );

	}

	getDrawingBufferSize() {

		vector2 = vector2 || new Vector2();

		return this.renderer.getDrawingBufferSize( vector2 );

	}

	getScissor() {

		vector4 = vector4 || new Vector4();

		return this.renderer.getScissor( vector4 );

	}

	setScissorTest( /*boolean*/ ) { }

	getClearColor() {

		const renderer = this.renderer;

		color4 = color4 || new Color4();

		renderer.getClearColor( color4 );

		color4.getRGB( color4, this.renderer.currentColorSpace );

		return color4;

	}

	getDomElement() {

		let domElement = this.domElement;

		if ( domElement === null ) {

			domElement = ( this.parameters.canvas !== undefined ) ? this.parameters.canvas : createCanvasElement();

			// OffscreenCanvas does not have setAttribute, see #22811
			if ( 'setAttribute' in domElement ) domElement.setAttribute( 'data-engine', `three.js r${REVISION} webgpu` );

			this.domElement = domElement;

		}

		return domElement;

	}

	// resource properties

	set( object, value ) {

		this.data.set( object, value );

	}

	get( object ) {

		let map = this.data.get( object );

		if ( map === undefined ) {

			map = {};
			this.data.set( object, map );

		}

		return map;

	}

	has( object ) {

		return this.data.has( object );

	}

	delete( object ) {

		this.data.delete( object );

	}

	dispose() { }

}

let _id$1 = 0;

class DualAttributeData {

	constructor( attributeData, dualBuffer ) {

		this.buffers = [ attributeData.bufferGPU, dualBuffer ];
		this.type = attributeData.type;
		this.bufferType = attributeData.bufferType;
		this.pbo = attributeData.pbo;
		this.byteLength = attributeData.byteLength;
		this.bytesPerElement = attributeData.BYTES_PER_ELEMENT;
		this.version = attributeData.version;
		this.isInteger = attributeData.isInteger;
		this.activeBufferIndex = 0;
		this.baseId = attributeData.id;

	}


	get id() {

		return `${ this.baseId }|${ this.activeBufferIndex }`;

	}

	get bufferGPU() {

		return this.buffers[ this.activeBufferIndex ];

	}

	get transformBuffer() {

		return this.buffers[ this.activeBufferIndex ^ 1 ];

	}

	switchBuffers() {

		this.activeBufferIndex ^= 1;

	}

}

class WebGLAttributeUtils {

	constructor( backend ) {

		this.backend = backend;

	}

	createAttribute( attribute, bufferType ) {

		const backend = this.backend;
		const { gl } = backend;

		const array = attribute.array;
		const usage = attribute.usage || gl.STATIC_DRAW;

		const bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;
		const bufferData = backend.get( bufferAttribute );

		let bufferGPU = bufferData.bufferGPU;

		if ( bufferGPU === undefined ) {

			bufferGPU = this._createBuffer( gl, bufferType, array, usage );

			bufferData.bufferGPU = bufferGPU;
			bufferData.bufferType = bufferType;
			bufferData.version = bufferAttribute.version;

		}

		//attribute.onUploadCallback();

		let type;

		if ( array instanceof Float32Array ) {

			type = gl.FLOAT;

		} else if ( array instanceof Uint16Array ) {

			if ( attribute.isFloat16BufferAttribute ) {

				type = gl.HALF_FLOAT;

			} else {

				type = gl.UNSIGNED_SHORT;

			}

		} else if ( array instanceof Int16Array ) {

			type = gl.SHORT;

		} else if ( array instanceof Uint32Array ) {

			type = gl.UNSIGNED_INT;

		} else if ( array instanceof Int32Array ) {

			type = gl.INT;

		} else if ( array instanceof Int8Array ) {

			type = gl.BYTE;

		} else if ( array instanceof Uint8Array ) {

			type = gl.UNSIGNED_BYTE;

		} else if ( array instanceof Uint8ClampedArray ) {

			type = gl.UNSIGNED_BYTE;

		} else {

			throw new Error( 'THREE.WebGLBackend: Unsupported buffer data format: ' + array );

		}

		let attributeData = {
			bufferGPU,
			bufferType,
			type,
			byteLength: array.byteLength,
			bytesPerElement: array.BYTES_PER_ELEMENT,
			version: attribute.version,
			pbo: attribute.pbo,
			isInteger: type === gl.INT || type === gl.UNSIGNED_INT || attribute.gpuType === IntType,
			id: _id$1 ++
		};

		if ( attribute.isStorageBufferAttribute || attribute.isStorageInstancedBufferAttribute ) {

			// create buffer for tranform feedback use
			const bufferGPUDual = this._createBuffer( gl, bufferType, array, usage );
			attributeData = new DualAttributeData( attributeData, bufferGPUDual );

		}

		backend.set( attribute, attributeData );

	}

	updateAttribute( attribute ) {

		const backend = this.backend;
		const { gl } = backend;

		const array = attribute.array;
		const bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;
		const bufferData = backend.get( bufferAttribute );
		const bufferType = bufferData.bufferType;
		const updateRanges = attribute.isInterleavedBufferAttribute ? attribute.data.updateRanges : attribute.updateRanges;

		gl.bindBuffer( bufferType, bufferData.bufferGPU );

		if ( updateRanges.length === 0 ) {

			// Not using update ranges

			gl.bufferSubData( bufferType, 0, array );

		} else {

			for ( let i = 0, l = updateRanges.length; i < l; i ++ ) {

				const range = updateRanges[ i ];
				gl.bufferSubData( bufferType, range.start * array.BYTES_PER_ELEMENT,
					array, range.start, range.count );

			}

			bufferAttribute.clearUpdateRanges();

		}

		gl.bindBuffer( bufferType, null );

		bufferData.version = bufferAttribute.version;

	}

	destroyAttribute( attribute ) {

		const backend = this.backend;
		const { gl } = backend;

		if ( attribute.isInterleavedBufferAttribute ) {

			backend.delete( attribute.data );

		}

		const attributeData = backend.get( attribute );

		gl.deleteBuffer( attributeData.bufferGPU );

		backend.delete( attribute );

	}

	async getArrayBufferAsync( attribute ) {

		const backend = this.backend;
		const { gl } = backend;

		const bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;
		const { bufferGPU } = backend.get( bufferAttribute );

		const array = attribute.array;
		const byteLength = array.byteLength;

		gl.bindBuffer( gl.COPY_READ_BUFFER, bufferGPU );

		const writeBuffer = gl.createBuffer();

		gl.bindBuffer( gl.COPY_WRITE_BUFFER, writeBuffer );
		gl.bufferData( gl.COPY_WRITE_BUFFER, byteLength, gl.STREAM_READ );

		gl.copyBufferSubData( gl.COPY_READ_BUFFER, gl.COPY_WRITE_BUFFER, 0, 0, byteLength );

		await backend.utils._clientWaitAsync();

		const dstBuffer = new attribute.array.constructor( array.length );

		// Ensure the buffer is bound before reading
		gl.bindBuffer( gl.COPY_WRITE_BUFFER, writeBuffer );

		gl.getBufferSubData( gl.COPY_WRITE_BUFFER, 0, dstBuffer );

		gl.deleteBuffer( writeBuffer );

		gl.bindBuffer( gl.COPY_READ_BUFFER, null );
		gl.bindBuffer( gl.COPY_WRITE_BUFFER, null );

		return dstBuffer.buffer;

	}

	_createBuffer( gl, bufferType, array, usage ) {

		const bufferGPU = gl.createBuffer();

		gl.bindBuffer( bufferType, bufferGPU );
		gl.bufferData( bufferType, array, usage );
		gl.bindBuffer( bufferType, null );

		return bufferGPU;

	}

}

let initialized$1 = false, equationToGL, factorToGL;

class WebGLState {

	constructor( backend ) {

		this.backend = backend;

		this.gl = this.backend.gl;

		this.enabled = {};
		this.currentFlipSided = null;
		this.currentCullFace = null;
		this.currentProgram = null;
		this.currentBlendingEnabled = false;
		this.currentBlending = null;
		this.currentBlendSrc = null;
		this.currentBlendDst = null;
		this.currentBlendSrcAlpha = null;
		this.currentBlendDstAlpha = null;
		this.currentPremultipledAlpha = null;
		this.currentPolygonOffsetFactor = null;
		this.currentPolygonOffsetUnits = null;
		this.currentColorMask = null;
		this.currentDepthFunc = null;
		this.currentDepthMask = null;
		this.currentStencilFunc = null;
		this.currentStencilRef = null;
		this.currentStencilFuncMask = null;
		this.currentStencilFail = null;
		this.currentStencilZFail = null;
		this.currentStencilZPass = null;
		this.currentStencilMask = null;
		this.currentLineWidth = null;
		this.currentClippingPlanes = 0;

		this.currentBoundFramebuffers = {};
		this.currentDrawbuffers = new WeakMap();

		this.maxTextures = this.gl.getParameter( this.gl.MAX_TEXTURE_IMAGE_UNITS );
		this.currentTextureSlot = null;
		this.currentBoundTextures = {};
		this.currentBoundBufferBases = {};

		if ( initialized$1 === false ) {

			this._init( this.gl );

			initialized$1 = true;

		}

	}

	_init( gl ) {

		// Store only WebGL constants here.

		equationToGL = {
			[ AddEquation ]: gl.FUNC_ADD,
			[ SubtractEquation ]: gl.FUNC_SUBTRACT,
			[ ReverseSubtractEquation ]: gl.FUNC_REVERSE_SUBTRACT
		};

		factorToGL = {
			[ ZeroFactor ]: gl.ZERO,
			[ OneFactor ]: gl.ONE,
			[ SrcColorFactor ]: gl.SRC_COLOR,
			[ SrcAlphaFactor ]: gl.SRC_ALPHA,
			[ SrcAlphaSaturateFactor ]: gl.SRC_ALPHA_SATURATE,
			[ DstColorFactor ]: gl.DST_COLOR,
			[ DstAlphaFactor ]: gl.DST_ALPHA,
			[ OneMinusSrcColorFactor ]: gl.ONE_MINUS_SRC_COLOR,
			[ OneMinusSrcAlphaFactor ]: gl.ONE_MINUS_SRC_ALPHA,
			[ OneMinusDstColorFactor ]: gl.ONE_MINUS_DST_COLOR,
			[ OneMinusDstAlphaFactor ]: gl.ONE_MINUS_DST_ALPHA
		};

	}

	enable( id ) {

		const { enabled } = this;

		if ( enabled[ id ] !== true ) {

			this.gl.enable( id );
			enabled[ id ] = true;

		}

	}

	disable( id ) {

		const { enabled } = this;

		if ( enabled[ id ] !== false ) {

			this.gl.disable( id );
			enabled[ id ] = false;

		}

	}

	setFlipSided( flipSided ) {

		if ( this.currentFlipSided !== flipSided ) {

			const { gl } = this;

			if ( flipSided ) {

				gl.frontFace( gl.CW );

			} else {

				gl.frontFace( gl.CCW );

			}

			this.currentFlipSided = flipSided;

		}

	}

	setCullFace( cullFace ) {

		const { gl } = this;

		if ( cullFace !== CullFaceNone ) {

			this.enable( gl.CULL_FACE );

			if ( cullFace !== this.currentCullFace ) {

				if ( cullFace === CullFaceBack ) {

					gl.cullFace( gl.BACK );

				} else if ( cullFace === CullFaceFront ) {

					gl.cullFace( gl.FRONT );

				} else {

					gl.cullFace( gl.FRONT_AND_BACK );

				}

			}

		} else {

			this.disable( gl.CULL_FACE );

		}

		this.currentCullFace = cullFace;

	}

	setLineWidth( width ) {

		const { currentLineWidth, gl } = this;

		if ( width !== currentLineWidth ) {

			gl.lineWidth( width );

			this.currentLineWidth = width;

		}

	}


	setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {

		const { gl } = this;

		if ( blending === NoBlending ) {

			if ( this.currentBlendingEnabled === true ) {

				this.disable( gl.BLEND );
				this.currentBlendingEnabled = false;

			}

			return;

		}

		if ( this.currentBlendingEnabled === false ) {

			this.enable( gl.BLEND );
			this.currentBlendingEnabled = true;

		}

		if ( blending !== CustomBlending ) {

			if ( blending !== this.currentBlending || premultipliedAlpha !== this.currentPremultipledAlpha ) {

				if ( this.currentBlendEquation !== AddEquation || this.currentBlendEquationAlpha !== AddEquation ) {

					gl.blendEquation( gl.FUNC_ADD );

					this.currentBlendEquation = AddEquation;
					this.currentBlendEquationAlpha = AddEquation;

				}

				if ( premultipliedAlpha ) {

					switch ( blending ) {

						case NormalBlending:
							gl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
							break;

						case AdditiveBlending:
							gl.blendFunc( gl.ONE, gl.ONE );
							break;

						case SubtractiveBlending:
							gl.blendFuncSeparate( gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE );
							break;

						case MultiplyBlending:
							gl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );
							break;

						default:
							console.error( 'THREE.WebGLState: Invalid blending: ', blending );
							break;

					}

				} else {

					switch ( blending ) {

						case NormalBlending:
							gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
							break;

						case AdditiveBlending:
							gl.blendFunc( gl.SRC_ALPHA, gl.ONE );
							break;

						case SubtractiveBlending:
							gl.blendFuncSeparate( gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE );
							break;

						case MultiplyBlending:
							gl.blendFunc( gl.ZERO, gl.SRC_COLOR );
							break;

						default:
							console.error( 'THREE.WebGLState: Invalid blending: ', blending );
							break;

					}

				}

				this.currentBlendSrc = null;
				this.currentBlendDst = null;
				this.currentBlendSrcAlpha = null;
				this.currentBlendDstAlpha = null;

				this.currentBlending = blending;
				this.currentPremultipledAlpha = premultipliedAlpha;

			}

			return;

		}

		// custom blending

		blendEquationAlpha = blendEquationAlpha || blendEquation;
		blendSrcAlpha = blendSrcAlpha || blendSrc;
		blendDstAlpha = blendDstAlpha || blendDst;

		if ( blendEquation !== this.currentBlendEquation || blendEquationAlpha !== this.currentBlendEquationAlpha ) {

			gl.blendEquationSeparate( equationToGL[ blendEquation ], equationToGL[ blendEquationAlpha ] );

			this.currentBlendEquation = blendEquation;
			this.currentBlendEquationAlpha = blendEquationAlpha;

		}

		if ( blendSrc !== this.currentBlendSrc || blendDst !== this.currentBlendDst || blendSrcAlpha !== this.currentBlendSrcAlpha || blendDstAlpha !== this.currentBlendDstAlpha ) {

			gl.blendFuncSeparate( factorToGL[ blendSrc ], factorToGL[ blendDst ], factorToGL[ blendSrcAlpha ], factorToGL[ blendDstAlpha ] );

			this.currentBlendSrc = blendSrc;
			this.currentBlendDst = blendDst;
			this.currentBlendSrcAlpha = blendSrcAlpha;
			this.currentBlendDstAlpha = blendDstAlpha;

		}

		this.currentBlending = blending;
		this.currentPremultipledAlpha = false;

	}

	setColorMask( colorMask ) {

		if ( this.currentColorMask !== colorMask ) {

			this.gl.colorMask( colorMask, colorMask, colorMask, colorMask );
			this.currentColorMask = colorMask;

		}

	}

	setDepthTest( depthTest ) {

		const { gl } = this;

		if ( depthTest ) {

			this.enable( gl.DEPTH_TEST );

		} else {

			this.disable( gl.DEPTH_TEST );

		}

	}

	setDepthMask( depthMask ) {

		if ( this.currentDepthMask !== depthMask ) {

			this.gl.depthMask( depthMask );
			this.currentDepthMask = depthMask;

		}

	}

	setDepthFunc( depthFunc ) {

		if ( this.currentDepthFunc !== depthFunc ) {

			const { gl } = this;

			switch ( depthFunc ) {

				case NeverDepth:

					gl.depthFunc( gl.NEVER );
					break;

				case AlwaysDepth:

					gl.depthFunc( gl.ALWAYS );
					break;

				case LessDepth:

					gl.depthFunc( gl.LESS );
					break;

				case LessEqualDepth:

					gl.depthFunc( gl.LEQUAL );
					break;

				case EqualDepth:

					gl.depthFunc( gl.EQUAL );
					break;

				case GreaterEqualDepth:

					gl.depthFunc( gl.GEQUAL );
					break;

				case GreaterDepth:

					gl.depthFunc( gl.GREATER );
					break;

				case NotEqualDepth:

					gl.depthFunc( gl.NOTEQUAL );
					break;

				default:

					gl.depthFunc( gl.LEQUAL );

			}

			this.currentDepthFunc = depthFunc;

		}

	}

	setStencilTest( stencilTest ) {

		const { gl } = this;

		if ( stencilTest ) {

			this.enable( gl.STENCIL_TEST );

		} else {

			this.disable( gl.STENCIL_TEST );

		}

	}

	setStencilMask( stencilMask ) {

		if ( this.currentStencilMask !== stencilMask ) {

			this.gl.stencilMask( stencilMask );
			this.currentStencilMask = stencilMask;

		}

	}

	setStencilFunc( stencilFunc, stencilRef, stencilMask ) {

		if ( this.currentStencilFunc !== stencilFunc ||
			 this.currentStencilRef !== stencilRef ||
			 this.currentStencilFuncMask !== stencilMask ) {

			this.gl.stencilFunc( stencilFunc, stencilRef, stencilMask );

			this.currentStencilFunc = stencilFunc;
			this.currentStencilRef = stencilRef;
			this.currentStencilFuncMask = stencilMask;

		}

	}

	setStencilOp( stencilFail, stencilZFail, stencilZPass ) {

		if ( this.currentStencilFail !== stencilFail ||
			 this.currentStencilZFail !== stencilZFail ||
			 this.currentStencilZPass !== stencilZPass ) {

			this.gl.stencilOp( stencilFail, stencilZFail, stencilZPass );

			this.currentStencilFail = stencilFail;
			this.currentStencilZFail = stencilZFail;
			this.currentStencilZPass = stencilZPass;

		}

	}

	setMaterial( material, frontFaceCW, hardwareClippingPlanes ) {

		const { gl } = this;

		material.side === DoubleSide
			? this.disable( gl.CULL_FACE )
			: this.enable( gl.CULL_FACE );

		let flipSided = ( material.side === BackSide );
		if ( frontFaceCW ) flipSided = ! flipSided;

		this.setFlipSided( flipSided );

		( material.blending === NormalBlending && material.transparent === false )
			? this.setBlending( NoBlending )
			: this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );

		this.setDepthFunc( material.depthFunc );
		this.setDepthTest( material.depthTest );
		this.setDepthMask( material.depthWrite );
		this.setColorMask( material.colorWrite );

		const stencilWrite = material.stencilWrite;
		this.setStencilTest( stencilWrite );
		if ( stencilWrite ) {

			this.setStencilMask( material.stencilWriteMask );
			this.setStencilFunc( material.stencilFunc, material.stencilRef, material.stencilFuncMask );
			this.setStencilOp( material.stencilFail, material.stencilZFail, material.stencilZPass );

		}

		this.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

		material.alphaToCoverage === true && this.backend.renderer.samples > 1
			? this.enable( gl.SAMPLE_ALPHA_TO_COVERAGE )
			: this.disable( gl.SAMPLE_ALPHA_TO_COVERAGE );

		if ( hardwareClippingPlanes > 0 ) {

			if ( this.currentClippingPlanes !== hardwareClippingPlanes ) {

				const CLIP_DISTANCE0_WEBGL = 0x3000;

				for ( let i = 0; i < 8; i ++ ) {

					if ( i < hardwareClippingPlanes ) {

						this.enable( CLIP_DISTANCE0_WEBGL + i );

					} else {

						this.disable( CLIP_DISTANCE0_WEBGL + i );

					}

				}

			}

		}

	}

	setPolygonOffset( polygonOffset, factor, units ) {

		const { gl } = this;

		if ( polygonOffset ) {

			this.enable( gl.POLYGON_OFFSET_FILL );

			if ( this.currentPolygonOffsetFactor !== factor || this.currentPolygonOffsetUnits !== units ) {

				gl.polygonOffset( factor, units );

				this.currentPolygonOffsetFactor = factor;
				this.currentPolygonOffsetUnits = units;

			}

		} else {

			this.disable( gl.POLYGON_OFFSET_FILL );

		}

	}

	useProgram( program ) {

		if ( this.currentProgram !== program ) {

			this.gl.useProgram( program );

			this.currentProgram = program;

			return true;

		}

		return false;

	}

	// framebuffer


	bindFramebuffer( target, framebuffer ) {

		const { gl, currentBoundFramebuffers } = this;

		if ( currentBoundFramebuffers[ target ] !== framebuffer ) {

			gl.bindFramebuffer( target, framebuffer );

			currentBoundFramebuffers[ target ] = framebuffer;

			// gl.DRAW_FRAMEBUFFER is equivalent to gl.FRAMEBUFFER

			if ( target === gl.DRAW_FRAMEBUFFER ) {

				currentBoundFramebuffers[ gl.FRAMEBUFFER ] = framebuffer;

			}

			if ( target === gl.FRAMEBUFFER ) {

				currentBoundFramebuffers[ gl.DRAW_FRAMEBUFFER ] = framebuffer;

			}

			return true;

		}

		return false;

	}

	drawBuffers( renderContext, framebuffer ) {

		const { gl } = this;

		let drawBuffers = [];

		let needsUpdate = false;

		if ( renderContext.textures !== null ) {

			drawBuffers = this.currentDrawbuffers.get( framebuffer );

			if ( drawBuffers === undefined ) {

				drawBuffers = [];
				this.currentDrawbuffers.set( framebuffer, drawBuffers );

			}


			const textures = renderContext.textures;

			if ( drawBuffers.length !== textures.length || drawBuffers[ 0 ] !== gl.COLOR_ATTACHMENT0 ) {

				for ( let i = 0, il = textures.length; i < il; i ++ ) {

					drawBuffers[ i ] = gl.COLOR_ATTACHMENT0 + i;

				}

				drawBuffers.length = textures.length;

				needsUpdate = true;

			}


		} else {

			if ( drawBuffers[ 0 ] !== gl.BACK ) {

				drawBuffers[ 0 ] = gl.BACK;

				needsUpdate = true;

			}

		}

		if ( needsUpdate ) {

			gl.drawBuffers( drawBuffers );

		}

	}


	// texture

	activeTexture( webglSlot ) {

		const { gl, currentTextureSlot, maxTextures } = this;

		if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;

		if ( currentTextureSlot !== webglSlot ) {

			gl.activeTexture( webglSlot );
			this.currentTextureSlot = webglSlot;

		}

	}

	bindTexture( webglType, webglTexture, webglSlot ) {

		const { gl, currentTextureSlot, currentBoundTextures, maxTextures } = this;

		if ( webglSlot === undefined ) {

			if ( currentTextureSlot === null ) {

				webglSlot = gl.TEXTURE0 + maxTextures - 1;

			} else {

				webglSlot = currentTextureSlot;

			}

		}

		let boundTexture = currentBoundTextures[ webglSlot ];

		if ( boundTexture === undefined ) {

			boundTexture = { type: undefined, texture: undefined };
			currentBoundTextures[ webglSlot ] = boundTexture;

		}

		if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

			if ( currentTextureSlot !== webglSlot ) {

				gl.activeTexture( webglSlot );
				this.currentTextureSlot = webglSlot;

			}

			gl.bindTexture( webglType, webglTexture );

			boundTexture.type = webglType;
			boundTexture.texture = webglTexture;

		}

	}

	bindBufferBase( target, index, buffer ) {

		const { gl } = this;

		const key = `${target}-${index}`;

		if ( this.currentBoundBufferBases[ key ] !== buffer ) {

			gl.bindBufferBase( target, index, buffer );
			this.currentBoundBufferBases[ key ] = buffer;

			return true;

		}

		return false;

	}


	unbindTexture() {

		const { gl, currentTextureSlot, currentBoundTextures } = this;

		const boundTexture = currentBoundTextures[ currentTextureSlot ];

		if ( boundTexture !== undefined && boundTexture.type !== undefined ) {

			gl.bindTexture( boundTexture.type, null );

			boundTexture.type = undefined;
			boundTexture.texture = undefined;

		}

	}

}

class WebGLUtils {

	constructor( backend ) {

		this.backend = backend;

		this.gl = this.backend.gl;
		this.extensions = backend.extensions;

	}

	convert( p, colorSpace = NoColorSpace ) {

		const { gl, extensions } = this;

		let extension;

		if ( p === UnsignedByteType ) return gl.UNSIGNED_BYTE;
		if ( p === UnsignedShort4444Type ) return gl.UNSIGNED_SHORT_4_4_4_4;
		if ( p === UnsignedShort5551Type ) return gl.UNSIGNED_SHORT_5_5_5_1;
		if ( p === UnsignedInt5999Type ) return gl.UNSIGNED_INT_5_9_9_9_REV;

		if ( p === ByteType ) return gl.BYTE;
		if ( p === ShortType ) return gl.SHORT;
		if ( p === UnsignedShortType ) return gl.UNSIGNED_SHORT;
		if ( p === IntType ) return gl.INT;
		if ( p === UnsignedIntType ) return gl.UNSIGNED_INT;
		if ( p === FloatType ) return gl.FLOAT;

		if ( p === HalfFloatType ) {

			return gl.HALF_FLOAT;

		}

		if ( p === AlphaFormat ) return gl.ALPHA;
		if ( p === RGBFormat ) return gl.RGB;
		if ( p === RGBAFormat ) return gl.RGBA;
		if ( p === LuminanceFormat ) return gl.LUMINANCE;
		if ( p === LuminanceAlphaFormat ) return gl.LUMINANCE_ALPHA;
		if ( p === DepthFormat ) return gl.DEPTH_COMPONENT;
		if ( p === DepthStencilFormat ) return gl.DEPTH_STENCIL;

		// WebGL2 formats.

		if ( p === RedFormat ) return gl.RED;
		if ( p === RedIntegerFormat ) return gl.RED_INTEGER;
		if ( p === RGFormat ) return gl.RG;
		if ( p === RGIntegerFormat ) return gl.RG_INTEGER;
		if ( p === RGBAIntegerFormat ) return gl.RGBA_INTEGER;

		// S3TC

		if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {

			if ( colorSpace === SRGBColorSpace ) {

				extension = extensions.get( 'WEBGL_compressed_texture_s3tc_srgb' );

				if ( extension !== null ) {

					if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
					if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;

				} else {

					return null;

				}

			} else {

				extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

				if ( extension !== null ) {

					if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
					if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

				} else {

					return null;

				}

			}

		}

		// PVRTC

		if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

			if ( extension !== null ) {

				if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
				if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
				if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
				if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

			} else {

				return null;

			}

		}

		// ETC

		if ( p === RGB_ETC1_Format || p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_etc' );

			if ( extension !== null ) {

				if ( p === RGB_ETC1_Format || p === RGB_ETC2_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
				if ( p === RGBA_ETC2_EAC_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;

			} else {

				return null;

			}

		}

		// ASTC

		if ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||
			p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||
			p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||
			p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||
			p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_astc' );

			if ( extension !== null ) {

				if ( p === RGBA_ASTC_4x4_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
				if ( p === RGBA_ASTC_5x4_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
				if ( p === RGBA_ASTC_5x5_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
				if ( p === RGBA_ASTC_6x5_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
				if ( p === RGBA_ASTC_6x6_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
				if ( p === RGBA_ASTC_8x5_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
				if ( p === RGBA_ASTC_8x6_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
				if ( p === RGBA_ASTC_8x8_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
				if ( p === RGBA_ASTC_10x5_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
				if ( p === RGBA_ASTC_10x6_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
				if ( p === RGBA_ASTC_10x8_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
				if ( p === RGBA_ASTC_10x10_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
				if ( p === RGBA_ASTC_12x10_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
				if ( p === RGBA_ASTC_12x12_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;

			} else {

				return null;

			}

		}

		// BPTC

		if ( p === RGBA_BPTC_Format ) {

			extension = extensions.get( 'EXT_texture_compression_bptc' );

			if ( extension !== null ) {

				if ( p === RGBA_BPTC_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;

			} else {

				return null;

			}

		}

		// RGTC

		if ( p === RED_RGTC1_Format || p === SIGNED_RED_RGTC1_Format || p === RED_GREEN_RGTC2_Format || p === SIGNED_RED_GREEN_RGTC2_Format ) {

			extension = extensions.get( 'EXT_texture_compression_rgtc' );

			if ( extension !== null ) {

				if ( p === RGBA_BPTC_Format ) return extension.COMPRESSED_RED_RGTC1_EXT;
				if ( p === SIGNED_RED_RGTC1_Format ) return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;
				if ( p === RED_GREEN_RGTC2_Format ) return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;
				if ( p === SIGNED_RED_GREEN_RGTC2_Format ) return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;

			} else {

				return null;

			}

		}

		//

		if ( p === UnsignedInt248Type ) {

			return gl.UNSIGNED_INT_24_8;

		}

		// if "p" can't be resolved, assume the user defines a WebGL constant as a string (fallback/workaround for packed RGB formats)

		return ( gl[ p ] !== undefined ) ? gl[ p ] : null;

	}

	_clientWaitAsync() {

		const { gl } = this;

		const sync = gl.fenceSync( gl.SYNC_GPU_COMMANDS_COMPLETE, 0 );

		gl.flush();

		return new Promise( ( resolve, reject ) => {

			function test() {

				const res = gl.clientWaitSync( sync, gl.SYNC_FLUSH_COMMANDS_BIT, 0 );

				if ( res === gl.WAIT_FAILED ) {

					gl.deleteSync( sync );

					reject();
					return;

				}

				if ( res === gl.TIMEOUT_EXPIRED ) {

					requestAnimationFrame( test );
					return;

				}

				gl.deleteSync( sync );

				resolve();

			}

			test();

		} );

	}

}

let initialized = false, wrappingToGL, filterToGL, compareToGL;

class WebGLTextureUtils {

	constructor( backend ) {

		this.backend = backend;

		this.gl = backend.gl;
		this.extensions = backend.extensions;
		this.defaultTextures = {};

		if ( initialized === false ) {

			this._init( this.gl );

			initialized = true;

		}

	}

	_init( gl ) {

		// Store only WebGL constants here.

		wrappingToGL = {
			[ RepeatWrapping ]: gl.REPEAT,
			[ ClampToEdgeWrapping ]: gl.CLAMP_TO_EDGE,
			[ MirroredRepeatWrapping ]: gl.MIRRORED_REPEAT
		};

		filterToGL = {
			[ NearestFilter ]: gl.NEAREST,
			[ NearestMipmapNearestFilter ]: gl.NEAREST_MIPMAP_NEAREST,
			[ NearestMipmapLinearFilter ]: gl.NEAREST_MIPMAP_LINEAR,

			[ LinearFilter ]: gl.LINEAR,
			[ LinearMipmapNearestFilter ]: gl.LINEAR_MIPMAP_NEAREST,
			[ LinearMipmapLinearFilter ]: gl.LINEAR_MIPMAP_LINEAR
		};

		compareToGL = {
			[ NeverCompare ]: gl.NEVER,
			[ AlwaysCompare ]: gl.ALWAYS,
			[ LessCompare ]: gl.LESS,
			[ LessEqualCompare ]: gl.LEQUAL,
			[ EqualCompare ]: gl.EQUAL,
			[ GreaterEqualCompare ]: gl.GEQUAL,
			[ GreaterCompare ]: gl.GREATER,
			[ NotEqualCompare ]: gl.NOTEQUAL
		};

	}

	filterFallback( f ) {

		const { gl } = this;

		if ( f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter ) {

			return gl.NEAREST;

		}

		return gl.LINEAR;

	}

	getGLTextureType( texture ) {

		const { gl } = this;

		let glTextureType;

		if ( texture.isCubeTexture === true ) {

			glTextureType = gl.TEXTURE_CUBE_MAP;

		} else if ( texture.isDataArrayTexture === true || texture.isCompressedArrayTexture === true ) {

			glTextureType = gl.TEXTURE_2D_ARRAY;

		} else if ( texture.isData3DTexture === true ) { // TODO: isCompressed3DTexture, wait for #26642

			glTextureType = gl.TEXTURE_3D;

		} else {

			glTextureType = gl.TEXTURE_2D;


		}

		return glTextureType;

	}

	getInternalFormat( internalFormatName, glFormat, glType, colorSpace, forceLinearTransfer = false ) {

		const { gl, extensions } = this;

		if ( internalFormatName !== null ) {

			if ( gl[ internalFormatName ] !== undefined ) return gl[ internalFormatName ];

			console.warn( 'THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'' );

		}

		let internalFormat = glFormat;

		if ( glFormat === gl.RED ) {

			if ( glType === gl.FLOAT ) internalFormat = gl.R32F;
			if ( glType === gl.HALF_FLOAT ) internalFormat = gl.R16F;
			if ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.R8;
			if ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.R16;
			if ( glType === gl.UNSIGNED_INT ) internalFormat = gl.R32UI;
			if ( glType === gl.BYTE ) internalFormat = gl.R8I;
			if ( glType === gl.SHORT ) internalFormat = gl.R16I;
			if ( glType === gl.INT ) internalFormat = gl.R32I;

		}

		if ( glFormat === gl.RED_INTEGER ) {

			if ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.R8UI;
			if ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.R16UI;
			if ( glType === gl.UNSIGNED_INT ) internalFormat = gl.R32UI;
			if ( glType === gl.BYTE ) internalFormat = gl.R8I;
			if ( glType === gl.SHORT ) internalFormat = gl.R16I;
			if ( glType === gl.INT ) internalFormat = gl.R32I;

		}

		if ( glFormat === gl.RG ) {

			if ( glType === gl.FLOAT ) internalFormat = gl.RG32F;
			if ( glType === gl.HALF_FLOAT ) internalFormat = gl.RG16F;
			if ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RG8;
			if ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RG16;
			if ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RG32UI;
			if ( glType === gl.BYTE ) internalFormat = gl.RG8I;
			if ( glType === gl.SHORT ) internalFormat = gl.RG16I;
			if ( glType === gl.INT ) internalFormat = gl.RG32I;

		}

		if ( glFormat === gl.RG_INTEGER ) {

			if ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RG8UI;
			if ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RG16UI;
			if ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RG32UI;
			if ( glType === gl.BYTE ) internalFormat = gl.RG8I;
			if ( glType === gl.SHORT ) internalFormat = gl.RG16I;
			if ( glType === gl.INT ) internalFormat = gl.RG32I;

		}

		if ( glFormat === gl.RGB ) {

			if ( glType === gl.FLOAT ) internalFormat = gl.RGB32F;
			if ( glType === gl.HALF_FLOAT ) internalFormat = gl.RGB16F;
			if ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RGB8;
			if ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RGB16;
			if ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RGB32UI;
			if ( glType === gl.BYTE ) internalFormat = gl.RGB8I;
			if ( glType === gl.SHORT ) internalFormat = gl.RGB16I;
			if ( glType === gl.INT ) internalFormat = gl.RGB32I;
			if ( glType === gl.UNSIGNED_BYTE ) internalFormat = ( colorSpace === SRGBColorSpace && forceLinearTransfer === false ) ? gl.SRGB8 : gl.RGB8;
			if ( glType === gl.UNSIGNED_SHORT_5_6_5 ) internalFormat = gl.RGB565;
			if ( glType === gl.UNSIGNED_SHORT_5_5_5_1 ) internalFormat = gl.RGB5_A1;
			if ( glType === gl.UNSIGNED_SHORT_4_4_4_4 ) internalFormat = gl.RGB4;
			if ( glType === gl.UNSIGNED_INT_5_9_9_9_REV ) internalFormat = gl.RGB9_E5;

		}

		if ( glFormat === gl.RGB_INTEGER ) {

			if ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RGB8UI;
			if ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RGB16UI;
			if ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RGB32UI;
			if ( glType === gl.BYTE ) internalFormat = gl.RGB8I;
			if ( glType === gl.SHORT ) internalFormat = gl.RGB16I;
			if ( glType === gl.INT ) internalFormat = gl.RGB32I;

		}

		if ( glFormat === gl.RGBA ) {

			if ( glType === gl.FLOAT ) internalFormat = gl.RGBA32F;
			if ( glType === gl.HALF_FLOAT ) internalFormat = gl.RGBA16F;
			if ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RGBA8;
			if ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RGBA16;
			if ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RGBA32UI;
			if ( glType === gl.BYTE ) internalFormat = gl.RGBA8I;
			if ( glType === gl.SHORT ) internalFormat = gl.RGBA16I;
			if ( glType === gl.INT ) internalFormat = gl.RGBA32I;
			if ( glType === gl.UNSIGNED_BYTE ) internalFormat = ( colorSpace === SRGBColorSpace && forceLinearTransfer === false ) ? gl.SRGB8_ALPHA8 : gl.RGBA8;
			if ( glType === gl.UNSIGNED_SHORT_4_4_4_4 ) internalFormat = gl.RGBA4;
			if ( glType === gl.UNSIGNED_SHORT_5_5_5_1 ) internalFormat = gl.RGB5_A1;

		}

		if ( glFormat === gl.RGBA_INTEGER ) {

			if ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RGBA8UI;
			if ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RGBA16UI;
			if ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RGBA32UI;
			if ( glType === gl.BYTE ) internalFormat = gl.RGBA8I;
			if ( glType === gl.SHORT ) internalFormat = gl.RGBA16I;
			if ( glType === gl.INT ) internalFormat = gl.RGBA32I;

		}

		if ( glFormat === gl.DEPTH_COMPONENT ) {

			if ( glType === gl.UNSIGNED_INT ) internalFormat = gl.DEPTH24_STENCIL8;
			if ( glType === gl.FLOAT ) internalFormat = gl.DEPTH_COMPONENT32F;

		}

		if ( glFormat === gl.DEPTH_STENCIL ) {

			if ( glType === gl.UNSIGNED_INT_24_8 ) internalFormat = gl.DEPTH24_STENCIL8;

		}

		if ( internalFormat === gl.R16F || internalFormat === gl.R32F ||
			internalFormat === gl.RG16F || internalFormat === gl.RG32F ||
			internalFormat === gl.RGBA16F || internalFormat === gl.RGBA32F ) {

			extensions.get( 'EXT_color_buffer_float' );

		}

		return internalFormat;

	}

	setTextureParameters( textureType, texture ) {

		const { gl, extensions, backend } = this;


		gl.pixelStorei( gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
		gl.pixelStorei( gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
		gl.pixelStorei( gl.UNPACK_ALIGNMENT, texture.unpackAlignment );
		gl.pixelStorei( gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE );

		gl.texParameteri( textureType, gl.TEXTURE_WRAP_S, wrappingToGL[ texture.wrapS ] );
		gl.texParameteri( textureType, gl.TEXTURE_WRAP_T, wrappingToGL[ texture.wrapT ] );

		if ( textureType === gl.TEXTURE_3D || textureType === gl.TEXTURE_2D_ARRAY ) {

			gl.texParameteri( textureType, gl.TEXTURE_WRAP_R, wrappingToGL[ texture.wrapR ] );

		}

		gl.texParameteri( textureType, gl.TEXTURE_MAG_FILTER, filterToGL[ texture.magFilter ] );


		const hasMipmaps = texture.mipmaps !== undefined && texture.mipmaps.length > 0;

		// follow WebGPU backend mapping for texture filtering
		const minFilter = texture.minFilter === LinearFilter && hasMipmaps ? LinearMipmapLinearFilter : texture.minFilter;

		gl.texParameteri( textureType, gl.TEXTURE_MIN_FILTER, filterToGL[ minFilter ] );

		if ( texture.compareFunction ) {

			gl.texParameteri( textureType, gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE );
			gl.texParameteri( textureType, gl.TEXTURE_COMPARE_FUNC, compareToGL[ texture.compareFunction ] );

		}

		if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {

			if ( texture.magFilter === NearestFilter ) return;
			if ( texture.minFilter !== NearestMipmapLinearFilter && texture.minFilter !== LinearMipmapLinearFilter ) return;
			if ( texture.type === FloatType && extensions.has( 'OES_texture_float_linear' ) === false ) return; // verify extension for WebGL 1 and WebGL 2

			if ( texture.anisotropy > 1 ) {

				const extension = extensions.get( 'EXT_texture_filter_anisotropic' );
				gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, backend.getMaxAnisotropy() ) );

			}

		}

	}

	createDefaultTexture( texture ) {

		const { gl, backend, defaultTextures } = this;


		const glTextureType = this.getGLTextureType( texture );

		let textureGPU = defaultTextures[ glTextureType ];

		if ( textureGPU === undefined ) {

			textureGPU = gl.createTexture();

			backend.state.bindTexture( glTextureType, textureGPU );
			gl.texParameteri( glTextureType, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
			gl.texParameteri( glTextureType, gl.TEXTURE_MAG_FILTER, gl.NEAREST );

			// gl.texImage2D( glTextureType, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );

			defaultTextures[ glTextureType ] = textureGPU;

		}

		backend.set( texture, {
			textureGPU,
			glTextureType,
			isDefault: true
		} );

	}

	createTexture( texture, options ) {

		const { gl, backend } = this;
		const { levels, width, height, depth } = options;

		const glFormat = backend.utils.convert( texture.format, texture.colorSpace );
		const glType = backend.utils.convert( texture.type );
		const glInternalFormat = this.getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace, texture.isVideoTexture );

		const textureGPU = gl.createTexture();
		const glTextureType = this.getGLTextureType( texture );

		backend.state.bindTexture( glTextureType, textureGPU );

		this.setTextureParameters( glTextureType, texture );

		if ( texture.isDataArrayTexture || texture.isCompressedArrayTexture ) {

			gl.texStorage3D( gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, width, height, depth );

		} else if ( texture.isData3DTexture ) {

			gl.texStorage3D( gl.TEXTURE_3D, levels, glInternalFormat, width, height, depth );

		} else if ( ! texture.isVideoTexture ) {

			gl.texStorage2D( glTextureType, levels, glInternalFormat, width, height );

		}

		backend.set( texture, {
			textureGPU,
			glTextureType,
			glFormat,
			glType,
			glInternalFormat
		} );

	}

	copyBufferToTexture( buffer, texture ) {

		const { gl, backend } = this;

		const { textureGPU, glTextureType, glFormat, glType } = backend.get( texture );

		const { width, height } = texture.source.data;

		gl.bindBuffer( gl.PIXEL_UNPACK_BUFFER, buffer );

		backend.state.bindTexture( glTextureType, textureGPU );

		gl.pixelStorei( gl.UNPACK_FLIP_Y_WEBGL, false );
		gl.pixelStorei( gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false );
		gl.texSubImage2D( glTextureType, 0, 0, 0, width, height, glFormat, glType, 0 );

		gl.bindBuffer( gl.PIXEL_UNPACK_BUFFER, null );

		backend.state.unbindTexture();
		// debug
		// const framebuffer = gl.createFramebuffer();
		// gl.bindFramebuffer( gl.FRAMEBUFFER, framebuffer );
		// gl.framebufferTexture2D( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, glTextureType, textureGPU, 0 );

		// const readout = new Float32Array( width * height * 4 );

		// const altFormat = gl.getParameter( gl.IMPLEMENTATION_COLOR_READ_FORMAT );
		// const altType = gl.getParameter( gl.IMPLEMENTATION_COLOR_READ_TYPE );

		// gl.readPixels( 0, 0, width, height, altFormat, altType, readout );
		// gl.bindFramebuffer( gl.FRAMEBUFFER, null );
		// console.log( readout );

	}

	updateTexture( texture, options ) {

		const { gl } = this;
		const { width, height } = options;
		const { textureGPU, glTextureType, glFormat, glType, glInternalFormat } = this.backend.get( texture );

		if ( texture.isRenderTargetTexture || ( textureGPU === undefined /* unsupported texture format */ ) )
			return;

		const getImage = ( source ) => {

			if ( source.isDataTexture ) {

				return source.image.data;

			} else if ( ( typeof HTMLImageElement !== 'undefined' && source instanceof HTMLImageElement ) ||
				( typeof HTMLCanvasElement !== 'undefined' && source instanceof HTMLCanvasElement ) ||
				( typeof ImageBitmap !== 'undefined' && source instanceof ImageBitmap ) ||
				source instanceof OffscreenCanvas ) {

				return source;

			}

			return source.data;

		};

		this.backend.state.bindTexture( glTextureType, textureGPU );

		this.setTextureParameters( glTextureType, texture );

		if ( texture.isCompressedTexture ) {

			const mipmaps = texture.mipmaps;
			const image = options.image;

			for ( let i = 0; i < mipmaps.length; i ++ ) {

				const mipmap = mipmaps[ i ];

				if ( texture.isCompressedArrayTexture ) {


					if ( texture.format !== gl.RGBA ) {

						if ( glFormat !== null ) {

							gl.compressedTexSubImage3D( gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, mipmap.data );

						} else {

							console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );

						}

					} else {

						gl.texSubImage3D( gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, glType, mipmap.data );

					}

				} else {

					if ( glFormat !== null ) {

						gl.compressedTexSubImage2D( gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data );

					} else {

						console.warn( 'Unsupported compressed texture format' );

					}

				}

			}


		} else if ( texture.isCubeTexture ) {

			const images = options.images;

			for ( let i = 0; i < 6; i ++ ) {

				const image = getImage( images[ i ] );

				gl.texSubImage2D( gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, width, height, glFormat, glType, image );

			}

		} else if ( texture.isDataArrayTexture ) {

			const image = options.image;

			gl.texSubImage3D( gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );

		} else if ( texture.isData3DTexture ) {

			const image = options.image;

			gl.texSubImage3D( gl.TEXTURE_3D, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );

		} else if ( texture.isVideoTexture ) {

			texture.update();

			gl.texImage2D( glTextureType, 0, glInternalFormat, glFormat, glType, options.image );


		} else {

			const image = getImage( options.image );

			gl.texSubImage2D( glTextureType, 0, 0, 0, width, height, glFormat, glType, image );

		}

	}

	generateMipmaps( texture ) {

		const { gl, backend } = this;
		const { textureGPU, glTextureType } = backend.get( texture );

		backend.state.bindTexture( glTextureType, textureGPU );
		gl.generateMipmap( glTextureType );

	}

	deallocateRenderBuffers( renderTarget ) {

		const { gl, backend } = this;

		// remove framebuffer reference
		if ( renderTarget ) {

			const renderContextData = backend.get( renderTarget );

			renderContextData.renderBufferStorageSetup = undefined;

			if ( renderContextData.framebuffers ) {

				for ( const cacheKey in renderContextData.framebuffers ) {

					gl.deleteFramebuffer( renderContextData.framebuffers[ cacheKey ] );

				}

				delete renderContextData.framebuffers;

			}

			if ( renderContextData.depthRenderbuffer ) {

				gl.deleteRenderbuffer( renderContextData.depthRenderbuffer );
				delete renderContextData.depthRenderbuffer;

			}

			if ( renderContextData.stencilRenderbuffer ) {

				gl.deleteRenderbuffer( renderContextData.stencilRenderbuffer );
				delete renderContextData.stencilRenderbuffer;

			}

			if ( renderContextData.msaaFrameBuffer ) {

				gl.deleteFramebuffer( renderContextData.msaaFrameBuffer );
				delete renderContextData.msaaFrameBuffer;

			}

			if ( renderContextData.msaaRenderbuffers ) {

				for ( let i = 0; i < renderContextData.msaaRenderbuffers.length; i ++ ) {

					gl.deleteRenderbuffer( renderContextData.msaaRenderbuffers[ i ] );

				}

				delete renderContextData.msaaRenderbuffers;

			}

		}

	}

	destroyTexture( texture ) {

		const { gl, backend } = this;
		const { textureGPU, renderTarget } = backend.get( texture );

		this.deallocateRenderBuffers( renderTarget );
		gl.deleteTexture( textureGPU );

		backend.delete( texture );

	}

	copyTextureToTexture( srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0 ) {

		const { gl, backend } = this;
		const { state } = this.backend;

		const { textureGPU: dstTextureGPU, glTextureType, glType, glFormat } = backend.get( dstTexture );

		let width, height, minX, minY;
		let dstX, dstY;

		if ( srcRegion !== null ) {

			width = srcRegion.max.x - srcRegion.min.x;
			height = srcRegion.max.y - srcRegion.min.y;
			minX = srcRegion.min.x;
			minY = srcRegion.min.y;

		} else {

			width = srcTexture.image.width;
			height = srcTexture.image.height;
			minX = 0;
			minY = 0;

		}

		if ( dstPosition !== null ) {

			dstX = dstPosition.x;
			dstY = dstPosition.y;

		} else {

			dstX = 0;
			dstY = 0;

		}

		state.bindTexture( glTextureType, dstTextureGPU );

		// As another texture upload may have changed pixelStorei
		// parameters, make sure they are correct for the dstTexture
		gl.pixelStorei( gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment );
		gl.pixelStorei( gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY );
		gl.pixelStorei( gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha );
		gl.pixelStorei( gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment );

		const currentUnpackRowLen = gl.getParameter( gl.UNPACK_ROW_LENGTH );
		const currentUnpackImageHeight = gl.getParameter( gl.UNPACK_IMAGE_HEIGHT );
		const currentUnpackSkipPixels = gl.getParameter( gl.UNPACK_SKIP_PIXELS );
		const currentUnpackSkipRows = gl.getParameter( gl.UNPACK_SKIP_ROWS );
		const currentUnpackSkipImages = gl.getParameter( gl.UNPACK_SKIP_IMAGES );

		const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[ level ] : srcTexture.image;

		gl.pixelStorei( gl.UNPACK_ROW_LENGTH, image.width );
		gl.pixelStorei( gl.UNPACK_IMAGE_HEIGHT, image.height );
		gl.pixelStorei( gl.UNPACK_SKIP_PIXELS, minX );
		gl.pixelStorei( gl.UNPACK_SKIP_ROWS, minY );

		if ( srcTexture.isRenderTargetTexture || srcTexture.isDepthTexture ) {

			const srcTextureData = backend.get( srcTexture );
			const dstTextureData = backend.get( dstTexture );

			const srcRenderContextData = backend.get( srcTextureData.renderTarget );
			const dstRenderContextData = backend.get( dstTextureData.renderTarget );

			const srcFramebuffer = srcRenderContextData.framebuffers[ srcTextureData.cacheKey ];
			const dstFramebuffer = dstRenderContextData.framebuffers[ dstTextureData.cacheKey ];

			state.bindFramebuffer( gl.READ_FRAMEBUFFER, srcFramebuffer );
			state.bindFramebuffer( gl.DRAW_FRAMEBUFFER, dstFramebuffer );

			let mask = gl.COLOR_BUFFER_BIT;

			if ( srcTexture.isDepthTexture ) mask = gl.DEPTH_BUFFER_BIT;

			gl.blitFramebuffer( minX, minY, width, height, dstX, dstY, width, height, mask, gl.NEAREST );

			state.bindFramebuffer( gl.READ_FRAMEBUFFER, null );
			state.bindFramebuffer( gl.DRAW_FRAMEBUFFER, null );

		} else {

			if ( srcTexture.isDataTexture ) {

				gl.texSubImage2D( gl.TEXTURE_2D, level, dstX, dstY, width, height, glFormat, glType, image.data );

			} else {

				if ( srcTexture.isCompressedTexture ) {

					gl.compressedTexSubImage2D( gl.TEXTURE_2D, level, dstX, dstY, image.width, image.height, glFormat, image.data );

				} else {

					gl.texSubImage2D( gl.TEXTURE_2D, level, dstX, dstY, width, height, glFormat, glType, image );

				}

			}

		}

		gl.pixelStorei( gl.UNPACK_ROW_LENGTH, currentUnpackRowLen );
		gl.pixelStorei( gl.UNPACK_IMAGE_HEIGHT, currentUnpackImageHeight );
		gl.pixelStorei( gl.UNPACK_SKIP_PIXELS, currentUnpackSkipPixels );
		gl.pixelStorei( gl.UNPACK_SKIP_ROWS, currentUnpackSkipRows );
		gl.pixelStorei( gl.UNPACK_SKIP_IMAGES, currentUnpackSkipImages );

		// Generate mipmaps only when copying level 0
		if ( level === 0 && dstTexture.generateMipmaps ) gl.generateMipmap( gl.TEXTURE_2D );

		state.unbindTexture();

	}

	copyFramebufferToTexture( texture, renderContext, rectangle ) {

		const { gl } = this;
		const { state } = this.backend;

		const { textureGPU } = this.backend.get( texture );

		const { x, y, z: width, w: height } = rectangle;

		const requireDrawFrameBuffer = texture.isDepthTexture === true || ( renderContext.renderTarget && renderContext.renderTarget.samples > 0 );

		const srcHeight = renderContext.renderTarget ? renderContext.renderTarget.height : this.backend.gerDrawingBufferSize().y;

		if ( requireDrawFrameBuffer ) {

			const partial = ( x !== 0 || y !== 0 );
			let mask;
			let attachment;

			if ( texture.isDepthTexture === true ) {

				mask = gl.DEPTH_BUFFER_BIT;
				attachment = gl.DEPTH_ATTACHMENT;

				if ( renderContext.stencil ) {

					mask |= gl.STENCIL_BUFFER_BIT;

				}

			} else {

				mask = gl.COLOR_BUFFER_BIT;
				attachment = gl.COLOR_ATTACHMENT0;

			}

			if ( partial ) {

				const renderTargetContextData = this.backend.get( renderContext.renderTarget );

				const fb = renderTargetContextData.framebuffers[ renderContext.getCacheKey() ];
				const msaaFrameBuffer = renderTargetContextData.msaaFrameBuffer;

				state.bindFramebuffer( gl.DRAW_FRAMEBUFFER, fb );
				state.bindFramebuffer( gl.READ_FRAMEBUFFER, msaaFrameBuffer );

				const flippedY = srcHeight - y - height;

				gl.blitFramebuffer( x, flippedY, x + width, flippedY + height, x, flippedY, x + width, flippedY + height, mask, gl.NEAREST );

				state.bindFramebuffer( gl.READ_FRAMEBUFFER, fb );

				state.bindTexture( gl.TEXTURE_2D, textureGPU );

				gl.copyTexSubImage2D( gl.TEXTURE_2D, 0, 0, 0, x, flippedY, width, height );

				state.unbindTexture();

			} else {

				const fb = gl.createFramebuffer();

				state.bindFramebuffer( gl.DRAW_FRAMEBUFFER, fb );

				gl.framebufferTexture2D( gl.DRAW_FRAMEBUFFER, attachment, gl.TEXTURE_2D, textureGPU, 0 );
				gl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, gl.NEAREST );

				gl.deleteFramebuffer( fb );

			}

		} else {

			state.bindTexture( gl.TEXTURE_2D, textureGPU );
			gl.copyTexSubImage2D( gl.TEXTURE_2D, 0, 0, 0, x, srcHeight - height - y, width, height );

			state.unbindTexture();

		}

		if ( texture.generateMipmaps ) this.generateMipmaps( texture );

		this.backend._setFramebuffer( renderContext );

	}

	// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
	setupRenderBufferStorage( renderbuffer, renderContext ) {

		const { gl } = this;
		const renderTarget = renderContext.renderTarget;

		const { samples, depthTexture, depthBuffer, stencilBuffer, width, height } = renderTarget;

		gl.bindRenderbuffer( gl.RENDERBUFFER, renderbuffer );

		if ( depthBuffer && ! stencilBuffer ) {

			let glInternalFormat = gl.DEPTH_COMPONENT24;

			if ( samples > 0 ) {

				if ( depthTexture && depthTexture.isDepthTexture ) {

					if ( depthTexture.type === gl.FLOAT ) {

						glInternalFormat = gl.DEPTH_COMPONENT32F;

					}

				}

				gl.renderbufferStorageMultisample( gl.RENDERBUFFER, samples, glInternalFormat, width, height );

			} else {

				gl.renderbufferStorage( gl.RENDERBUFFER, glInternalFormat, width, height );

			}

			gl.framebufferRenderbuffer( gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer );

		} else if ( depthBuffer && stencilBuffer ) {

			if ( samples > 0 ) {

				gl.renderbufferStorageMultisample( gl.RENDERBUFFER, samples, gl.DEPTH24_STENCIL8, width, height );

			} else {

				gl.renderbufferStorage( gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height );

			}


			gl.framebufferRenderbuffer( gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, renderbuffer );

		}

	}

	async copyTextureToBuffer( texture, x, y, width, height, faceIndex ) {

		const { backend, gl } = this;

		const { textureGPU, glFormat, glType } = this.backend.get( texture );

		const fb = gl.createFramebuffer();

		gl.bindFramebuffer( gl.READ_FRAMEBUFFER, fb );

		const target = texture.isCubeTexture ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex : gl.TEXTURE_2D;

		gl.framebufferTexture2D( gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, target, textureGPU, 0 );

		const typedArrayType = this._getTypedArrayType( glType );
		const bytesPerTexel = this._getBytesPerTexel( glType, glFormat );

		const elementCount = width * height;
		const byteLength = elementCount * bytesPerTexel;

		const buffer = gl.createBuffer();

		gl.bindBuffer( gl.PIXEL_PACK_BUFFER, buffer );
		gl.bufferData( gl.PIXEL_PACK_BUFFER, byteLength, gl.STREAM_READ );
		gl.readPixels( x, y, width, height, glFormat, glType, 0 );
		gl.bindBuffer( gl.PIXEL_PACK_BUFFER, null );

		await backend.utils._clientWaitAsync();

		const dstBuffer = new typedArrayType( byteLength / typedArrayType.BYTES_PER_ELEMENT );

		gl.bindBuffer( gl.PIXEL_PACK_BUFFER, buffer );
		gl.getBufferSubData( gl.PIXEL_PACK_BUFFER, 0, dstBuffer );
		gl.bindBuffer( gl.PIXEL_PACK_BUFFER, null );

		gl.deleteFramebuffer( fb );

		return dstBuffer;

	}

	_getTypedArrayType( glType ) {

		const { gl } = this;

		if ( glType === gl.UNSIGNED_BYTE ) return Uint8Array;

		if ( glType === gl.UNSIGNED_SHORT_4_4_4_4 ) return Uint16Array;
		if ( glType === gl.UNSIGNED_SHORT_5_5_5_1 ) return Uint16Array;
		if ( glType === gl.UNSIGNED_SHORT_5_6_5 ) return Uint16Array;
		if ( glType === gl.UNSIGNED_SHORT ) return Uint16Array;
		if ( glType === gl.UNSIGNED_INT ) return Uint32Array;

		if ( glType === gl.HALF_FLOAT ) return Uint16Array;
		if ( glType === gl.FLOAT ) return Float32Array;

		throw new Error( `Unsupported WebGL type: ${glType}` );

	}

	_getBytesPerTexel( glType, glFormat ) {

		const { gl } = this;

		let bytesPerComponent = 0;

		if ( glType === gl.UNSIGNED_BYTE ) bytesPerComponent = 1;

		if ( glType === gl.UNSIGNED_SHORT_4_4_4_4 ||
			glType === gl.UNSIGNED_SHORT_5_5_5_1 ||
			glType === gl.UNSIGNED_SHORT_5_6_5 ||
			glType === gl.UNSIGNED_SHORT ||
			glType === gl.HALF_FLOAT ) bytesPerComponent = 2;

		if ( glType === gl.UNSIGNED_INT ||
			glType === gl.FLOAT ) bytesPerComponent = 4;

		if ( glFormat === gl.RGBA ) return bytesPerComponent * 4;
		if ( glFormat === gl.RGB ) return bytesPerComponent * 3;
		if ( glFormat === gl.ALPHA ) return bytesPerComponent;

	}

}

class WebGLExtensions {

	constructor( backend ) {

		this.backend = backend;

		this.gl = this.backend.gl;
		this.availableExtensions = this.gl.getSupportedExtensions();

		this.extensions = {};

	}

	get( name ) {

		let extension = this.extensions[ name ];

		if ( extension === undefined ) {

			extension = this.gl.getExtension( name );

			this.extensions[ name ] = extension;

		}

		return extension;

	}

	has( name ) {

		return this.availableExtensions.includes( name );

	}

}

class WebGLCapabilities {

	constructor( backend ) {

		this.backend = backend;

		this.maxAnisotropy = null;

	}

	getMaxAnisotropy() {

		if ( this.maxAnisotropy !== null ) return this.maxAnisotropy;

		const gl = this.backend.gl;
		const extensions = this.backend.extensions;

		if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {

			const extension = extensions.get( 'EXT_texture_filter_anisotropic' );

			this.maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

		} else {

			this.maxAnisotropy = 0;

		}

		return this.maxAnisotropy;

	}

}

const GLFeatureName = {

	'WEBGL_multi_draw': 'WEBGL_multi_draw',
	'WEBGL_compressed_texture_astc': 'texture-compression-astc',
	'WEBGL_compressed_texture_etc': 'texture-compression-etc2',
	'WEBGL_compressed_texture_etc1': 'texture-compression-etc1',
	'WEBGL_compressed_texture_pvrtc': 'texture-compression-pvrtc',
	'WEBKIT_WEBGL_compressed_texture_pvrtc': 'texture-compression-pvrtc',
	'WEBGL_compressed_texture_s3tc': 'texture-compression-bc',
	'EXT_texture_compression_bptc': 'texture-compression-bptc',
	'EXT_disjoint_timer_query_webgl2': 'timestamp-query',

};

class WebGLBufferRenderer {

	constructor( backend ) {

		this.gl = backend.gl;
		this.extensions = backend.extensions;
		this.info = backend.renderer.info;
		this.mode = null;
		this.index = 0;
		this.type = null;
		this.object = null;

	}

	render( start, count ) {

		const { gl, mode, object, type, info, index } = this;

		if ( index !== 0 ) {

			gl.drawElements( mode, count, type, start );

		} else {

			gl.drawArrays( mode, start, count );

		}

		info.update( object, count, mode, 1 );

	}

	renderInstances( start, count, primcount ) {

		const { gl, mode, type, index, object, info } = this;

		if ( primcount === 0 ) return;

		if ( index !== 0 ) {

			gl.drawElementsInstanced( mode, count, type, start, primcount );

		} else {

			gl.drawArraysInstanced( mode, start, count, primcount );

		}

		info.update( object, count, mode, primcount );

	}

	renderMultiDraw( starts, counts, drawCount ) {

		const { extensions, mode, object, info } = this;

		if ( drawCount === 0 ) return;

		const extension = extensions.get( 'WEBGL_multi_draw' );

		if ( extension === null ) {

			for ( let i = 0; i < drawCount; i ++ ) {

				this.render( starts[ i ], counts[ i ] );

			}

		} else {

			if ( this.index !== 0 ) {

				extension.multiDrawElementsWEBGL( mode, counts, 0, this.type, starts, 0, drawCount );

			} else {

				extension.multiDrawArraysWEBGL( mode, starts, 0, counts, 0, drawCount );

			}

			let elementCount = 0;
			for ( let i = 0; i < drawCount; i ++ ) {

				elementCount += counts[ i ];

			}

			info.update( object, elementCount, mode, 1 );

		}

	}

	renderMultiDrawInstances( starts, counts, drawCount, primcount ) {

		const { extensions, mode, object, info } = this;

		if ( drawCount === 0 ) return;

		const extension = extensions.get( 'WEBGL_multi_draw' );

		if ( extension === null ) {

			for ( let i = 0; i < drawCount; i ++ ) {

				this.renderInstances( starts[ i ], counts[ i ], primcount[ i ] );

			}

		} else {

			if ( this.index !== 0 ) {

				extension.multiDrawElementsInstancedWEBGL( mode, counts, 0, this.type, starts, 0, primcount, 0, drawCount );

			} else {

				extension.multiDrawArraysInstancedWEBGL( mode, starts, 0, counts, 0, primcount, 0, drawCount );

			}

			let elementCount = 0;
			for ( let i = 0; i < drawCount; i ++ ) {

				elementCount += counts[ i ] * primcount[ i ];

			}

			info.update( object, elementCount, mode, 1 );

		}

	}

	//

}

//

class WebGLBackend extends Backend {

	constructor( parameters = {} ) {

		super( parameters );

		this.isWebGLBackend = true;

	}

	init( renderer ) {

		super.init( renderer );

		//

		const parameters = this.parameters;

		const glContext = ( parameters.context !== undefined ) ? parameters.context : renderer.domElement.getContext( 'webgl2' );

	 	function onContextLost( event ) {

			event.preventDefault();

			const contextLossInfo = {
				api: 'WebGL',
				message: event.statusMessage || 'Unknown reason',
				reason: null,
				originalEvent: event
			};

			renderer.onDeviceLost( contextLossInfo );

		}

		this._onContextLost = onContextLost;

		renderer.domElement.addEventListener( 'webglcontextlost', onContextLost, false );

		this.gl = glContext;

		this.extensions = new WebGLExtensions( this );
		this.capabilities = new WebGLCapabilities( this );
		this.attributeUtils = new WebGLAttributeUtils( this );
		this.textureUtils = new WebGLTextureUtils( this );
		this.bufferRenderer = new WebGLBufferRenderer( this );

		this.state = new WebGLState( this );
		this.utils = new WebGLUtils( this );

		this.vaoCache = {};
		this.transformFeedbackCache = {};
		this.discard = false;
		this.trackTimestamp = ( parameters.trackTimestamp === true );

		this.extensions.get( 'EXT_color_buffer_float' );
		this.extensions.get( 'WEBGL_clip_cull_distance' );
		this.extensions.get( 'OES_texture_float_linear' );
		this.extensions.get( 'EXT_color_buffer_half_float' );
		this.extensions.get( 'WEBGL_multisampled_render_to_texture' );
		this.extensions.get( 'WEBGL_render_shared_exponent' );
		this.extensions.get( 'WEBGL_multi_draw' );

		this.disjoint = this.extensions.get( 'EXT_disjoint_timer_query_webgl2' );
		this.parallel = this.extensions.get( 'KHR_parallel_shader_compile' );

		this._knownBindings = new WeakSet();

		this._currentContext = null;

	}

	get coordinateSystem() {

		return WebGLCoordinateSystem;

	}

	async getArrayBufferAsync( attribute ) {

		return await this.attributeUtils.getArrayBufferAsync( attribute );

	}

	async waitForGPU() {

		await this.utils._clientWaitAsync();

	}

	initTimestampQuery( renderContext ) {

		if ( ! this.disjoint || ! this.trackTimestamp ) return;

		const renderContextData = this.get( renderContext );

		if ( this.queryRunning ) {

		  if ( ! renderContextData.queryQueue ) renderContextData.queryQueue = [];
		  renderContextData.queryQueue.push( renderContext );
		  return;

		}

		if ( renderContextData.activeQuery ) {

		  this.gl.endQuery( this.disjoint.TIME_ELAPSED_EXT );
		  renderContextData.activeQuery = null;

		}

		renderContextData.activeQuery = this.gl.createQuery();

		if ( renderContextData.activeQuery !== null ) {

		  this.gl.beginQuery( this.disjoint.TIME_ELAPSED_EXT, renderContextData.activeQuery );
		  this.queryRunning = true;

		}

	}

	// timestamp utils

	prepareTimestampBuffer( renderContext ) {

		if ( ! this.disjoint || ! this.trackTimestamp ) return;

		const renderContextData = this.get( renderContext );

		if ( renderContextData.activeQuery ) {

		  this.gl.endQuery( this.disjoint.TIME_ELAPSED_EXT );

		  if ( ! renderContextData.gpuQueries ) renderContextData.gpuQueries = [];
		  renderContextData.gpuQueries.push( { query: renderContextData.activeQuery } );
		  renderContextData.activeQuery = null;
		  this.queryRunning = false;

		  if ( renderContextData.queryQueue && renderContextData.queryQueue.length > 0 ) {

				const nextRenderContext = renderContextData.queryQueue.shift();
				this.initTimestampQuery( nextRenderContext );

			}

		}

	}

	async resolveTimestampAsync( renderContext, type = 'render' ) {

		if ( ! this.disjoint || ! this.trackTimestamp ) return;

		const renderContextData = this.get( renderContext );

		if ( ! renderContextData.gpuQueries ) renderContextData.gpuQueries = [];

		for ( let i = 0; i < renderContextData.gpuQueries.length; i ++ ) {

		  const queryInfo = renderContextData.gpuQueries[ i ];
		  const available = this.gl.getQueryParameter( queryInfo.query, this.gl.QUERY_RESULT_AVAILABLE );
		  const disjoint = this.gl.getParameter( this.disjoint.GPU_DISJOINT_EXT );

		  if ( available && ! disjoint ) {

				const elapsed = this.gl.getQueryParameter( queryInfo.query, this.gl.QUERY_RESULT );
				const duration = Number( elapsed ) / 1000000; // Convert nanoseconds to milliseconds
				this.gl.deleteQuery( queryInfo.query );
				renderContextData.gpuQueries.splice( i, 1 ); // Remove the processed query
				i --;
				this.renderer.info.updateTimestamp( type, duration );

			}

		}

	}

	getContext() {

		return this.gl;

	}

	beginRender( renderContext ) {

		const { gl } = this;
		const renderContextData = this.get( renderContext );

		//

		//

		this.initTimestampQuery( renderContext );

		renderContextData.previousContext = this._currentContext;
		this._currentContext = renderContext;

		this._setFramebuffer( renderContext );

		this.clear( renderContext.clearColor, renderContext.clearDepth, renderContext.clearStencil, renderContext, false );

		//
		if ( renderContext.viewport ) {

			this.updateViewport( renderContext );

		} else {

			gl.viewport( 0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight );

		}

		if ( renderContext.scissor ) {

			const { x, y, width, height } = renderContext.scissorValue;

			gl.scissor( x, renderContext.height - height - y, width, height );

		}

		const occlusionQueryCount = renderContext.occlusionQueryCount;

		if ( occlusionQueryCount > 0 ) {

			// Get a reference to the array of objects with queries. The renderContextData property
			// can be changed by another render pass before the async reading of all previous queries complete
			renderContextData.currentOcclusionQueries = renderContextData.occlusionQueries;
			renderContextData.currentOcclusionQueryObjects = renderContextData.occlusionQueryObjects;

			renderContextData.lastOcclusionObject = null;
			renderContextData.occlusionQueries = new Array( occlusionQueryCount );
			renderContextData.occlusionQueryObjects = new Array( occlusionQueryCount );
			renderContextData.occlusionQueryIndex = 0;

		}

	}

	finishRender( renderContext ) {

		const { gl, state } = this;
		const renderContextData = this.get( renderContext );
		const previousContext = renderContextData.previousContext;

		const occlusionQueryCount = renderContext.occlusionQueryCount;

		if ( occlusionQueryCount > 0 ) {

			if ( occlusionQueryCount > renderContextData.occlusionQueryIndex ) {

				gl.endQuery( gl.ANY_SAMPLES_PASSED );

			}

			this.resolveOccludedAsync( renderContext );

		}

		const textures = renderContext.textures;

		if ( textures !== null ) {

			for ( let i = 0; i < textures.length; i ++ ) {

				const texture = textures[ i ];

				if ( texture.generateMipmaps ) {

					this.generateMipmaps( texture );

				}

			}

		}

		this._currentContext = previousContext;

		if ( renderContext.textures !== null && renderContext.renderTarget ) {

			const renderTargetContextData = this.get( renderContext.renderTarget );

			const { samples } = renderContext.renderTarget;

			if ( samples > 0 ) {

				const fb = renderTargetContextData.framebuffers[ renderContext.getCacheKey() ];

				const mask = gl.COLOR_BUFFER_BIT;

				const msaaFrameBuffer = renderTargetContextData.msaaFrameBuffer;

				const textures = renderContext.textures;

				state.bindFramebuffer( gl.READ_FRAMEBUFFER, msaaFrameBuffer );
				state.bindFramebuffer( gl.DRAW_FRAMEBUFFER, fb );

				for ( let i = 0; i < textures.length; i ++ ) {

					// TODO Add support for MRT

					if ( renderContext.scissor ) {

						const { x, y, width, height } = renderContext.scissorValue;

						const viewY = renderContext.height - height - y;

						gl.blitFramebuffer( x, viewY, x + width, viewY + height, x, viewY, x + width, viewY + height, mask, gl.NEAREST );
						gl.invalidateSubFramebuffer( gl.READ_FRAMEBUFFER, renderTargetContextData.invalidationArray, x, viewY, width, height );

					} else {

						gl.blitFramebuffer( 0, 0, renderContext.width, renderContext.height, 0, 0, renderContext.width, renderContext.height, mask, gl.NEAREST );
						gl.invalidateFramebuffer( gl.READ_FRAMEBUFFER, renderTargetContextData.invalidationArray );

					}

				}

			}


		}

		if ( previousContext !== null ) {

			this._setFramebuffer( previousContext );

			if ( previousContext.viewport ) {

				this.updateViewport( previousContext );

			} else {

				gl.viewport( 0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight );

			}

		}

		this.prepareTimestampBuffer( renderContext );

	}

	resolveOccludedAsync( renderContext ) {

		const renderContextData = this.get( renderContext );

		// handle occlusion query results

		const { currentOcclusionQueries, currentOcclusionQueryObjects } = renderContextData;

		if ( currentOcclusionQueries && currentOcclusionQueryObjects ) {

			const occluded = new WeakSet();
			const { gl } = this;

			renderContextData.currentOcclusionQueryObjects = null;
			renderContextData.currentOcclusionQueries = null;

			const check = () => {

				let completed = 0;

				// check all queries and requeue as appropriate
				for ( let i = 0; i < currentOcclusionQueries.length; i ++ ) {

					const query = currentOcclusionQueries[ i ];

					if ( query === null ) continue;

					if ( gl.getQueryParameter( query, gl.QUERY_RESULT_AVAILABLE ) ) {

						if ( gl.getQueryParameter( query, gl.QUERY_RESULT ) > 0 ) occluded.add( currentOcclusionQueryObjects[ i ] );

						currentOcclusionQueries[ i ] = null;
						gl.deleteQuery( query );

						completed ++;

					}

				}

				if ( completed < currentOcclusionQueries.length ) {

					requestAnimationFrame( check );

				} else {

					renderContextData.occluded = occluded;

				}

			};

			check();

		}

	}

	isOccluded( renderContext, object ) {

		const renderContextData = this.get( renderContext );

		return renderContextData.occluded && renderContextData.occluded.has( object );

	}

	updateViewport( renderContext ) {

		const gl = this.gl;
		const { x, y, width, height } = renderContext.viewportValue;

		gl.viewport( x, renderContext.height - height - y, width, height );

	}

	setScissorTest( boolean ) {

		const gl = this.gl;

		if ( boolean ) {

			gl.enable( gl.SCISSOR_TEST );

		} else {

			gl.disable( gl.SCISSOR_TEST );

		}

	}

	clear( color, depth, stencil, descriptor = null, setFrameBuffer = true ) {

		const { gl } = this;

		if ( descriptor === null ) {

			const clearColor = this.getClearColor();

			// premultiply alpha

			clearColor.r *= clearColor.a;
			clearColor.g *= clearColor.a;
			clearColor.b *= clearColor.a;

			descriptor = {
				textures: null,
				clearColorValue: clearColor
			};

		}

		//

		let clear = 0;

		if ( color ) clear |= gl.COLOR_BUFFER_BIT;
		if ( depth ) clear |= gl.DEPTH_BUFFER_BIT;
		if ( stencil ) clear |= gl.STENCIL_BUFFER_BIT;

		if ( clear !== 0 ) {

			let clearColor;

			if ( descriptor.clearColorValue ) {

				clearColor = descriptor.clearColorValue;

			} else {

				clearColor = this.getClearColor();

				// premultiply alpha

				clearColor.r *= clearColor.a;
				clearColor.g *= clearColor.a;
				clearColor.b *= clearColor.a;

			}

			if ( depth ) this.state.setDepthMask( true );

			if ( descriptor.textures === null ) {

				gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearColor.a );
				gl.clear( clear );

			} else {

				if ( setFrameBuffer ) this._setFramebuffer( descriptor );

				if ( color ) {

					for ( let i = 0; i < descriptor.textures.length; i ++ ) {

						gl.clearBufferfv( gl.COLOR, i, [ clearColor.r, clearColor.g, clearColor.b, clearColor.a ] );

					}

				}

				if ( depth && stencil ) {

					gl.clearBufferfi( gl.DEPTH_STENCIL, 0, 1, 0 );

				} else if ( depth ) {

					gl.clearBufferfv( gl.DEPTH, 0, [ 1.0 ] );

				} else if ( stencil ) {

					gl.clearBufferiv( gl.STENCIL, 0, [ 0 ] );

				}

			}

		}

	}

	beginCompute( computeGroup ) {

		const { state, gl } = this;

		state.bindFramebuffer( gl.FRAMEBUFFER, null );
		this.initTimestampQuery( computeGroup );

	}

	compute( computeGroup, computeNode, bindings, pipeline ) {

		const { state, gl } = this;

		if ( ! this.discard ) {

			// required here to handle async behaviour of render.compute()
			gl.enable( gl.RASTERIZER_DISCARD );
			this.discard = true;

		}

		const { programGPU, transformBuffers, attributes } = this.get( pipeline );

		const vaoKey = this._getVaoKey( null, attributes );

		const vaoGPU = this.vaoCache[ vaoKey ];

		if ( vaoGPU === undefined ) {

			this._createVao( null, attributes );

		} else {

			gl.bindVertexArray( vaoGPU );

		}

		state.useProgram( programGPU );

		this._bindUniforms( bindings );

		const transformFeedbackGPU = this._getTransformFeedback( transformBuffers );

		gl.bindTransformFeedback( gl.TRANSFORM_FEEDBACK, transformFeedbackGPU );
		gl.beginTransformFeedback( gl.POINTS );

		if ( attributes[ 0 ].isStorageInstancedBufferAttribute ) {

			gl.drawArraysInstanced( gl.POINTS, 0, 1, computeNode.count );

		} else {

			gl.drawArrays( gl.POINTS, 0, computeNode.count );

		}

		gl.endTransformFeedback();
		gl.bindTransformFeedback( gl.TRANSFORM_FEEDBACK, null );

		// switch active buffers

		for ( let i = 0; i < transformBuffers.length; i ++ ) {

			const dualAttributeData = transformBuffers[ i ];

			if ( dualAttributeData.pbo ) {

				this.textureUtils.copyBufferToTexture( dualAttributeData.transformBuffer, dualAttributeData.pbo );

			}

			dualAttributeData.switchBuffers();


		}

	}

	finishCompute( computeGroup ) {

		const gl = this.gl;

		this.discard = false;

		gl.disable( gl.RASTERIZER_DISCARD );

		this.prepareTimestampBuffer( computeGroup );

		if ( this._currentContext ) {

			this._setFramebuffer( this._currentContext );

		}

	}

	draw( renderObject/*, info*/ ) {

		const { object, pipeline, material, context, hardwareClippingPlanes } = renderObject;
		const { programGPU } = this.get( pipeline );

		const { gl, state } = this;

		const contextData = this.get( context );

		const drawParams = renderObject.getDrawParameters();

		if ( drawParams === null ) return;

		//

		this._bindUniforms( renderObject.getBindings() );

		const frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );

		state.setMaterial( material, frontFaceCW, hardwareClippingPlanes );

		state.useProgram( programGPU );

		//

		const renderObjectData = this.get( renderObject );

		let vaoGPU = renderObjectData.staticVao;

		if ( vaoGPU === undefined || renderObjectData.geometryId !== renderObject.geometry.id ) {

			const vaoKey = this._getVaoKey( renderObject.getIndex(), renderObject.getAttributes() );

			vaoGPU = this.vaoCache[ vaoKey ];

			if ( vaoGPU === undefined ) {

				let staticVao;

				( { vaoGPU, staticVao } = this._createVao( renderObject.getIndex(), renderObject.getAttributes() ) );

				if ( staticVao ) {

					renderObjectData.staticVao = vaoGPU;
					renderObjectData.geometryId = renderObject.geometry.id;

				}

			}

		}

		gl.bindVertexArray( vaoGPU );

		//

		const index = renderObject.getIndex();

		//

		const lastObject = contextData.lastOcclusionObject;

		if ( lastObject !== object && lastObject !== undefined ) {

			if ( lastObject !== null && lastObject.occlusionTest === true ) {

				gl.endQuery( gl.ANY_SAMPLES_PASSED );

				contextData.occlusionQueryIndex ++;

			}

			if ( object.occlusionTest === true ) {

				const query = gl.createQuery();

				gl.beginQuery( gl.ANY_SAMPLES_PASSED, query );

				contextData.occlusionQueries[ contextData.occlusionQueryIndex ] = query;
				contextData.occlusionQueryObjects[ contextData.occlusionQueryIndex ] = object;

			}

			contextData.lastOcclusionObject = object;

		}

		//
		const renderer = this.bufferRenderer;

		if ( object.isPoints ) renderer.mode = gl.POINTS;
		else if ( object.isLineSegments ) renderer.mode = gl.LINES;
		else if ( object.isLine ) renderer.mode = gl.LINE_STRIP;
		else if ( object.isLineLoop ) renderer.mode = gl.LINE_LOOP;
		else {

			if ( material.wireframe === true ) {

				state.setLineWidth( material.wireframeLinewidth * this.renderer.getPixelRatio() );
				renderer.mode = gl.LINES;

			} else {

				renderer.mode = gl.TRIANGLES;

			}

		}

		//

		const { vertexCount, instanceCount } = drawParams;
		let { firstVertex } = drawParams;

		renderer.object = object;

		if ( index !== null ) {

			firstVertex *= index.array.BYTES_PER_ELEMENT;

			const indexData = this.get( index );

			renderer.index = index.count;
			renderer.type = indexData.type;

		} else {

			renderer.index = 0;

		}

		if ( object.isBatchedMesh ) {

			if ( object._multiDrawInstances !== null ) {

				renderer.renderMultiDrawInstances( object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount, object._multiDrawInstances );

			} else if ( ! this.hasFeature( 'WEBGL_multi_draw' ) ) {

				warnOnce( 'THREE.WebGLRenderer: WEBGL_multi_draw not supported.' );

			} else {

				renderer.renderMultiDraw( object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount );

			}

		} else if ( instanceCount > 1 ) {

			renderer.renderInstances( firstVertex, vertexCount, instanceCount );

		} else {

			renderer.render( firstVertex, vertexCount );

		}
		//

		gl.bindVertexArray( null );

	}

	needsRenderUpdate( /*renderObject*/ ) {

		return false;

	}

	getRenderCacheKey( /*renderObject*/ ) {

		return '';

	}

	// textures

	createDefaultTexture( texture ) {

		this.textureUtils.createDefaultTexture( texture );

	}

	createTexture( texture, options ) {

		this.textureUtils.createTexture( texture, options );

	}

	updateTexture( texture, options ) {

		this.textureUtils.updateTexture( texture, options );

	}

	generateMipmaps( texture ) {

		this.textureUtils.generateMipmaps( texture );

	}


	destroyTexture( texture ) {

		this.textureUtils.destroyTexture( texture );

	}

	copyTextureToBuffer( texture, x, y, width, height, faceIndex ) {

		return this.textureUtils.copyTextureToBuffer( texture, x, y, width, height, faceIndex );

	}

	createSampler( /*texture*/ ) {

		//console.warn( 'Abstract class.' );

	}

	destroySampler() {}

	// node builder

	createNodeBuilder( object, renderer ) {

		return new GLSLNodeBuilder( object, renderer );

	}

	// program

	createProgram( program ) {

		const gl = this.gl;
		const { stage, code } = program;

		const shader = stage === 'fragment' ? gl.createShader( gl.FRAGMENT_SHADER ) : gl.createShader( gl.VERTEX_SHADER );

		gl.shaderSource( shader, code );
		gl.compileShader( shader );

		this.set( program, {
			shaderGPU: shader
		} );

	}

	destroyProgram( /*program*/ ) {

		console.warn( 'Abstract class.' );

	}

	createRenderPipeline( renderObject, promises ) {

		const gl = this.gl;
		const pipeline = renderObject.pipeline;

		// Program

		const { fragmentProgram, vertexProgram } = pipeline;

		const programGPU = gl.createProgram();

		const fragmentShader = this.get( fragmentProgram ).shaderGPU;
		const vertexShader = this.get( vertexProgram ).shaderGPU;

		gl.attachShader( programGPU, fragmentShader );
		gl.attachShader( programGPU, vertexShader );
		gl.linkProgram( programGPU );

		this.set( pipeline, {
			programGPU,
			fragmentShader,
			vertexShader
		} );

		if ( promises !== null && this.parallel ) {

			const p = new Promise( ( resolve /*, reject*/ ) => {

				const parallel = this.parallel;
				const checkStatus = () => {

					if ( gl.getProgramParameter( programGPU, parallel.COMPLETION_STATUS_KHR ) ) {

						this._completeCompile( renderObject, pipeline );
						resolve();

					} else {

						requestAnimationFrame( checkStatus );

					}

				};

				checkStatus();

			} );

			promises.push( p );

			return;

		}

		this._completeCompile( renderObject, pipeline );

	}

	_handleSource( string, errorLine ) {

		const lines = string.split( '\n' );
		const lines2 = [];

		const from = Math.max( errorLine - 6, 0 );
		const to = Math.min( errorLine + 6, lines.length );

		for ( let i = from; i < to; i ++ ) {

			const line = i + 1;
			lines2.push( `${line === errorLine ? '>' : ' '} ${line}: ${lines[ i ]}` );

		}

		return lines2.join( '\n' );

	}

	_getShaderErrors( gl, shader, type ) {

		const status = gl.getShaderParameter( shader, gl.COMPILE_STATUS );
		const errors = gl.getShaderInfoLog( shader ).trim();

		if ( status && errors === '' ) return '';

		const errorMatches = /ERROR: 0:(\d+)/.exec( errors );
		if ( errorMatches ) {

			const errorLine = parseInt( errorMatches[ 1 ] );
			return type.toUpperCase() + '\n\n' + errors + '\n\n' + this._handleSource( gl.getShaderSource( shader ), errorLine );

		} else {

			return errors;

		}

	}

	_logProgramError( programGPU, glFragmentShader, glVertexShader ) {

		if ( this.renderer.debug.checkShaderErrors ) {

			const gl = this.gl;

			const programLog = gl.getProgramInfoLog( programGPU ).trim();

			if ( gl.getProgramParameter( programGPU, gl.LINK_STATUS ) === false ) {


				if ( typeof this.renderer.debug.onShaderError === 'function' ) {

					this.renderer.debug.onShaderError( gl, programGPU, glVertexShader, glFragmentShader );

				} else {

					// default error reporting

					const vertexErrors = this._getShaderErrors( gl, glVertexShader, 'vertex' );
					const fragmentErrors = this._getShaderErrors( gl, glFragmentShader, 'fragment' );

					console.error(
						'THREE.WebGLProgram: Shader Error ' + gl.getError() + ' - ' +
						'VALIDATE_STATUS ' + gl.getProgramParameter( programGPU, gl.VALIDATE_STATUS ) + '\n\n' +
						'Program Info Log: ' + programLog + '\n' +
						vertexErrors + '\n' +
						fragmentErrors
					);

				}

			} else if ( programLog !== '' ) {

				console.warn( 'THREE.WebGLProgram: Program Info Log:', programLog );

			}

		}

	}

	_completeCompile( renderObject, pipeline ) {

		const { state, gl } = this;
		const pipelineData = this.get( pipeline );
		const { programGPU, fragmentShader, vertexShader } = pipelineData;

		if ( gl.getProgramParameter( programGPU, gl.LINK_STATUS ) === false ) {

			this._logProgramError( programGPU, fragmentShader, vertexShader );

		}

		state.useProgram( programGPU );

		// Bindings

		const bindings = renderObject.getBindings();

		this._setupBindings( bindings, programGPU );

		//

		this.set( pipeline, {
			programGPU
		} );

	}

	createComputePipeline( computePipeline, bindings ) {

		const { state, gl } = this;

		// Program

		const fragmentProgram = {
			stage: 'fragment',
			code: '#version 300 es\nprecision highp float;\nvoid main() {}'
		};

		this.createProgram( fragmentProgram );

		const { computeProgram } = computePipeline;

		const programGPU = gl.createProgram();

		const fragmentShader = this.get( fragmentProgram ).shaderGPU;
		const vertexShader = this.get( computeProgram ).shaderGPU;

		const transforms = computeProgram.transforms;

		const transformVaryingNames = [];
		const transformAttributeNodes = [];

		for ( let i = 0; i < transforms.length; i ++ ) {

			const transform = transforms[ i ];

			transformVaryingNames.push( transform.varyingName );
			transformAttributeNodes.push( transform.attributeNode );

		}

		gl.attachShader( programGPU, fragmentShader );
		gl.attachShader( programGPU, vertexShader );

		gl.transformFeedbackVaryings(
			programGPU,
			transformVaryingNames,
			gl.SEPARATE_ATTRIBS
		);

		gl.linkProgram( programGPU );

		if ( gl.getProgramParameter( programGPU, gl.LINK_STATUS ) === false ) {

			this._logProgramError( programGPU, fragmentShader, vertexShader );


		}

		state.useProgram( programGPU );

		// Bindings

		this._setupBindings( bindings, programGPU );

		const attributeNodes = computeProgram.attributes;
		const attributes = [];
		const transformBuffers = [];

		for ( let i = 0; i < attributeNodes.length; i ++ ) {

			const attribute = attributeNodes[ i ].node.attribute;

			attributes.push( attribute );

			if ( ! this.has( attribute ) ) this.attributeUtils.createAttribute( attribute, gl.ARRAY_BUFFER );

		}

		for ( let i = 0; i < transformAttributeNodes.length; i ++ ) {

			const attribute = transformAttributeNodes[ i ].attribute;

			if ( ! this.has( attribute ) ) this.attributeUtils.createAttribute( attribute, gl.ARRAY_BUFFER );

			const attributeData = this.get( attribute );

			transformBuffers.push( attributeData );

		}

		//

		this.set( computePipeline, {
			programGPU,
			transformBuffers,
			attributes
		} );

	}

	createBindings( bindGroup, bindings ) {

		if ( this._knownBindings.has( bindings ) === false ) {

			this._knownBindings.add( bindings );

			let uniformBuffers = 0;
			let textures = 0;

			for ( const bindGroup of bindings ) {

				this.set( bindGroup, {
					textures: textures,
					uniformBuffers: uniformBuffers
				} );

				for ( const binding of bindGroup.bindings ) {

					if ( binding.isUniformBuffer ) uniformBuffers ++;
					if ( binding.isSampledTexture ) textures ++;

				}

			}

		}

		this.updateBindings( bindGroup, bindings );

	}

	updateBindings( bindGroup /*, bindings*/ ) {

		const { gl } = this;

		const bindGroupData = this.get( bindGroup );

		let i = bindGroupData.uniformBuffers;
		let t = bindGroupData.textures;

		for ( const binding of bindGroup.bindings ) {

			if ( binding.isUniformsGroup || binding.isUniformBuffer ) {

				const data = binding.buffer;
				const bufferGPU = gl.createBuffer();

				gl.bindBuffer( gl.UNIFORM_BUFFER, bufferGPU );
				gl.bufferData( gl.UNIFORM_BUFFER, data, gl.DYNAMIC_DRAW );

				this.set( binding, {
					index: i ++,
					bufferGPU
				} );

			} else if ( binding.isSampledTexture ) {

				const { textureGPU, glTextureType } = this.get( binding.texture );

				this.set( binding, {
					index: t ++,
					textureGPU,
					glTextureType
				} );

			}

		}

	}

	updateBinding( binding ) {

		const gl = this.gl;

		if ( binding.isUniformsGroup || binding.isUniformBuffer ) {

			const bindingData = this.get( binding );
			const bufferGPU = bindingData.bufferGPU;
			const data = binding.buffer;

			gl.bindBuffer( gl.UNIFORM_BUFFER, bufferGPU );
			gl.bufferData( gl.UNIFORM_BUFFER, data, gl.DYNAMIC_DRAW );

		}

	}

	// attributes

	createIndexAttribute( attribute ) {

		const gl = this.gl;

		this.attributeUtils.createAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );

	}

	createAttribute( attribute ) {

		if ( this.has( attribute ) ) return;

		const gl = this.gl;

		this.attributeUtils.createAttribute( attribute, gl.ARRAY_BUFFER );

	}

	createStorageAttribute( attribute ) {

		if ( this.has( attribute ) ) return;

		const gl = this.gl;

		this.attributeUtils.createAttribute( attribute, gl.ARRAY_BUFFER );

	}

	updateAttribute( attribute ) {

		this.attributeUtils.updateAttribute( attribute );

	}

	destroyAttribute( attribute ) {

		this.attributeUtils.destroyAttribute( attribute );

	}

	updateSize() {

		//console.warn( 'Abstract class.' );

	}

	hasFeature( name ) {

		const keysMatching = Object.keys( GLFeatureName ).filter( key => GLFeatureName[ key ] === name );

		const extensions = this.extensions;

		for ( let i = 0; i < keysMatching.length; i ++ ) {

			if ( extensions.has( keysMatching[ i ] ) ) return true;

		}

		return false;

	}

	getMaxAnisotropy() {

		return this.capabilities.getMaxAnisotropy();

	}

	copyTextureToTexture( srcTexture, dstTexture, srcRegion, dstPosition, level ) {

		this.textureUtils.copyTextureToTexture( srcTexture, dstTexture, srcRegion, dstPosition, level );

	}

	copyFramebufferToTexture( texture, renderContext, rectangle ) {

		this.textureUtils.copyFramebufferToTexture( texture, renderContext, rectangle );

	}

	_setFramebuffer( descriptor ) {

		const { gl, state } = this;

		let currentFrameBuffer = null;

		if ( descriptor.textures !== null ) {

			const renderTarget = descriptor.renderTarget;
			const renderTargetContextData = this.get( renderTarget );
			const { samples, depthBuffer, stencilBuffer } = renderTarget;

			const isCube = renderTarget.isWebGLCubeRenderTarget === true;

			let msaaFb = renderTargetContextData.msaaFrameBuffer;
			let depthRenderbuffer = renderTargetContextData.depthRenderbuffer;

			const cacheKey = getCacheKey( descriptor );

			let fb;

			if ( isCube ) {

				renderTargetContextData.cubeFramebuffers || ( renderTargetContextData.cubeFramebuffers = {} );

				fb = renderTargetContextData.cubeFramebuffers[ cacheKey ];

			} else {

				renderTargetContextData.framebuffers || ( renderTargetContextData.framebuffers = {} );

				fb = renderTargetContextData.framebuffers[ cacheKey ];

			}

			if ( fb === undefined ) {

				fb = gl.createFramebuffer();

				state.bindFramebuffer( gl.FRAMEBUFFER, fb );

				const textures = descriptor.textures;

				if ( isCube ) {

					renderTargetContextData.cubeFramebuffers[ cacheKey ] = fb;

					const { textureGPU } = this.get( textures[ 0 ] );

					const cubeFace = this.renderer._activeCubeFace;

					gl.framebufferTexture2D( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + cubeFace, textureGPU, 0 );

				} else {

					renderTargetContextData.framebuffers[ cacheKey ] = fb;

					for ( let i = 0; i < textures.length; i ++ ) {

						const texture = textures[ i ];
						const textureData = this.get( texture );
						textureData.renderTarget = descriptor.renderTarget;
						textureData.cacheKey = cacheKey; // required for copyTextureToTexture()

						const attachment = gl.COLOR_ATTACHMENT0 + i;

						gl.framebufferTexture2D( gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, textureData.textureGPU, 0 );

					}

					state.drawBuffers( descriptor, fb );

				}

				if ( descriptor.depthTexture !== null ) {

					const textureData = this.get( descriptor.depthTexture );
					const depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
					textureData.renderTarget = descriptor.renderTarget;
					textureData.cacheKey = cacheKey; // required for copyTextureToTexture()

					gl.framebufferTexture2D( gl.FRAMEBUFFER, depthStyle, gl.TEXTURE_2D, textureData.textureGPU, 0 );

				}

			}

			if ( samples > 0 ) {

				if ( msaaFb === undefined ) {

					const invalidationArray = [];

					msaaFb = gl.createFramebuffer();

					state.bindFramebuffer( gl.FRAMEBUFFER, msaaFb );

					const msaaRenderbuffers = [];

					const textures = descriptor.textures;

					for ( let i = 0; i < textures.length; i ++ ) {

						msaaRenderbuffers[ i ] = gl.createRenderbuffer();

						gl.bindRenderbuffer( gl.RENDERBUFFER, msaaRenderbuffers[ i ] );

						invalidationArray.push( gl.COLOR_ATTACHMENT0 + i );

						if ( depthBuffer ) {

							const depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
							invalidationArray.push( depthStyle );

						}

						const texture = descriptor.textures[ i ];
						const textureData = this.get( texture );

						gl.renderbufferStorageMultisample( gl.RENDERBUFFER, samples, textureData.glInternalFormat, descriptor.width, descriptor.height );
						gl.framebufferRenderbuffer( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, msaaRenderbuffers[ i ] );


					}

					renderTargetContextData.msaaFrameBuffer = msaaFb;
					renderTargetContextData.msaaRenderbuffers = msaaRenderbuffers;

					if ( depthRenderbuffer === undefined ) {

						depthRenderbuffer = gl.createRenderbuffer();
						this.textureUtils.setupRenderBufferStorage( depthRenderbuffer, descriptor );

						renderTargetContextData.depthRenderbuffer = depthRenderbuffer;

						const depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
						invalidationArray.push( depthStyle );

					}

					renderTargetContextData.invalidationArray = invalidationArray;

				}

				currentFrameBuffer = renderTargetContextData.msaaFrameBuffer;

			} else {

				currentFrameBuffer = fb;

			}

		}

		state.bindFramebuffer( gl.FRAMEBUFFER, currentFrameBuffer );

	}


	_getVaoKey( index, attributes ) {

		let key = [];

		if ( index !== null ) {

			const indexData = this.get( index );

			key += ':' + indexData.id;

		}

		for ( let i = 0; i < attributes.length; i ++ ) {

			const attributeData = this.get( attributes[ i ] );

			key += ':' + attributeData.id;

		}

		return key;

	}

	_createVao( index, attributes ) {

		const { gl } = this;

		const vaoGPU = gl.createVertexArray();
		let key = '';

		let staticVao = true;

		gl.bindVertexArray( vaoGPU );

		if ( index !== null ) {

			const indexData = this.get( index );

			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, indexData.bufferGPU );

			key += ':' + indexData.id;

		}

		for ( let i = 0; i < attributes.length; i ++ ) {

			const attribute = attributes[ i ];
			const attributeData = this.get( attribute );

			key += ':' + attributeData.id;

			gl.bindBuffer( gl.ARRAY_BUFFER, attributeData.bufferGPU );
			gl.enableVertexAttribArray( i );

			if ( attribute.isStorageBufferAttribute || attribute.isStorageInstancedBufferAttribute ) staticVao = false;

			let stride, offset;

			if ( attribute.isInterleavedBufferAttribute === true ) {

				stride = attribute.data.stride * attributeData.bytesPerElement;
				offset = attribute.offset * attributeData.bytesPerElement;

			} else {

				stride = 0;
				offset = 0;

			}

			if ( attributeData.isInteger ) {

				gl.vertexAttribIPointer( i, attribute.itemSize, attributeData.type, stride, offset );

			} else {

				gl.vertexAttribPointer( i, attribute.itemSize, attributeData.type, attribute.normalized, stride, offset );

			}

			if ( attribute.isInstancedBufferAttribute && ! attribute.isInterleavedBufferAttribute ) {

				gl.vertexAttribDivisor( i, attribute.meshPerAttribute );

			} else if ( attribute.isInterleavedBufferAttribute && attribute.data.isInstancedInterleavedBuffer ) {

				gl.vertexAttribDivisor( i, attribute.data.meshPerAttribute );

			}

		}

		gl.bindBuffer( gl.ARRAY_BUFFER, null );

		this.vaoCache[ key ] = vaoGPU;

		return { vaoGPU, staticVao };

	}

	_getTransformFeedback( transformBuffers ) {

		let key = '';

		for ( let i = 0; i < transformBuffers.length; i ++ ) {

			key += ':' + transformBuffers[ i ].id;

		}

		let transformFeedbackGPU = this.transformFeedbackCache[ key ];

		if ( transformFeedbackGPU !== undefined ) {

			return transformFeedbackGPU;

		}

		const { gl } = this;

		transformFeedbackGPU = gl.createTransformFeedback();

		gl.bindTransformFeedback( gl.TRANSFORM_FEEDBACK, transformFeedbackGPU );

		for ( let i = 0; i < transformBuffers.length; i ++ ) {

			const attributeData = transformBuffers[ i ];

			gl.bindBufferBase( gl.TRANSFORM_FEEDBACK_BUFFER, i, attributeData.transformBuffer );

		}

		gl.bindTransformFeedback( gl.TRANSFORM_FEEDBACK, null );

		this.transformFeedbackCache[ key ] = transformFeedbackGPU;

		return transformFeedbackGPU;

	}


	_setupBindings( bindings, programGPU ) {

		const gl = this.gl;

		for ( const bindGroup of bindings ) {

			for ( const binding of bindGroup.bindings ) {

				const bindingData = this.get( binding );
				const index = bindingData.index;

				if ( binding.isUniformsGroup || binding.isUniformBuffer ) {

					const location = gl.getUniformBlockIndex( programGPU, binding.name );
					gl.uniformBlockBinding( programGPU, location, index );

				} else if ( binding.isSampledTexture ) {

					const location = gl.getUniformLocation( programGPU, binding.name );
					gl.uniform1i( location, index );

				}

			}

		}

	}

	_bindUniforms( bindings ) {

		const { gl, state } = this;

		for ( const bindGroup of bindings ) {

			for ( const binding of bindGroup.bindings ) {

				const bindingData = this.get( binding );
				const index = bindingData.index;

				if ( binding.isUniformsGroup || binding.isUniformBuffer ) {

					// TODO USE bindBufferRange to group multiple uniform buffers
					state.bindBufferBase( gl.UNIFORM_BUFFER, index, bindingData.bufferGPU );

				} else if ( binding.isSampledTexture ) {

					state.bindTexture( bindingData.glTextureType, bindingData.textureGPU, gl.TEXTURE0 + index );

				}

			}

		}

	}

	dispose() {

		this.renderer.domElement.removeEventListener( 'webglcontextlost', this._onContextLost );

	}

}

const GPUPrimitiveTopology = {
	PointList: 'point-list',
	LineList: 'line-list',
	LineStrip: 'line-strip',
	TriangleList: 'triangle-list',
	TriangleStrip: 'triangle-strip',
};

const GPUCompareFunction = {
	Never: 'never',
	Less: 'less',
	Equal: 'equal',
	LessEqual: 'less-equal',
	Greater: 'greater',
	NotEqual: 'not-equal',
	GreaterEqual: 'greater-equal',
	Always: 'always'
};

const GPUStoreOp = {
	Store: 'store'};

const GPULoadOp = {
	Load: 'load',
	Clear: 'clear'
};

const GPUFrontFace = {
	CCW: 'ccw'};

const GPUCullMode = {
	None: 'none',
	Front: 'front',
	Back: 'back'
};

const GPUIndexFormat = {
	Uint16: 'uint16',
	Uint32: 'uint32'
};

const GPUTextureFormat = {

	// 8-bit formats

	R8Unorm: 'r8unorm',
	R8Snorm: 'r8snorm',
	R8Uint: 'r8uint',
	R8Sint: 'r8sint',

	// 16-bit formats

	R16Uint: 'r16uint',
	R16Sint: 'r16sint',
	R16Float: 'r16float',
	RG8Unorm: 'rg8unorm',
	RG8Snorm: 'rg8snorm',
	RG8Uint: 'rg8uint',
	RG8Sint: 'rg8sint',

	// 32-bit formats

	R32Uint: 'r32uint',
	R32Sint: 'r32sint',
	R32Float: 'r32float',
	RG16Uint: 'rg16uint',
	RG16Sint: 'rg16sint',
	RG16Float: 'rg16float',
	RGBA8Unorm: 'rgba8unorm',
	RGBA8UnormSRGB: 'rgba8unorm-srgb',
	RGBA8Snorm: 'rgba8snorm',
	RGBA8Uint: 'rgba8uint',
	RGBA8Sint: 'rgba8sint',
	BGRA8Unorm: 'bgra8unorm',
	BGRA8UnormSRGB: 'bgra8unorm-srgb',
	// Packed 32-bit formats
	RGB9E5UFloat: 'rgb9e5ufloat',
	RGB10A2Unorm: 'rgb10a2unorm',
	// 64-bit formats

	RG32Uint: 'rg32uint',
	RG32Sint: 'rg32sint',
	RG32Float: 'rg32float',
	RGBA16Uint: 'rgba16uint',
	RGBA16Sint: 'rgba16sint',
	RGBA16Float: 'rgba16float',

	// 128-bit formats

	RGBA32Uint: 'rgba32uint',
	RGBA32Sint: 'rgba32sint',
	RGBA32Float: 'rgba32float',

	Depth16Unorm: 'depth16unorm',
	Depth24Plus: 'depth24plus',
	Depth24PlusStencil8: 'depth24plus-stencil8',
	Depth32Float: 'depth32float',

	// 'depth32float-stencil8' extension

	Depth32FloatStencil8: 'depth32float-stencil8',

	// BC compressed formats usable if 'texture-compression-bc' is both
	// supported by the device/user agent and enabled in requestDevice.

	BC1RGBAUnorm: 'bc1-rgba-unorm',
	BC1RGBAUnormSRGB: 'bc1-rgba-unorm-srgb',
	BC2RGBAUnorm: 'bc2-rgba-unorm',
	BC2RGBAUnormSRGB: 'bc2-rgba-unorm-srgb',
	BC3RGBAUnorm: 'bc3-rgba-unorm',
	BC3RGBAUnormSRGB: 'bc3-rgba-unorm-srgb',
	BC4RUnorm: 'bc4-r-unorm',
	BC5RGUnorm: 'bc5-rg-unorm',
	BC5RGSnorm: 'bc5-rg-snorm',
	BC6HRGBUFloat: 'bc6h-rgb-ufloat',
	BC6HRGBFloat: 'bc6h-rgb-float',
	BC7RGBAUnorm: 'bc7-rgba-unorm',
	BC7RGBAUnormSRGB: 'bc7-rgba-srgb',

	// ETC2 compressed formats usable if 'texture-compression-etc2' is both
	// supported by the device/user agent and enabled in requestDevice.

	ETC2RGB8Unorm: 'etc2-rgb8unorm',
	ETC2RGB8UnormSRGB: 'etc2-rgb8unorm-srgb',
	ETC2RGB8A1Unorm: 'etc2-rgb8a1unorm',
	ETC2RGB8A1UnormSRGB: 'etc2-rgb8a1unorm-srgb',
	ETC2RGBA8Unorm: 'etc2-rgba8unorm',
	ETC2RGBA8UnormSRGB: 'etc2-rgba8unorm-srgb',
	EACR11Unorm: 'eac-r11unorm',
	EACR11Snorm: 'eac-r11snorm',
	EACRG11Unorm: 'eac-rg11unorm',
	EACRG11Snorm: 'eac-rg11snorm',

	// ASTC compressed formats usable if 'texture-compression-astc' is both
	// supported by the device/user agent and enabled in requestDevice.

	ASTC4x4Unorm: 'astc-4x4-unorm',
	ASTC4x4UnormSRGB: 'astc-4x4-unorm-srgb',
	ASTC5x4Unorm: 'astc-5x4-unorm',
	ASTC5x4UnormSRGB: 'astc-5x4-unorm-srgb',
	ASTC5x5Unorm: 'astc-5x5-unorm',
	ASTC5x5UnormSRGB: 'astc-5x5-unorm-srgb',
	ASTC6x5Unorm: 'astc-6x5-unorm',
	ASTC6x5UnormSRGB: 'astc-6x5-unorm-srgb',
	ASTC6x6Unorm: 'astc-6x6-unorm',
	ASTC6x6UnormSRGB: 'astc-6x6-unorm-srgb',
	ASTC8x5Unorm: 'astc-8x5-unorm',
	ASTC8x5UnormSRGB: 'astc-8x5-unorm-srgb',
	ASTC8x6Unorm: 'astc-8x6-unorm',
	ASTC8x6UnormSRGB: 'astc-8x6-unorm-srgb',
	ASTC8x8Unorm: 'astc-8x8-unorm',
	ASTC8x8UnormSRGB: 'astc-8x8-unorm-srgb',
	ASTC10x5Unorm: 'astc-10x5-unorm',
	ASTC10x5UnormSRGB: 'astc-10x5-unorm-srgb',
	ASTC10x6Unorm: 'astc-10x6-unorm',
	ASTC10x6UnormSRGB: 'astc-10x6-unorm-srgb',
	ASTC10x8Unorm: 'astc-10x8-unorm',
	ASTC10x8UnormSRGB: 'astc-10x8-unorm-srgb',
	ASTC10x10Unorm: 'astc-10x10-unorm',
	ASTC10x10UnormSRGB: 'astc-10x10-unorm-srgb',
	ASTC12x10Unorm: 'astc-12x10-unorm',
	ASTC12x10UnormSRGB: 'astc-12x10-unorm-srgb',
	ASTC12x12Unorm: 'astc-12x12-unorm',
	ASTC12x12UnormSRGB: 'astc-12x12-unorm-srgb',

};

const GPUAddressMode = {
	ClampToEdge: 'clamp-to-edge',
	Repeat: 'repeat',
	MirrorRepeat: 'mirror-repeat'
};

const GPUFilterMode = {
	Linear: 'linear',
	Nearest: 'nearest'
};

const GPUBlendFactor = {
	Zero: 'zero',
	One: 'one',
	Src: 'src',
	OneMinusSrc: 'one-minus-src',
	SrcAlpha: 'src-alpha',
	OneMinusSrcAlpha: 'one-minus-src-alpha',
	Dst: 'dst',
	OneMinusDstColor: 'one-minus-dst',
	DstAlpha: 'dst-alpha',
	OneMinusDstAlpha: 'one-minus-dst-alpha',
	SrcAlphaSaturated: 'src-alpha-saturated',
	Constant: 'constant',
	OneMinusConstant: 'one-minus-constant'
};

const GPUBlendOperation = {
	Add: 'add',
	Subtract: 'subtract',
	ReverseSubtract: 'reverse-subtract',
	Min: 'min',
	Max: 'max'
};

const GPUColorWriteFlags = {
	None: 0,
	All: 0xF
};

const GPUStencilOperation = {
	Keep: 'keep',
	Zero: 'zero',
	Replace: 'replace',
	Invert: 'invert',
	IncrementClamp: 'increment-clamp',
	DecrementClamp: 'decrement-clamp',
	IncrementWrap: 'increment-wrap',
	DecrementWrap: 'decrement-wrap'
};

const GPUBufferBindingType = {
	Storage: 'storage',
	ReadOnlyStorage: 'read-only-storage'
};

const GPUStorageTextureAccess = {
	WriteOnly: 'write-only',
	ReadOnly: 'read-only',
	ReadWrite: 'read-write',
};

const GPUTextureSampleType = {
	Float: 'float',
	UnfilterableFloat: 'unfilterable-float',
	Depth: 'depth',
	SInt: 'sint',
	UInt: 'uint'
};

const GPUTextureDimension = {
	TwoD: '2d',
	ThreeD: '3d'
};

const GPUTextureViewDimension = {
	TwoD: '2d',
	TwoDArray: '2d-array',
	Cube: 'cube',
	ThreeD: '3d'
};

const GPUTextureAspect = {
	All: 'all'};

const GPUInputStepMode = {
	Vertex: 'vertex',
	Instance: 'instance'
};

const GPUFeatureName = {
	DepthClipControl: 'depth-clip-control',
	Depth32FloatStencil8: 'depth32float-stencil8',
	TextureCompressionBC: 'texture-compression-bc',
	TextureCompressionETC2: 'texture-compression-etc2',
	TextureCompressionASTC: 'texture-compression-astc',
	TimestampQuery: 'timestamp-query',
	IndirectFirstInstance: 'indirect-first-instance',
	ShaderF16: 'shader-f16',
	RG11B10UFloat: 'rg11b10ufloat-renderable',
	BGRA8UNormStorage: 'bgra8unorm-storage',
	Float32Filterable: 'float32-filterable',
	ClipDistances: 'clip-distances',
	DualSourceBlending: 'dual-source-blending',
	Subgroups: 'subgroups'
};

class Sampler extends Binding {

	constructor( name, texture ) {

		super( name );

		this.texture = texture;
		this.version = texture ? texture.version : 0;

		this.isSampler = true;

	}

}

class NodeSampler extends Sampler {

	constructor( name, textureNode, groupNode ) {

		super( name, textureNode ? textureNode.value : null );

		this.textureNode = textureNode;
		this.groupNode = groupNode;

	}

	update() {

		this.texture = this.textureNode.value;

	}

}

class StorageBuffer extends Buffer {

	constructor( name, attribute ) {

		super( name, attribute ? attribute.array : null );

		this.attribute = attribute;

		this.isStorageBuffer = true;

	}

}

let _id = 0;

class NodeStorageBuffer extends StorageBuffer {

	constructor( nodeUniform, groupNode ) {

		super( 'StorageBuffer_' + _id ++, nodeUniform ? nodeUniform.value : null );

		this.nodeUniform = nodeUniform;
		this.access = nodeUniform ? nodeUniform.access : NodeAccess.READ_WRITE;
		this.groupNode = groupNode;

	}

	get buffer() {

		return this.nodeUniform.value;

	}

}

class WebGPUTexturePassUtils extends DataMap {

	constructor( device ) {

		super();

		this.device = device;

		const mipmapVertexSource = `
struct VarysStruct {
	@builtin( position ) Position: vec4<f32>,
	@location( 0 ) vTex : vec2<f32>
};

@vertex
fn main( @builtin( vertex_index ) vertexIndex : u32 ) -> VarysStruct {

	var Varys : VarysStruct;

	var pos = array< vec2<f32>, 4 >(
		vec2<f32>( -1.0,  1.0 ),
		vec2<f32>(  1.0,  1.0 ),
		vec2<f32>( -1.0, -1.0 ),
		vec2<f32>(  1.0, -1.0 )
	);

	var tex = array< vec2<f32>, 4 >(
		vec2<f32>( 0.0, 0.0 ),
		vec2<f32>( 1.0, 0.0 ),
		vec2<f32>( 0.0, 1.0 ),
		vec2<f32>( 1.0, 1.0 )
	);

	Varys.vTex = tex[ vertexIndex ];
	Varys.Position = vec4<f32>( pos[ vertexIndex ], 0.0, 1.0 );

	return Varys;

}
`;

		const mipmapFragmentSource = `
@group( 0 ) @binding( 0 )
var imgSampler : sampler;

@group( 0 ) @binding( 1 )
var img : texture_2d<f32>;

@fragment
fn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {

	return textureSample( img, imgSampler, vTex );

}
`;

		const flipYFragmentSource = `
@group( 0 ) @binding( 0 )
var imgSampler : sampler;

@group( 0 ) @binding( 1 )
var img : texture_2d<f32>;

@fragment
fn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {

	return textureSample( img, imgSampler, vec2( vTex.x, 1.0 - vTex.y ) );

}
`;
		this.mipmapSampler = device.createSampler( { minFilter: GPUFilterMode.Linear } );
		this.flipYSampler = device.createSampler( { minFilter: GPUFilterMode.Nearest } ); //@TODO?: Consider using textureLoad()

		// We'll need a new pipeline for every texture format used.
		this.transferPipelines = {};
		this.flipYPipelines = {};

		this.mipmapVertexShaderModule = device.createShaderModule( {
			label: 'mipmapVertex',
			code: mipmapVertexSource
		} );

		this.mipmapFragmentShaderModule = device.createShaderModule( {
			label: 'mipmapFragment',
			code: mipmapFragmentSource
		} );

		this.flipYFragmentShaderModule = device.createShaderModule( {
			label: 'flipYFragment',
			code: flipYFragmentSource
		} );

	}

	getTransferPipeline( format ) {

		let pipeline = this.transferPipelines[ format ];

		if ( pipeline === undefined ) {

			pipeline = this.device.createRenderPipeline( {
				label: `mipmap-${ format }`,
				vertex: {
					module: this.mipmapVertexShaderModule,
					entryPoint: 'main'
				},
				fragment: {
					module: this.mipmapFragmentShaderModule,
					entryPoint: 'main',
					targets: [ { format } ]
				},
				primitive: {
					topology: GPUPrimitiveTopology.TriangleStrip,
					stripIndexFormat: GPUIndexFormat.Uint32
				},
				layout: 'auto'
			} );

			this.transferPipelines[ format ] = pipeline;

		}

		return pipeline;

	}

	getFlipYPipeline( format ) {

		let pipeline = this.flipYPipelines[ format ];

		if ( pipeline === undefined ) {

			pipeline = this.device.createRenderPipeline( {
				label: `flipY-${ format }`,
				vertex: {
					module: this.mipmapVertexShaderModule,
					entryPoint: 'main'
				},
				fragment: {
					module: this.flipYFragmentShaderModule,
					entryPoint: 'main',
					targets: [ { format } ]
				},
				primitive: {
					topology: GPUPrimitiveTopology.TriangleStrip,
					stripIndexFormat: GPUIndexFormat.Uint32
				},
				layout: 'auto'
			} );

			this.flipYPipelines[ format ] = pipeline;

		}

		return pipeline;

	}

	flipY( textureGPU, textureGPUDescriptor, baseArrayLayer = 0 ) {

		const format = textureGPUDescriptor.format;
		const { width, height } = textureGPUDescriptor.size;

		const transferPipeline = this.getTransferPipeline( format );
		const flipYPipeline = this.getFlipYPipeline( format );

		const tempTexture = this.device.createTexture( {
			size: { width, height, depthOrArrayLayers: 1 },
			format,
			usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
		} );

		const srcView = textureGPU.createView( {
			baseMipLevel: 0,
			mipLevelCount: 1,
			dimension: GPUTextureViewDimension.TwoD,
			baseArrayLayer
		} );

		const dstView = tempTexture.createView( {
			baseMipLevel: 0,
			mipLevelCount: 1,
			dimension: GPUTextureViewDimension.TwoD,
			baseArrayLayer: 0
		} );

		const commandEncoder = this.device.createCommandEncoder( {} );

		const pass = ( pipeline, sourceView, destinationView ) => {

			const bindGroupLayout = pipeline.getBindGroupLayout( 0 ); // @TODO: Consider making this static.

			const bindGroup = this.device.createBindGroup( {
				layout: bindGroupLayout,
				entries: [ {
					binding: 0,
					resource: this.flipYSampler
				}, {
					binding: 1,
					resource: sourceView
				} ]
			} );

			const passEncoder = commandEncoder.beginRenderPass( {
				colorAttachments: [ {
					view: destinationView,
					loadOp: GPULoadOp.Clear,
					storeOp: GPUStoreOp.Store,
					clearValue: [ 0, 0, 0, 0 ]
				} ]
			} );

			passEncoder.setPipeline( pipeline );
			passEncoder.setBindGroup( 0, bindGroup );
			passEncoder.draw( 4, 1, 0, 0 );
			passEncoder.end();

		};

		pass( transferPipeline, srcView, dstView );
		pass( flipYPipeline, dstView, srcView );

		this.device.queue.submit( [ commandEncoder.finish() ] );

		tempTexture.destroy();

	}

	generateMipmaps( textureGPU, textureGPUDescriptor, baseArrayLayer = 0 ) {

		const textureData = this.get( textureGPU );

		if ( textureData.useCount === undefined ) {

			textureData.useCount = 0;
			textureData.layers = [];

		}

		const passes = textureData.layers[ baseArrayLayer ] || this._mipmapCreateBundles( textureGPU, textureGPUDescriptor, baseArrayLayer );

		const commandEncoder = this.device.createCommandEncoder( {} );

		this._mipmapRunBundles( commandEncoder, passes );

		this.device.queue.submit( [ commandEncoder.finish() ] );

		if ( textureData.useCount !== 0 ) textureData.layers[ baseArrayLayer ] = passes;

		textureData.useCount ++;

	}

	_mipmapCreateBundles( textureGPU, textureGPUDescriptor, baseArrayLayer ) {

		const pipeline = this.getTransferPipeline( textureGPUDescriptor.format );

		const bindGroupLayout = pipeline.getBindGroupLayout( 0 ); // @TODO: Consider making this static.

		let srcView = textureGPU.createView( {
			baseMipLevel: 0,
			mipLevelCount: 1,
			dimension: GPUTextureViewDimension.TwoD,
			baseArrayLayer
		} );

		const passes = [];

		for ( let i = 1; i < textureGPUDescriptor.mipLevelCount; i ++ ) {

			const bindGroup = this.device.createBindGroup( {
				layout: bindGroupLayout,
				entries: [ {
					binding: 0,
					resource: this.mipmapSampler
				}, {
					binding: 1,
					resource: srcView
				} ]
			} );

			const dstView = textureGPU.createView( {
				baseMipLevel: i,
				mipLevelCount: 1,
				dimension: GPUTextureViewDimension.TwoD,
				baseArrayLayer
			} );

			const passDescriptor = {
				colorAttachments: [ {
					view: dstView,
					loadOp: GPULoadOp.Clear,
					storeOp: GPUStoreOp.Store,
					clearValue: [ 0, 0, 0, 0 ]
				} ]
			};

			const passEncoder = this.device.createRenderBundleEncoder( {
				colorFormats: [ textureGPUDescriptor.format ]
			} );

			passEncoder.setPipeline( pipeline );
			passEncoder.setBindGroup( 0, bindGroup );
			passEncoder.draw( 4, 1, 0, 0 );

			passes.push( {
				renderBundles: [ passEncoder.finish() ],
				passDescriptor
			} );

			srcView = dstView;

		}

		return passes;

	}

	_mipmapRunBundles( commandEncoder, passes ) {

		const levels = passes.length;

		for ( let i = 0; i < levels; i ++ ) {

			const pass = passes[ i ];

			const passEncoder = commandEncoder.beginRenderPass( pass.passDescriptor );

			passEncoder.executeBundles( pass.renderBundles );

			passEncoder.end();

		}

	}

}

const _compareToWebGPU = {
	[ NeverCompare ]: 'never',
	[ LessCompare ]: 'less',
	[ EqualCompare ]: 'equal',
	[ LessEqualCompare ]: 'less-equal',
	[ GreaterCompare ]: 'greater',
	[ GreaterEqualCompare ]: 'greater-equal',
	[ AlwaysCompare ]: 'always',
	[ NotEqualCompare ]: 'not-equal'
};

const _flipMap = [ 0, 1, 3, 2, 4, 5 ];

class WebGPUTextureUtils {

	constructor( backend ) {

		this.backend = backend;

		this._passUtils = null;

		this.defaultTexture = {};
		this.defaultCubeTexture = {};
		this.defaultVideoFrame = null;

		this.colorBuffer = null;

		this.depthTexture = new DepthTexture();
		this.depthTexture.name = 'depthBuffer';

	}

	createSampler( texture ) {

		const backend = this.backend;
		const device = backend.device;

		const textureGPU = backend.get( texture );

		const samplerDescriptorGPU = {
			addressModeU: this._convertAddressMode( texture.wrapS ),
			addressModeV: this._convertAddressMode( texture.wrapT ),
			addressModeW: this._convertAddressMode( texture.wrapR ),
			magFilter: this._convertFilterMode( texture.magFilter ),
			minFilter: this._convertFilterMode( texture.minFilter ),
			mipmapFilter: this._convertFilterMode( texture.minFilter ),
			maxAnisotropy: 1
		};

		// anisotropy can only be used when all filter modes are set to linear.

		if ( samplerDescriptorGPU.magFilter === GPUFilterMode.Linear && samplerDescriptorGPU.minFilter === GPUFilterMode.Linear && samplerDescriptorGPU.mipmapFilter === GPUFilterMode.Linear ) {

			samplerDescriptorGPU.maxAnisotropy = texture.anisotropy;

		}

		if ( texture.isDepthTexture && texture.compareFunction !== null ) {

			samplerDescriptorGPU.compare = _compareToWebGPU[ texture.compareFunction ];

		}

		textureGPU.sampler = device.createSampler( samplerDescriptorGPU );

	}

	createDefaultTexture( texture ) {

		let textureGPU;

		const format = getFormat( texture );

		if ( texture.isCubeTexture ) {

			textureGPU = this._getDefaultCubeTextureGPU( format );

		} else if ( texture.isVideoTexture ) {

			this.backend.get( texture ).externalTexture = this._getDefaultVideoFrame();

		} else {

			textureGPU = this._getDefaultTextureGPU( format );

		}

		this.backend.get( texture ).texture = textureGPU;

	}

	createTexture( texture, options = {} ) {

		const backend = this.backend;
		const textureData = backend.get( texture );

		if ( textureData.initialized ) {

			throw new Error( 'WebGPUTextureUtils: Texture already initialized.' );

		}

		if ( options.needsMipmaps === undefined ) options.needsMipmaps = false;
		if ( options.levels === undefined ) options.levels = 1;
		if ( options.depth === undefined ) options.depth = 1;

		const { width, height, depth, levels } = options;

		if ( texture.isFramebufferTexture ) {

			if ( options.renderTarget ) {

				options.format = this.backend.utils.getCurrentColorFormat( options.renderTarget );

			} else {

				options.format = this.backend.utils.getPreferredCanvasFormat();

			}

		}

		const dimension = this._getDimension( texture );
		const format = texture.internalFormat || options.format || getFormat( texture, backend.device );

		textureData.format = format;

		let sampleCount = options.sampleCount !== undefined ? options.sampleCount : 1;

		sampleCount = backend.utils.getSampleCount( sampleCount );

		const primarySampleCount = texture.isRenderTargetTexture && ! texture.isMultisampleRenderTargetTexture ? 1 : sampleCount;

		let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC;

		if ( texture.isStorageTexture === true ) {

			usage |= GPUTextureUsage.STORAGE_BINDING;

		}

		if ( texture.isCompressedTexture !== true && texture.isCompressedArrayTexture !== true ) {

			usage |= GPUTextureUsage.RENDER_ATTACHMENT;

		}

		const textureDescriptorGPU = {
			label: texture.name,
			size: {
				width: width,
				height: height,
				depthOrArrayLayers: depth,
			},
			mipLevelCount: levels,
			sampleCount: primarySampleCount,
			dimension: dimension,
			format: format,
			usage: usage
		};

		// texture creation

		if ( texture.isVideoTexture ) {

			const video = texture.source.data;
			const videoFrame = new VideoFrame( video );

			textureDescriptorGPU.size.width = videoFrame.displayWidth;
			textureDescriptorGPU.size.height = videoFrame.displayHeight;

			videoFrame.close();

			textureData.externalTexture = video;

		} else {

			if ( format === undefined ) {

				console.warn( 'WebGPURenderer: Texture format not supported.' );

				return this.createDefaultTexture( texture );

			}

			textureData.texture = backend.device.createTexture( textureDescriptorGPU );

		}

		if ( texture.isRenderTargetTexture && sampleCount > 1 && ! texture.isMultisampleRenderTargetTexture ) {

			const msaaTextureDescriptorGPU = Object.assign( {}, textureDescriptorGPU );

			msaaTextureDescriptorGPU.label = msaaTextureDescriptorGPU.label + '-msaa';
			msaaTextureDescriptorGPU.sampleCount = sampleCount;

			textureData.msaaTexture = backend.device.createTexture( msaaTextureDescriptorGPU );

		}

		textureData.initialized = true;

		textureData.textureDescriptorGPU = textureDescriptorGPU;

	}

	destroyTexture( texture ) {

		const backend = this.backend;
		const textureData = backend.get( texture );

		if ( textureData.texture !== undefined ) textureData.texture.destroy();

		if ( textureData.msaaTexture !== undefined ) textureData.msaaTexture.destroy();

		backend.delete( texture );

	}

	destroySampler( texture ) {

		const backend = this.backend;
		const textureData = backend.get( texture );

		delete textureData.sampler;

	}

	generateMipmaps( texture ) {

		const textureData = this.backend.get( texture );

		if ( texture.isCubeTexture ) {

			for ( let i = 0; i < 6; i ++ ) {

				this._generateMipmaps( textureData.texture, textureData.textureDescriptorGPU, i );

			}

		} else {

			const depth = texture.image.depth || 1;

			for ( let i = 0; i < depth; i ++ ) {

				this._generateMipmaps( textureData.texture, textureData.textureDescriptorGPU, i );

			}

		}

	}

	getColorBuffer() {

		if ( this.colorBuffer ) this.colorBuffer.destroy();

		const backend = this.backend;
		const { width, height } = backend.getDrawingBufferSize();

		this.colorBuffer = backend.device.createTexture( {
			label: 'colorBuffer',
			size: {
				width: width,
				height: height,
				depthOrArrayLayers: 1
			},
			sampleCount: backend.utils.getSampleCount( backend.renderer.samples ),
			format: backend.utils.getPreferredCanvasFormat(),
			usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC
		} );

		return this.colorBuffer;

	}

	getDepthBuffer( depth = true, stencil = false ) {

		const backend = this.backend;
		const { width, height } = backend.getDrawingBufferSize();

		const depthTexture = this.depthTexture;
		const depthTextureGPU = backend.get( depthTexture ).texture;

		let format, type;

		if ( stencil ) {

			format = DepthStencilFormat;
			type = UnsignedInt248Type;

		} else if ( depth ) {

			format = DepthFormat;
			type = UnsignedIntType;

		}

		if ( depthTextureGPU !== undefined ) {

			if ( depthTexture.image.width === width && depthTexture.image.height === height && depthTexture.format === format && depthTexture.type === type ) {

				return depthTextureGPU;

			}

			this.destroyTexture( depthTexture );

		}

		depthTexture.name = 'depthBuffer';
		depthTexture.format = format;
		depthTexture.type = type;
		depthTexture.image.width = width;
		depthTexture.image.height = height;

		this.createTexture( depthTexture, { sampleCount: backend.utils.getSampleCount( backend.renderer.samples ), width, height } );

		return backend.get( depthTexture ).texture;

	}

	updateTexture( texture, options ) {

		const textureData = this.backend.get( texture );

		const { textureDescriptorGPU } = textureData;

		if ( texture.isRenderTargetTexture || ( textureDescriptorGPU === undefined /* unsupported texture format */ ) )
			return;

		// transfer texture data

		if ( texture.isDataTexture ) {

			this._copyBufferToTexture( options.image, textureData.texture, textureDescriptorGPU, 0, texture.flipY );

		} else if ( texture.isDataArrayTexture || texture.isData3DTexture ) {

			for ( let i = 0; i < options.image.depth; i ++ ) {

				this._copyBufferToTexture( options.image, textureData.texture, textureDescriptorGPU, i, texture.flipY, i );

			}

		} else if ( texture.isCompressedTexture || texture.isCompressedArrayTexture ) {

			this._copyCompressedBufferToTexture( texture.mipmaps, textureData.texture, textureDescriptorGPU );

		} else if ( texture.isCubeTexture ) {

			this._copyCubeMapToTexture( options.images, textureData.texture, textureDescriptorGPU, texture.flipY );

		} else if ( texture.isVideoTexture ) {

			const video = texture.source.data;

			textureData.externalTexture = video;

		} else {

			this._copyImageToTexture( options.image, textureData.texture, textureDescriptorGPU, 0, texture.flipY );

		}

		//

		textureData.version = texture.version;

		if ( texture.onUpdate ) texture.onUpdate( texture );

	}

	async copyTextureToBuffer( texture, x, y, width, height, faceIndex ) {

		const device = this.backend.device;

		const textureData = this.backend.get( texture );
		const textureGPU = textureData.texture;
		const format = textureData.textureDescriptorGPU.format;
		const bytesPerTexel = this._getBytesPerTexel( format );

		let bytesPerRow = width * bytesPerTexel;
		bytesPerRow = Math.ceil( bytesPerRow / 256 ) * 256; // Align to 256 bytes

		const readBuffer = device.createBuffer(
			{
				size: width * height * bytesPerTexel,
				usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
			}
		);

		const encoder = device.createCommandEncoder();

		encoder.copyTextureToBuffer(
			{
				texture: textureGPU,
				origin: { x, y, z: faceIndex },
			},
			{
				buffer: readBuffer,
				bytesPerRow: bytesPerRow
			},
			{
				width: width,
				height: height
			}

		);

		const typedArrayType = this._getTypedArrayType( format );

		device.queue.submit( [ encoder.finish() ] );

		await readBuffer.mapAsync( GPUMapMode.READ );

		const buffer = readBuffer.getMappedRange();

		return new typedArrayType( buffer );

	}

	_isEnvironmentTexture( texture ) {

		const mapping = texture.mapping;

		return ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) || ( mapping === CubeReflectionMapping || mapping === CubeRefractionMapping );

	}

	_getDefaultTextureGPU( format ) {

		let defaultTexture = this.defaultTexture[ format ];

		if ( defaultTexture === undefined ) {

			const texture = new Texture();
			texture.minFilter = NearestFilter;
			texture.magFilter = NearestFilter;

			this.createTexture( texture, { width: 1, height: 1, format } );

			this.defaultTexture[ format ] = defaultTexture = texture;

		}

		return this.backend.get( defaultTexture ).texture;

	}

	_getDefaultCubeTextureGPU( format ) {

		let defaultCubeTexture = this.defaultTexture[ format ];

		if ( defaultCubeTexture === undefined ) {

			const texture = new CubeTexture();
			texture.minFilter = NearestFilter;
			texture.magFilter = NearestFilter;

			this.createTexture( texture, { width: 1, height: 1, depth: 6 } );

			this.defaultCubeTexture[ format ] = defaultCubeTexture = texture;

		}

		return this.backend.get( defaultCubeTexture ).texture;

	}

	_getDefaultVideoFrame() {

		let defaultVideoFrame = this.defaultVideoFrame;

		if ( defaultVideoFrame === null ) {

			const init = {
				timestamp: 0,
				codedWidth: 1,
				codedHeight: 1,
				format: 'RGBA',
			};

			this.defaultVideoFrame = defaultVideoFrame = new VideoFrame( new Uint8Array( [ 0, 0, 0, 0xff ] ), init );

		}

		return defaultVideoFrame;

	}

	_copyCubeMapToTexture( images, textureGPU, textureDescriptorGPU, flipY ) {

		for ( let i = 0; i < 6; i ++ ) {

			const image = images[ i ];

			const flipIndex = flipY === true ? _flipMap[ i ] : i;

			if ( image.isDataTexture ) {

				this._copyBufferToTexture( image.image, textureGPU, textureDescriptorGPU, flipIndex, flipY );

			} else {

				this._copyImageToTexture( image, textureGPU, textureDescriptorGPU, flipIndex, flipY );

			}

		}

	}

	_copyImageToTexture( image, textureGPU, textureDescriptorGPU, originDepth, flipY ) {

		const device = this.backend.device;

		device.queue.copyExternalImageToTexture(
			{
				source: image
			}, {
				texture: textureGPU,
				mipLevel: 0,
				origin: { x: 0, y: 0, z: originDepth }
			}, {
				width: image.width,
				height: image.height,
				depthOrArrayLayers: 1
			}
		);

		if ( flipY === true ) {

			this._flipY( textureGPU, textureDescriptorGPU, originDepth );

		}

	}

	_getPassUtils() {

		let passUtils = this._passUtils;

		if ( passUtils === null ) {

			this._passUtils = passUtils = new WebGPUTexturePassUtils( this.backend.device );

		}

		return passUtils;

	}

	_generateMipmaps( textureGPU, textureDescriptorGPU, baseArrayLayer = 0 ) {

		this._getPassUtils().generateMipmaps( textureGPU, textureDescriptorGPU, baseArrayLayer );

	}

	_flipY( textureGPU, textureDescriptorGPU, originDepth = 0 ) {

		this._getPassUtils().flipY( textureGPU, textureDescriptorGPU, originDepth );

	}

	_copyBufferToTexture( image, textureGPU, textureDescriptorGPU, originDepth, flipY, depth = 0 ) {

		// @TODO: Consider to use GPUCommandEncoder.copyBufferToTexture()
		// @TODO: Consider to support valid buffer layouts with other formats like RGB

		const device = this.backend.device;

		const data = image.data;

		const bytesPerTexel = this._getBytesPerTexel( textureDescriptorGPU.format );
		const bytesPerRow = image.width * bytesPerTexel;

		device.queue.writeTexture(
			{
				texture: textureGPU,
				mipLevel: 0,
				origin: { x: 0, y: 0, z: originDepth }
			},
			data,
			{
				offset: image.width * image.height * bytesPerTexel * depth,
				bytesPerRow
			},
			{
				width: image.width,
				height: image.height,
				depthOrArrayLayers: 1
			} );

		if ( flipY === true ) {

			this._flipY( textureGPU, textureDescriptorGPU, originDepth );

		}

	}

	_copyCompressedBufferToTexture( mipmaps, textureGPU, textureDescriptorGPU ) {

		// @TODO: Consider to use GPUCommandEncoder.copyBufferToTexture()

		const device = this.backend.device;

		const blockData = this._getBlockData( textureDescriptorGPU.format );
		const isTextureArray = textureDescriptorGPU.size.depthOrArrayLayers > 1;

		for ( let i = 0; i < mipmaps.length; i ++ ) {

			const mipmap = mipmaps[ i ];

			const width = mipmap.width;
			const height = mipmap.height;
			const depth = isTextureArray ? textureDescriptorGPU.size.depthOrArrayLayers : 1;

			const bytesPerRow = Math.ceil( width / blockData.width ) * blockData.byteLength;
			const bytesPerImage = bytesPerRow * Math.ceil( height / blockData.height );

			for ( let j = 0; j < depth; j ++ ) {

				device.queue.writeTexture(
					{
						texture: textureGPU,
						mipLevel: i,
						origin: { x: 0, y: 0, z: j }
					},
					mipmap.data,
					{
						offset: j * bytesPerImage,
						bytesPerRow,
						rowsPerImage: Math.ceil( height / blockData.height )
					},
					{
						width: Math.ceil( width / blockData.width ) * blockData.width,
						height: Math.ceil( height / blockData.height ) * blockData.height,
						depthOrArrayLayers: 1
					}
				);

			}

		}

	}

	_getBlockData( format ) {

		// this method is only relevant for compressed texture formats

		if ( format === GPUTextureFormat.BC1RGBAUnorm || format === GPUTextureFormat.BC1RGBAUnormSRGB ) return { byteLength: 8, width: 4, height: 4 }; // DXT1
		if ( format === GPUTextureFormat.BC2RGBAUnorm || format === GPUTextureFormat.BC2RGBAUnormSRGB ) return { byteLength: 16, width: 4, height: 4 }; // DXT3
		if ( format === GPUTextureFormat.BC3RGBAUnorm || format === GPUTextureFormat.BC3RGBAUnormSRGB ) return { byteLength: 16, width: 4, height: 4 }; // DXT5
		if ( format === GPUTextureFormat.BC4RUnorm || format === GPUTextureFormat.BC4RSNorm ) return { byteLength: 8, width: 4, height: 4 }; // RGTC1
		if ( format === GPUTextureFormat.BC5RGUnorm || format === GPUTextureFormat.BC5RGSnorm ) return { byteLength: 16, width: 4, height: 4 }; // RGTC2
		if ( format === GPUTextureFormat.BC6HRGBUFloat || format === GPUTextureFormat.BC6HRGBFloat ) return { byteLength: 16, width: 4, height: 4 }; // BPTC (float)
		if ( format === GPUTextureFormat.BC7RGBAUnorm || format === GPUTextureFormat.BC7RGBAUnormSRGB ) return { byteLength: 16, width: 4, height: 4 }; // BPTC (unorm)

		if ( format === GPUTextureFormat.ETC2RGB8Unorm || format === GPUTextureFormat.ETC2RGB8UnormSRGB ) return { byteLength: 8, width: 4, height: 4 };
		if ( format === GPUTextureFormat.ETC2RGB8A1Unorm || format === GPUTextureFormat.ETC2RGB8A1UnormSRGB ) return { byteLength: 8, width: 4, height: 4 };
		if ( format === GPUTextureFormat.ETC2RGBA8Unorm || format === GPUTextureFormat.ETC2RGBA8UnormSRGB ) return { byteLength: 16, width: 4, height: 4 };
		if ( format === GPUTextureFormat.EACR11Unorm ) return { byteLength: 8, width: 4, height: 4 };
		if ( format === GPUTextureFormat.EACR11Snorm ) return { byteLength: 8, width: 4, height: 4 };
		if ( format === GPUTextureFormat.EACRG11Unorm ) return { byteLength: 16, width: 4, height: 4 };
		if ( format === GPUTextureFormat.EACRG11Snorm ) return { byteLength: 16, width: 4, height: 4 };

		if ( format === GPUTextureFormat.ASTC4x4Unorm || format === GPUTextureFormat.ASTC4x4UnormSRGB ) return { byteLength: 16, width: 4, height: 4 };
		if ( format === GPUTextureFormat.ASTC5x4Unorm || format === GPUTextureFormat.ASTC5x4UnormSRGB ) return { byteLength: 16, width: 5, height: 4 };
		if ( format === GPUTextureFormat.ASTC5x5Unorm || format === GPUTextureFormat.ASTC5x5UnormSRGB ) return { byteLength: 16, width: 5, height: 5 };
		if ( format === GPUTextureFormat.ASTC6x5Unorm || format === GPUTextureFormat.ASTC6x5UnormSRGB ) return { byteLength: 16, width: 6, height: 5 };
		if ( format === GPUTextureFormat.ASTC6x6Unorm || format === GPUTextureFormat.ASTC6x6UnormSRGB ) return { byteLength: 16, width: 6, height: 6 };
		if ( format === GPUTextureFormat.ASTC8x5Unorm || format === GPUTextureFormat.ASTC8x5UnormSRGB ) return { byteLength: 16, width: 8, height: 5 };
		if ( format === GPUTextureFormat.ASTC8x6Unorm || format === GPUTextureFormat.ASTC8x6UnormSRGB ) return { byteLength: 16, width: 8, height: 6 };
		if ( format === GPUTextureFormat.ASTC8x8Unorm || format === GPUTextureFormat.ASTC8x8UnormSRGB ) return { byteLength: 16, width: 8, height: 8 };
		if ( format === GPUTextureFormat.ASTC10x5Unorm || format === GPUTextureFormat.ASTC10x5UnormSRGB ) return { byteLength: 16, width: 10, height: 5 };
		if ( format === GPUTextureFormat.ASTC10x6Unorm || format === GPUTextureFormat.ASTC10x6UnormSRGB ) return { byteLength: 16, width: 10, height: 6 };
		if ( format === GPUTextureFormat.ASTC10x8Unorm || format === GPUTextureFormat.ASTC10x8UnormSRGB ) return { byteLength: 16, width: 10, height: 8 };
		if ( format === GPUTextureFormat.ASTC10x10Unorm || format === GPUTextureFormat.ASTC10x10UnormSRGB ) return { byteLength: 16, width: 10, height: 10 };
		if ( format === GPUTextureFormat.ASTC12x10Unorm || format === GPUTextureFormat.ASTC12x10UnormSRGB ) return { byteLength: 16, width: 12, height: 10 };
		if ( format === GPUTextureFormat.ASTC12x12Unorm || format === GPUTextureFormat.ASTC12x12UnormSRGB ) return { byteLength: 16, width: 12, height: 12 };

	}

	_convertAddressMode( value ) {

		let addressMode = GPUAddressMode.ClampToEdge;

		if ( value === RepeatWrapping ) {

			addressMode = GPUAddressMode.Repeat;

		} else if ( value === MirroredRepeatWrapping ) {

			addressMode = GPUAddressMode.MirrorRepeat;

		}

		return addressMode;

	}

	_convertFilterMode( value ) {

		let filterMode = GPUFilterMode.Linear;

		if ( value === NearestFilter || value === NearestMipmapNearestFilter || value === NearestMipmapLinearFilter ) {

			filterMode = GPUFilterMode.Nearest;

		}

		return filterMode;

	}

	_getBytesPerTexel( format ) {

		// 8-bit formats
		if ( format === GPUTextureFormat.R8Unorm ||
			format === GPUTextureFormat.R8Snorm ||
			format === GPUTextureFormat.R8Uint ||
			format === GPUTextureFormat.R8Sint ) return 1;

		// 16-bit formats
		if ( format === GPUTextureFormat.R16Uint ||
			format === GPUTextureFormat.R16Sint ||
			format === GPUTextureFormat.R16Float ||
			format === GPUTextureFormat.RG8Unorm ||
			format === GPUTextureFormat.RG8Snorm ||
			format === GPUTextureFormat.RG8Uint ||
			format === GPUTextureFormat.RG8Sint ) return 2;

		// 32-bit formats
		if ( format === GPUTextureFormat.R32Uint ||
			format === GPUTextureFormat.R32Sint ||
			format === GPUTextureFormat.R32Float ||
			format === GPUTextureFormat.RG16Uint ||
			format === GPUTextureFormat.RG16Sint ||
			format === GPUTextureFormat.RG16Float ||
			format === GPUTextureFormat.RGBA8Unorm ||
			format === GPUTextureFormat.RGBA8UnormSRGB ||
			format === GPUTextureFormat.RGBA8Snorm ||
			format === GPUTextureFormat.RGBA8Uint ||
			format === GPUTextureFormat.RGBA8Sint ||
			format === GPUTextureFormat.BGRA8Unorm ||
			format === GPUTextureFormat.BGRA8UnormSRGB ||
			// Packed 32-bit formats
			format === GPUTextureFormat.RGB9E5UFloat ||
			format === GPUTextureFormat.RGB10A2Unorm ||
			format === GPUTextureFormat.RG11B10UFloat ||
			format === GPUTextureFormat.Depth32Float ||
			format === GPUTextureFormat.Depth24Plus ||
			format === GPUTextureFormat.Depth24PlusStencil8 ||
			format === GPUTextureFormat.Depth32FloatStencil8 ) return 4;

		// 64-bit formats
		if ( format === GPUTextureFormat.RG32Uint ||
			format === GPUTextureFormat.RG32Sint ||
			format === GPUTextureFormat.RG32Float ||
			format === GPUTextureFormat.RGBA16Uint ||
			format === GPUTextureFormat.RGBA16Sint ||
			format === GPUTextureFormat.RGBA16Float ) return 8;

		// 128-bit formats
		if ( format === GPUTextureFormat.RGBA32Uint ||
			format === GPUTextureFormat.RGBA32Sint ||
			format === GPUTextureFormat.RGBA32Float ) return 16;


	}

	_getTypedArrayType( format ) {

		if ( format === GPUTextureFormat.R8Uint ) return Uint8Array;
		if ( format === GPUTextureFormat.R8Sint ) return Int8Array;
		if ( format === GPUTextureFormat.R8Unorm ) return Uint8Array;
		if ( format === GPUTextureFormat.R8Snorm ) return Int8Array;
		if ( format === GPUTextureFormat.RG8Uint ) return Uint8Array;
		if ( format === GPUTextureFormat.RG8Sint ) return Int8Array;
		if ( format === GPUTextureFormat.RG8Unorm ) return Uint8Array;
		if ( format === GPUTextureFormat.RG8Snorm ) return Int8Array;
		if ( format === GPUTextureFormat.RGBA8Uint ) return Uint8Array;
		if ( format === GPUTextureFormat.RGBA8Sint ) return Int8Array;
		if ( format === GPUTextureFormat.RGBA8Unorm ) return Uint8Array;
		if ( format === GPUTextureFormat.RGBA8Snorm ) return Int8Array;


		if ( format === GPUTextureFormat.R16Uint ) return Uint16Array;
		if ( format === GPUTextureFormat.R16Sint ) return Int16Array;
		if ( format === GPUTextureFormat.RG16Uint ) return Uint16Array;
		if ( format === GPUTextureFormat.RG16Sint ) return Int16Array;
		if ( format === GPUTextureFormat.RGBA16Uint ) return Uint16Array;
		if ( format === GPUTextureFormat.RGBA16Sint ) return Int16Array;
		if ( format === GPUTextureFormat.R16Float ) return Uint16Array;
		if ( format === GPUTextureFormat.RG16Float ) return Uint16Array;
		if ( format === GPUTextureFormat.RGBA16Float ) return Uint16Array;


		if ( format === GPUTextureFormat.R32Uint ) return Uint32Array;
		if ( format === GPUTextureFormat.R32Sint ) return Int32Array;
		if ( format === GPUTextureFormat.R32Float ) return Float32Array;
		if ( format === GPUTextureFormat.RG32Uint ) return Uint32Array;
		if ( format === GPUTextureFormat.RG32Sint ) return Int32Array;
		if ( format === GPUTextureFormat.RG32Float ) return Float32Array;
		if ( format === GPUTextureFormat.RGBA32Uint ) return Uint32Array;
		if ( format === GPUTextureFormat.RGBA32Sint ) return Int32Array;
		if ( format === GPUTextureFormat.RGBA32Float ) return Float32Array;

		if ( format === GPUTextureFormat.BGRA8Unorm ) return Uint8Array;
		if ( format === GPUTextureFormat.BGRA8UnormSRGB ) return Uint8Array;
		if ( format === GPUTextureFormat.RGB10A2Unorm ) return Uint32Array;
		if ( format === GPUTextureFormat.RGB9E5UFloat ) return Uint32Array;
		if ( format === GPUTextureFormat.RG11B10UFloat ) return Uint32Array;

		if ( format === GPUTextureFormat.Depth32Float ) return Float32Array;
		if ( format === GPUTextureFormat.Depth24Plus ) return Uint32Array;
		if ( format === GPUTextureFormat.Depth24PlusStencil8 ) return Uint32Array;
		if ( format === GPUTextureFormat.Depth32FloatStencil8 ) return Float32Array;

	}

	_getDimension( texture ) {

		let dimension;

		if ( texture.isData3DTexture ) {

			dimension = GPUTextureDimension.ThreeD;

		} else {

			dimension = GPUTextureDimension.TwoD;

		}

		return dimension;

	}

}

function getFormat( texture, device = null ) {

	const format = texture.format;
	const type = texture.type;
	const colorSpace = texture.colorSpace;

	let formatGPU;

	if ( texture.isCompressedTexture === true || texture.isCompressedArrayTexture === true ) {

		switch ( format ) {

			case RGBA_S3TC_DXT1_Format:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.BC1RGBAUnormSRGB : GPUTextureFormat.BC1RGBAUnorm;
				break;

			case RGBA_S3TC_DXT3_Format:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.BC2RGBAUnormSRGB : GPUTextureFormat.BC2RGBAUnorm;
				break;

			case RGBA_S3TC_DXT5_Format:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.BC3RGBAUnormSRGB : GPUTextureFormat.BC3RGBAUnorm;
				break;

			case RGB_ETC2_Format:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ETC2RGB8UnormSRGB : GPUTextureFormat.ETC2RGB8Unorm;
				break;

			case RGBA_ETC2_EAC_Format:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ETC2RGBA8UnormSRGB : GPUTextureFormat.ETC2RGBA8Unorm;
				break;

			case RGBA_ASTC_4x4_Format:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC4x4UnormSRGB : GPUTextureFormat.ASTC4x4Unorm;
				break;

			case RGBA_ASTC_5x4_Format:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC5x4UnormSRGB : GPUTextureFormat.ASTC5x4Unorm;
				break;

			case RGBA_ASTC_5x5_Format:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC5x5UnormSRGB : GPUTextureFormat.ASTC5x5Unorm;
				break;

			case RGBA_ASTC_6x5_Format:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC6x5UnormSRGB : GPUTextureFormat.ASTC6x5Unorm;
				break;

			case RGBA_ASTC_6x6_Format:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC6x6UnormSRGB : GPUTextureFormat.ASTC6x6Unorm;
				break;

			case RGBA_ASTC_8x5_Format:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC8x5UnormSRGB : GPUTextureFormat.ASTC8x5Unorm;
				break;

			case RGBA_ASTC_8x6_Format:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC8x6UnormSRGB : GPUTextureFormat.ASTC8x6Unorm;
				break;

			case RGBA_ASTC_8x8_Format:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC8x8UnormSRGB : GPUTextureFormat.ASTC8x8Unorm;
				break;

			case RGBA_ASTC_10x5_Format:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC10x5UnormSRGB : GPUTextureFormat.ASTC10x5Unorm;
				break;

			case RGBA_ASTC_10x6_Format:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC10x6UnormSRGB : GPUTextureFormat.ASTC10x6Unorm;
				break;

			case RGBA_ASTC_10x8_Format:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC10x8UnormSRGB : GPUTextureFormat.ASTC10x8Unorm;
				break;

			case RGBA_ASTC_10x10_Format:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC10x10UnormSRGB : GPUTextureFormat.ASTC10x10Unorm;
				break;

			case RGBA_ASTC_12x10_Format:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC12x10UnormSRGB : GPUTextureFormat.ASTC12x10Unorm;
				break;

			case RGBA_ASTC_12x12_Format:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC12x12UnormSRGB : GPUTextureFormat.ASTC12x12Unorm;
				break;

			case RGBAFormat:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.RGBA8UnormSRGB : GPUTextureFormat.RGBA8Unorm;
				break;

			default:
				console.error( 'WebGPURenderer: Unsupported texture format.', format );

		}

	} else {

		switch ( format ) {

			case RGBAFormat:

				switch ( type ) {

					case ByteType:
						formatGPU = GPUTextureFormat.RGBA8Snorm;
						break;

					case ShortType:
						formatGPU = GPUTextureFormat.RGBA16Sint;
						break;

					case UnsignedShortType:
						formatGPU = GPUTextureFormat.RGBA16Uint;
						break;
					case UnsignedIntType:
						formatGPU = GPUTextureFormat.RGBA32Uint;
						break;

					case IntType:
						formatGPU = GPUTextureFormat.RGBA32Sint;
						break;

					case UnsignedByteType:
						formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.RGBA8UnormSRGB : GPUTextureFormat.RGBA8Unorm;
						break;

					case HalfFloatType:
						formatGPU = GPUTextureFormat.RGBA16Float;
						break;

					case FloatType:
						formatGPU = GPUTextureFormat.RGBA32Float;
						break;

					default:
						console.error( 'WebGPURenderer: Unsupported texture type with RGBAFormat.', type );

				}

				break;

			case RGBFormat:

				switch ( type ) {

					case UnsignedInt5999Type:
						formatGPU = GPUTextureFormat.RGB9E5UFloat;
						break;

					default:
						console.error( 'WebGPURenderer: Unsupported texture type with RGBFormat.', type );

				}

				break;

			case RedFormat:

				switch ( type ) {

					case ByteType:
						formatGPU = GPUTextureFormat.R8Snorm;
						break;

					case ShortType:
						formatGPU = GPUTextureFormat.R16Sint;
						break;

					case UnsignedShortType:
						formatGPU = GPUTextureFormat.R16Uint;
						break;

					case UnsignedIntType:
						formatGPU = GPUTextureFormat.R32Uint;
						break;

					case IntType:
						formatGPU = GPUTextureFormat.R32Sint;
						break;

					case UnsignedByteType:
						formatGPU = GPUTextureFormat.R8Unorm;
						break;

					case HalfFloatType:
						formatGPU = GPUTextureFormat.R16Float;
						break;

					case FloatType:
						formatGPU = GPUTextureFormat.R32Float;
						break;

					default:
						console.error( 'WebGPURenderer: Unsupported texture type with RedFormat.', type );

				}

				break;

			case RGFormat:

				switch ( type ) {

					case ByteType:
						formatGPU = GPUTextureFormat.RG8Snorm;
						break;

					case ShortType:
						formatGPU = GPUTextureFormat.RG16Sint;
						break;

					case UnsignedShortType:
						formatGPU = GPUTextureFormat.RG16Uint;
						break;

					case UnsignedIntType:
						formatGPU = GPUTextureFormat.RG32Uint;
						break;

					case IntType:
						formatGPU = GPUTextureFormat.RG32Sint;
						break;

					case UnsignedByteType:
						formatGPU = GPUTextureFormat.RG8Unorm;
						break;

					case HalfFloatType:
						formatGPU = GPUTextureFormat.RG16Float;
						break;

					case FloatType:
						formatGPU = GPUTextureFormat.RG32Float;
						break;

					default:
						console.error( 'WebGPURenderer: Unsupported texture type with RGFormat.', type );

				}

				break;

			case DepthFormat:

				switch ( type ) {

					case UnsignedShortType:
						formatGPU = GPUTextureFormat.Depth16Unorm;
						break;

					case UnsignedIntType:
						formatGPU = GPUTextureFormat.Depth24Plus;
						break;

					case FloatType:
						formatGPU = GPUTextureFormat.Depth32Float;
						break;

					default:
						console.error( 'WebGPURenderer: Unsupported texture type with DepthFormat.', type );

				}

				break;

			case DepthStencilFormat:

				switch ( type ) {

					case UnsignedInt248Type:
						formatGPU = GPUTextureFormat.Depth24PlusStencil8;
						break;

					case FloatType:

						if ( device && device.features.has( GPUFeatureName.Depth32FloatStencil8 ) === false ) {

							console.error( 'WebGPURenderer: Depth textures with DepthStencilFormat + FloatType can only be used with the "depth32float-stencil8" GPU feature.' );

						}

						formatGPU = GPUTextureFormat.Depth32FloatStencil8;

						break;

					default:
						console.error( 'WebGPURenderer: Unsupported texture type with DepthStencilFormat.', type );

				}

				break;

			case RedIntegerFormat:

				switch ( type ) {

					case IntType:
						formatGPU = GPUTextureFormat.R32Sint;
						break;

					case UnsignedIntType:
						formatGPU = GPUTextureFormat.R32Uint;
						break;

					default:
						console.error( 'WebGPURenderer: Unsupported texture type with RedIntegerFormat.', type );

				}

				break;

			case RGIntegerFormat:

				switch ( type ) {

					case IntType:
						formatGPU = GPUTextureFormat.RG32Sint;
						break;

					case UnsignedIntType:
						formatGPU = GPUTextureFormat.RG32Uint;
						break;

					default:
						console.error( 'WebGPURenderer: Unsupported texture type with RGIntegerFormat.', type );

				}

				break;

			case RGBAIntegerFormat:

				switch ( type ) {

					case IntType:
						formatGPU = GPUTextureFormat.RGBA32Sint;
						break;

					case UnsignedIntType:
						formatGPU = GPUTextureFormat.RGBA32Uint;
						break;

					default:
						console.error( 'WebGPURenderer: Unsupported texture type with RGBAIntegerFormat.', type );

				}

				break;

			default:
				console.error( 'WebGPURenderer: Unsupported texture format.', format );

		}

	}

	return formatGPU;

}

const declarationRegexp = /^[fn]*\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)\s*[\-\>]*\s*([a-z_0-9]+(?:<[\s\S]+?>)?)/i;
const propertiesRegexp = /([a-z_0-9]+)\s*:\s*([a-z_0-9]+(?:<[\s\S]+?>)?)/ig;

const wgslTypeLib$1 = {
	'f32': 'float',
	'i32': 'int',
	'u32': 'uint',
	'bool': 'bool',

	'vec2<f32>': 'vec2',
 	'vec2<i32>': 'ivec2',
 	'vec2<u32>': 'uvec2',
 	'vec2<bool>': 'bvec2',

	'vec2f': 'vec2',
	'vec2i': 'ivec2',
	'vec2u': 'uvec2',
	'vec2b': 'bvec2',

	'vec3<f32>': 'vec3',
	'vec3<i32>': 'ivec3',
	'vec3<u32>': 'uvec3',
	'vec3<bool>': 'bvec3',

	'vec3f': 'vec3',
	'vec3i': 'ivec3',
	'vec3u': 'uvec3',
	'vec3b': 'bvec3',

	'vec4<f32>': 'vec4',
	'vec4<i32>': 'ivec4',
	'vec4<u32>': 'uvec4',
	'vec4<bool>': 'bvec4',

	'vec4f': 'vec4',
	'vec4i': 'ivec4',
	'vec4u': 'uvec4',
	'vec4b': 'bvec4',

	'mat2x2<f32>': 'mat2',
	'mat2x2f': 'mat2',

	'mat3x3<f32>': 'mat3',
	'mat3x3f': 'mat3',

	'mat4x4<f32>': 'mat4',
	'mat4x4f': 'mat4',

	'sampler': 'sampler',

	'texture_1d': 'texture',

	'texture_2d': 'texture',
	'texture_2d_array': 'texture',
	'texture_multisampled_2d': 'cubeTexture',

	'texture_depth_2d': 'depthTexture',

	'texture_3d': 'texture3D',

	'texture_cube': 'cubeTexture',
	'texture_cube_array': 'cubeTexture',

	'texture_storage_1d': 'storageTexture',
	'texture_storage_2d': 'storageTexture',
	'texture_storage_2d_array': 'storageTexture',
	'texture_storage_3d': 'storageTexture'

};

const parse = ( source ) => {

	source = source.trim();

	const declaration = source.match( declarationRegexp );

	if ( declaration !== null && declaration.length === 4 ) {

		const inputsCode = declaration[ 2 ];
		const propsMatches = [];
		let match = null;

		while ( ( match = propertiesRegexp.exec( inputsCode ) ) !== null ) {

			propsMatches.push( { name: match[ 1 ], type: match[ 2 ] } );

		}

		// Process matches to correctly pair names and types
		const inputs = [];
		for ( let i = 0; i < propsMatches.length; i ++ ) {

			const { name, type } = propsMatches[ i ];

			let resolvedType = type;

			if ( resolvedType.startsWith( 'ptr' ) ) {

				resolvedType = 'pointer';

			} else {

				if ( resolvedType.startsWith( 'texture' ) ) {

					resolvedType = type.split( '<' )[ 0 ];

				}

				resolvedType = wgslTypeLib$1[ resolvedType ];

			}

			inputs.push( new NodeFunctionInput( resolvedType, name ) );

		}

		const blockCode = source.substring( declaration[ 0 ].length );
		const outputType = declaration[ 3 ] || 'void';

		const name = declaration[ 1 ] !== undefined ? declaration[ 1 ] : '';
		const type = wgslTypeLib$1[ outputType ] || outputType;

		return {
			type,
			inputs,
			name,
			inputsCode,
			blockCode,
			outputType
		};

	} else {

		throw new Error( 'FunctionNode: Function is not a WGSL code.' );

	}

};

class WGSLNodeFunction extends NodeFunction {

	constructor( source ) {

		const { type, inputs, name, inputsCode, blockCode, outputType } = parse( source );

		super( type, inputs, name );

		this.inputsCode = inputsCode;
		this.blockCode = blockCode;
		this.outputType = outputType;

	}

	getCode( name = this.name ) {

		const outputType = this.outputType !== 'void' ? '-> ' + this.outputType : '';

		return `fn ${ name } ( ${ this.inputsCode.trim() } ) ${ outputType }` + this.blockCode;

	}

}

class WGSLNodeParser extends NodeParser {

	parseFunction( source ) {

		return new WGSLNodeFunction( source );

	}

}

// GPUShaderStage is not defined in browsers not supporting WebGPU
const GPUShaderStage = ( typeof self !== 'undefined' ) ? self.GPUShaderStage : { VERTEX: 1, FRAGMENT: 2, COMPUTE: 4 };

const accessNames = {
	[ NodeAccess.READ_ONLY ]: 'read',
	[ NodeAccess.WRITE_ONLY ]: 'write',
	[ NodeAccess.READ_WRITE ]: 'read_write'
};

const wrapNames = {
	[ RepeatWrapping ]: 'repeat',
	[ ClampToEdgeWrapping ]: 'clamp',
	[ MirroredRepeatWrapping ]: 'mirror'
};

const gpuShaderStageLib = {
	'vertex': GPUShaderStage ? GPUShaderStage.VERTEX : 1,
	'fragment': GPUShaderStage ? GPUShaderStage.FRAGMENT : 2,
	'compute': GPUShaderStage ? GPUShaderStage.COMPUTE : 4
};

const supports = {
	instance: true,
	swizzleAssign: false,
	storageBuffer: true
};

const wgslFnOpLib = {
	'^^': 'tsl_xor'
};

const wgslTypeLib = {
	float: 'f32',
	int: 'i32',
	uint: 'u32',
	bool: 'bool',
	color: 'vec3<f32>',

	vec2: 'vec2<f32>',
	ivec2: 'vec2<i32>',
	uvec2: 'vec2<u32>',
	bvec2: 'vec2<bool>',

	vec3: 'vec3<f32>',
	ivec3: 'vec3<i32>',
	uvec3: 'vec3<u32>',
	bvec3: 'vec3<bool>',

	vec4: 'vec4<f32>',
	ivec4: 'vec4<i32>',
	uvec4: 'vec4<u32>',
	bvec4: 'vec4<bool>',

	mat2: 'mat2x2<f32>',
	mat3: 'mat3x3<f32>',
	mat4: 'mat4x4<f32>'
};

const wgslCodeCache = {};

const wgslPolyfill = {
	tsl_xor: new CodeNode( 'fn tsl_xor( a : bool, b : bool ) -> bool { return ( a || b ) && !( a && b ); }' ),
	mod_float: new CodeNode( 'fn tsl_mod_float( x : f32, y : f32 ) -> f32 { return x - y * floor( x / y ); }' ),
	mod_vec2: new CodeNode( 'fn tsl_mod_vec2( x : vec2f, y : vec2f ) -> vec2f { return x - y * floor( x / y ); }' ),
	mod_vec3: new CodeNode( 'fn tsl_mod_vec3( x : vec3f, y : vec3f ) -> vec3f { return x - y * floor( x / y ); }' ),
	mod_vec4: new CodeNode( 'fn tsl_mod_vec4( x : vec4f, y : vec4f ) -> vec4f { return x - y * floor( x / y ); }' ),
	equals_bool: new CodeNode( 'fn tsl_equals_bool( a : bool, b : bool ) -> bool { return a == b; }' ),
	equals_bvec2: new CodeNode( 'fn tsl_equals_bvec2( a : vec2f, b : vec2f ) -> vec2<bool> { return vec2<bool>( a.x == b.x, a.y == b.y ); }' ),
	equals_bvec3: new CodeNode( 'fn tsl_equals_bvec3( a : vec3f, b : vec3f ) -> vec3<bool> { return vec3<bool>( a.x == b.x, a.y == b.y, a.z == b.z ); }' ),
	equals_bvec4: new CodeNode( 'fn tsl_equals_bvec4( a : vec4f, b : vec4f ) -> vec4<bool> { return vec4<bool>( a.x == b.x, a.y == b.y, a.z == b.z, a.w == b.w ); }' ),
	repeatWrapping_float: new CodeNode( 'fn tsl_repeatWrapping_float( coord: f32 ) -> f32 { return fract( coord ); }' ),
	mirrorWrapping_float: new CodeNode( 'fn tsl_mirrorWrapping_float( coord: f32 ) -> f32 { let mirrored = fract( coord * 0.5 ) * 2.0; return 1.0 - abs( 1.0 - mirrored ); }' ),
	clampWrapping_float: new CodeNode( 'fn tsl_clampWrapping_float( coord: f32 ) -> f32 { return clamp( coord, 0.0, 1.0 ); }' ),
	biquadraticTexture: new CodeNode( /* wgsl */`
fn tsl_biquadraticTexture( map : texture_2d<f32>, coord : vec2f, iRes : vec2u, level : u32 ) -> vec4f {

	let res = vec2f( iRes );

	let uvScaled = coord * res;
	let uvWrapping = ( ( uvScaled % res ) + res ) % res;

	// https://www.shadertoy.com/view/WtyXRy

	let uv = uvWrapping - 0.5;
	let iuv = floor( uv );
	let f = fract( uv );

	let rg1 = textureLoad( map, vec2u( iuv + vec2( 0.5, 0.5 ) ) % iRes, level );
	let rg2 = textureLoad( map, vec2u( iuv + vec2( 1.5, 0.5 ) ) % iRes, level );
	let rg3 = textureLoad( map, vec2u( iuv + vec2( 0.5, 1.5 ) ) % iRes, level );
	let rg4 = textureLoad( map, vec2u( iuv + vec2( 1.5, 1.5 ) ) % iRes, level );

	return mix( mix( rg1, rg2, f.x ), mix( rg3, rg4, f.x ), f.y );

}
` )
};

const wgslMethods = {
	dFdx: 'dpdx',
	dFdy: '- dpdy',
	mod_float: 'tsl_mod_float',
	mod_vec2: 'tsl_mod_vec2',
	mod_vec3: 'tsl_mod_vec3',
	mod_vec4: 'tsl_mod_vec4',
	equals_bool: 'tsl_equals_bool',
	equals_bvec2: 'tsl_equals_bvec2',
	equals_bvec3: 'tsl_equals_bvec3',
	equals_bvec4: 'tsl_equals_bvec4',
	inversesqrt: 'inverseSqrt',
	bitcast: 'bitcast<f32>'
};

// WebGPU issue: does not support pow() with negative base on Windows

if ( typeof navigator !== 'undefined' && /Windows/g.test( navigator.userAgent ) ) {

	wgslPolyfill.pow_float = new CodeNode( 'fn tsl_pow_float( a : f32, b : f32 ) -> f32 { return select( -pow( -a, b ), pow( a, b ), a > 0.0 ); }' );
	wgslPolyfill.pow_vec2 = new CodeNode( 'fn tsl_pow_vec2( a : vec2f, b : vec2f ) -> vec2f { return vec2f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ) ); }', [ wgslPolyfill.pow_float ] );
	wgslPolyfill.pow_vec3 = new CodeNode( 'fn tsl_pow_vec3( a : vec3f, b : vec3f ) -> vec3f { return vec3f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ) ); }', [ wgslPolyfill.pow_float ] );
	wgslPolyfill.pow_vec4 = new CodeNode( 'fn tsl_pow_vec4( a : vec4f, b : vec4f ) -> vec4f { return vec4f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ), tsl_pow_float( a.w, b.w ) ); }', [ wgslPolyfill.pow_float ] );

	wgslMethods.pow_float = 'tsl_pow_float';
	wgslMethods.pow_vec2 = 'tsl_pow_vec2';
	wgslMethods.pow_vec3 = 'tsl_pow_vec3';
	wgslMethods.pow_vec4 = 'tsl_pow_vec4';

}

//

let diagnostics = '';

if ( ( typeof navigator !== 'undefined' && /Firefox|Deno/g.test( navigator.userAgent ) ) !== true ) {

	diagnostics += 'diagnostic( off, derivative_uniformity );\n';

}

//

class WGSLNodeBuilder extends NodeBuilder {

	constructor( object, renderer ) {

		super( object, renderer, new WGSLNodeParser() );

		this.uniformGroups = {};

		this.builtins = {};

		this.directives = {};

		this.scopedArrays = new Map();

	}

	needsToWorkingColorSpace( texture ) {

		return texture.isVideoTexture === true && texture.colorSpace !== NoColorSpace;

	}

	_generateTextureSample( texture, textureProperty, uvSnippet, depthSnippet, shaderStage = this.shaderStage ) {

		if ( shaderStage === 'fragment' ) {

			if ( depthSnippet ) {

				return `textureSample( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ depthSnippet } )`;

			} else {

				return `textureSample( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet } )`;

			}

		} else if ( this.isFilteredTexture( texture ) ) {

			return this.generateFilteredTexture( texture, textureProperty, uvSnippet );

		} else {

			return this.generateTextureLod( texture, textureProperty, uvSnippet, depthSnippet, '0' );

		}

	}

	_generateVideoSample( textureProperty, uvSnippet, shaderStage = this.shaderStage ) {

		if ( shaderStage === 'fragment' ) {

			return `textureSampleBaseClampToEdge( ${ textureProperty }, ${ textureProperty }_sampler, vec2<f32>( ${ uvSnippet }.x, 1.0 - ${ uvSnippet }.y ) )`;

		} else {

			console.error( `WebGPURenderer: THREE.VideoTexture does not support ${ shaderStage } shader.` );

		}

	}

	_generateTextureSampleLevel( texture, textureProperty, uvSnippet, levelSnippet, depthSnippet, shaderStage = this.shaderStage ) {

		if ( shaderStage === 'fragment' && this.isUnfilterable( texture ) === false ) {

			return `textureSampleLevel( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ levelSnippet } )`;

		} else if ( this.isFilteredTexture( texture ) ) {

			return this.generateFilteredTexture( texture, textureProperty, uvSnippet, levelSnippet );

		} else {

			return this.generateTextureLod( texture, textureProperty, uvSnippet, depthSnippet, levelSnippet );

		}

	}

	generateWrapFunction( texture ) {

		const functionName = `tsl_coord_${ wrapNames[ texture.wrapS ] }S_${ wrapNames[ texture.wrapT ] }T`;

		let nodeCode = wgslCodeCache[ functionName ];

		if ( nodeCode === undefined ) {

			const includes = [];

			let code = `fn ${ functionName }( coord : vec2f ) -> vec2f {\n\n\treturn vec2f(\n`;

			const addWrapSnippet = ( wrap, axis ) => {

				if ( wrap === RepeatWrapping ) {

					includes.push( wgslPolyfill.repeatWrapping_float );

					code += `\t\ttsl_repeatWrapping_float( coord.${ axis } )`;

				} else if ( wrap === ClampToEdgeWrapping ) {

					includes.push( wgslPolyfill.clampWrapping_float );

					code += `\t\ttsl_clampWrapping_float( coord.${ axis } )`;

				} else if ( wrap === MirroredRepeatWrapping ) {

					includes.push( wgslPolyfill.mirrorWrapping_float );

					code += `\t\ttsl_mirrorWrapping_float( coord.${ axis } )`;

				} else {

					code += `\t\tcoord.${ axis }`;

					console.warn( `WebGPURenderer: Unsupported texture wrap type "${ wrap }" for vertex shader.` );

				}

			};

			addWrapSnippet( texture.wrapS, 'x' );

			code += ',\n';

			addWrapSnippet( texture.wrapT, 'y' );

			code += '\n\t);\n\n}\n';

			wgslCodeCache[ functionName ] = nodeCode = new CodeNode( code, includes );

		}

		nodeCode.build( this );

		return functionName;

	}

	generateTextureDimension( texture, textureProperty, levelSnippet ) {

		const textureData = this.getDataFromNode( texture, this.shaderStage, this.globalCache );

		if ( textureData.dimensionsSnippet === undefined ) textureData.dimensionsSnippet = {};

		let textureDimensionNode = textureData.dimensionsSnippet[ levelSnippet ];

		if ( textureData.dimensionsSnippet[ levelSnippet ] === undefined ) {

			let textureDimensionsParams;

			if ( texture.isMultisampleRenderTargetTexture === true ) {

				textureDimensionsParams = textureProperty;

			} else {

				textureDimensionsParams = `${ textureProperty }, u32( ${ levelSnippet } )`;

			}

			textureDimensionNode = new VarNode( new ExpressionNode( `textureDimensions( ${ textureDimensionsParams } )`, 'uvec2' ) );

			textureData.dimensionsSnippet[ levelSnippet ] = textureDimensionNode;

		}

		return textureDimensionNode.build( this );

	}

	generateFilteredTexture( texture, textureProperty, uvSnippet, levelSnippet = '0u' ) {

		this._include( 'biquadraticTexture' );

		const wrapFunction = this.generateWrapFunction( texture );
		const textureDimension = this.generateTextureDimension( texture, textureProperty, levelSnippet );

		return `tsl_biquadraticTexture( ${ textureProperty }, ${ wrapFunction }( ${ uvSnippet } ), ${ textureDimension }, u32( ${ levelSnippet } ) )`;

	}

	generateTextureLod( texture, textureProperty, uvSnippet, depthSnippet, levelSnippet = '0u' ) {

		const wrapFunction = this.generateWrapFunction( texture );
		const textureDimension = this.generateTextureDimension( texture, textureProperty, levelSnippet );

		const coordSnippet = `vec2u( ${ wrapFunction }( ${ uvSnippet } ) * vec2f( ${ textureDimension } ) )`;

		return this.generateTextureLoad( texture, textureProperty, coordSnippet, depthSnippet, levelSnippet );

	}

	generateTextureLoad( texture, textureProperty, uvIndexSnippet, depthSnippet, levelSnippet = '0u' ) {

		if ( texture.isVideoTexture === true || texture.isStorageTexture === true ) {

			return `textureLoad( ${ textureProperty }, ${ uvIndexSnippet } )`;

		} else if ( depthSnippet ) {

			return `textureLoad( ${ textureProperty }, ${ uvIndexSnippet }, ${ depthSnippet }, u32( ${ levelSnippet } ) )`;

		} else {

			return `textureLoad( ${ textureProperty }, ${ uvIndexSnippet }, u32( ${ levelSnippet } ) )`;

		}

	}

	generateTextureStore( texture, textureProperty, uvIndexSnippet, valueSnippet ) {

		return `textureStore( ${ textureProperty }, ${ uvIndexSnippet }, ${ valueSnippet } )`;

	}

	isSampleCompare( texture ) {

		return texture.isDepthTexture === true && texture.compareFunction !== null;

	}

	isUnfilterable( texture ) {

		return this.getComponentTypeFromTexture( texture ) !== 'float' ||
			( ! this.isAvailable( 'float32Filterable' ) && texture.isDataTexture === true && texture.type === FloatType ) ||
			( this.isSampleCompare( texture ) === false && texture.minFilter === NearestFilter && texture.magFilter === NearestFilter ) ||
			texture.isMultisampleRenderTargetTexture === true;

	}

	generateTexture( texture, textureProperty, uvSnippet, depthSnippet, shaderStage = this.shaderStage ) {

		let snippet = null;

		if ( texture.isVideoTexture === true ) {

			snippet = this._generateVideoSample( textureProperty, uvSnippet, shaderStage );

		} else if ( this.isUnfilterable( texture ) ) {

			snippet = this.generateTextureLod( texture, textureProperty, uvSnippet, depthSnippet, '0', shaderStage );

		} else {

			snippet = this._generateTextureSample( texture, textureProperty, uvSnippet, depthSnippet, shaderStage );

		}

		return snippet;

	}

	generateTextureGrad( texture, textureProperty, uvSnippet, gradSnippet, depthSnippet, shaderStage = this.shaderStage ) {

		if ( shaderStage === 'fragment' ) {

			// TODO handle i32 or u32 --> uvSnippet, array_index: A, ddx, ddy
			return `textureSampleGrad( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet },  ${ gradSnippet[ 0 ] }, ${ gradSnippet[ 1 ] } )`;

		} else {

			console.error( `WebGPURenderer: THREE.TextureNode.gradient() does not support ${ shaderStage } shader.` );

		}

	}

	generateTextureCompare( texture, textureProperty, uvSnippet, compareSnippet, depthSnippet, shaderStage = this.shaderStage ) {

		if ( shaderStage === 'fragment' ) {

			return `textureSampleCompare( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ compareSnippet } )`;

		} else {

			console.error( `WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${ shaderStage } shader.` );

		}

	}

	generateTextureLevel( texture, textureProperty, uvSnippet, levelSnippet, depthSnippet, shaderStage = this.shaderStage ) {

		let snippet = null;

		if ( texture.isVideoTexture === true ) {

			snippet = this._generateVideoSample( textureProperty, uvSnippet, shaderStage );

		} else {

			snippet = this._generateTextureSampleLevel( texture, textureProperty, uvSnippet, levelSnippet, depthSnippet, shaderStage );

		}

		return snippet;

	}

	generateTextureBias( texture, textureProperty, uvSnippet, biasSnippet, depthSnippet, shaderStage = this.shaderStage ) {

		if ( shaderStage === 'fragment' ) {

			return `textureSampleBias( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ biasSnippet } )`;

		} else {

			console.error( `WebGPURenderer: THREE.TextureNode.biasNode does not support ${ shaderStage } shader.` );

		}

	}

	getPropertyName( node, shaderStage = this.shaderStage ) {

		if ( node.isNodeVarying === true && node.needsInterpolation === true ) {

			if ( shaderStage === 'vertex' ) {

				return `varyings.${ node.name }`;

			}

		} else if ( node.isNodeUniform === true ) {

			const name = node.name;
			const type = node.type;

			if ( type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D' ) {

				return name;

			} else if ( type === 'buffer' || type === 'storageBuffer' || type === 'indirectStorageBuffer' ) {

				return `NodeBuffer_${ node.id }.${name}`;

			} else {

				return node.groupNode.name + '.' + name;

			}

		}

		return super.getPropertyName( node );

	}

	getOutputStructName() {

		return 'output';

	}

	_getUniformGroupCount( shaderStage ) {

		return Object.keys( this.uniforms[ shaderStage ] ).length;

	}

	getFunctionOperator( op ) {

		const fnOp = wgslFnOpLib[ op ];

		if ( fnOp !== undefined ) {

			this._include( fnOp );

			return fnOp;

		}

		return null;

	}

	getNodeAccess( node, shaderStage ) {

		if ( shaderStage !== 'compute' )
			return NodeAccess.READ_ONLY;

		return node.access;

	}

	getStorageAccess( node, shaderStage ) {

		return accessNames[ this.getNodeAccess( node, shaderStage ) ];

	}

	getUniformFromNode( node, type, shaderStage, name = null ) {

		const uniformNode = super.getUniformFromNode( node, type, shaderStage, name );
		const nodeData = this.getDataFromNode( node, shaderStage, this.globalCache );

		if ( nodeData.uniformGPU === undefined ) {

			let uniformGPU;

			const group = node.groupNode;
			const groupName = group.name;

			const bindings = this.getBindGroupArray( groupName, shaderStage );

			if ( type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D' ) {

				let texture = null;

				const access = this.getNodeAccess( node, shaderStage );

				if ( type === 'texture' || type === 'storageTexture' ) {

					texture = new NodeSampledTexture( uniformNode.name, uniformNode.node, group, access );

				} else if ( type === 'cubeTexture' ) {

					texture = new NodeSampledCubeTexture( uniformNode.name, uniformNode.node, group, access );

				} else if ( type === 'texture3D' ) {

					texture = new NodeSampledTexture3D( uniformNode.name, uniformNode.node, group, access );

				}

				texture.store = node.isStorageTextureNode === true;
				texture.setVisibility( gpuShaderStageLib[ shaderStage ] );

				if ( shaderStage === 'fragment' && this.isUnfilterable( node.value ) === false && texture.store === false ) {

					const sampler = new NodeSampler( `${uniformNode.name}_sampler`, uniformNode.node, group );
					sampler.setVisibility( gpuShaderStageLib[ shaderStage ] );

					bindings.push( sampler, texture );

					uniformGPU = [ sampler, texture ];

				} else {

					bindings.push( texture );

					uniformGPU = [ texture ];

				}

			} else if ( type === 'buffer' || type === 'storageBuffer' || type === 'indirectStorageBuffer' ) {

				const bufferClass = type === 'buffer' ? NodeUniformBuffer : NodeStorageBuffer;

				const buffer = new bufferClass( node, group );
				buffer.setVisibility( gpuShaderStageLib[ shaderStage ] );

				bindings.push( buffer );

				uniformGPU = buffer;

			} else {

				const uniformsStage = this.uniformGroups[ shaderStage ] || ( this.uniformGroups[ shaderStage ] = {} );

				let uniformsGroup = uniformsStage[ groupName ];

				if ( uniformsGroup === undefined ) {

					uniformsGroup = new NodeUniformsGroup( groupName, group );
					uniformsGroup.setVisibility( gpuShaderStageLib[ shaderStage ] );

					uniformsStage[ groupName ] = uniformsGroup;

					bindings.push( uniformsGroup );

				}

				uniformGPU = this.getNodeUniform( uniformNode, type );

				uniformsGroup.addUniform( uniformGPU );

			}

			nodeData.uniformGPU = uniformGPU;

		}

		return uniformNode;

	}

	getBuiltin( name, property, type, shaderStage = this.shaderStage ) {

		const map = this.builtins[ shaderStage ] || ( this.builtins[ shaderStage ] = new Map() );

		if ( map.has( name ) === false ) {

			map.set( name, {
				name,
				property,
				type
			} );

		}

		return property;

	}

	hasBuiltin( name, shaderStage = this.shaderStage ) {

		return ( this.builtins[ shaderStage ] !== undefined && this.builtins[ shaderStage ].has( name ) );

	}

	getVertexIndex() {

		if ( this.shaderStage === 'vertex' ) {

			return this.getBuiltin( 'vertex_index', 'vertexIndex', 'u32', 'attribute' );

		}

		return 'vertexIndex';

	}

	buildFunctionCode( shaderNode ) {

		const layout = shaderNode.layout;
		const flowData = this.flowShaderNode( shaderNode );

		const parameters = [];

		for ( const input of layout.inputs ) {

			parameters.push( input.name + ' : ' + this.getType( input.type ) );

		}

		//

		let code = `fn ${ layout.name }( ${ parameters.join( ', ' ) } ) -> ${ this.getType( layout.type ) } {
${ flowData.vars }
${ flowData.code }
`;

		if ( flowData.result ) {

			code += `\treturn ${ flowData.result };\n`;

		}

		code += '\n}\n';

		//

		return code;

	}

	getInstanceIndex() {

		if ( this.shaderStage === 'vertex' ) {

			return this.getBuiltin( 'instance_index', 'instanceIndex', 'u32', 'attribute' );

		}

		return 'instanceIndex';

	}

	getInvocationLocalIndex() {

		return this.getBuiltin( 'local_invocation_index', 'invocationLocalIndex', 'u32', 'attribute' );

	}

	getSubgroupSize() {

		this.enableSubGroups();

		return this.getBuiltin( 'subgroup_size', 'subgroupSize', 'u32', 'attribute' );

	}

	getInvocationSubgroupIndex() {

		this.enableSubGroups();

		return this.getBuiltin( 'subgroup_invocation_id', 'invocationSubgroupIndex', 'u32', 'attribute' );

	}

	getSubgroupIndex() {

		this.enableSubGroups();

		return this.getBuiltin( 'subgroup_id', 'subgroupIndex', 'u32', 'attribute' );

	}

	getDrawIndex() {

		return null;

	}

	getFrontFacing() {

		return this.getBuiltin( 'front_facing', 'isFront', 'bool' );

	}

	getFragCoord() {

		return this.getBuiltin( 'position', 'fragCoord', 'vec4<f32>' ) + '.xy';

	}

	getFragDepth() {

		return 'output.' + this.getBuiltin( 'frag_depth', 'depth', 'f32', 'output' );

	}

	getClipDistance() {

		return 'varyings.hw_clip_distances';

	}

	isFlipY() {

		return false;

	}

	enableDirective( name, shaderStage = this.shaderStage ) {

		const stage = this.directives[ shaderStage ] || ( this.directives[ shaderStage ] = new Set() );
		stage.add( name );

	}

	getDirectives( shaderStage ) {

		const snippets = [];
		const directives = this.directives[ shaderStage ];

		if ( directives !== undefined ) {

			for ( const directive of directives ) {

				snippets.push( `enable ${directive};` );

			}

		}

		return snippets.join( '\n' );

	}

	enableSubGroups() {

		this.enableDirective( 'subgroups' );

	}

	enableSubgroupsF16() {

		this.enableDirective( 'subgroups-f16' );

	}

	enableClipDistances() {

		this.enableDirective( 'clip_distances' );

	}

	enableShaderF16() {

		this.enableDirective( 'f16' );

	}

	enableDualSourceBlending() {

		this.enableDirective( 'dual_source_blending' );

	}

	enableHardwareClipping( planeCount ) {

		this.enableClipDistances();
		this.getBuiltin( 'clip_distances', 'hw_clip_distances', `array<f32, ${ planeCount } >`, 'vertex' );

	}

	getBuiltins( shaderStage ) {

		const snippets = [];
		const builtins = this.builtins[ shaderStage ];

		if ( builtins !== undefined ) {

			for ( const { name, property, type } of builtins.values() ) {

				snippets.push( `@builtin( ${name} ) ${property} : ${type}` );

			}

		}

		return snippets.join( ',\n\t' );

	}

	getScopedArray( name, scope, bufferType, bufferCount ) {

		if ( this.scopedArrays.has( name ) === false ) {

			this.scopedArrays.set( name, {
				name,
				scope,
				bufferType,
				bufferCount
			} );

		}

		return name;

	}

	getScopedArrays( shaderStage ) {

		if ( shaderStage !== 'compute' ) {

			return;

		}

		const snippets = [];

		for ( const { name, scope, bufferType, bufferCount } of this.scopedArrays.values() ) {

			const type = this.getType( bufferType );

			snippets.push( `var<${scope}> ${name}: array< ${type}, ${bufferCount} >;` );

		}

		return snippets.join( '\n' );

	}

	getAttributes( shaderStage ) {

		const snippets = [];

		if ( shaderStage === 'compute' ) {

			this.getBuiltin( 'global_invocation_id', 'id', 'vec3<u32>', 'attribute' );
			this.getBuiltin( 'workgroup_id', 'workgroupId', 'vec3<u32>', 'attribute' );
			this.getBuiltin( 'local_invocation_id', 'localId', 'vec3<u32>', 'attribute' );
			this.getBuiltin( 'num_workgroups', 'numWorkgroups', 'vec3<u32>', 'attribute' );

			if ( this.renderer.hasFeature( 'subgroups' ) ) {

				this.enableDirective( 'subgroups', shaderStage );
				this.getBuiltin( 'subgroup_size', 'subgroupSize', 'u32', 'attribute' );

			}

		}

		if ( shaderStage === 'vertex' || shaderStage === 'compute' ) {

			const builtins = this.getBuiltins( 'attribute' );

			if ( builtins ) snippets.push( builtins );

			const attributes = this.getAttributesArray();

			for ( let index = 0, length = attributes.length; index < length; index ++ ) {

				const attribute = attributes[ index ];
				const name = attribute.name;
				const type = this.getType( attribute.type );

				snippets.push( `@location( ${index} ) ${ name } : ${ type }` );

			}

		}

		return snippets.join( ',\n\t' );

	}

	getStructMembers( struct ) {

		const snippets = [];
		const members = struct.getMemberTypes();

		for ( let i = 0; i < members.length; i ++ ) {

			const member = members[ i ];
			snippets.push( `\t@location( ${i} ) m${i} : ${ member }<f32>` );

		}

		const builtins = this.getBuiltins( 'output' );

		if ( builtins ) snippets.push( '\t' + builtins );

		return snippets.join( ',\n' );

	}

	getStructs( shaderStage ) {

		const snippets = [];
		const structs = this.structs[ shaderStage ];

		for ( let index = 0, length = structs.length; index < length; index ++ ) {

			const struct = structs[ index ];
			const name = struct.name;

			let snippet = `\struct ${ name } {\n`;
			snippet += this.getStructMembers( struct );
			snippet += '\n}';


			snippets.push( snippet );

			snippets.push( `\nvar<private> output : ${ name };\n\n` );

		}

		return snippets.join( '\n\n' );

	}

	getVar( type, name ) {

		return `var ${ name } : ${ this.getType( type ) }`;

	}

	getVars( shaderStage ) {

		const snippets = [];
		const vars = this.vars[ shaderStage ];

		if ( vars !== undefined ) {

			for ( const variable of vars ) {

				snippets.push( `\t${ this.getVar( variable.type, variable.name ) };` );

			}

		}

		return `\n${ snippets.join( '\n' ) }\n`;

	}

	getVaryings( shaderStage ) {

		const snippets = [];

		if ( shaderStage === 'vertex' ) {

			this.getBuiltin( 'position', 'Vertex', 'vec4<f32>', 'vertex' );

		}

		if ( shaderStage === 'vertex' || shaderStage === 'fragment' ) {

			const varyings = this.varyings;
			const vars = this.vars[ shaderStage ];

			for ( let index = 0; index < varyings.length; index ++ ) {

				const varying = varyings[ index ];

				if ( varying.needsInterpolation ) {

					let attributesSnippet = `@location( ${index} )`;

					if ( /^(int|uint|ivec|uvec)/.test( varying.type ) ) {

						attributesSnippet += ' @interpolate( flat )';


					}

					snippets.push( `${ attributesSnippet } ${ varying.name } : ${ this.getType( varying.type ) }` );

				} else if ( shaderStage === 'vertex' && vars.includes( varying ) === false ) {

					vars.push( varying );

				}

			}

		}

		const builtins = this.getBuiltins( shaderStage );

		if ( builtins ) snippets.push( builtins );

		const code = snippets.join( ',\n\t' );

		return shaderStage === 'vertex' ? this._getWGSLStruct( 'VaryingsStruct', '\t' + code ) : code;

	}

	getUniforms( shaderStage ) {

		const uniforms = this.uniforms[ shaderStage ];

		const bindingSnippets = [];
		const bufferSnippets = [];
		const structSnippets = [];
		const uniformGroups = {};

		for ( const uniform of uniforms ) {

			const groupName = uniform.groupNode.name;
			const uniformIndexes = this.bindingsIndexes[ groupName ];

			if ( uniform.type === 'texture' || uniform.type === 'cubeTexture' || uniform.type === 'storageTexture' || uniform.type === 'texture3D' ) {

				const texture = uniform.node.value;

				if ( shaderStage === 'fragment' && this.isUnfilterable( texture ) === false && uniform.node.isStorageTextureNode !== true ) {

					if ( this.isSampleCompare( texture ) ) {

						bindingSnippets.push( `@binding( ${ uniformIndexes.binding ++ } ) @group( ${ uniformIndexes.group } ) var ${ uniform.name }_sampler : sampler_comparison;` );

					} else {

						bindingSnippets.push( `@binding( ${ uniformIndexes.binding ++ } ) @group( ${ uniformIndexes.group } ) var ${ uniform.name }_sampler : sampler;` );

					}

				}

				let textureType;

				let multisampled = '';

				if ( texture.isMultisampleRenderTargetTexture === true ) {

					multisampled = '_multisampled';

				}

				if ( texture.isCubeTexture === true ) {

					textureType = 'texture_cube<f32>';

				} else if ( texture.isDataArrayTexture === true || texture.isCompressedArrayTexture === true ) {

					textureType = 'texture_2d_array<f32>';

				} else if ( texture.isDepthTexture === true ) {

					textureType = `texture_depth${multisampled}_2d`;

				} else if ( texture.isVideoTexture === true ) {

					textureType = 'texture_external';

				} else if ( texture.isData3DTexture === true ) {

					textureType = 'texture_3d<f32>';

				} else if ( uniform.node.isStorageTextureNode === true ) {

					const format = getFormat( texture );
					const access = this.getStorageAccess( uniform.node, shaderStage );

					textureType = `texture_storage_2d<${ format }, ${ access }>`;

				} else {

					const componentPrefix = this.getComponentTypeFromTexture( texture ).charAt( 0 );

					textureType = `texture${multisampled}_2d<${ componentPrefix }32>`;

				}

				bindingSnippets.push( `@binding( ${ uniformIndexes.binding ++ } ) @group( ${ uniformIndexes.group } ) var ${ uniform.name } : ${ textureType };` );

			} else if ( uniform.type === 'buffer' || uniform.type === 'storageBuffer' || uniform.type === 'indirectStorageBuffer' ) {

				const bufferNode = uniform.node;
				const bufferType = this.getType( bufferNode.bufferType );
				const bufferCount = bufferNode.bufferCount;

				const bufferCountSnippet = bufferCount > 0 && uniform.type === 'buffer' ? ', ' + bufferCount : '';
				const bufferTypeSnippet = bufferNode.isAtomic ? `atomic<${bufferType}>` : `${bufferType}`;
				const bufferSnippet = `\t${ uniform.name } : array< ${ bufferTypeSnippet }${ bufferCountSnippet } >\n`;
				const bufferAccessMode = bufferNode.isStorageBufferNode ? `storage, ${ this.getStorageAccess( bufferNode, shaderStage ) }` : 'uniform';

				bufferSnippets.push( this._getWGSLStructBinding( 'NodeBuffer_' + bufferNode.id, bufferSnippet, bufferAccessMode, uniformIndexes.binding ++, uniformIndexes.group ) );

			} else {

				const vectorType = this.getType( this.getVectorType( uniform.type ) );
				const groupName = uniform.groupNode.name;

				const group = uniformGroups[ groupName ] || ( uniformGroups[ groupName ] = {
					index: uniformIndexes.binding ++,
					id: uniformIndexes.group,
					snippets: []
				} );

				group.snippets.push( `\t${ uniform.name } : ${ vectorType }` );

			}

		}

		for ( const name in uniformGroups ) {

			const group = uniformGroups[ name ];

			structSnippets.push( this._getWGSLStructBinding( name, group.snippets.join( ',\n' ), 'uniform', group.index, group.id ) );

		}

		let code = bindingSnippets.join( '\n' );
		code += bufferSnippets.join( '\n' );
		code += structSnippets.join( '\n' );

		return code;

	}

	buildCode() {

		const shadersData = this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };

		this.sortBindingGroups();

		for ( const shaderStage in shadersData ) {

			const stageData = shadersData[ shaderStage ];
			stageData.uniforms = this.getUniforms( shaderStage );
			stageData.attributes = this.getAttributes( shaderStage );
			stageData.varyings = this.getVaryings( shaderStage );
			stageData.structs = this.getStructs( shaderStage );
			stageData.vars = this.getVars( shaderStage );
			stageData.codes = this.getCodes( shaderStage );
			stageData.directives = this.getDirectives( shaderStage );
			stageData.scopedArrays = this.getScopedArrays( shaderStage );

			//

			let flow = '// code\n\n';
			flow += this.flowCode[ shaderStage ];

			const flowNodes = this.flowNodes[ shaderStage ];
			const mainNode = flowNodes[ flowNodes.length - 1 ];

			const outputNode = mainNode.outputNode;
			const isOutputStruct = ( outputNode !== undefined && outputNode.isOutputStructNode === true );

			for ( const node of flowNodes ) {

				const flowSlotData = this.getFlowData( node/*, shaderStage*/ );
				const slotName = node.name;

				if ( slotName ) {

					if ( flow.length > 0 ) flow += '\n';

					flow += `\t// flow -> ${ slotName }\n\t`;

				}

				flow += `${ flowSlotData.code }\n\t`;

				if ( node === mainNode && shaderStage !== 'compute' ) {

					flow += '// result\n\n\t';

					if ( shaderStage === 'vertex' ) {

						flow += `varyings.Vertex = ${ flowSlotData.result };`;

					} else if ( shaderStage === 'fragment' ) {

						if ( isOutputStruct ) {

							stageData.returnType = outputNode.nodeType;

							flow += `return ${ flowSlotData.result };`;

						} else {

							let structSnippet = '\t@location(0) color: vec4<f32>';

							const builtins = this.getBuiltins( 'output' );

							if ( builtins ) structSnippet += ',\n\t' + builtins;

							stageData.returnType = 'OutputStruct';
							stageData.structs += this._getWGSLStruct( 'OutputStruct', structSnippet );
							stageData.structs += '\nvar<private> output : OutputStruct;\n\n';

							flow += `output.color = ${ flowSlotData.result };\n\n\treturn output;`;

						}

					}

				}

			}

			stageData.flow = flow;


		}

		if ( this.material !== null ) {

			this.vertexShader = this._getWGSLVertexCode( shadersData.vertex );
			this.fragmentShader = this._getWGSLFragmentCode( shadersData.fragment );

		} else {

			this.computeShader = this._getWGSLComputeCode( shadersData.compute, ( this.object.workgroupSize || [ 64 ] ).join( ', ' ) );

		}

	}

	getMethod( method, output = null ) {

		let wgslMethod;

		if ( output !== null ) {

			wgslMethod = this._getWGSLMethod( method + '_' + output );

		}

		if ( wgslMethod === undefined ) {

			wgslMethod = this._getWGSLMethod( method );

		}

		return wgslMethod || method;

	}

	getType( type ) {

		return wgslTypeLib[ type ] || type;

	}

	isAvailable( name ) {

		let result = supports[ name ];

		if ( result === undefined ) {

			if ( name === 'float32Filterable' ) {

				result = this.renderer.hasFeature( 'float32-filterable' );

			} else if ( name === 'clipDistance' ) {

				result = this.renderer.hasFeature( 'clip-distances' );

			}

			supports[ name ] = result;

		}

		return result;

	}

	_getWGSLMethod( method ) {

		if ( wgslPolyfill[ method ] !== undefined ) {

			this._include( method );

		}

		return wgslMethods[ method ];

	}

	_include( name ) {

		const codeNode = wgslPolyfill[ name ];
		codeNode.build( this );

		if ( this.currentFunctionNode !== null ) {

			this.currentFunctionNode.includes.push( codeNode );

		}

		return codeNode;

	}

	_getWGSLVertexCode( shaderData ) {

		return `${ this.getSignature() }
// directives
${shaderData.directives}

// uniforms
${shaderData.uniforms}

// varyings
${shaderData.varyings}
var<private> varyings : VaryingsStruct;

// codes
${shaderData.codes}

@vertex
fn main( ${shaderData.attributes} ) -> VaryingsStruct {

	// vars
	${shaderData.vars}

	// flow
	${shaderData.flow}

	return varyings;

}
`;

	}

	_getWGSLFragmentCode( shaderData ) {

		return `${ this.getSignature() }
// global
${ diagnostics }

// uniforms
${shaderData.uniforms}

// structs
${shaderData.structs}

// codes
${shaderData.codes}

@fragment
fn main( ${shaderData.varyings} ) -> ${shaderData.returnType} {

	// vars
	${shaderData.vars}

	// flow
	${shaderData.flow}

}
`;

	}

	_getWGSLComputeCode( shaderData, workgroupSize ) {

		return `${ this.getSignature() }
// directives
${shaderData.directives}

// system
var<private> instanceIndex : u32;

// locals
${shaderData.scopedArrays}

// uniforms
${shaderData.uniforms}

// codes
${shaderData.codes}

@compute @workgroup_size( ${workgroupSize} )
fn main( ${shaderData.attributes} ) {

	// system
	instanceIndex = id.x + id.y * numWorkgroups.x * u32(${workgroupSize}) + id.z * numWorkgroups.x * numWorkgroups.y * u32(${workgroupSize});

	// vars
	${shaderData.vars}

	// flow
	${shaderData.flow}

}
`;

	}

	_getWGSLStruct( name, vars ) {

		return `
struct ${name} {
${vars}
};`;

	}

	_getWGSLStructBinding( name, vars, access, binding = 0, group = 0 ) {

		const structName = name + 'Struct';
		const structSnippet = this._getWGSLStruct( structName, vars );

		return `${structSnippet}
@binding( ${binding} ) @group( ${group} )
var<${access}> ${name} : ${structName};`;

	}

}

class WebGPUUtils {

	constructor( backend ) {

		this.backend = backend;

	}

	getCurrentDepthStencilFormat( renderContext ) {

		let format;

		if ( renderContext.depthTexture !== null ) {

			format = this.getTextureFormatGPU( renderContext.depthTexture );

		} else if ( renderContext.depth && renderContext.stencil ) {

			format = GPUTextureFormat.Depth24PlusStencil8;

		} else if ( renderContext.depth ) {

			format = GPUTextureFormat.Depth24Plus;

		}

		return format;

	}

	getTextureFormatGPU( texture ) {

		return this.backend.get( texture ).format;

	}

	getCurrentColorFormat( renderContext ) {

		let format;

		if ( renderContext.textures !== null ) {

			format = this.getTextureFormatGPU( renderContext.textures[ 0 ] );

		} else {

			format = this.getPreferredCanvasFormat(); // default context format

		}

		return format;

	}

	getCurrentColorSpace( renderContext ) {

		if ( renderContext.textures !== null ) {

			return renderContext.textures[ 0 ].colorSpace;

		}

		return this.backend.renderer.outputColorSpace;

	}

	getPrimitiveTopology( object, material ) {

		if ( object.isPoints ) return GPUPrimitiveTopology.PointList;
		else if ( object.isLineSegments || ( object.isMesh && material.wireframe === true ) ) return GPUPrimitiveTopology.LineList;
		else if ( object.isLine ) return GPUPrimitiveTopology.LineStrip;
		else if ( object.isMesh ) return GPUPrimitiveTopology.TriangleList;

	}

	getSampleCount( sampleCount ) {

		let count = 1;

		if ( sampleCount > 1 ) {

			// WebGPU only supports power-of-two sample counts and 2 is not a valid value
			count = Math.pow( 2, Math.floor( Math.log2( sampleCount ) ) );

			if ( count === 2 ) {

				count = 4;

			}

		}

		return count;

	}

	getSampleCountRenderContext( renderContext ) {

		if ( renderContext.textures !== null ) {

			return this.getSampleCount( renderContext.sampleCount );

		}

		return this.getSampleCount( this.backend.renderer.samples );

	}

	getPreferredCanvasFormat() {

		// TODO: Remove this check when Quest 34.5 is out
		// https://github.com/mrdoob/three.js/pull/29221/files#r1731833949

		if ( navigator.userAgent.includes( 'Quest' ) ) {

			return GPUTextureFormat.BGRA8Unorm;

		} else {

			return navigator.gpu.getPreferredCanvasFormat();

		}

	}

}

const typedArraysToVertexFormatPrefix = new Map( [
	[ Int8Array, [ 'sint8', 'snorm8' ]],
	[ Uint8Array, [ 'uint8', 'unorm8' ]],
	[ Int16Array, [ 'sint16', 'snorm16' ]],
	[ Uint16Array, [ 'uint16', 'unorm16' ]],
	[ Int32Array, [ 'sint32', 'snorm32' ]],
	[ Uint32Array, [ 'uint32', 'unorm32' ]],
	[ Float32Array, [ 'float32', ]],
] );

const typedAttributeToVertexFormatPrefix = new Map( [
	[ Float16BufferAttribute, [ 'float16', ]],
] );

const typeArraysToVertexFormatPrefixForItemSize1 = new Map( [
	[ Int32Array, 'sint32' ],
	[ Int16Array, 'sint32' ], // patch for INT16
	[ Uint32Array, 'uint32' ],
	[ Uint16Array, 'uint32' ], // patch for UINT16
	[ Float32Array, 'float32' ]
] );

class WebGPUAttributeUtils {

	constructor( backend ) {

		this.backend = backend;

	}

	createAttribute( attribute, usage ) {

		const bufferAttribute = this._getBufferAttribute( attribute );

		const backend = this.backend;
		const bufferData = backend.get( bufferAttribute );

		let buffer = bufferData.buffer;

		if ( buffer === undefined ) {

			const device = backend.device;

			let array = bufferAttribute.array;

			// patch for INT16 and UINT16
			if ( attribute.normalized === false && ( array.constructor === Int16Array || array.constructor === Uint16Array ) ) {

				const tempArray = new Uint32Array( array.length );
				for ( let i = 0; i < array.length; i ++ ) {

					tempArray[ i ] = array[ i ];

				}

				array = tempArray;

			}

			bufferAttribute.array = array;

			if ( ( bufferAttribute.isStorageBufferAttribute || bufferAttribute.isStorageInstancedBufferAttribute ) && bufferAttribute.itemSize === 3 ) {

				array = new array.constructor( bufferAttribute.count * 4 );

				for ( let i = 0; i < bufferAttribute.count; i ++ ) {

					array.set( bufferAttribute.array.subarray( i * 3, i * 3 + 3 ), i * 4 );

				}

				// Update BufferAttribute
				bufferAttribute.itemSize = 4;
				bufferAttribute.array = array;

			}

			const size = array.byteLength + ( ( 4 - ( array.byteLength % 4 ) ) % 4 ); // ensure 4 byte alignment, see #20441

			buffer = device.createBuffer( {
				label: bufferAttribute.name,
				size: size,
				usage: usage,
				mappedAtCreation: true
			} );

			new array.constructor( buffer.getMappedRange() ).set( array );

			buffer.unmap();

			bufferData.buffer = buffer;

		}

	}

	updateAttribute( attribute ) {

		const bufferAttribute = this._getBufferAttribute( attribute );

		const backend = this.backend;
		const device = backend.device;

		const buffer = backend.get( bufferAttribute ).buffer;

		const array = bufferAttribute.array;
		const isTypedArray = this._isTypedArray( array );
		const updateRanges = bufferAttribute.updateRanges;

		if ( updateRanges.length === 0 ) {

			// Not using update ranges

			device.queue.writeBuffer(
				buffer,
				0,
				array,
				0
			);

		} else {

			const byteOffsetFactor = isTypedArray ? 1 : array.BYTES_PER_ELEMENT;

			for ( let i = 0, l = updateRanges.length; i < l; i ++ ) {

				const range = updateRanges[ i ];

				const dataOffset = range.start * byteOffsetFactor;
				const size = range.count * byteOffsetFactor;

				device.queue.writeBuffer(
					buffer,
					0,
					array,
					dataOffset,
					size
				);

			}

			bufferAttribute.clearUpdateRanges();

		}

	}

	createShaderVertexBuffers( renderObject ) {

		const attributes = renderObject.getAttributes();
		const vertexBuffers = new Map();

		for ( let slot = 0; slot < attributes.length; slot ++ ) {

			const geometryAttribute = attributes[ slot ];
			const bytesPerElement = geometryAttribute.array.BYTES_PER_ELEMENT;
			const bufferAttribute = this._getBufferAttribute( geometryAttribute );

			let vertexBufferLayout = vertexBuffers.get( bufferAttribute );

			if ( vertexBufferLayout === undefined ) {

				let arrayStride, stepMode;

				if ( geometryAttribute.isInterleavedBufferAttribute === true ) {

					arrayStride = geometryAttribute.data.stride * bytesPerElement;
					stepMode = geometryAttribute.data.isInstancedInterleavedBuffer ? GPUInputStepMode.Instance : GPUInputStepMode.Vertex;

				} else {

					arrayStride = geometryAttribute.itemSize * bytesPerElement;
					stepMode = geometryAttribute.isInstancedBufferAttribute ? GPUInputStepMode.Instance : GPUInputStepMode.Vertex;

				}

				// patch for INT16 and UINT16
				if ( geometryAttribute.normalized === false && ( geometryAttribute.array.constructor === Int16Array || geometryAttribute.array.constructor === Uint16Array ) ) {

					arrayStride = 4;

				}

				vertexBufferLayout = {
					arrayStride,
					attributes: [],
					stepMode
				};

				vertexBuffers.set( bufferAttribute, vertexBufferLayout );

			}

			const format = this._getVertexFormat( geometryAttribute );
			const offset = ( geometryAttribute.isInterleavedBufferAttribute === true ) ? geometryAttribute.offset * bytesPerElement : 0;

			vertexBufferLayout.attributes.push( {
				shaderLocation: slot,
				offset,
				format
			} );

		}

		return Array.from( vertexBuffers.values() );

	}

	destroyAttribute( attribute ) {

		const backend = this.backend;
		const data = backend.get( this._getBufferAttribute( attribute ) );

		data.buffer.destroy();

		backend.delete( attribute );

	}

	async getArrayBufferAsync( attribute ) {

		const backend = this.backend;
		const device = backend.device;

		const data = backend.get( this._getBufferAttribute( attribute ) );

		const bufferGPU = data.buffer;
		const size = bufferGPU.size;

		const readBufferGPU = device.createBuffer( {
			label: attribute.name,
			size,
			usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
		} );


		const cmdEncoder = device.createCommandEncoder( {} );

		cmdEncoder.copyBufferToBuffer(
			bufferGPU,
			0,
			readBufferGPU,
			0,
			size
		);

		readBufferGPU.unmap();

		const gpuCommands = cmdEncoder.finish();
		device.queue.submit( [ gpuCommands ] );

		await readBufferGPU.mapAsync( GPUMapMode.READ );

		const arrayBuffer = readBufferGPU.getMappedRange();

		return arrayBuffer;

	}

	_getVertexFormat( geometryAttribute ) {

		const { itemSize, normalized } = geometryAttribute;
		const ArrayType = geometryAttribute.array.constructor;
		const AttributeType = geometryAttribute.constructor;

		let format;

		if ( itemSize == 1 ) {

			format = typeArraysToVertexFormatPrefixForItemSize1.get( ArrayType );

		} else {

			const prefixOptions = typedAttributeToVertexFormatPrefix.get( AttributeType ) || typedArraysToVertexFormatPrefix.get( ArrayType );
			const prefix = prefixOptions[ normalized ? 1 : 0 ];

			if ( prefix ) {

				const bytesPerUnit = ArrayType.BYTES_PER_ELEMENT * itemSize;
				const paddedBytesPerUnit = Math.floor( ( bytesPerUnit + 3 ) / 4 ) * 4;
				const paddedItemSize = paddedBytesPerUnit / ArrayType.BYTES_PER_ELEMENT;

				if ( paddedItemSize % 1 ) {

					throw new Error( 'THREE.WebGPUAttributeUtils: Bad vertex format item size.' );

				}

				format = `${prefix}x${paddedItemSize}`;

			}

		}

		if ( ! format ) {

			console.error( 'THREE.WebGPUAttributeUtils: Vertex format not supported yet.' );

		}

		return format;

	}

	_isTypedArray( array ) {

		return ArrayBuffer.isView( array ) && ! ( array instanceof DataView );

	}

	_getBufferAttribute( attribute ) {

		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

		return attribute;

	}

}

class WebGPUBindingUtils {

	constructor( backend ) {

		this.backend = backend;
		this.bindGroupLayoutCache = new WeakMap();

	}

	createBindingsLayout( bindGroup ) {

		const backend = this.backend;
		const device = backend.device;

		const entries = [];

		let index = 0;

		for ( const binding of bindGroup.bindings ) {

			const bindingGPU = {
				binding: index ++,
				visibility: binding.visibility
			};

			if ( binding.isUniformBuffer || binding.isStorageBuffer ) {

				const buffer = {}; // GPUBufferBindingLayout

				if ( binding.isStorageBuffer ) {

					if ( binding.visibility & 4 ) {

						// compute

						if ( binding.access === NodeAccess.READ_WRITE || binding.access === NodeAccess.WRITE_ONLY ) {

							buffer.type = GPUBufferBindingType.Storage;

						} else {

							buffer.type = GPUBufferBindingType.ReadOnlyStorage;

						}

					} else {

						buffer.type = GPUBufferBindingType.ReadOnlyStorage;

					}

				}

				bindingGPU.buffer = buffer;

			} else if ( binding.isSampler ) {

				const sampler = {}; // GPUSamplerBindingLayout

				if ( binding.texture.isDepthTexture ) {

					if ( binding.texture.compareFunction !== null ) {

						sampler.type = 'comparison';

					}

				}

				bindingGPU.sampler = sampler;

			} else if ( binding.isSampledTexture && binding.texture.isVideoTexture ) {

				bindingGPU.externalTexture = {}; // GPUExternalTextureBindingLayout

			} else if ( binding.isSampledTexture && binding.store ) {

				const storageTexture = {}; // GPUStorageTextureBindingLayout
				storageTexture.format = this.backend.get( binding.texture ).texture.format;

				const access = binding.access;

				if ( access === NodeAccess.READ_WRITE ) {

					storageTexture.access = GPUStorageTextureAccess.ReadWrite;

				} else if ( access === NodeAccess.WRITE_ONLY ) {

					storageTexture.access = GPUStorageTextureAccess.WriteOnly;

				} else {

					storageTexture.access = GPUStorageTextureAccess.ReadOnly;

				}

				bindingGPU.storageTexture = storageTexture;

			} else if ( binding.isSampledTexture ) {

				const texture = {}; // GPUTextureBindingLayout

				if ( binding.texture.isMultisampleRenderTargetTexture === true ) {

					texture.multisampled = true;

				}

				if ( binding.texture.isDepthTexture ) {

					texture.sampleType = GPUTextureSampleType.Depth;

				} else if ( binding.texture.isDataTexture || binding.texture.isDataArrayTexture || binding.texture.isData3DTexture ) {

					const type = binding.texture.type;

					if ( type === IntType ) {

						texture.sampleType = GPUTextureSampleType.SInt;

					} else if ( type === UnsignedIntType ) {

						texture.sampleType = GPUTextureSampleType.UInt;

					} else if ( type === FloatType ) {

						if ( this.backend.hasFeature( 'float32-filterable' ) ) {

							texture.sampleType = GPUTextureSampleType.Float;

						} else {

							texture.sampleType = GPUTextureSampleType.UnfilterableFloat;

						}

					}

				}

				if ( binding.isSampledCubeTexture ) {

					texture.viewDimension = GPUTextureViewDimension.Cube;

				} else if ( binding.texture.isDataArrayTexture || binding.texture.isCompressedArrayTexture ) {

					texture.viewDimension = GPUTextureViewDimension.TwoDArray;

				} else if ( binding.isSampledTexture3D ) {

					texture.viewDimension = GPUTextureViewDimension.ThreeD;

				}

				bindingGPU.texture = texture;

			} else {

				console.error( `WebGPUBindingUtils: Unsupported binding "${ binding }".` );

			}

			entries.push( bindingGPU );

		}

		return device.createBindGroupLayout( { entries } );

	}

	createBindings( bindGroup, bindings, cacheIndex, version = 0 ) {

		const { backend, bindGroupLayoutCache } = this;
		const bindingsData = backend.get( bindGroup );

		// setup (static) binding layout and (dynamic) binding group

		let bindLayoutGPU = bindGroupLayoutCache.get( bindGroup.bindingsReference );

		if ( bindLayoutGPU === undefined ) {

			bindLayoutGPU = this.createBindingsLayout( bindGroup );
			bindGroupLayoutCache.set( bindGroup.bindingsReference, bindLayoutGPU );

		}

		let bindGroupGPU;

		if ( cacheIndex > 0 ) {

			if ( bindingsData.groups === undefined ) {

				bindingsData.groups = [];
				bindingsData.versions = [];

			}

			if ( bindingsData.versions[ cacheIndex ] === version ) {

				bindGroupGPU = bindingsData.groups[ cacheIndex ];

			}

		}

		if ( bindGroupGPU === undefined ) {

			bindGroupGPU = this.createBindGroup( bindGroup, bindLayoutGPU );

			if ( cacheIndex > 0 ) {

				bindingsData.groups[ cacheIndex ] = bindGroupGPU;
				bindingsData.versions[ cacheIndex ] = version;

			}

		}

		bindingsData.group = bindGroupGPU;
		bindingsData.layout = bindLayoutGPU;

	}

	updateBinding( binding ) {

		const backend = this.backend;
		const device = backend.device;

		const buffer = binding.buffer;
		const bufferGPU = backend.get( binding ).buffer;

		device.queue.writeBuffer( bufferGPU, 0, buffer, 0 );

	}

	createBindGroup( bindGroup, layoutGPU ) {

		const backend = this.backend;
		const device = backend.device;

		let bindingPoint = 0;
		const entriesGPU = [];

		for ( const binding of bindGroup.bindings ) {

			if ( binding.isUniformBuffer ) {

				const bindingData = backend.get( binding );

				if ( bindingData.buffer === undefined ) {

					const byteLength = binding.byteLength;

					const usage = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST;

					const bufferGPU = device.createBuffer( {
						label: 'bindingBuffer_' + binding.name,
						size: byteLength,
						usage: usage
					} );

					bindingData.buffer = bufferGPU;

				}

				entriesGPU.push( { binding: bindingPoint, resource: { buffer: bindingData.buffer } } );

			} else if ( binding.isStorageBuffer ) {

				const bindingData = backend.get( binding );

				if ( bindingData.buffer === undefined ) {

					const attribute = binding.attribute;
					//const usage = GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | /*GPUBufferUsage.COPY_SRC |*/ GPUBufferUsage.COPY_DST;

					//backend.attributeUtils.createAttribute( attribute, usage ); // @TODO: Move it to universal renderer

					bindingData.buffer = backend.get( attribute ).buffer;

				}

				entriesGPU.push( { binding: bindingPoint, resource: { buffer: bindingData.buffer } } );

			} else if ( binding.isSampler ) {

				const textureGPU = backend.get( binding.texture );

				entriesGPU.push( { binding: bindingPoint, resource: textureGPU.sampler } );

			} else if ( binding.isSampledTexture ) {

				const textureData = backend.get( binding.texture );

				let resourceGPU;

				if ( textureData.externalTexture !== undefined ) {

					resourceGPU = device.importExternalTexture( { source: textureData.externalTexture } );

				} else {

					const mipLevelCount = binding.store ? 1 : textureData.texture.mipLevelCount;
					const propertyName = `view-${ textureData.texture.width }-${ textureData.texture.height }-${ mipLevelCount }`;

					resourceGPU = textureData[ propertyName ];

					if ( resourceGPU === undefined ) {

						const aspectGPU = GPUTextureAspect.All;

						let dimensionViewGPU;

						if ( binding.isSampledCubeTexture ) {

							dimensionViewGPU = GPUTextureViewDimension.Cube;

						} else if ( binding.isSampledTexture3D ) {

							dimensionViewGPU = GPUTextureViewDimension.ThreeD;

						} else if ( binding.texture.isDataArrayTexture || binding.texture.isCompressedArrayTexture ) {

							dimensionViewGPU = GPUTextureViewDimension.TwoDArray;

						} else {

							dimensionViewGPU = GPUTextureViewDimension.TwoD;

						}

						resourceGPU = textureData[ propertyName ] = textureData.texture.createView( { aspect: aspectGPU, dimension: dimensionViewGPU, mipLevelCount } );

					}

				}

				entriesGPU.push( { binding: bindingPoint, resource: resourceGPU } );

			}

			bindingPoint ++;

		}

		return device.createBindGroup( {
			label: 'bindGroup_' + bindGroup.name,
			layout: layoutGPU,
			entries: entriesGPU
		} );

	}

}

class WebGPUPipelineUtils {

	constructor( backend ) {

		this.backend = backend;

	}

	_getSampleCount( renderObjectContext ) {

		return this.backend.utils.getSampleCountRenderContext( renderObjectContext );

	}

	createRenderPipeline( renderObject, promises ) {

		const { object, material, geometry, pipeline } = renderObject;
		const { vertexProgram, fragmentProgram } = pipeline;

		const backend = this.backend;
		const device = backend.device;
		const utils = backend.utils;

		const pipelineData = backend.get( pipeline );

		// bind group layouts

		const bindGroupLayouts = [];

		for ( const bindGroup of renderObject.getBindings() ) {

			const bindingsData = backend.get( bindGroup );

			bindGroupLayouts.push( bindingsData.layout );

		}

		// vertex buffers

		const vertexBuffers = backend.attributeUtils.createShaderVertexBuffers( renderObject );

		// blending

		let blending;

		if ( material.transparent === true && material.blending !== NoBlending ) {

			blending = this._getBlending( material );

		}

		// stencil

		let stencilFront = {};

		if ( material.stencilWrite === true ) {

			stencilFront = {
				compare: this._getStencilCompare( material ),
				failOp: this._getStencilOperation( material.stencilFail ),
				depthFailOp: this._getStencilOperation( material.stencilZFail ),
				passOp: this._getStencilOperation( material.stencilZPass )
			};

		}

		const colorWriteMask = this._getColorWriteMask( material );

		const targets = [];

		if ( renderObject.context.textures !== null ) {

			const textures = renderObject.context.textures;

			for ( let i = 0; i < textures.length; i ++ ) {

				const colorFormat = utils.getTextureFormatGPU( textures[ i ] );

				targets.push( {
					format: colorFormat,
					blend: blending,
					writeMask: colorWriteMask
				} );

			}

		} else {

			const colorFormat = utils.getCurrentColorFormat( renderObject.context );

			targets.push( {
				format: colorFormat,
				blend: blending,
				writeMask: colorWriteMask
			} );

		}

		const vertexModule = backend.get( vertexProgram ).module;
		const fragmentModule = backend.get( fragmentProgram ).module;

		const primitiveState = this._getPrimitiveState( object, geometry, material );
		const depthCompare = this._getDepthCompare( material );
		const depthStencilFormat = utils.getCurrentDepthStencilFormat( renderObject.context );

		const sampleCount = this._getSampleCount( renderObject.context );

		const pipelineDescriptor = {
			label: `renderPipeline_${ material.name || material.type }_${ material.id }`,
			vertex: Object.assign( {}, vertexModule, { buffers: vertexBuffers } ),
			fragment: Object.assign( {}, fragmentModule, { targets } ),
			primitive: primitiveState,
			multisample: {
				count: sampleCount,
				alphaToCoverageEnabled: material.alphaToCoverage && sampleCount > 1
			},
			layout: device.createPipelineLayout( {
				bindGroupLayouts
			} )
		};


		const depthStencil = {};
		const renderDepth = renderObject.context.depth;
		const renderStencil = renderObject.context.stencil;

		if ( renderDepth === true || renderStencil === true ) {

			if ( renderDepth === true ) {

				depthStencil.format = depthStencilFormat;
				depthStencil.depthWriteEnabled = material.depthWrite;
				depthStencil.depthCompare = depthCompare;

			}

			if ( renderStencil === true ) {

				depthStencil.stencilFront = stencilFront;
				depthStencil.stencilBack = {}; // three.js does not provide an API to configure the back function (gl.stencilFuncSeparate() was never used)
				depthStencil.stencilReadMask = material.stencilFuncMask;
				depthStencil.stencilWriteMask = material.stencilWriteMask;

			}

			pipelineDescriptor.depthStencil = depthStencil;

		}


		if ( promises === null ) {

			pipelineData.pipeline = device.createRenderPipeline( pipelineDescriptor );

		} else {

			const p = new Promise( ( resolve /*, reject*/ ) => {

				device.createRenderPipelineAsync( pipelineDescriptor ).then( pipeline => {

					pipelineData.pipeline = pipeline;
					resolve();

				} );

			} );

			promises.push( p );

		}

	}

	createBundleEncoder( renderContext ) {

		const backend = this.backend;
		const { utils, device } = backend;

		const depthStencilFormat = utils.getCurrentDepthStencilFormat( renderContext );
		const colorFormat = utils.getCurrentColorFormat( renderContext );
		const sampleCount = this._getSampleCount( renderContext );

		const descriptor = {
			label: 'renderBundleEncoder',
			colorFormats: [ colorFormat ],
			depthStencilFormat,
			sampleCount
		};

		return device.createRenderBundleEncoder( descriptor );

	}

	createComputePipeline( pipeline, bindings ) {

		const backend = this.backend;
		const device = backend.device;

		const computeProgram = backend.get( pipeline.computeProgram ).module;

		const pipelineGPU = backend.get( pipeline );

		// bind group layouts

		const bindGroupLayouts = [];

		for ( const bindingsGroup of bindings ) {

			const bindingsData = backend.get( bindingsGroup );

			bindGroupLayouts.push( bindingsData.layout );

		}

		pipelineGPU.pipeline = device.createComputePipeline( {
			compute: computeProgram,
			layout: device.createPipelineLayout( {
				bindGroupLayouts
			} )
		} );

	}

	_getBlending( material ) {

		let color, alpha;

		const blending = material.blending;
		const blendSrc = material.blendSrc;
		const blendDst = material.blendDst;
		const blendEquation = material.blendEquation;


		if ( blending === CustomBlending ) {

			const blendSrcAlpha = material.blendSrcAlpha !== null ? material.blendSrcAlpha : blendSrc;
			const blendDstAlpha = material.blendDstAlpha !== null ? material.blendDstAlpha : blendDst;
			const blendEquationAlpha = material.blendEquationAlpha !== null ? material.blendEquationAlpha : blendEquation;

			color = {
				srcFactor: this._getBlendFactor( blendSrc ),
				dstFactor: this._getBlendFactor( blendDst ),
				operation: this._getBlendOperation( blendEquation )
			};

			alpha = {
				srcFactor: this._getBlendFactor( blendSrcAlpha ),
				dstFactor: this._getBlendFactor( blendDstAlpha ),
				operation: this._getBlendOperation( blendEquationAlpha )
			};

		} else {

			const premultipliedAlpha = material.premultipliedAlpha;

			const setBlend = ( srcRGB, dstRGB, srcAlpha, dstAlpha ) => {

				color = {
					srcFactor: srcRGB,
					dstFactor: dstRGB,
					operation: GPUBlendOperation.Add
				};

				alpha = {
					srcFactor: srcAlpha,
					dstFactor: dstAlpha,
					operation: GPUBlendOperation.Add
				};

			};

			if ( premultipliedAlpha ) {

				switch ( blending ) {

					case NormalBlending:
						setBlend( GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha, GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha );
						break;

					case AdditiveBlending:
						setBlend( GPUBlendFactor.One, GPUBlendFactor.One, GPUBlendFactor.One, GPUBlendFactor.One );
						break;

					case SubtractiveBlending:
						setBlend( GPUBlendFactor.Zero, GPUBlendFactor.OneMinusSrc, GPUBlendFactor.Zero, GPUBlendFactor.One );
						break;

					case MultiplyBlending:
						setBlend( GPUBlendFactor.Zero, GPUBlendFactor.Src, GPUBlendFactor.Zero, GPUBlendFactor.SrcAlpha );
						break;

				}

			} else {

				switch ( blending ) {

					case NormalBlending:
						setBlend( GPUBlendFactor.SrcAlpha, GPUBlendFactor.OneMinusSrcAlpha, GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha );
						break;

					case AdditiveBlending:
						setBlend( GPUBlendFactor.SrcAlpha, GPUBlendFactor.One, GPUBlendFactor.SrcAlpha, GPUBlendFactor.One );
						break;

					case SubtractiveBlending:
						setBlend( GPUBlendFactor.Zero, GPUBlendFactor.OneMinusSrc, GPUBlendFactor.Zero, GPUBlendFactor.One );
						break;

					case MultiplyBlending:
						setBlend( GPUBlendFactor.Zero, GPUBlendFactor.Src, GPUBlendFactor.Zero, GPUBlendFactor.Src );
						break;

				}

			}

		}

		if ( color !== undefined && alpha !== undefined ) {

			return { color, alpha };

		} else {

			console.error( 'THREE.WebGPURenderer: Invalid blending: ', blending );

		}

	}

	_getBlendFactor( blend ) {

		let blendFactor;

		switch ( blend ) {

			case ZeroFactor:
				blendFactor = GPUBlendFactor.Zero;
				break;

			case OneFactor:
				blendFactor = GPUBlendFactor.One;
				break;

			case SrcColorFactor:
				blendFactor = GPUBlendFactor.Src;
				break;

			case OneMinusSrcColorFactor:
				blendFactor = GPUBlendFactor.OneMinusSrc;
				break;

			case SrcAlphaFactor:
				blendFactor = GPUBlendFactor.SrcAlpha;
				break;

			case OneMinusSrcAlphaFactor:
				blendFactor = GPUBlendFactor.OneMinusSrcAlpha;
				break;

			case DstColorFactor:
				blendFactor = GPUBlendFactor.Dst;
				break;

			case OneMinusDstColorFactor:
				blendFactor = GPUBlendFactor.OneMinusDstColor;
				break;

			case DstAlphaFactor:
				blendFactor = GPUBlendFactor.DstAlpha;
				break;

			case OneMinusDstAlphaFactor:
				blendFactor = GPUBlendFactor.OneMinusDstAlpha;
				break;

			case SrcAlphaSaturateFactor:
				blendFactor = GPUBlendFactor.SrcAlphaSaturated;
				break;

			case BlendColorFactor:
				blendFactor = GPUBlendFactor.Constant;
				break;

			case OneMinusBlendColorFactor:
				blendFactor = GPUBlendFactor.OneMinusConstant;
				break;

			default:
				console.error( 'THREE.WebGPURenderer: Blend factor not supported.', blend );

		}

		return blendFactor;

	}

	_getStencilCompare( material ) {

		let stencilCompare;

		const stencilFunc = material.stencilFunc;

		switch ( stencilFunc ) {

			case NeverStencilFunc:
				stencilCompare = GPUCompareFunction.Never;
				break;

			case AlwaysStencilFunc:
				stencilCompare = GPUCompareFunction.Always;
				break;

			case LessStencilFunc:
				stencilCompare = GPUCompareFunction.Less;
				break;

			case LessEqualStencilFunc:
				stencilCompare = GPUCompareFunction.LessEqual;
				break;

			case EqualStencilFunc:
				stencilCompare = GPUCompareFunction.Equal;
				break;

			case GreaterEqualStencilFunc:
				stencilCompare = GPUCompareFunction.GreaterEqual;
				break;

			case GreaterStencilFunc:
				stencilCompare = GPUCompareFunction.Greater;
				break;

			case NotEqualStencilFunc:
				stencilCompare = GPUCompareFunction.NotEqual;
				break;

			default:
				console.error( 'THREE.WebGPURenderer: Invalid stencil function.', stencilFunc );

		}

		return stencilCompare;

	}

	_getStencilOperation( op ) {

		let stencilOperation;

		switch ( op ) {

			case KeepStencilOp:
				stencilOperation = GPUStencilOperation.Keep;
				break;

			case ZeroStencilOp:
				stencilOperation = GPUStencilOperation.Zero;
				break;

			case ReplaceStencilOp:
				stencilOperation = GPUStencilOperation.Replace;
				break;

			case InvertStencilOp:
				stencilOperation = GPUStencilOperation.Invert;
				break;

			case IncrementStencilOp:
				stencilOperation = GPUStencilOperation.IncrementClamp;
				break;

			case DecrementStencilOp:
				stencilOperation = GPUStencilOperation.DecrementClamp;
				break;

			case IncrementWrapStencilOp:
				stencilOperation = GPUStencilOperation.IncrementWrap;
				break;

			case DecrementWrapStencilOp:
				stencilOperation = GPUStencilOperation.DecrementWrap;
				break;

			default:
				console.error( 'THREE.WebGPURenderer: Invalid stencil operation.', stencilOperation );

		}

		return stencilOperation;

	}

	_getBlendOperation( blendEquation ) {

		let blendOperation;

		switch ( blendEquation ) {

			case AddEquation:
				blendOperation = GPUBlendOperation.Add;
				break;

			case SubtractEquation:
				blendOperation = GPUBlendOperation.Subtract;
				break;

			case ReverseSubtractEquation:
				blendOperation = GPUBlendOperation.ReverseSubtract;
				break;

			case MinEquation:
				blendOperation = GPUBlendOperation.Min;
				break;

			case MaxEquation:
				blendOperation = GPUBlendOperation.Max;
				break;

			default:
				console.error( 'THREE.WebGPUPipelineUtils: Blend equation not supported.', blendEquation );

		}

		return blendOperation;

	}

	_getPrimitiveState( object, geometry, material ) {

		const descriptor = {};
		const utils = this.backend.utils;

		descriptor.topology = utils.getPrimitiveTopology( object, material );

		if ( geometry.index !== null && object.isLine === true && object.isLineSegments !== true ) {

			descriptor.stripIndexFormat = ( geometry.index.array instanceof Uint16Array ) ? GPUIndexFormat.Uint16 : GPUIndexFormat.Uint32;

		}

		switch ( material.side ) {

			case FrontSide:
				descriptor.frontFace = GPUFrontFace.CCW;
				descriptor.cullMode = GPUCullMode.Back;
				break;

			case BackSide:
				descriptor.frontFace = GPUFrontFace.CCW;
				descriptor.cullMode = GPUCullMode.Front;
				break;

			case DoubleSide:
				descriptor.frontFace = GPUFrontFace.CCW;
				descriptor.cullMode = GPUCullMode.None;
				break;

			default:
				console.error( 'THREE.WebGPUPipelineUtils: Unknown material.side value.', material.side );
				break;

		}

		return descriptor;

	}

	_getColorWriteMask( material ) {

		return ( material.colorWrite === true ) ? GPUColorWriteFlags.All : GPUColorWriteFlags.None;

	}

	_getDepthCompare( material ) {

		let depthCompare;

		if ( material.depthTest === false ) {

			depthCompare = GPUCompareFunction.Always;

		} else {

			const depthFunc = material.depthFunc;

			switch ( depthFunc ) {

				case NeverDepth:
					depthCompare = GPUCompareFunction.Never;
					break;

				case AlwaysDepth:
					depthCompare = GPUCompareFunction.Always;
					break;

				case LessDepth:
					depthCompare = GPUCompareFunction.Less;
					break;

				case LessEqualDepth:
					depthCompare = GPUCompareFunction.LessEqual;
					break;

				case EqualDepth:
					depthCompare = GPUCompareFunction.Equal;
					break;

				case GreaterEqualDepth:
					depthCompare = GPUCompareFunction.GreaterEqual;
					break;

				case GreaterDepth:
					depthCompare = GPUCompareFunction.Greater;
					break;

				case NotEqualDepth:
					depthCompare = GPUCompareFunction.NotEqual;
					break;

				default:
					console.error( 'THREE.WebGPUPipelineUtils: Invalid depth function.', depthFunc );

			}

		}

		return depthCompare;

	}

}

/*// debugger tools
import 'https://greggman.github.io/webgpu-avoid-redundant-state-setting/webgpu-check-redundant-state-setting.js';
//*/


//

class WebGPUBackend extends Backend {

	constructor( parameters = {} ) {

		super( parameters );

		this.isWebGPUBackend = true;

		// some parameters require default values other than "undefined"
		this.parameters.alpha = ( parameters.alpha === undefined ) ? true : parameters.alpha;

		this.parameters.requiredLimits = ( parameters.requiredLimits === undefined ) ? {} : parameters.requiredLimits;

		this.trackTimestamp = ( parameters.trackTimestamp === true );

		this.device = null;
		this.context = null;
		this.colorBuffer = null;
		this.defaultRenderPassdescriptor = null;

		this.utils = new WebGPUUtils( this );
		this.attributeUtils = new WebGPUAttributeUtils( this );
		this.bindingUtils = new WebGPUBindingUtils( this );
		this.pipelineUtils = new WebGPUPipelineUtils( this );
		this.textureUtils = new WebGPUTextureUtils( this );
		this.occludedResolveCache = new Map();

	}

	async init( renderer ) {

		await super.init( renderer );

		//

		const parameters = this.parameters;

		// create the device if it is not passed with parameters

		let device;

		if ( parameters.device === undefined ) {

			const adapterOptions = {
				powerPreference: parameters.powerPreference
			};

			const adapter = ( typeof navigator !== 'undefined' ) ? await navigator.gpu.requestAdapter( adapterOptions ) : null;

			if ( adapter === null ) {

				throw new Error( 'WebGPUBackend: Unable to create WebGPU adapter.' );

			}

			// feature support

			const features = Object.values( GPUFeatureName );

			const supportedFeatures = [];

			for ( const name of features ) {

				if ( adapter.features.has( name ) ) {

					supportedFeatures.push( name );

				}

			}

			const deviceDescriptor = {
				requiredFeatures: supportedFeatures,
				requiredLimits: parameters.requiredLimits
			};

			device = await adapter.requestDevice( deviceDescriptor );

		} else {

			device = parameters.device;

		}

		device.lost.then( ( info ) => {

			const deviceLossInfo = {
				api: 'WebGPU',
				message: info.message || 'Unknown reason',
				reason: info.reason || null,
				originalEvent: info
			};

			renderer.onDeviceLost( deviceLossInfo );

		} );

		const context = ( parameters.context !== undefined ) ? parameters.context : renderer.domElement.getContext( 'webgpu' );

		this.device = device;
		this.context = context;

		const alphaMode = parameters.alpha ? 'premultiplied' : 'opaque';

		this.trackTimestamp = this.trackTimestamp && this.hasFeature( GPUFeatureName.TimestampQuery );

		this.context.configure( {
			device: this.device,
			format: this.utils.getPreferredCanvasFormat(),
			usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
			alphaMode: alphaMode
		} );

		this.updateSize();

	}

	get coordinateSystem() {

		return WebGPUCoordinateSystem;

	}

	async getArrayBufferAsync( attribute ) {

		return await this.attributeUtils.getArrayBufferAsync( attribute );

	}

	getContext() {

		return this.context;

	}

	_getDefaultRenderPassDescriptor() {

		let descriptor = this.defaultRenderPassdescriptor;

		if ( descriptor === null ) {

			const renderer = this.renderer;

			descriptor = {
				colorAttachments: [ {
					view: null
				} ],
			};

			if ( this.renderer.depth === true || this.renderer.stencil === true ) {

				descriptor.depthStencilAttachment = {
					view: this.textureUtils.getDepthBuffer( renderer.depth, renderer.stencil ).createView()
				};

			}

			const colorAttachment = descriptor.colorAttachments[ 0 ];

			if ( this.renderer.samples > 0 ) {

				colorAttachment.view = this.colorBuffer.createView();

			} else {

				colorAttachment.resolveTarget = undefined;

			}

			this.defaultRenderPassdescriptor = descriptor;

		}

		const colorAttachment = descriptor.colorAttachments[ 0 ];

		if ( this.renderer.samples > 0 ) {

			colorAttachment.resolveTarget = this.context.getCurrentTexture().createView();

		} else {

			colorAttachment.view = this.context.getCurrentTexture().createView();

		}

		return descriptor;

	}

	_getRenderPassDescriptor( renderContext ) {

		const renderTarget = renderContext.renderTarget;
		const renderTargetData = this.get( renderTarget );

		let descriptors = renderTargetData.descriptors;

		if ( descriptors === undefined ||
			renderTargetData.width !== renderTarget.width ||
			renderTargetData.height !== renderTarget.height ||
			renderTargetData.activeMipmapLevel !== renderTarget.activeMipmapLevel ||
			renderTargetData.samples !== renderTarget.samples
		) {

			descriptors = {};

			renderTargetData.descriptors = descriptors;

			// dispose

			const onDispose = () => {

				renderTarget.removeEventListener( 'dispose', onDispose );

				this.delete( renderTarget );

			};

			renderTarget.addEventListener( 'dispose', onDispose );

		}

		const cacheKey = renderContext.getCacheKey();

		let descriptor = descriptors[ cacheKey ];

		if ( descriptor === undefined ) {

			const textures = renderContext.textures;
			const colorAttachments = [];

			for ( let i = 0; i < textures.length; i ++ ) {

				const textureData = this.get( textures[ i ] );

				const textureView = textureData.texture.createView( {
					baseMipLevel: renderContext.activeMipmapLevel,
					mipLevelCount: 1,
					baseArrayLayer: renderContext.activeCubeFace,
					dimension: GPUTextureViewDimension.TwoD
				} );

				let view, resolveTarget;

				if ( textureData.msaaTexture !== undefined ) {

					view = textureData.msaaTexture.createView();
					resolveTarget = textureView;

				} else {

					view = textureView;
					resolveTarget = undefined;

				}

				colorAttachments.push( {
					view,
					resolveTarget,
					loadOp: GPULoadOp.Load,
					storeOp: GPUStoreOp.Store
				} );

			}


			descriptor = {
				colorAttachments,
			};

			if ( renderContext.depth ) {

				const depthTextureData = this.get( renderContext.depthTexture );

				const depthStencilAttachment = {
					view: depthTextureData.texture.createView()
				};
				descriptor.depthStencilAttachment = depthStencilAttachment;

			}

			descriptors[ cacheKey ] = descriptor;

			renderTargetData.width = renderTarget.width;
			renderTargetData.height = renderTarget.height;
			renderTargetData.samples = renderTarget.samples;
			renderTargetData.activeMipmapLevel = renderTarget.activeMipmapLevel;

		}

		return descriptor;

	}

	beginRender( renderContext ) {

		const renderContextData = this.get( renderContext );

		const device = this.device;
		const occlusionQueryCount = renderContext.occlusionQueryCount;

		let occlusionQuerySet;

		if ( occlusionQueryCount > 0 ) {

			if ( renderContextData.currentOcclusionQuerySet ) renderContextData.currentOcclusionQuerySet.destroy();
			if ( renderContextData.currentOcclusionQueryBuffer ) renderContextData.currentOcclusionQueryBuffer.destroy();

			// Get a reference to the array of objects with queries. The renderContextData property
			// can be changed by another render pass before the buffer.mapAsyc() completes.
			renderContextData.currentOcclusionQuerySet = renderContextData.occlusionQuerySet;
			renderContextData.currentOcclusionQueryBuffer = renderContextData.occlusionQueryBuffer;
			renderContextData.currentOcclusionQueryObjects = renderContextData.occlusionQueryObjects;

			//

			occlusionQuerySet = device.createQuerySet( { type: 'occlusion', count: occlusionQueryCount, label: `occlusionQuerySet_${ renderContext.id }` } );

			renderContextData.occlusionQuerySet = occlusionQuerySet;
			renderContextData.occlusionQueryIndex = 0;
			renderContextData.occlusionQueryObjects = new Array( occlusionQueryCount );

			renderContextData.lastOcclusionObject = null;

		}

		let descriptor;

		if ( renderContext.textures === null ) {

			descriptor = this._getDefaultRenderPassDescriptor();

		} else {

			descriptor = this._getRenderPassDescriptor( renderContext );

		}

		this.initTimestampQuery( renderContext, descriptor );

		descriptor.occlusionQuerySet = occlusionQuerySet;

		const depthStencilAttachment = descriptor.depthStencilAttachment;

		if ( renderContext.textures !== null ) {

			const colorAttachments = descriptor.colorAttachments;

			for ( let i = 0; i < colorAttachments.length; i ++ ) {

				const colorAttachment = colorAttachments[ i ];

				if ( renderContext.clearColor ) {

					colorAttachment.clearValue = i === 0 ? renderContext.clearColorValue : { r: 0, g: 0, b: 0, a: 1 };
					colorAttachment.loadOp = GPULoadOp.Clear;
					colorAttachment.storeOp = GPUStoreOp.Store;

				} else {

					colorAttachment.loadOp = GPULoadOp.Load;
					colorAttachment.storeOp = GPUStoreOp.Store;

				}

			}

		} else {

			const colorAttachment = descriptor.colorAttachments[ 0 ];

			if ( renderContext.clearColor ) {

				colorAttachment.clearValue = renderContext.clearColorValue;
				colorAttachment.loadOp = GPULoadOp.Clear;
				colorAttachment.storeOp = GPUStoreOp.Store;

			} else {

				colorAttachment.loadOp = GPULoadOp.Load;
				colorAttachment.storeOp = GPUStoreOp.Store;

			}

		}

		//

		if ( renderContext.depth ) {

			if ( renderContext.clearDepth ) {

				depthStencilAttachment.depthClearValue = renderContext.clearDepthValue;
				depthStencilAttachment.depthLoadOp = GPULoadOp.Clear;
				depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;

			} else {

				depthStencilAttachment.depthLoadOp = GPULoadOp.Load;
				depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;

			}

		}

		if ( renderContext.stencil ) {

			if ( renderContext.clearStencil ) {

				depthStencilAttachment.stencilClearValue = renderContext.clearStencilValue;
				depthStencilAttachment.stencilLoadOp = GPULoadOp.Clear;
				depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;

			} else {

				depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;
				depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;

			}

		}

		//

		const encoder = device.createCommandEncoder( { label: 'renderContext_' + renderContext.id } );
		const currentPass = encoder.beginRenderPass( descriptor );

		//

		renderContextData.descriptor = descriptor;
		renderContextData.encoder = encoder;
		renderContextData.currentPass = currentPass;
		renderContextData.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null };
		renderContextData.renderBundles = [];

		//

		if ( renderContext.viewport ) {

			this.updateViewport( renderContext );

		}

		if ( renderContext.scissor ) {

			const { x, y, width, height } = renderContext.scissorValue;

			currentPass.setScissorRect( x, y, width, height );

		}

	}

	finishRender( renderContext ) {

		const renderContextData = this.get( renderContext );
		const occlusionQueryCount = renderContext.occlusionQueryCount;

		if ( renderContextData.renderBundles.length > 0 ) {

			renderContextData.currentPass.executeBundles( renderContextData.renderBundles );

		}

		if ( occlusionQueryCount > renderContextData.occlusionQueryIndex ) {

			renderContextData.currentPass.endOcclusionQuery();

		}

		renderContextData.currentPass.end();

		if ( occlusionQueryCount > 0 ) {

			const bufferSize = occlusionQueryCount * 8; // 8 byte entries for query results

			//

			let queryResolveBuffer = this.occludedResolveCache.get( bufferSize );

			if ( queryResolveBuffer === undefined ) {

				queryResolveBuffer = this.device.createBuffer(
					{
						size: bufferSize,
						usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC
					}
				);

				this.occludedResolveCache.set( bufferSize, queryResolveBuffer );

			}

			//

			const readBuffer = this.device.createBuffer(
				{
					size: bufferSize,
					usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
				}
			);

			// two buffers required here - WebGPU doesn't allow usage of QUERY_RESOLVE & MAP_READ to be combined
			renderContextData.encoder.resolveQuerySet( renderContextData.occlusionQuerySet, 0, occlusionQueryCount, queryResolveBuffer, 0 );
			renderContextData.encoder.copyBufferToBuffer( queryResolveBuffer, 0, readBuffer, 0, bufferSize );

			renderContextData.occlusionQueryBuffer = readBuffer;

			//

			this.resolveOccludedAsync( renderContext );

		}

		this.prepareTimestampBuffer( renderContext, renderContextData.encoder );

		this.device.queue.submit( [ renderContextData.encoder.finish() ] );


		//

		if ( renderContext.textures !== null ) {

			const textures = renderContext.textures;

			for ( let i = 0; i < textures.length; i ++ ) {

				const texture = textures[ i ];

				if ( texture.generateMipmaps === true ) {

					this.textureUtils.generateMipmaps( texture );

				}

			}

		}

	}

	isOccluded( renderContext, object ) {

		const renderContextData = this.get( renderContext );

		return renderContextData.occluded && renderContextData.occluded.has( object );

	}

	async resolveOccludedAsync( renderContext ) {

		const renderContextData = this.get( renderContext );

		// handle occlusion query results

		const { currentOcclusionQueryBuffer, currentOcclusionQueryObjects } = renderContextData;

		if ( currentOcclusionQueryBuffer && currentOcclusionQueryObjects ) {

			const occluded = new WeakSet();

			renderContextData.currentOcclusionQueryObjects = null;
			renderContextData.currentOcclusionQueryBuffer = null;

			await currentOcclusionQueryBuffer.mapAsync( GPUMapMode.READ );

			const buffer = currentOcclusionQueryBuffer.getMappedRange();
			const results = new BigUint64Array( buffer );

			for ( let i = 0; i < currentOcclusionQueryObjects.length; i ++ ) {

				if ( results[ i ] !== BigInt( 0 ) ) {

					occluded.add( currentOcclusionQueryObjects[ i ] );

				}

			}

			currentOcclusionQueryBuffer.destroy();

			renderContextData.occluded = occluded;

		}

	}

	updateViewport( renderContext ) {

		const { currentPass } = this.get( renderContext );
		const { x, y, width, height, minDepth, maxDepth } = renderContext.viewportValue;

		currentPass.setViewport( x, y, width, height, minDepth, maxDepth );

	}

	clear( color, depth, stencil, renderTargetData = null ) {

		const device = this.device;
		const renderer = this.renderer;

		let colorAttachments = [];

		let depthStencilAttachment;
		let clearValue;

		let supportsDepth;
		let supportsStencil;

		if ( color ) {

			const clearColor = this.getClearColor();

			if ( this.renderer.alpha === true ) {

				// premultiply alpha

				const a = clearColor.a;

				clearValue = { r: clearColor.r * a, g: clearColor.g * a, b: clearColor.b * a, a: a };

			} else {

				clearValue = { r: clearColor.r, g: clearColor.g, b: clearColor.b, a: clearColor.a };

			}

		}

		if ( renderTargetData === null ) {

			supportsDepth = renderer.depth;
			supportsStencil = renderer.stencil;

			const descriptor = this._getDefaultRenderPassDescriptor();

			if ( color ) {

				colorAttachments = descriptor.colorAttachments;

				const colorAttachment = colorAttachments[ 0 ];

				colorAttachment.clearValue = clearValue;
				colorAttachment.loadOp = GPULoadOp.Clear;
				colorAttachment.storeOp = GPUStoreOp.Store;

			}

			if ( supportsDepth || supportsStencil ) {

				depthStencilAttachment = descriptor.depthStencilAttachment;

			}

		} else {

			supportsDepth = renderTargetData.depth;
			supportsStencil = renderTargetData.stencil;

			if ( color ) {

				for ( const texture of renderTargetData.textures ) {

					const textureData = this.get( texture );
					const textureView = textureData.texture.createView();

					let view, resolveTarget;

					if ( textureData.msaaTexture !== undefined ) {

						view = textureData.msaaTexture.createView();
						resolveTarget = textureView;

					} else {

						view = textureView;
						resolveTarget = undefined;

					}

					colorAttachments.push( {
						view,
						resolveTarget,
						clearValue,
						loadOp: GPULoadOp.Clear,
						storeOp: GPUStoreOp.Store
					} );

				}

			}

			if ( supportsDepth || supportsStencil ) {

				const depthTextureData = this.get( renderTargetData.depthTexture );

				depthStencilAttachment = {
					view: depthTextureData.texture.createView()
				};

			}

		}

		//

		if ( supportsDepth ) {

			if ( depth ) {

				depthStencilAttachment.depthLoadOp = GPULoadOp.Clear;
				depthStencilAttachment.depthClearValue = renderer.getClearDepth();
				depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;

			} else {

				depthStencilAttachment.depthLoadOp = GPULoadOp.Load;
				depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;

			}

		}

		//

		if ( supportsStencil ) {

			if ( stencil ) {

				depthStencilAttachment.stencilLoadOp = GPULoadOp.Clear;
				depthStencilAttachment.stencilClearValue = renderer.getClearStencil();
				depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;

			} else {

				depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;
				depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;

			}

		}

		//

		const encoder = device.createCommandEncoder( {} );
		const currentPass = encoder.beginRenderPass( {
			colorAttachments,
			depthStencilAttachment
		} );

		currentPass.end();

		device.queue.submit( [ encoder.finish() ] );

	}

	// compute

	beginCompute( computeGroup ) {

		const groupGPU = this.get( computeGroup );


		const descriptor = {};

		this.initTimestampQuery( computeGroup, descriptor );

		groupGPU.cmdEncoderGPU = this.device.createCommandEncoder();

		groupGPU.passEncoderGPU = groupGPU.cmdEncoderGPU.beginComputePass( descriptor );

	}

	compute( computeGroup, computeNode, bindings, pipeline ) {

		const { passEncoderGPU } = this.get( computeGroup );

		// pipeline

		const pipelineGPU = this.get( pipeline ).pipeline;
		passEncoderGPU.setPipeline( pipelineGPU );

		// bind groups

		for ( let i = 0, l = bindings.length; i < l; i ++ ) {

			const bindGroup = bindings[ i ];
			const bindingsData = this.get( bindGroup );

			passEncoderGPU.setBindGroup( i, bindingsData.group );

		}

		const maxComputeWorkgroupsPerDimension = this.device.limits.maxComputeWorkgroupsPerDimension;

		const computeNodeData = this.get( computeNode );

		if ( computeNodeData.dispatchSize === undefined ) computeNodeData.dispatchSize = { x: 0, y: 1, z: 1 };

		const { dispatchSize } = computeNodeData;

		if ( computeNode.dispatchCount > maxComputeWorkgroupsPerDimension ) {

			dispatchSize.x = Math.min( computeNode.dispatchCount, maxComputeWorkgroupsPerDimension );
			dispatchSize.y = Math.ceil( computeNode.dispatchCount / maxComputeWorkgroupsPerDimension );

		} else {

			dispatchSize.x = computeNode.dispatchCount;

		}

		passEncoderGPU.dispatchWorkgroups(
			dispatchSize.x,
			dispatchSize.y,
			dispatchSize.z
		);

	}

	finishCompute( computeGroup ) {

		const groupData = this.get( computeGroup );

		groupData.passEncoderGPU.end();

		this.prepareTimestampBuffer( computeGroup, groupData.cmdEncoderGPU );

		this.device.queue.submit( [ groupData.cmdEncoderGPU.finish() ] );

	}

	async waitForGPU() {

		await this.device.queue.onSubmittedWorkDone();

	}

	// render object

	draw( renderObject, info ) {

		const { object, context, pipeline } = renderObject;
		const bindings = renderObject.getBindings();
		const renderContextData = this.get( context );
		const pipelineGPU = this.get( pipeline ).pipeline;
		const currentSets = renderContextData.currentSets;
		const passEncoderGPU = renderContextData.currentPass;

		const drawParams = renderObject.getDrawParameters();

		if ( drawParams === null ) return;

		// pipeline

		if ( currentSets.pipeline !== pipelineGPU ) {

			passEncoderGPU.setPipeline( pipelineGPU );

			currentSets.pipeline = pipelineGPU;

		}

		// bind groups

		const currentBindingGroups = currentSets.bindingGroups;

		for ( let i = 0, l = bindings.length; i < l; i ++ ) {

			const bindGroup = bindings[ i ];
			const bindingsData = this.get( bindGroup );

			if ( currentBindingGroups[ bindGroup.index ] !== bindGroup.id ) {

				passEncoderGPU.setBindGroup( bindGroup.index, bindingsData.group );
				currentBindingGroups[ bindGroup.index ] = bindGroup.id;

			}

		}

		// attributes

		const index = renderObject.getIndex();

		const hasIndex = ( index !== null );

		// index

		if ( hasIndex === true ) {

			if ( currentSets.index !== index ) {

				const buffer = this.get( index ).buffer;
				const indexFormat = ( index.array instanceof Uint16Array ) ? GPUIndexFormat.Uint16 : GPUIndexFormat.Uint32;

				passEncoderGPU.setIndexBuffer( buffer, indexFormat );

				currentSets.index = index;

			}

		}

		// vertex buffers

		const vertexBuffers = renderObject.getVertexBuffers();

		for ( let i = 0, l = vertexBuffers.length; i < l; i ++ ) {

			const vertexBuffer = vertexBuffers[ i ];

			if ( currentSets.attributes[ i ] !== vertexBuffer ) {

				const buffer = this.get( vertexBuffer ).buffer;
				passEncoderGPU.setVertexBuffer( i, buffer );

				currentSets.attributes[ i ] = vertexBuffer;

			}

		}

		// occlusion queries - handle multiple consecutive draw calls for an object

		if ( renderContextData.occlusionQuerySet !== undefined ) {

			const lastObject = renderContextData.lastOcclusionObject;

			if ( lastObject !== object ) {

				if ( lastObject !== null && lastObject.occlusionTest === true ) {

					passEncoderGPU.endOcclusionQuery();
					renderContextData.occlusionQueryIndex ++;

				}

				if ( object.occlusionTest === true ) {

					passEncoderGPU.beginOcclusionQuery( renderContextData.occlusionQueryIndex );
					renderContextData.occlusionQueryObjects[ renderContextData.occlusionQueryIndex ] = object;

				}

				renderContextData.lastOcclusionObject = object;

			}

		}

		// draw

		if ( object.isBatchedMesh === true ) {

			const starts = object._multiDrawStarts;
			const counts = object._multiDrawCounts;
			const drawCount = object._multiDrawCount;
			const drawInstances = object._multiDrawInstances;

			const bytesPerElement = hasIndex ? index.array.BYTES_PER_ELEMENT : 1;

			for ( let i = 0; i < drawCount; i ++ ) {

				const count = drawInstances ? drawInstances[ i ] : 1;
				const firstInstance = count > 1 ? 0 : i;

				passEncoderGPU.drawIndexed( counts[ i ], count, starts[ i ] / bytesPerElement, 0, firstInstance );

			}

		} else if ( hasIndex === true ) {

			const { vertexCount: indexCount, instanceCount, firstVertex: firstIndex } = drawParams;

			const indirect = renderObject.getIndirect();

			if ( indirect !== null ) {

				const buffer = this.get( indirect ).buffer;

				passEncoderGPU.drawIndexedIndirect( buffer, 0 );

			} else {

				passEncoderGPU.drawIndexed( indexCount, instanceCount, firstIndex, 0, 0 );

			}

			info.update( object, indexCount, instanceCount );

		} else {

			const { vertexCount, instanceCount, firstVertex } = drawParams;

			const indirect = renderObject.getIndirect();

			if ( indirect !== null ) {

				const buffer = this.get( indirect ).buffer;

				passEncoderGPU.drawIndirect( buffer, 0 );

			} else {

				passEncoderGPU.draw( vertexCount, instanceCount, firstVertex, 0 );

			}

			info.update( object, vertexCount, instanceCount );

		}

	}

	// cache key

	needsRenderUpdate( renderObject ) {

		const data = this.get( renderObject );

		const { object, material } = renderObject;

		const utils = this.utils;

		const sampleCount = utils.getSampleCountRenderContext( renderObject.context );
		const colorSpace = utils.getCurrentColorSpace( renderObject.context );
		const colorFormat = utils.getCurrentColorFormat( renderObject.context );
		const depthStencilFormat = utils.getCurrentDepthStencilFormat( renderObject.context );
		const primitiveTopology = utils.getPrimitiveTopology( object, material );

		let needsUpdate = false;

		if ( data.material !== material || data.materialVersion !== material.version ||
			data.transparent !== material.transparent || data.blending !== material.blending || data.premultipliedAlpha !== material.premultipliedAlpha ||
			data.blendSrc !== material.blendSrc || data.blendDst !== material.blendDst || data.blendEquation !== material.blendEquation ||
			data.blendSrcAlpha !== material.blendSrcAlpha || data.blendDstAlpha !== material.blendDstAlpha || data.blendEquationAlpha !== material.blendEquationAlpha ||
			data.colorWrite !== material.colorWrite || data.depthWrite !== material.depthWrite || data.depthTest !== material.depthTest || data.depthFunc !== material.depthFunc ||
			data.stencilWrite !== material.stencilWrite || data.stencilFunc !== material.stencilFunc ||
			data.stencilFail !== material.stencilFail || data.stencilZFail !== material.stencilZFail || data.stencilZPass !== material.stencilZPass ||
			data.stencilFuncMask !== material.stencilFuncMask || data.stencilWriteMask !== material.stencilWriteMask ||
			data.side !== material.side || data.alphaToCoverage !== material.alphaToCoverage ||
			data.sampleCount !== sampleCount || data.colorSpace !== colorSpace ||
			data.colorFormat !== colorFormat || data.depthStencilFormat !== depthStencilFormat ||
			data.primitiveTopology !== primitiveTopology ||
			data.clippingContextCacheKey !== renderObject.clippingContextCacheKey
		) {

			data.material = material; data.materialVersion = material.version;
			data.transparent = material.transparent; data.blending = material.blending; data.premultipliedAlpha = material.premultipliedAlpha;
			data.blendSrc = material.blendSrc; data.blendDst = material.blendDst; data.blendEquation = material.blendEquation;
			data.blendSrcAlpha = material.blendSrcAlpha; data.blendDstAlpha = material.blendDstAlpha; data.blendEquationAlpha = material.blendEquationAlpha;
			data.colorWrite = material.colorWrite;
			data.depthWrite = material.depthWrite; data.depthTest = material.depthTest; data.depthFunc = material.depthFunc;
			data.stencilWrite = material.stencilWrite; data.stencilFunc = material.stencilFunc;
			data.stencilFail = material.stencilFail; data.stencilZFail = material.stencilZFail; data.stencilZPass = material.stencilZPass;
			data.stencilFuncMask = material.stencilFuncMask; data.stencilWriteMask = material.stencilWriteMask;
			data.side = material.side; data.alphaToCoverage = material.alphaToCoverage;
			data.sampleCount = sampleCount;
			data.colorSpace = colorSpace;
			data.colorFormat = colorFormat;
			data.depthStencilFormat = depthStencilFormat;
			data.primitiveTopology = primitiveTopology;
			data.clippingContextCacheKey = renderObject.clippingContextCacheKey;

			needsUpdate = true;

		}

		return needsUpdate;

	}

	getRenderCacheKey( renderObject ) {

		const { object, material } = renderObject;

		const utils = this.utils;
		const renderContext = renderObject.context;

		return [
			material.transparent, material.blending, material.premultipliedAlpha,
			material.blendSrc, material.blendDst, material.blendEquation,
			material.blendSrcAlpha, material.blendDstAlpha, material.blendEquationAlpha,
			material.colorWrite,
			material.depthWrite, material.depthTest, material.depthFunc,
			material.stencilWrite, material.stencilFunc,
			material.stencilFail, material.stencilZFail, material.stencilZPass,
			material.stencilFuncMask, material.stencilWriteMask,
			material.side,
			utils.getSampleCountRenderContext( renderContext ),
			utils.getCurrentColorSpace( renderContext ), utils.getCurrentColorFormat( renderContext ), utils.getCurrentDepthStencilFormat( renderContext ),
			utils.getPrimitiveTopology( object, material ),
			renderObject.getGeometryCacheKey(),
			renderObject.clippingContextCacheKey
		].join();

	}

	// textures

	createSampler( texture ) {

		this.textureUtils.createSampler( texture );

	}

	destroySampler( texture ) {

		this.textureUtils.destroySampler( texture );

	}

	createDefaultTexture( texture ) {

		this.textureUtils.createDefaultTexture( texture );

	}

	createTexture( texture, options ) {

		this.textureUtils.createTexture( texture, options );

	}

	updateTexture( texture, options ) {

		this.textureUtils.updateTexture( texture, options );

	}

	generateMipmaps( texture ) {

		this.textureUtils.generateMipmaps( texture );

	}

	destroyTexture( texture ) {

		this.textureUtils.destroyTexture( texture );

	}

	copyTextureToBuffer( texture, x, y, width, height, faceIndex ) {

		return this.textureUtils.copyTextureToBuffer( texture, x, y, width, height, faceIndex );

	}


	initTimestampQuery( renderContext, descriptor ) {

		if ( ! this.trackTimestamp ) return;

		const renderContextData = this.get( renderContext );

		if ( ! renderContextData.timeStampQuerySet ) {


			const type = renderContext.isComputeNode ? 'compute' : 'render';
			const timeStampQuerySet = this.device.createQuerySet( { type: 'timestamp', count: 2, label: `timestamp_${type}_${renderContext.id}` } );

			const timestampWrites = {
				querySet: timeStampQuerySet,
				beginningOfPassWriteIndex: 0, // Write timestamp in index 0 when pass begins.
				endOfPassWriteIndex: 1, // Write timestamp in index 1 when pass ends.
			};

			Object.assign( descriptor, { timestampWrites } );

			renderContextData.timeStampQuerySet = timeStampQuerySet;

		}

	}

	// timestamp utils

	prepareTimestampBuffer( renderContext, encoder ) {

		if ( ! this.trackTimestamp ) return;

		const renderContextData = this.get( renderContext );


		const size = 2 * BigInt64Array.BYTES_PER_ELEMENT;

		if ( renderContextData.currentTimestampQueryBuffers === undefined ) {

			renderContextData.currentTimestampQueryBuffers = {
				resolveBuffer: this.device.createBuffer( {
					label: 'timestamp resolve buffer',
					size: size,
					usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC,
				} ),
				resultBuffer: this.device.createBuffer( {
					label: 'timestamp result buffer',
					size: size,
					usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
				} )
			};

		}

		const { resolveBuffer, resultBuffer } = renderContextData.currentTimestampQueryBuffers;


		encoder.resolveQuerySet( renderContextData.timeStampQuerySet, 0, 2, resolveBuffer, 0 );

		if ( resultBuffer.mapState === 'unmapped' ) {

			encoder.copyBufferToBuffer( resolveBuffer, 0, resultBuffer, 0, size );

		}

	}

	async resolveTimestampAsync( renderContext, type = 'render' ) {

		if ( ! this.trackTimestamp ) return;

		const renderContextData = this.get( renderContext );

		if ( renderContextData.currentTimestampQueryBuffers === undefined ) return;

		const { resultBuffer } = renderContextData.currentTimestampQueryBuffers;

		await this.device.queue.onSubmittedWorkDone();

		if ( resultBuffer.mapState === 'unmapped' ) {

			resultBuffer.mapAsync( GPUMapMode.READ ).then( () => {

				const times = new BigUint64Array( resultBuffer.getMappedRange() );
				const duration = Number( times[ 1 ] - times[ 0 ] ) / 1000000;


				this.renderer.info.updateTimestamp( type, duration );

				resultBuffer.unmap();


			} );

		}

	}

	// node builder

	createNodeBuilder( object, renderer ) {

		return new WGSLNodeBuilder( object, renderer );

	}

	// program

	createProgram( program ) {

		const programGPU = this.get( program );

		programGPU.module = {
			module: this.device.createShaderModule( { code: program.code, label: program.stage } ),
			entryPoint: 'main'
		};

	}

	destroyProgram( program ) {

		this.delete( program );

	}

	// pipelines

	createRenderPipeline( renderObject, promises ) {

		this.pipelineUtils.createRenderPipeline( renderObject, promises );

	}

	createComputePipeline( computePipeline, bindings ) {

		this.pipelineUtils.createComputePipeline( computePipeline, bindings );

	}

	beginBundle( renderContext ) {

		const renderContextData = this.get( renderContext );

		renderContextData._currentPass = renderContextData.currentPass;
		renderContextData._currentSets = renderContextData.currentSets;

		renderContextData.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null };
		renderContextData.currentPass = this.pipelineUtils.createBundleEncoder( renderContext );

	}

	finishBundle( renderContext, bundle ) {

		const renderContextData = this.get( renderContext );

		const bundleEncoder = renderContextData.currentPass;
		const bundleGPU = bundleEncoder.finish();

		this.get( bundle ).bundleGPU = bundleGPU;

		// restore render pass state

		renderContextData.currentSets = renderContextData._currentSets;
		renderContextData.currentPass = renderContextData._currentPass;

	}

	addBundle( renderContext, bundle ) {

		const renderContextData = this.get( renderContext );

		renderContextData.renderBundles.push( this.get( bundle ).bundleGPU );

	}

	// bindings

	createBindings( bindGroup, bindings, cacheIndex, version ) {

		this.bindingUtils.createBindings( bindGroup, bindings, cacheIndex, version );

	}

	updateBindings( bindGroup, bindings, cacheIndex, version ) {

		this.bindingUtils.createBindings( bindGroup, bindings, cacheIndex, version );

	}

	updateBinding( binding ) {

		this.bindingUtils.updateBinding( binding );

	}

	// attributes

	createIndexAttribute( attribute ) {

		this.attributeUtils.createAttribute( attribute, GPUBufferUsage.INDEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST );

	}

	createAttribute( attribute ) {

		this.attributeUtils.createAttribute( attribute, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST );

	}

	createStorageAttribute( attribute ) {

		this.attributeUtils.createAttribute( attribute, GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST );

	}

	createIndirectStorageAttribute( attribute ) {

		this.attributeUtils.createAttribute( attribute, GPUBufferUsage.STORAGE | GPUBufferUsage.INDIRECT | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST );

	}

	updateAttribute( attribute ) {

		this.attributeUtils.updateAttribute( attribute );

	}

	destroyAttribute( attribute ) {

		this.attributeUtils.destroyAttribute( attribute );

	}

	// canvas

	updateSize() {

		this.colorBuffer = this.textureUtils.getColorBuffer();
		this.defaultRenderPassdescriptor = null;

	}

	// utils public

	getMaxAnisotropy() {

		return 16;

	}

	hasFeature( name ) {

		return this.device.features.has( name );

	}

	copyTextureToTexture( srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0 ) {

		let dstX = 0;
		let dstY = 0;
		let dstLayer = 0;

		let srcX = 0;
		let srcY = 0;
		let srcLayer = 0;

		let srcWidth = srcTexture.image.width;
		let srcHeight = srcTexture.image.height;

		if ( srcRegion !== null ) {

			srcX = srcRegion.x;
			srcY = srcRegion.y;
			srcLayer = srcRegion.z || 0;
			srcWidth = srcRegion.width;
			srcHeight = srcRegion.height;

		}

		if ( dstPosition !== null ) {

			dstX = dstPosition.x;
			dstY = dstPosition.y;
			dstLayer = dstPosition.z || 0;

		}

		const encoder = this.device.createCommandEncoder( { label: 'copyTextureToTexture_' + srcTexture.id + '_' + dstTexture.id } );

		const sourceGPU = this.get( srcTexture ).texture;
		const destinationGPU = this.get( dstTexture ).texture;

		encoder.copyTextureToTexture(
			{
				texture: sourceGPU,
				mipLevel: level,
				origin: { x: srcX, y: srcY, z: srcLayer }
			},
			{
				texture: destinationGPU,
				mipLevel: level,
				origin: { x: dstX, y: dstY, z: dstLayer }
			},
			[
				srcWidth,
				srcHeight,
				1
			]
		);

		this.device.queue.submit( [ encoder.finish() ] );

	}

	copyFramebufferToTexture( texture, renderContext, rectangle ) {

		const renderContextData = this.get( renderContext );

		let sourceGPU = null;

		if ( renderContext.renderTarget ) {

			if ( texture.isDepthTexture ) {

				sourceGPU = this.get( renderContext.depthTexture ).texture;

			} else {

				sourceGPU = this.get( renderContext.textures[ 0 ] ).texture;

			}

		} else {

			if ( texture.isDepthTexture ) {

				sourceGPU = this.textureUtils.getDepthBuffer( renderContext.depth, renderContext.stencil );

			} else {

				sourceGPU = this.context.getCurrentTexture();

			}

		}

		const destinationGPU = this.get( texture ).texture;

		if ( sourceGPU.format !== destinationGPU.format ) {

			console.error( 'WebGPUBackend: copyFramebufferToTexture: Source and destination formats do not match.', sourceGPU.format, destinationGPU.format );

			return;

		}

		let encoder;

		if ( renderContextData.currentPass ) {

			renderContextData.currentPass.end();

			encoder = renderContextData.encoder;

		} else {

			encoder = this.device.createCommandEncoder( { label: 'copyFramebufferToTexture_' + texture.id } );

		}

		encoder.copyTextureToTexture(
			{
				texture: sourceGPU,
				origin: [ rectangle.x, rectangle.y, 0 ],
			},
			{
				texture: destinationGPU
			},
			[
				rectangle.z,
				rectangle.w
			]
		);

		if ( texture.generateMipmaps ) this.textureUtils.generateMipmaps( texture );

		if ( renderContextData.currentPass ) {

			const { descriptor } = renderContextData;

			for ( let i = 0; i < descriptor.colorAttachments.length; i ++ ) {

				descriptor.colorAttachments[ i ].loadOp = GPULoadOp.Load;

			}

			if ( renderContext.depth ) descriptor.depthStencilAttachment.depthLoadOp = GPULoadOp.Load;
			if ( renderContext.stencil ) descriptor.depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;

			renderContextData.currentPass = encoder.beginRenderPass( descriptor );
			renderContextData.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null };

			if ( renderContext.viewport ) {

				this.updateViewport( renderContext );

			}

			if ( renderContext.scissor ) {

				const { x, y, width, height } = renderContext.scissorValue;

				renderContextData.currentPass.setScissorRect( x, y, width, height );

			}

		} else {

			this.device.queue.submit( [ encoder.finish() ] );

		}

	}

}

class IESSpotLight extends SpotLight {

	constructor( color, intensity, distance, angle, penumbra, decay ) {

		super( color, intensity, distance, angle, penumbra, decay );

		this.iesMap = null;

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.iesMap = source.iesMap;

		return this;

	}

}

class StandardNodeLibrary extends NodeLibrary {

	constructor() {

		super();

		this.addMaterial( MeshPhongNodeMaterial, 'MeshPhongMaterial' );
		this.addMaterial( MeshStandardNodeMaterial, 'MeshStandardMaterial' );
		this.addMaterial( MeshPhysicalNodeMaterial, 'MeshPhysicalMaterial' );
		this.addMaterial( MeshToonNodeMaterial, 'MeshToonMaterial' );
		this.addMaterial( MeshBasicNodeMaterial, 'MeshBasicMaterial' );
		this.addMaterial( MeshLambertNodeMaterial, 'MeshLambertMaterial' );
		this.addMaterial( MeshNormalNodeMaterial, 'MeshNormalMaterial' );
		this.addMaterial( MeshMatcapNodeMaterial, 'MeshMatcapMaterial' );
		this.addMaterial( LineBasicNodeMaterial, 'LineBasicMaterial' );
		this.addMaterial( LineDashedNodeMaterial, 'LineDashedMaterial' );
		this.addMaterial( PointsNodeMaterial, 'PointsMaterial' );
		this.addMaterial( SpriteNodeMaterial, 'SpriteMaterial' );
		this.addMaterial( ShadowNodeMaterial, 'ShadowMaterial' );

		this.addLight( PointLightNode, PointLight );
		this.addLight( DirectionalLightNode, DirectionalLight );
		this.addLight( RectAreaLightNode, RectAreaLight );
		this.addLight( SpotLightNode, SpotLight );
		this.addLight( AmbientLightNode, AmbientLight );
		this.addLight( HemisphereLightNode, HemisphereLight );
		this.addLight( LightProbeNode, LightProbe );
		this.addLight( IESSpotLightNode, IESSpotLight );

		this.addToneMapping( linearToneMapping, LinearToneMapping );
		this.addToneMapping( reinhardToneMapping, ReinhardToneMapping );
		this.addToneMapping( cineonToneMapping, CineonToneMapping );
		this.addToneMapping( acesFilmicToneMapping, ACESFilmicToneMapping );
		this.addToneMapping( agxToneMapping, AgXToneMapping );
		this.addToneMapping( neutralToneMapping, NeutralToneMapping );

	}

}

/*
const debugHandler = {

	get: function ( target, name ) {

		// Add |update
		if ( /^(create|destroy)/.test( name ) ) console.log( 'WebGPUBackend.' + name );

		return target[ name ];

	}

};
*/
class WebGPURenderer extends Renderer {

	constructor( parameters = {} ) {

		let BackendClass;

		if ( parameters.forceWebGL ) {

			BackendClass = WebGLBackend;

		} else {

			BackendClass = WebGPUBackend;

			parameters.getFallback = () => {

				console.warn( 'THREE.WebGPURenderer: WebGPU is not available, running under WebGL2 backend.' );

				return new WebGLBackend( parameters );

			};

		}

		const backend = new BackendClass( parameters );

		//super( new Proxy( backend, debugHandler ) );
		super( backend, parameters );

		this.library = new StandardNodeLibrary();

		this.isWebGPURenderer = true;

	}

}

/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */

TSL.BRDF_GGX;
TSL.BRDF_Lambert;
TSL.BasicShadowFilter;
TSL.Break;
TSL.Continue;
TSL.DFGApprox;
TSL.D_GGX;
TSL.Discard;
TSL.EPSILON;
TSL.F_Schlick;
const Fn = TSL.Fn;
TSL.INFINITY;
TSL.If;
TSL.Loop;
TSL.NodeShaderStage;
TSL.NodeType;
TSL.NodeUpdateType;
TSL.NodeAccess;
TSL.PCFShadowFilter;
TSL.PCFSoftShadowFilter;
TSL.PI;
TSL.PI2;
TSL.Return;
TSL.Schlick_to_F0;
TSL.ScriptableNodeResources;
TSL.ShaderNode;
TSL.TBNViewMatrix;
TSL.VSMShadowFilter;
TSL.V_GGX_SmithCorrelated;
const abs = TSL.abs;
TSL.acesFilmicToneMapping;
TSL.acos;
const add = TSL.add;
TSL.addMethodChaining;
TSL.addNodeElement;
TSL.agxToneMapping;
TSL.all;
TSL.alphaT;
TSL.and;
TSL.anisotropy;
TSL.anisotropyB;
TSL.anisotropyT;
TSL.any;
TSL.append;
TSL.arrayBuffer;
TSL.asin;
TSL.assign;
TSL.atan;
TSL.atan2;
TSL.atomicAdd;
TSL.atomicAnd;
TSL.atomicFunc;
TSL.atomicMax;
TSL.atomicMin;
TSL.atomicOr;
TSL.atomicStore;
TSL.atomicSub;
TSL.atomicXor;
TSL.attenuationColor;
TSL.attenuationDistance;
const attribute = TSL.attribute;
TSL.attributeArray;
TSL.backgroundBlurriness;
TSL.backgroundIntensity;
TSL.backgroundRotation;
TSL.batch;
TSL.billboarding;
TSL.bitAnd;
TSL.bitNot;
TSL.bitOr;
TSL.bitXor;
TSL.bitangentGeometry;
TSL.bitangentLocal;
TSL.bitangentView;
TSL.bitangentWorld;
TSL.bitcast;
TSL.blendBurn;
TSL.blendColor;
TSL.blendDodge;
TSL.blendOverlay;
TSL.blendScreen;
TSL.blur;
TSL.bool;
TSL.buffer;
TSL.bufferAttribute;
TSL.bumpMap;
TSL.burn;
TSL.bvec2;
TSL.bvec3;
TSL.bvec4;
TSL.bypass;
TSL.cache;
TSL.call;
TSL.cameraFar;
TSL.cameraNear;
TSL.cameraNormalMatrix;
const cameraPosition = TSL.cameraPosition;
TSL.cameraProjectionMatrix;
TSL.cameraProjectionMatrixInverse;
TSL.cameraViewMatrix;
TSL.cameraWorldMatrix;
TSL.cbrt;
TSL.cdl;
TSL.ceil;
TSL.checker;
TSL.cineonToneMapping;
TSL.clamp;
TSL.clearcoat;
TSL.clearcoatRoughness;
TSL.code;
const color = TSL.color;
TSL.colorSpaceToWorking;
TSL.colorToDirection;
TSL.compute;
TSL.cond;
TSL.context;
TSL.convert;
TSL.convertColorSpace;
TSL.convertToTexture;
const cos = TSL.cos;
TSL.cross;
TSL.cubeTexture;
TSL.dFdx;
TSL.dFdy;
TSL.dashSize;
TSL.defaultBuildStages;
TSL.defaultShaderStages;
TSL.defined;
TSL.degrees;
TSL.deltaTime;
TSL.densityFog;
TSL.depth;
TSL.depthPass;
TSL.difference;
TSL.diffuseColor;
TSL.directPointLight;
TSL.directionToColor;
TSL.dispersion;
const distance = TSL.distance;
const div = TSL.div;
TSL.dodge;
const dot = TSL.dot;
TSL.drawIndex;
TSL.dynamicBufferAttribute;
TSL.element;
TSL.emissive;
TSL.equal;
TSL.equals;
TSL.equirectUV;
const exp = TSL.exp;
TSL.exp2;
TSL.expression;
TSL.faceDirection;
TSL.faceForward;
const float = TSL.float;
const floor = TSL.floor;
TSL.fog;
const fract = TSL.fract;
TSL.frameGroup;
TSL.frameId;
TSL.frontFacing;
TSL.fwidth;
TSL.gain;
TSL.gapSize;
TSL.getConstNodeType;
TSL.getCurrentStack;
TSL.getDirection;
TSL.getDistanceAttenuation;
TSL.getGeometryRoughness;
TSL.getNormalFromDepth;
TSL.getParallaxCorrectNormal;
TSL.getRoughness;
TSL.getScreenPosition;
TSL.getShIrradianceAt;
TSL.getTextureIndex;
TSL.getViewPosition;
TSL.glsl;
TSL.glslFn;
TSL.grayscale;
TSL.greaterThan;
TSL.greaterThanEqual;
TSL.hash;
TSL.highPrecisionModelNormalViewMatrix;
TSL.highPrecisionModelViewMatrix;
TSL.hue;
TSL.instance;
TSL.instanceIndex;
TSL.instancedArray;
TSL.instancedBufferAttribute;
TSL.instancedDynamicBufferAttribute;
TSL.instancedMesh;
TSL.int;
TSL.inverseSqrt;
TSL.invocationLocalIndex;
TSL.invocationSubgroupIndex;
TSL.ior;
TSL.iridescence;
TSL.iridescenceIOR;
TSL.iridescenceThickness;
TSL.ivec2;
TSL.ivec3;
TSL.ivec4;
TSL.js;
TSL.label;
TSL.length;
TSL.lengthSq;
TSL.lessThan;
TSL.lessThanEqual;
TSL.lightPosition;
TSL.lightTargetDirection;
TSL.lightTargetPosition;
TSL.lightViewPosition;
TSL.lightingContext;
TSL.lights;
TSL.linearDepth;
TSL.linearToneMapping;
TSL.localId;
TSL.log;
TSL.log2;
TSL.logarithmicDepthToViewZ;
TSL.loop;
TSL.luminance;
TSL.mat2;
TSL.mat3;
TSL.mat4;
TSL.matcapUV;
TSL.materialAOMap;
TSL.materialAlphaTest;
TSL.materialAnisotropy;
TSL.materialAnisotropyVector;
TSL.materialAttenuationColor;
TSL.materialAttenuationDistance;
TSL.materialClearcoat;
TSL.materialClearcoatNormal;
TSL.materialClearcoatRoughness;
TSL.materialColor;
TSL.materialDispersion;
TSL.materialEmissive;
TSL.materialIOR;
TSL.materialIridescence;
TSL.materialIridescenceIOR;
TSL.materialIridescenceThickness;
TSL.materialLightMap;
TSL.materialLineDashOffset;
TSL.materialLineDashSize;
TSL.materialLineGapSize;
TSL.materialLineScale;
TSL.materialLineWidth;
TSL.materialMetalness;
TSL.materialNormal;
TSL.materialOpacity;
TSL.materialPointWidth;
TSL.materialReference;
TSL.materialReflectivity;
TSL.materialRefractionRatio;
TSL.materialRotation;
TSL.materialRoughness;
TSL.materialSheen;
TSL.materialSheenRoughness;
TSL.materialShininess;
TSL.materialSpecular;
TSL.materialSpecularColor;
TSL.materialSpecularIntensity;
TSL.materialSpecularStrength;
TSL.materialThickness;
TSL.materialTransmission;
const max = TSL.max;
TSL.maxMipLevel;
TSL.metalness;
TSL.min;
const mix = TSL.mix;
TSL.mixElement;
TSL.mod;
TSL.modInt;
TSL.modelDirection;
TSL.modelNormalMatrix;
TSL.modelPosition;
TSL.modelScale;
TSL.modelViewMatrix;
TSL.modelViewPosition;
TSL.modelViewProjection;
TSL.modelWorldMatrix;
TSL.modelWorldMatrixInverse;
TSL.morphReference;
TSL.mrt;
const mul = TSL.mul;
TSL.mx_aastep;
TSL.mx_cell_noise_float;
TSL.mx_contrast;
TSL.mx_fractal_noise_float;
TSL.mx_fractal_noise_vec2;
TSL.mx_fractal_noise_vec3;
TSL.mx_fractal_noise_vec4;
TSL.mx_hsvtorgb;
const mx_noise_float = TSL.mx_noise_float;
TSL.mx_noise_vec3;
TSL.mx_noise_vec4;
TSL.mx_ramplr;
TSL.mx_ramptb;
TSL.mx_rgbtohsv;
TSL.mx_safepower;
TSL.mx_splitlr;
TSL.mx_splittb;
TSL.mx_srgb_texture_to_lin_rec709;
TSL.mx_transform_uv;
TSL.mx_worley_noise_float;
TSL.mx_worley_noise_vec2;
TSL.mx_worley_noise_vec3;
TSL.negate;
TSL.neutralToneMapping;
TSL.nodeArray;
TSL.nodeImmutable;
TSL.nodeObject;
TSL.nodeObjects;
TSL.nodeProxy;
TSL.normalFlat;
TSL.normalGeometry;
TSL.normalLocal;
TSL.normalMap;
const normalView = TSL.normalView;
const normalWorld = TSL.normalWorld;
const normalize = TSL.normalize;
TSL.not;
TSL.notEqual;
TSL.numWorkgroups;
TSL.objectDirection;
TSL.objectGroup;
TSL.objectPosition;
TSL.objectScale;
TSL.objectViewPosition;
TSL.objectWorldMatrix;
TSL.oneMinus;
TSL.or;
TSL.orthographicDepthToViewZ;
TSL.oscSawtooth;
TSL.oscSine;
TSL.oscSquare;
TSL.oscTriangle;
TSL.output;
TSL.outputStruct;
TSL.overlay;
TSL.overloadingFn;
TSL.parabola;
TSL.parallaxDirection;
TSL.parallaxUV;
TSL.parameter;
TSL.pass;
TSL.passTexture;
TSL.pcurve;
TSL.perspectiveDepthToViewZ;
TSL.pmremTexture;
TSL.pointUV;
TSL.pointWidth;
TSL.positionGeometry;
const positionLocal = TSL.positionLocal;
TSL.positionPrevious;
TSL.positionView;
TSL.positionViewDirection;
const positionWorld = TSL.positionWorld;
TSL.positionWorldDirection;
TSL.posterize;
const pow = TSL.pow;
TSL.pow2;
TSL.pow3;
TSL.pow4;
TSL.property;
TSL.radians;
TSL.rand;
TSL.range;
TSL.rangeFog;
TSL.reciprocal;
TSL.reference;
TSL.referenceBuffer;
TSL.reflect;
TSL.reflectVector;
TSL.reflectView;
TSL.reflector;
TSL.refract;
TSL.refractVector;
TSL.refractView;
TSL.reinhardToneMapping;
TSL.remainder;
TSL.remap;
TSL.remapClamp;
TSL.renderGroup;
TSL.renderOutput;
TSL.rendererReference;
TSL.rotate;
TSL.rotateUV;
TSL.roughness;
TSL.round;
TSL.rtt;
TSL.sRGBTransferEOTF;
TSL.sRGBTransferOETF;
TSL.sampler;
TSL.saturate;
TSL.saturation;
TSL.screen;
TSL.screenCoordinate;
TSL.screenSize;
TSL.screenUV;
TSL.scriptable;
TSL.scriptableValue;
TSL.select;
TSL.setCurrentStack;
TSL.shaderStages;
TSL.shadow;
TSL.sharedUniformGroup;
TSL.sheen;
TSL.sheenRoughness;
TSL.shiftLeft;
TSL.shiftRight;
TSL.shininess;
TSL.sign;
const sin = TSL.sin;
TSL.sinc;
TSL.skinning;
TSL.skinningReference;
const smoothstep = TSL.smoothstep;
TSL.smoothstepElement;
TSL.specularColor;
TSL.specularF90;
TSL.spherizeUV;
TSL.split;
TSL.spritesheetUV;
TSL.sqrt;
TSL.stack;
TSL.step;
TSL.storage;
TSL.storageBarrier;
TSL.storageObject;
TSL.storageTexture;
TSL.string;
const sub = TSL.sub;
TSL.subgroupIndex;
TSL.subgroupSize;
TSL.tan;
TSL.tangentGeometry;
TSL.tangentLocal;
TSL.tangentView;
TSL.tangentWorld;
TSL.temp;
TSL.texture;
TSL.texture3D;
TSL.textureBarrier;
TSL.textureBicubic;
TSL.textureCubeUV;
TSL.textureLoad;
TSL.textureSize;
TSL.textureStore;
TSL.thickness;
TSL.threshold;
const time = TSL.time;
TSL.timerDelta;
TSL.timerGlobal;
TSL.timerLocal;
TSL.toOutputColorSpace;
TSL.toWorkingColorSpace;
TSL.toneMapping;
TSL.toneMappingExposure;
TSL.toonOutlinePass;
TSL.transformDirection;
TSL.transformNormal;
TSL.transformNormalToView;
TSL.transformedBentNormalView;
TSL.transformedBitangentView;
TSL.transformedBitangentWorld;
TSL.transformedClearcoatNormalView;
TSL.transformedNormalView;
TSL.transformedNormalWorld;
TSL.transformedTangentView;
TSL.transformedTangentWorld;
TSL.transmission;
TSL.transpose;
TSL.tri;
TSL.tri3;
TSL.triNoise3D;
TSL.triplanarTexture;
TSL.triplanarTextures;
TSL.trunc;
TSL.tslFn;
TSL.uint;
const uniform = TSL.uniform;
TSL.uniformArray;
TSL.uniformGroup;
TSL.uniforms;
TSL.userData;
const uv = TSL.uv;
TSL.uvec2;
TSL.uvec3;
TSL.uvec4;
TSL.varying;
TSL.varyingProperty;
const vec2 = TSL.vec2;
const vec3 = TSL.vec3;
const vec4 = TSL.vec4;
TSL.vectorComponents;
TSL.velocity;
TSL.vertexColor;
TSL.vertexIndex;
TSL.vibrance;
TSL.viewZToLogarithmicDepth;
TSL.viewZToOrthographicDepth;
TSL.viewZToPerspectiveDepth;
TSL.viewport;
TSL.viewportBottomLeft;
TSL.viewportCoordinate;
TSL.viewportDepthTexture;
TSL.viewportLinearDepth;
TSL.viewportMipTexture;
TSL.viewportResolution;
TSL.viewportSafeUV;
TSL.viewportSharedTexture;
TSL.viewportSize;
TSL.viewportTexture;
TSL.viewportTopLeft;
TSL.viewportUV;
TSL.wgsl;
TSL.wgslFn;
TSL.workgroupArray;
TSL.workgroupBarrier;
TSL.workgroupId;
TSL.workingToColorSpace;
TSL.xor;

// Global uniform for glitch intensity (0.0 to 1.0)
// This should be updated by MusicReactivitySystem when 9xx commands are detected.
const uGlitchIntensity = uniform(0.0);

/**
 * TSL Function to apply a "Sample-Offset Glitch" effect.
 * It combines UV pixelation (sample offset) and vertex jitter.
 *
 * NOTE: This is a standard JS function (not wrapped in Fn) because it returns
 * a JS object containing multiple Nodes { uv, position }, which Fn cannot handle.
 *
 * @param {Node} baseUV - The original UV coordinates.
 * @param {Node} basePosition - The original vertex position.
 * @param {Node} intensity - Glitch intensity (0-1).
 * @returns {Object} { uv: glitchedUV, position: glitchedPosition }
 */
const applyGlitch = (baseUV, basePosition, intensity) => {
    // 1. Pixelation / Blockiness (Sample Offset)
    // Reduce UV resolution based on intensity
    // As intensity increases, blocks get larger (resolution gets smaller)

    // Safety clamp to avoid division by zero or negative resolution
    const resolution = mix(float(100.0), float(10.0), intensity);

    // Pixelate UVs
    const pixelatedUV = floor(baseUV.mul(resolution)).div(resolution);

    // Mix between original and pixelated based on intensity threshold
    // We only glitch when intensity is significant (> 0.1)
    const isGlitchy = smoothstep(float(0.1), float(0.3), intensity);
    const resultUV = mix(baseUV, pixelatedUV, isGlitchy);

    // 2. Vertex Jitter
    // Random offset based on position and time (using a simple hash-like logic)
    
    const jitterAmount = float(0.5).mul(intensity); // Max jitter distance

    // Pseudo-random offset
    // sin(x * big_number) creates high frequency oscillation
    // Explicit float() wrapping for safety
    const noiseX = sin(basePosition.y.mul(float(50.0)).add(intensity.mul(float(100.0))));
    const noiseY = cos(basePosition.x.mul(float(50.0)).add(intensity.mul(float(100.0))));
    const noiseZ = sin(basePosition.z.mul(float(50.0)));

    const offset = vec3(noiseX, noiseY, noiseZ).mul(jitterAmount);

    // Apply jitter only when glitch is active
    const resultPos = basePosition.add(offset.mul(isGlitchy));

    return { uv: resultUV, position: resultPos };
};

// src/foliage/common.js


// --- Shared Resources & Geometries ---
const sharedGeometries = {
    unitSphere: new SphereGeometry(1, 16, 16),
    unitCylinder: new CylinderGeometry(1, 1, 1, 12).translate(0, 0.5, 0), // Pivot at bottom
    unitCone: new ConeGeometry(1, 1, 16).translate(0, 0.5, 0), // Pivot at bottom
    quad: new PlaneGeometry(1, 1),

    // Common convenience aliases
    sphere: new SphereGeometry(1, 16, 16),
    sphereLow: new SphereGeometry(1, 8, 8),
    cylinder: new CylinderGeometry(1, 1, 1, 12).translate(0, 0.5, 0),
    cylinderLow: new CylinderGeometry(1, 1, 1, 8).translate(0, 0.5, 0),
    capsule: new CapsuleGeometry(0.5, 1, 6, 8),
    eye: new SphereGeometry(0.12, 16, 16),
    pupil: new SphereGeometry(0.05, 12, 12)
};

const eyeGeo = sharedGeometries.eye;
let reactivityCounter = 0; 
const reactiveMaterials = []; 
const _foliageReactiveColor = new Color(); 
const uWindSpeed = uniform(0.0);
const uWindDirection = uniform(new Vector3(1, 0, 0));
const uTime = uniform(0.0); 

function median(arr) {
    if (arr.length === 0) return 0;
    const sorted = [...arr].sort((a, b) => a - b);
    const mid = Math.floor(sorted.length / 2);
    return sorted.length % 2 !== 0 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
}

// --- TSL UTILITY FUNCTIONS ---

const triplanarNoise = Fn((pos, scale) => {
    const p = mul(pos, scale);
    const n = abs(normalWorld);

    // FIX: float(0.0)
    const noiseX = mx_noise_float(vec3(p.y, p.z, float(0.0)));
    const noiseY = mx_noise_float(vec3(p.x, p.z, float(0.0)));
    const noiseZ = mx_noise_float(vec3(p.x, p.y, float(0.0)));

    const nSum = add(n.x, n.y).add(n.z);
    const blend = div(n, nSum);

    const termX = mul(noiseX, blend.x);
    const termY = mul(noiseY, blend.y);
    const termZ = mul(noiseZ, blend.z);

    return add(termX, termY).add(termZ);
});

const perturbNormal = Fn((pos, normal, scale, strength) => {
    const eps = float(0.01);
    const s = scale;

    const n0 = mx_noise_float(mul(pos, s));

    // FIX: float(0.0)
    const posX = mul(add(pos, vec3(eps, float(0.0), float(0.0))), s);
    const nX = mx_noise_float(posX);

    const posY = mul(add(pos, vec3(float(0.0), eps, float(0.0))), s);
    const nY = mx_noise_float(posY);

    const posZ = mul(add(pos, vec3(float(0.0), float(0.0), eps)), s);
    const nZ = mx_noise_float(posZ);

    const dx = div(sub(nX, n0), eps);
    const dy = div(sub(nY, n0), eps);
    const dz = div(sub(nZ, n0), eps);

    const noiseGrad = vec3(dx, dy, dz);
    const perturbed = normalize(sub(normal, mul(noiseGrad, strength)));
    return perturbed;
});

Fn((baseColorNode, normalNode, viewDirNode) => {
    const rimPower = float(3.0);
    const rimIntensity = float(0.5);
    // FIX: max(float(0.0), ...) to prevent TypeErrors
    const NdotV = max(float(0.0), dot(normalNode, viewDirNode));
    const rim = mul(pow(sub(float(1.0), NdotV), rimPower), rimIntensity);
    return add(baseColorNode, rim);
});

// --- UNIFIED MATERIAL PIPELINE ---

function createUnifiedMaterial(hexColor, options = {}) {
    const {
        roughness = 0.5,
        metalness = 0.0,
        bumpStrength = 0.0,
        noiseScale = 5.0,
        triplanar = false,    
        side = FrontSide, 
        transmission = 0.0,    
        thickness = 0.0,      
        ior = 1.5,             
        thicknessDistortion = 0.0,
        subsurfaceStrength = 0.0,
        subsurfaceColor = 0xFFFFFF,
        iridescenceStrength = 0.0,
        iridescenceFresnelPower = 4.0,
        sheen = 0.0,
        sheenColor = 0xFFFFFF,
        sheenRoughness = 1.0,
        animateMoisture = false,
        animatePulse = false
    } = options;

    const material = new MeshStandardNodeMaterial();

    material.colorNode = color(hexColor);
    material.roughnessNode = float(roughness);
    material.metalnessNode = float(metalness);
    material.side = side;

    let surfaceNoise = float(0.0);

    if (bumpStrength > 0.0 || thicknessDistortion > 0.0 || animateMoisture) {
        let pos = positionLocal;
        if (animateMoisture) {
            // FIX: float(0.0)
            const timeOffset = vec3(float(0.0), uTime.mul(float(0.2)), float(0.0));
            pos = pos.add(timeOffset);
        }

        if (triplanar) {
            surfaceNoise = triplanarNoise(pos, float(noiseScale));
        } else {
            surfaceNoise = mx_noise_float(pos.mul(float(noiseScale)));
        }
    }

    if (bumpStrength > 0.0) {
        material.normalNode = perturbNormal(positionLocal, normalWorld, float(noiseScale), float(bumpStrength));
        // FIX: float() for smoothstep
        const cavity = smoothstep(float(0.3), float(0.7), surfaceNoise);
        material.colorNode = material.colorNode.mul(cavity.mul(float(0.5)).add(float(0.5)));
    }

    const glitchRes = applyGlitch(uv(), material.positionNode || positionLocal, uGlitchIntensity);
    material.positionNode = glitchRes.position;

    const glitchTint = vec3(1.0, 0.0, 1.0);
    // FIX: float()
    const glitchMix = smoothstep(float(0.1), float(0.3), uGlitchIntensity).mul(float(0.5));
    material.colorNode = mix(material.colorNode, glitchTint, glitchMix);

    if (animateMoisture) {
        const wetness = surfaceNoise.mul(float(0.3));
        material.roughnessNode = material.roughnessNode.sub(wetness);
    }

    if (transmission > 0.0) {
        material.transmissionNode = float(transmission);
        material.iorNode = float(ior);
        material.transparent = true;

        let thickNode = float(thickness);
        if (thicknessDistortion > 0.0) {
            thickNode = thickNode.mul(surfaceNoise.mul(float(thicknessDistortion)).add(float(1.0)));
        }
        material.thicknessNode = thickNode;

        const absorption = exp(thickNode.negate().mul(float(0.5)));
        material.colorNode = material.colorNode.mul(absorption.add(float(0.2)));
    }

    if (subsurfaceStrength > 0.0) {
        const lightDir = normalize(vec3(0.5, 1.0, 0.5));
        const NdotL = dot(normalWorld, lightDir);
        const wrap = float(1.0).sub(max(float(0.0), NdotL)).pow(float(2.0)); 

        const sssColorNode = color(subsurfaceColor);
        const sssEffect = wrap.mul(float(subsurfaceStrength)).mul(sssColorNode);
        material.colorNode = material.colorNode.add(sssEffect);
    }

    if (iridescenceStrength > 0.0) {
        const viewDir = normalize(cameraPosition.sub(positionWorld));
        const NdotV = abs(dot(normalWorld, viewDir));
        const fresnel = float(1.0).sub(NdotV).pow(float(iridescenceFresnelPower));

        const irisR = sin(fresnel.mul(float(10.0)));
        const irisG = sin(fresnel.mul(float(10.0)).add(float(2.0)));
        const irisB = sin(fresnel.mul(float(10.0)).add(float(4.0)));

        const rainbow = vec3(irisR, irisG, irisB).mul(float(0.5)).add(float(0.5));
        material.emissiveNode = rainbow.mul(float(iridescenceStrength)).mul(fresnel);
    }

    if (animatePulse) {
        const pulse = sin(uTime.mul(float(3.0))).mul(float(0.2)).add(float(0.8));
        material.emissiveNode = (material.emissiveNode || color(0x000000)).add(material.colorNode.mul(pulse.mul(float(0.2))));
    }

    if (sheen > 0.0) {
        material.sheen = sheen;
        material.sheenColorNode = color(sheenColor);
        material.sheenRoughnessNode = float(sheenRoughness);
    }

    material.userData.isUnified = true;
    return material;
}

const CandyPresets = {
    Clay: (hex, opts={}) => createUnifiedMaterial(hex, {
        roughness: 0.8,
        bumpStrength: 0.15,
        noiseScale: 8.0,
        triplanar: true,
        ...opts
    }),
    Sugar: (hex, opts={}) => createUnifiedMaterial(hex, {
        roughness: 0.6,
        bumpStrength: 0.8,
        noiseScale: 60.0, 
        sheen: 1.0,
        sheenColor: 0xFFFFFF,
        sheenRoughness: 0.5,
        ...opts
    }),
    Gummy: (hex, opts={}) => createUnifiedMaterial(hex, {
        transmission: 0.9,
        thickness: 1.5,
        roughness: 0.2,
        ior: 1.4,
        subsurfaceStrength: 0.6,
        subsurfaceColor: hex,
        thicknessDistortion: 0.3,
        ...opts
    }),
    SeaJelly: (hex, opts={}) => createUnifiedMaterial(hex, {
        transmission: 0.95,
        thickness: 0.8,
        ior: 1.33,
        roughness: 0.05,
        subsurfaceStrength: 0.4,
        subsurfaceColor: 0xCCFFFF,
        animateMoisture: true, 
        thicknessDistortion: 0.5,
        ...opts
    }),
    Crystal: (hex, opts={}) => createUnifiedMaterial(hex, {
        transmission: 1.0,
        thickness: 4.0,
        roughness: 0.0,
        ior: 2.0, 
        iridescenceStrength: 0.7,
        iridescenceFresnelPower: 2.5,
        ...opts
    }),
    Velvet: (hex, opts={}) => createUnifiedMaterial(hex, {
        roughness: 1.0,
        sheen: 1.0,
        sheenColor: hex, 
        sheenRoughness: 1.0,
        bumpStrength: 0.05,
        ...opts
    }),
    OilSlick: (hex=0x222222, opts={}) => createUnifiedMaterial(hex, {
        roughness: 0.3,
        metalness: 0.8,
        iridescenceStrength: 1.0,
        iridescenceFresnelPower: 1.5,
        ...opts
    })
};

function createClayMaterial(hexColor) {
    return CandyPresets.Clay(hexColor);
}

function createCandyMaterial(hexColor) {
    return CandyPresets.Gummy(hexColor);
}

function createStandardNodeMaterial(options = {}) {
    const mat = new MeshStandardNodeMaterial();
    if (options.color !== undefined) mat.colorNode = color(options.color);
    if (options.roughness !== undefined) mat.roughnessNode = float(options.roughness);
    if (options.metalness !== undefined) mat.metalnessNode = float(options.metalness);
    if (options.emissive !== undefined) mat.emissiveNode = color(options.emissive);
    if (options.emissiveIntensity !== undefined && options.emissive !== undefined) {
         mat.emissiveNode = color(options.emissive).mul(float(options.emissiveIntensity));
    }
    
    if (options.transparent) mat.transparent = true;
    if (options.opacity !== undefined) mat.opacity = options.opacity;
    if (options.side !== undefined) mat.side = options.side;
    if (options.blending !== undefined) mat.blending = options.blending;
    if (options.depthWrite !== undefined) mat.depthWrite = options.depthWrite;
    
    return mat;
}

function createTransparentNodeMaterial(options = {}) {
    const mat = createStandardNodeMaterial(options);
    mat.transparent = true;
    mat.depthWrite = options.depthWrite !== undefined ? options.depthWrite : false; 
    return mat;
}

const foliageMaterials = {
    stem: CandyPresets.Clay(0x66AA55),
    flowerCenter: CandyPresets.Velvet(0x442211),
    vine: CandyPresets.Clay(0x558833),
    wood: createUnifiedMaterial(0x8B4513, { roughness: 0.9, bumpStrength: 0.3, noiseScale: 3.0 }),
    leaf: createUnifiedMaterial(0x228B22, { roughness: 0.6, side: DoubleSide, bumpStrength: 0.1 }),
    
    flowerStem: CandyPresets.Clay(0x66AA55),
    lotusRing: CandyPresets.Gummy(0xFFFFFF),
    opticCable: createUnifiedMaterial(0x111111, { roughness: 0.4 }),
    opticTip: createStandardNodeMaterial({
        color: 0xFFFFFF,
        emissive: 0xFF00FF,
        emissiveIntensity: 1.0,
        roughness: 0.2
    }),

    lightBeam: new MeshStandardNodeMaterial({ 
        color: 0xFFFFFF, 
        transparent: true, 
        opacity: 0.2, 
        blending: AdditiveBlending,
        depthWrite: false,
        roughness: 1.0 
    }),
    
    mushroomStem: CandyPresets.Clay(0xF5F5DC),

    mushroomCap: [
        CandyPresets.Clay(0xFF6B6B),        
        CandyPresets.Gummy(0xFF9F43),       
        CandyPresets.Sugar(0xFDCB6E),       
        CandyPresets.Crystal(0x54A0FF),     
        CandyPresets.OilSlick()             
    ],

    mushroomCheek: CandyPresets.Velvet(0xFFAACC),
    mushroomGills: CandyPresets.Clay(0x332211, { side: DoubleSide }),
    mushroomSpots: CandyPresets.Sugar(0xFFFFFF),

    flowerPetal: [
        CandyPresets.Velvet(0xFF69B4, { side: DoubleSide }),
        CandyPresets.Gummy(0xFFD700, { side: DoubleSide }),
        CandyPresets.Crystal(0xFFFFFF, { side: DoubleSide }),
        CandyPresets.Sugar(0x9933FF, { side: DoubleSide }),
    ],

    eye: CandyPresets.Gummy(0xFFFFFF), 
    pupil: new MeshStandardNodeMaterial({ color: 0x000000, roughness: 0.0 }),
    mouth: CandyPresets.Clay(0x2D3436),
    clayMouth: CandyPresets.Clay(0x2D3436)
};

function registerReactiveMaterial(mat) { reactiveMaterials.push(mat); }
function pickAnimation(types) { return types[Math.floor(Math.random() * types.length)]; }

function attachReactivity(group, options = {}) {
    group.userData.reactivityType = options.type || group.userData.reactivityType || 'flora';
    if (typeof group.userData.reactivityId === 'undefined') group.userData.reactivityId = reactivityCounter++;
    const light = options.lightPreference || {};
    group.userData.minLight = (typeof light.min !== 'undefined') ? light.min : (group.userData.minLight ?? 0.0);
    group.userData.maxLight = (typeof light.max !== 'undefined') ? light.max : (group.userData.maxLight ?? 1.0);
    return group;
}

function validateFoliageMaterials() {
    const required = ['lightBeam', 'mushroomCap', 'opticTip', 'lotusRing', 'flowerStem'];
    let safe = true;
    required.forEach(key => {
        if (!foliageMaterials[key]) {
            console.error(`[Foliage] Missing material: ${key}. Using fallback.`);
            foliageMaterials[key] = new MeshStandardNodeMaterial({ color: 0xFF00FF });
            safe = false;
        }
    });
    return safe;
}

function validateNodeGeometries(scene) {
    const missingPosition = [];

    function inferVertexCount(geo) {
        if (!geo) return 0;
        if (geo.index) return geo.index.count;
        let maxCount = 0;
        for (const key in geo.attributes) {
            if (Object.prototype.hasOwnProperty.call(geo.attributes, key)) {
                const a = geo.attributes[key];
                if (a && a.count > maxCount) maxCount = a.count;
            }
        }
        return maxCount;
    }

    function getObjectPath(obj) {
        const parts = [];
        let cur = obj;
        while (cur) {
            const name = cur.name || cur.type || cur.uuid;
            parts.unshift(name);
            cur = cur.parent;
        }
        return parts.join('/') || obj.uuid;
    }

    scene.traverse(obj => {
        if (obj.isMesh || obj.isPoints) {
            const geo = obj.geometry;
            if (geo) {
                if (!geo.attributes.position) {
                    const preAttrKeys = Object.keys(geo.attributes || {}).join(', ') || '(none)';
                    const inferred = inferVertexCount(geo);
                    if (inferred > 0) {
                        const positions = new Float32Array(inferred * 3);
                        geo.setAttribute('position', new BufferAttribute(positions, 3));
                    } else {
                        try {
                            const worldPos = new Vector3();
                            obj.getWorldPosition(worldPos);
                            const positions = new Float32Array(3);
                            positions[0] = worldPos.x; positions[1] = worldPos.y; positions[2] = worldPos.z;
                            geo.setAttribute('position', new BufferAttribute(positions, 3));

                            const normals = new Float32Array(3);
                            normals[0] = 0; normals[1] = 1; normals[2] = 0;
                            geo.setAttribute('normal', new BufferAttribute(normals, 3));

                            obj.userData._patchedByValidate = true;

                            const name = obj.name || 'Unnamed';
                            const type = obj.userData?.type || 'Unknown Type';
                            const attrKeys = Object.keys(geo.attributes || {}).join(', ') || '(none)';
                            const geoType = geo.type || geo.constructor?.name || 'UnknownGeo';

                            let anc = obj.parent;
                            let ancestorType = null;
                            let ancestorName = null;
                            let depth = 0;
                            while (anc && depth < 10) {
                                if (anc && anc.userData && anc.userData.type) {
                                    ancestorType = anc.userData.type;
                                    ancestorName = anc.name || anc.userData.type;
                                    break;
                                }
                                anc = anc.parent;
                                depth++;
                            }
                            missingPosition.push({ name, type, obj, geoType, attrKeys, path: getObjectPath(obj), patched: true, ancestorType, ancestorName, preAttrKeys });
                        } catch (err) {
                            const name = obj.name || 'Unnamed';
                            const type = obj.userData?.type || 'Unknown Type';
                            const attrKeys = Object.keys(geo.attributes || {}).join(', ') || '(none)';
                            const geoType = geo.type || geo.constructor?.name || 'UnknownGeo';
                            missingPosition.push({ name, type, obj, geoType, attrKeys, path: getObjectPath(obj), preAttrKeys });
                        }
                    }
                }

                if (!geo.attributes.normal) {
                    const count = geo.attributes.position ? geo.attributes.position.count : inferVertexCount(geo);
                    if (count > 0) {
                        const normals = new Float32Array(count * 3);
                        for (let i = 0; i < count * 3; i += 3) { normals[i] = 0; normals[i + 1] = 1; normals[i + 2] = 0; }
                        geo.setAttribute('normal', new BufferAttribute(normals, 3));
                    }
                }
            }
        }
    });

    if (missingPosition.length > 0) {
        const header = `[TSL] ${missingPosition.length} geometries missing 'position' attribute.`;
        const examples = missingPosition.slice(0, 10).map(m => `${m.path} -> ${m.name}(${m.type}) [${m.geoType}] attrs: ${m.attrKeys}${m.patched ? ' (patched)' : ''}${m.ancestorType ? ` ancestor:${m.ancestorType}` : ''}`);
        const patchedCount = missingPosition.filter(m => m.patched).length;
        const more = missingPosition.length > 10 ? ` + ${missingPosition.length - 10} more` : '';
        let msg = `${header} Examples: ${examples.join('; ')}${more}.`;
        if (patchedCount > 0) {
            msg += ` Note: ${patchedCount} were auto-patched with minimal position/normal data; consider fixing the source constructor.`;
        }
        console.warn(msg);
    }
}

// --- Reusable Colors for Berry Updates ---
new Color(0x331100);
new Color();
new Color();

function chargeBerries(berryCluster, chargeAmount) {
    if (!berryCluster.userData) return;
    berryCluster.userData.weatherGlow = Math.min(
        2.0,
        (berryCluster.userData.weatherGlow || 0) + chargeAmount
    );
}

function updateBerrySeasons(berryCluster, phase, phaseProgress) {
    if (!berryCluster.userData.berries) return;

    if (!berryCluster.userData.originalBerryScales) {
        berryCluster.userData.originalBerryScales = berryCluster.userData.berries.map(b => b.scale.x);
    }

    let targetScale = 1.0;
    switch (phase) {
        case 'sunset':
            targetScale = 1.0 + phaseProgress * 0.3;
            break;
        case 'dusk':
            targetScale = 1.3 - phaseProgress * 0.1;
            break;
        case 'deepNight':
            targetScale = 1.2 - phaseProgress * 0.4;
            break;
        case 'preDawn':
            targetScale = 0.8 + phaseProgress * 0.2;
            break;
        default:
            targetScale = 1.0;
    }

    berryCluster.userData.berries.forEach((berry, i) => {
        const origScale = berryCluster.userData.originalBerryScales[i];
        const newScale = origScale * targetScale;
        berry.scale.setScalar(newScale);
    });
}

// --- Falling Berry Particle System ---
let fallingBerryPool = [];
const MAX_FALLING_BERRIES = 50;
let fallingBerryGroup = null;

function initFallingBerries(scene) {
    fallingBerryGroup = new Group();
    fallingBerryGroup.name = 'fallingBerries';

    const berryGeo = new SphereGeometry(0.06, 8, 8);

    for (let i = 0; i < MAX_FALLING_BERRIES; i++) {
        const mat = new MeshStandardMaterial({
            color: 0xFF6600,
            emissive: 0xFF6600,
            emissiveIntensity: 0.5
        });
        const berry = new Mesh(berryGeo, mat);
        berry.visible = false;
        berry.userData.velocity = new Vector3();
        berry.userData.active = false;
        berry.userData.age = 0;
        fallingBerryGroup.add(berry);
        fallingBerryPool.push(berry);
    }

    scene.add(fallingBerryGroup);
}

function spawnFallingBerry(position, colorHex = 0xFF6600) {
    const berry = fallingBerryPool.find(b => !b.userData.active);
    if (!berry) return;

    berry.position.copy(position);
    berry.material.color.setHex(colorHex);
    berry.material.emissive.setHex(colorHex);
    berry.userData.velocity.set(
        (Math.random() - 0.5) * 2,
        -2 - Math.random() * 3,
        (Math.random() - 0.5) * 2
    );
    berry.userData.active = true;
    berry.userData.age = 0;
    berry.visible = true;
}

function updateFallingBerries(delta) {
    if (!fallingBerryGroup) return;

    const gravity = -9.8;
    const maxAge = 3.0;

    fallingBerryPool.forEach(berry => {
        if (!berry.userData.active) return;

        berry.userData.age += delta;
        berry.userData.velocity.y += gravity * delta;

        berry.position.x += berry.userData.velocity.x * delta;
        berry.position.y += berry.userData.velocity.y * delta;
        berry.position.z += berry.userData.velocity.z * delta;

        berry.material.opacity = 1.0 - (berry.userData.age / maxAge);

        if (berry.position.y < 0 || berry.userData.age > maxAge) {
            berry.userData.active = false;
            berry.visible = false;
        }
    });
}

function shakeBerriesLoose(cluster, intensity) {
    if (!cluster.userData.berries) return;

    cluster.userData.berries.forEach(berry => {
        if (Math.random() < intensity * 0.02) {
            const worldPos = new Vector3();
            berry.getWorldPosition(worldPos);
            spawnFallingBerry(worldPos, cluster.userData.berryColor || 0xFF6600);
        }
    });
}

function collectFallingBerries(playerPos, collectRadius = 1.0) {
    if (!fallingBerryPool) return 0;

    let collected = 0;
    const radiusSq = collectRadius * collectRadius;

    fallingBerryPool.forEach(berry => {
        if (!berry.userData.active) return;

        const distSq = berry.position.distanceToSquared(playerPos);
        if (distSq < radiusSq) {
            berry.userData.active = false;
            berry.visible = false;
            collected++;
        }
    });

    return collected;
}

// src/foliage/grass.js


let grassMeshes = [];
const dummy = new Object3D();
const MAX_PER_MESH = 1000;

function initGrassSystem(scene, count = 5000) {
    grassMeshes = [];
    const height = 0.8;
    const geo = new BoxGeometry(0.05, height, 0.05);
    geo.translate(0, height / 2, 0);
    // Ensure normals exist for TSL
    geo.computeVertexNormals();

    const mat = new MeshStandardNodeMaterial({
        color: 0x7CFC00,
        roughness: 0.8,
        metalness: 0.0
    });

    // Wind Logic
    const windTime = time.mul(uWindSpeed.max(0.5));
    const swayPhase = positionLocal.x.add(positionLocal.z).add(windTime);
    const swayAmt = positionLocal.y.mul(0.3).mul(sin(swayPhase));

    const swayX = swayAmt.mul(uWindDirection.x);
    const swayZ = swayAmt.mul(uWindDirection.z);

    mat.positionNode = positionLocal.add(vec3(swayX, 0, swayZ));

    // Rim Light Logic (Inlined TSL)
    const viewDir = vec3(0, 0, 1);
    const NdotV = max(0.0, dot(normalView, viewDir));
    const rimFactor = float(1.0).sub(NdotV).pow(3.0).mul(0.6);

    // Mix Base Color with Rim Color
    const baseColor = color(0x7CFC00);
    const rimColor = color(0xAAFFAA);
    mat.colorNode = baseColor.add(rimColor.mul(rimFactor));

    const meshCount = Math.ceil(count / MAX_PER_MESH);

    for (let i = 0; i < meshCount; i++) {
        const capacity = Math.min(MAX_PER_MESH, count - i * MAX_PER_MESH);
        const mesh = new InstancedMesh(geo, mat, capacity);
        mesh.instanceMatrix.setUsage(DynamicDrawUsage);
        mesh.count = 0;
        mesh.receiveShadow = true;
        scene.add(mesh);
        grassMeshes.push(mesh);
    }

    return grassMeshes;
}

function addGrassInstance(x, y, z) {
    const mesh = grassMeshes.find(m => m.count < m.instanceMatrix.count);
    if (!mesh) return;

    const index = mesh.count;

    dummy.position.set(x, y, z);
    dummy.rotation.y = Math.random() * Math.PI;
    const s = 0.8 + Math.random() * 0.4;
    dummy.scale.set(s, s, s);

    dummy.updateMatrix();
    mesh.setMatrixAt(index, dummy.matrix);
    mesh.count++;
    mesh.instanceMatrix.needsUpdate = true;
}

// src/foliage/mushrooms.js


// 12 Chromatic Notes with their corresponding colors
// Colors are defined here to match CONFIG.noteColorMap.mushroom palette
const MUSHROOM_NOTES = [
    { note: 'C',  color: 0xFF4040, name: 'C Red' },       // Red
    { note: 'C#', color: 0xEF1280, name: 'C# Magenta' },  // Magenta-Red
    { note: 'D',  color: 0xC020C0, name: 'D Magenta' },   // Magenta
    { note: 'D#', color: 0x8020EF, name: 'D# Violet' },   // Violet
    { note: 'E',  color: 0x4040FF, name: 'E Blue' },      // Blue
    { note: 'F',  color: 0x1280EF, name: 'F Azure' },     // Azure
    { note: 'F#', color: 0x00C0C0, name: 'F# Cyan' },     // Cyan
    { note: 'G',  color: 0x12EF80, name: 'G Spring' },    // Spring Green
    { note: 'G#', color: 0x40FF40, name: 'G# Green' },    // Green
    { note: 'A',  color: 0x80EF12, name: 'A Lime' },      // Lime
    { note: 'A#', color: 0xC0C000, name: 'A# Yellow' },   // Yellow
    { note: 'B',  color: 0xEF8012, name: 'B Orange' }     // Orange
];

function createMushroom(options = {}) {
    const {
        size = 'regular',
        scale = 1.0,
        colorIndex = -1,
        hasFace = false,
        isBouncy = false,
        note = null,  // Musical note (e.g., 'C', 'F#', etc.)
        noteIndex = -1 // Index into MUSHROOM_NOTES array (0-11)
    } = options;

    const group = new Group();
    const isGiant = size === 'giant';
    // All mushrooms get faces now if requested, but giants always have them
    const showFace = isGiant || hasFace;

    // Determine which musical note this mushroom represents
    let mushroomNote = null;
    let noteColor = null;
    let actualNoteIndex = -1;

    if (noteIndex >= 0 && noteIndex < MUSHROOM_NOTES.length) {
        actualNoteIndex = noteIndex;
        mushroomNote = MUSHROOM_NOTES[noteIndex];
        noteColor = mushroomNote.color;
    } else if (note) {
        // Find note by name
        const found = MUSHROOM_NOTES.find(n => n.note === note);
        if (found) {
            mushroomNote = found;
            noteColor = found.color;
            actualNoteIndex = MUSHROOM_NOTES.indexOf(found);
        }
    }

    // Shape variations based on note (0-11 creates subtle differences)
    const noteVariation = actualNoteIndex >= 0 ? actualNoteIndex / 11.0 : Math.random();
    
    // REDUCED: Changed from 8.0 to 5.0 to prevent them from covering the map
    const baseScale = isGiant ? 5.0 * scale : 1.0 * scale;
    
    // Subtle shape variations by note
    // Lower notes (C, C#, D) = shorter, wider; Higher notes (A, A#, B) = taller, thinner
    const heightMod = 0.8 + (noteVariation * 0.6); // 0.8 to 1.4
    const widthMod = 1.2 - (noteVariation * 0.4);  // 1.2 to 0.8
    
    const stemH = (1.0 + Math.random() * 0.3) * baseScale * heightMod;
    const stemR = (0.15 + Math.random() * 0.05) * baseScale * widthMod;
    const capR = stemR * (2.5 + Math.random() * 0.5) * (isGiant ? 1.0 : 1.2) * widthMod;

    // Stem Geometry (Lathe)
    const stemPoints = [];
    for (let i = 0; i <= 10; i++) {
        const t = i / 10;
        const r = stemR * (1.0 - Math.pow(t - 0.3, 2) * 0.5);
        const y = t * stemH;
        stemPoints.push(new Vector2(r, y));
    }
    const stemGeo = new LatheGeometry(stemPoints, 16);
    const stem = new Mesh(stemGeo, foliageMaterials.mushroomStem);
    stem.castShadow = true;
    stem.receiveShadow = true;
    group.add(stem);

    // Cap Geometry (Sphere)
    const capGeo = new SphereGeometry(capR, 24, 24, 0, Math.PI * 2, 0, Math.PI / 1.8);
    let capMat;
    let chosenColorIndex;
    
    // Use note color if available, otherwise use colorIndex or random
    if (noteColor !== null) {
        // Create dedicated material with note color for musical mushrooms
        const baseCapMat = foliageMaterials.mushroomCap[0] || foliageMaterials.mushroomStem;
        capMat = baseCapMat.clone();
        capMat.colorNode = color(noteColor); // Ensure Node is set
        capMat.roughness = 0.7;
        chosenColorIndex = actualNoteIndex;
    } else if (colorIndex >= 0 && colorIndex < foliageMaterials.mushroomCap.length) {
        chosenColorIndex = colorIndex;
        capMat = foliageMaterials.mushroomCap[chosenColorIndex];
    } else {
        chosenColorIndex = Math.floor(Math.random() * foliageMaterials.mushroomCap.length);
        capMat = foliageMaterials.mushroomCap[chosenColorIndex];
    }

    // Clone material to allow individual emissive strobing
    const instanceCapMat = capMat.clone();
    // Ensure base emissive is set for fade-back
    instanceCapMat.userData.baseEmissive = new Color(0x000000);
    // Store note color for reactivity
    if (noteColor !== null) {
        instanceCapMat.userData.noteColor = new Color(noteColor);
    }

    const cap = new Mesh(capGeo, instanceCapMat);
    cap.position.y = stemH - (capR * 0.2);
    cap.castShadow = true;
    cap.receiveShadow = true;
    group.add(cap);

    // Gills (Cone)
    const gillGeo = new ConeGeometry(capR * 0.9, capR * 0.4, 24, 1, true);
    const gillMat = foliageMaterials.mushroomGills;
    const gill = new Mesh(gillGeo, gillMat);
    gill.position.y = stemH - (capR * 0.2);
    gill.rotation.x = Math.PI;
    group.add(gill);

    // Spots - vary pattern based on note
    const spotCount = actualNoteIndex >= 0 ? (3 + actualNoteIndex % 5) : (3 + Math.floor(Math.random() * 5));
    const spotGeo = new SphereGeometry(capR * 0.15, 6, 6);
    const spotMat = foliageMaterials.mushroomSpots;
    
    // Add note-colored accent spots if this is a musical mushroom
    let accentSpotMat = spotMat;
    if (noteColor !== null) {
        // Create tinted spot material
        accentSpotMat = spotMat.clone();
        const tintColor = new Color(noteColor);
        // Blend white with note color for subtle tint
        accentSpotMat.color.copy(new Color(0xFFFFFF).lerp(tintColor, 0.4));
    }

    for (let i = 0; i < spotCount; i++) {
        const u = Math.random();
        const v = Math.random() * 0.5;
        const theta = 2 * Math.PI * u;
        const phi = Math.acos(1 - v);

        const x = Math.sin(phi) * Math.cos(theta) * capR;
        const y = Math.cos(phi) * capR;
        const z = Math.sin(phi) * Math.sin(theta) * capR;

        // Use accent material for some spots on musical mushrooms
        const useAccent = noteColor !== null && i % 2 === 0;
        const spot = new Mesh(spotGeo, useAccent ? accentSpotMat : spotMat);
        spot.position.set(x, y + stemH - (capR * 0.2), z);
        spot.scale.set(1, 0.2, 1);
        spot.lookAt(0, stemH + capR, 0);
        group.add(spot);
    }

    // Face
    if (showFace) {
        const faceGroup = new Group();
        // Position face on the front of the stem/cap junction
        faceGroup.position.set(0, stemH * 0.6, stemR * 0.85);
        const faceScale = isGiant ? baseScale : baseScale * 0.6;
        faceGroup.scale.set(faceScale, faceScale, faceScale);

        // Eyes
        const leftEye = new Mesh(eyeGeo, foliageMaterials.eye);
        leftEye.position.set(-0.15, 0.1, 0.1);
        const rightEye = new Mesh(eyeGeo, foliageMaterials.eye);
        rightEye.position.set(0.15, 0.1, 0.1);

        // Pupils
        const pupilGeo = new SphereGeometry(0.06, 8, 8);
        const leftPupil = new Mesh(pupilGeo, foliageMaterials.pupil);
        leftPupil.position.set(0, 0, 0.1);
        leftEye.add(leftPupil);

        const rightPupil = new Mesh(pupilGeo, foliageMaterials.pupil);
        rightPupil.position.set(0, 0, 0.1);
        rightEye.add(rightPupil);

        // Smile
        const smileGeo = new TorusGeometry(0.12, 0.04, 6, 12, Math.PI);
        const smile = new Mesh(smileGeo, foliageMaterials.clayMouth);
        smile.rotation.z = Math.PI;
        smile.position.set(0, -0.05, 0.1);

        // Cheeks (Rosy!)
        const cheekGeo = new SphereGeometry(0.08, 8, 8);
        const leftCheek = new Mesh(cheekGeo, foliageMaterials.mushroomCheek);
        leftCheek.position.set(-0.25, 0.0, 0.05);
        leftCheek.scale.set(1, 0.6, 0.5);

        const rightCheek = new Mesh(cheekGeo, foliageMaterials.mushroomCheek);
        rightCheek.position.set(0.25, 0.0, 0.05);
        rightCheek.scale.set(1, 0.6, 0.5);

        faceGroup.add(leftEye, rightEye, smile, leftCheek, rightCheek);
        group.add(faceGroup);
    }

    // Giant Breathing Effect & Pulsing Stripes (TSL)
    if (isGiant) {
        // FIX: Using MeshStandardNodeMaterial correctly
        const breathMat = new MeshStandardNodeMaterial();
        // Inherit color node from the instance material (CandyPreset)
        // instanceCapMat.color is likely default white, so we must use colorNode
        breathMat.colorNode = instanceCapMat.colorNode || color(0xFFFFFF);
        breathMat.roughness = 0.8;
        breathMat.metalness = 0.0;

        const pos = positionLocal;
        const breathSpeed = time.mul(float(2.0)); // Explicit float
        const breath = sin(breathSpeed).mul(float(0.1)).add(float(1.0)); // Explicit floats
        
        // Displace vertices for breathing
        breathMat.positionNode = pos.mul(breath);

        // Animated Emission Stripes
        // Use positionLocal.y to create horizontal stripes
        // Use time to move them upwards
        const stripeFreq = float(10.0);
        const stripeSpeed = float(2.0);
        // Explicit floats in chain
        const stripePattern = sin(pos.y.mul(stripeFreq).sub(time.mul(stripeSpeed)));

        // Clamp to 0-1 and sharpen
        const stripeIntensity = stripePattern.add(float(1.0)).mul(float(0.5)).pow(float(2.0));

        // Base color pulse + Stripe overlay
        const basePulse = sin(breathSpeed.mul(float(2.0))).mul(float(0.1)).add(float(0.2));
        const totalEmission = stripeIntensity.mul(float(0.3)).add(basePulse);

        // Use the same base color for emission
        breathMat.emissiveNode = breathMat.colorNode.mul(totalEmission);

        cap.material = breathMat;
        // Keep reference for reactivity override
        instanceCapMat.colorNode = breathMat.colorNode;
    }

    group.userData.animationType = pickAnimation(['wobble', 'bounce', 'accordion']);
    group.userData.animationOffset = Math.random() * 10;
    group.userData.type = 'mushroom';
    group.userData.colorIndex = typeof chosenColorIndex === 'number' ? chosenColorIndex : -1;
    
    // Store musical note information
    if (mushroomNote) {
        group.userData.musicalNote = mushroomNote.note;
        group.userData.noteColor = noteColor;
        group.userData.noteIndex = actualNoteIndex;
    }
    
    // --- NEW: Bioluminescence Logic ---
    // Musical mushrooms always glow at night with their note color
    const shouldGlow = mushroomNote !== null || options.isBioluminescent;
    
    if (shouldGlow) {
        // Determine color based on note or cap material
        // Use colorNode if available for accurate color, otherwise fall back to white
        // We can't easily get the Hex from a Node, so we rely on noteColor or instanceCapMat props
        const lightColor = noteColor !== null 
            ? new Color(noteColor) 
            : ((instanceCapMat && instanceCapMat.color) ? instanceCapMat.color : new Color(0x00FF88));

        // Add a Point Light inside the cap for night glow
        const light = new PointLight(lightColor, 0, 4.0); // Start at 0, will be animated
        // Position it under the cap so it lights up the stem and ground
        light.position.set(0, stemH * 0.5, 0);
        group.add(light);
        
        // Store light reference for animation
        group.userData.glowLight = light;

        // Make the gills emissive for bioluminescence
        if (gill && gill.material) {
            // Clone to avoid affecting all mushrooms
            gill.material = gill.material.clone();
            gill.material.emissive = lightColor.clone().multiplyScalar(0.3);
            gill.material.emissiveIntensity = 0.3;
        }

        group.userData.isBioluminescent = true;
    }
    // ----------------------------------

    // --- IMPORTANT: Metadata for Weather System ---
    group.userData.size = size;
    group.userData.capRadius = capR;
    group.userData.capHeight = stemH;
    group.userData.stemRadius = stemR;

    // Register cap for flash animation system
    group.userData.reactiveMeshes = [cap];
    // ----------------------------------------------

    if (isGiant || isBouncy) {
        group.userData.isTrampoline = true;
    }

    // Attach Reactivity with Custom Logic
    attachReactivity(group, { type: 'flora' });

    // Custom Reactivity Method: Note-specific Blink & Bounce
    group.reactToNote = (note, colorVal, velocity) => {
        // Only react if this mushroom's note matches the played note
        if (group.userData.musicalNote) {
            // Extract base note name (e.g., "C#" from "C#4")
            let playedNote = note;
            if (typeof note === 'string') {
                playedNote = note.replace(/[0-9-]/g, '');
            } else if (typeof note === 'number') {
                const CHROMATIC = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
                playedNote = CHROMATIC[note % 12];
            }
            
            // Only react if notes match
            if (playedNote !== group.userData.musicalNote) {
                return;
            }
        }
        
        // 1. Strobe Effect (via animateFoliage system)
        const flashColor = group.userData.noteColor 
            ? new Color(group.userData.noteColor)
            : new Color(colorVal);
            
        cap.userData.flashColor = flashColor;
        cap.userData.flashIntensity = 1.5 + (velocity * 2.5); // High intensity for blink
        cap.userData.flashDecay = 0.15; // Fast decay for strobe effect

        // 2. Glow light blink at night
        if (group.userData.glowLight) {
            const light = group.userData.glowLight;
            light.intensity = 2.0 + (velocity * 3.0); // Bright flash
            // Store original for fade back
            if (!light.userData.baseIntensity) {
                light.userData.baseIntensity = 0.8;
            }
        }

        // 3. Bounce / Retrigger Squish
        const squash = 1.0 - (velocity * 0.3);
        const stretch = 1.0 + (velocity * 0.3);
        group.scale.set(baseScale * stretch, baseScale * squash, baseScale * stretch);

        // Store scale animation state for frame-based animation
        group.userData.scaleTarget = baseScale;
        group.userData.scaleAnimTime = 0.08; // 80ms duration
        group.userData.scaleAnimStart = Date.now();
    };

    return group;
}

// src/foliage/flowers.js


function createFlower(options = {}) {
    const { color = null, shape = 'simple' } = options;
    const group = new Group();

    const stemHeight = 0.6 + Math.random() * 0.4;
    // Use Shared Cylinder
    const stem = new Mesh(sharedGeometries.unitCylinder, foliageMaterials.flowerStem);
    stem.scale.set(0.05, stemHeight, 0.05); // Radius 0.05, Height determined by scale Y
    stem.castShadow = true;
    group.add(stem);

    const head = new Group();
    head.position.y = stemHeight;
    group.add(head);

    // Use Shared Sphere
    const center = new Mesh(sharedGeometries.unitSphere, foliageMaterials.flowerCenter);
    center.scale.setScalar(0.1);
    center.name = 'flowerCenter';
    head.add(center);

    const stamenCount = 3;
    const stamenMat = createClayMaterial(0xFFFF00);
    for (let i = 0; i < stamenCount; i++) {
        const stamen = new Mesh(sharedGeometries.unitCylinder, stamenMat);
        stamen.position.y = 0.075;
        stamen.scale.set(0.01, 0.15, 0.01);
        stamen.rotation.z = (Math.random() - 0.5) * 1.0;
        stamen.rotation.x = (Math.random() - 0.5) * 1.0;
        head.add(stamen);
    }

    let petalMat;
    if (color) {
        petalMat = createClayMaterial(color);
        registerReactiveMaterial(petalMat);
    } else {
        petalMat = foliageMaterials.flowerPetal[Math.floor(Math.random() * foliageMaterials.flowerPetal.length)];
    }

    if (shape === 'simple') {
        const petalCount = 5 + Math.floor(Math.random() * 2);
        const petalGeo = new IcosahedronGeometry(0.15, 0); // Keep Ico for style, or use sphere
        petalGeo.scale(1, 0.5, 1);
        for (let i = 0; i < petalCount; i++) {
            const angle = (i / petalCount) * Math.PI * 2;
            const petal = new Mesh(petalGeo, petalMat);
            petal.position.set(Math.cos(angle) * 0.18, 0, Math.sin(angle) * 0.18);
            petal.rotation.z = Math.PI / 4;
            head.add(petal);
        }
    } else if (shape === 'multi') {
        const petalCount = 8 + Math.floor(Math.random() * 4);
        for (let i = 0; i < petalCount; i++) {
            const angle = (i / petalCount) * Math.PI * 2;
            const petal = new Mesh(sharedGeometries.unitSphere, petalMat);
            petal.scale.setScalar(0.12);
            petal.position.set(Math.cos(angle) * 0.2, Math.sin(i * 0.5) * 0.1, Math.sin(angle) * 0.2);
            head.add(petal);
        }
    } else if (shape === 'spiral') {
        const petalCount = 10;
        for (let i = 0; i < petalCount; i++) {
            const angle = (i / petalCount) * Math.PI * 4;
            const radius = 0.05 + (i / petalCount) * 0.15;
            const petal = new Mesh(sharedGeometries.unitCone, petalMat);
            petal.scale.set(0.1, 0.2, 0.1);
            petal.position.set(Math.cos(angle) * radius, (i / petalCount) * 0.1, Math.sin(angle) * radius);
            petal.rotation.z = angle;
            head.add(petal);
        }
    } else if (shape === 'layered') {
        for (let layer = 0; layer < 2; layer++) {
            const petalCount = 5;
            const petalGeo = new IcosahedronGeometry(0.12, 0);
            petalGeo.scale(1, 0.5, 1);
            const layerColor = layer === 0 ? petalMat : createClayMaterial(color ? color + 0x111111 : 0xFFD700);
            if (layer !== 0) registerReactiveMaterial(layerColor);

            for (let i = 0; i < petalCount; i++) {
                const angle = (i / petalCount) * Math.PI * 2 + (layer * Math.PI / petalCount);
                const petal = new Mesh(petalGeo, layerColor);
                petal.position.set(
                    Math.cos(angle) * (0.15 + layer * 0.05),
                    layer * 0.05,
                    Math.sin(angle) * (0.15 + layer * 0.05)
                );
                petal.rotation.z = Math.PI / 4;
                head.add(petal);
            }
        }
    }

    if (Math.random() > 0.5) {
        // Use shared cone for beam
        const beam = new Mesh(sharedGeometries.unitCone, foliageMaterials.lightBeam.clone());
        beam.scale.set(0.1, 1.0, 0.1);
        beam.position.y = stemHeight;
        beam.userData.isBeam = true;
        group.add(beam);
    }

    group.userData.animationOffset = Math.random() * 10;
    group.userData.animationType = pickAnimation(['sway', 'wobble', 'accordion']);
    group.userData.type = 'flower';
    group.userData.isFlower = true;

    // Sun Flower logic (Reacts when bright)
    if (shape === 'sunflower' || shape === 'multi') {
        return attachReactivity(group, { });
    }

    // Standard Flower logic (Daytime/Dusk)
    return attachReactivity(group, { });
}

function createGlowingFlower(options = {}) {
    const { color = 0xFFD700, intensity = 1.5 } = options;
    const group = new Group();

    const stemHeight = 0.6 + Math.random() * 0.4;
    const stem = new Mesh(sharedGeometries.unitCylinder, foliageMaterials.flowerStem);
    stem.scale.set(0.05, stemHeight, 0.05);
    stem.castShadow = true;
    group.add(stem);

    // Use Safe Material Helper
    const headMat = createStandardNodeMaterial({
        color,
        emissive: color,
        emissiveIntensity: intensity,
        roughness: 0.8
    });
    registerReactiveMaterial(headMat);

    const head = new Mesh(sharedGeometries.unitSphere, headMat);
    head.scale.setScalar(0.2);
    head.position.y = stemHeight;
    group.add(head);

    const wash = new Mesh(sharedGeometries.unitSphere, foliageMaterials.lightBeam);
    wash.scale.setScalar(1.5);
    wash.position.y = stemHeight;
    wash.userData.isWash = true;
    group.add(wash);

    const light = new PointLight(color, 0.5, 3.0);
    light.position.y = stemHeight;
    group.add(light);

    group.userData.animationType = 'glowPulse';
    group.userData.animationOffset = Math.random() * 10;
    group.userData.type = 'flower';
    // Glowing flowers are often Night Dancers
    return attachReactivity(group, { });
}

function createStarflower(options = {}) {
    const { color: hexColor = 0xFF6EC7 } = options;
    const group = new Group();

    const stemH = 0.7 + Math.random() * 0.4;
    const stem = new Mesh(sharedGeometries.unitCylinder, createClayMaterial(0x228B22));
    stem.scale.set(0.04, stemH, 0.04);
    stem.castShadow = true;
    group.add(stem);

    const center = new Mesh(sharedGeometries.unitSphere, foliageMaterials.flowerCenter);
    center.scale.setScalar(0.09);
    center.position.y = stemH;
    group.add(center);

    const petalMat = createClayMaterial(hexColor);
    registerReactiveMaterial(petalMat);

    const petalCount = 6 + Math.floor(Math.random() * 3);
    for (let i = 0; i < petalCount; i++) {
        const petal = new Mesh(sharedGeometries.unitCone, petalMat);
        petal.scale.set(0.09, 0.2, 0.09);
        const angle = (i / petalCount) * Math.PI * 2;
        petal.position.set(Math.cos(angle) * 0.16, stemH, Math.sin(angle) * 0.16);
        petal.rotation.x = Math.PI * 0.5;
        petal.rotation.z = angle;
        group.add(petal);
    }

    const beamMat = foliageMaterials.lightBeam.clone();
    beamMat.colorNode = color(hexColor);
    const beam = new Mesh(sharedGeometries.unitCone, beamMat);
    beam.position.y = stemH;
    beam.scale.set(0.02, 4.0, 0.02); // Tall thin beam
    beam.userData.isBeam = true;
    group.add(beam);

    group.userData.animationType = 'spin';
    group.userData.animationOffset = Math.random() * 10;
    group.userData.type = 'starflower';
    // Moon Flower logic (Night only)
    return attachReactivity(group, { });
}

function createPrismRoseBush(options = {}) {
    const group = new Group();

    const stemsMat = createClayMaterial(0x5D4037);
    const baseHeight = 1.0 + Math.random() * 0.5;

    const trunk = new Mesh(sharedGeometries.unitCylinder, stemsMat);
    trunk.scale.set(0.15, baseHeight, 0.15);
    trunk.castShadow = true;
    group.add(trunk);

    const branchCount = 3 + Math.floor(Math.random() * 3);
    const roseColors = [0xFF0055, 0xFFAA00, 0x00CCFF, 0xFF00FF, 0x00FF88];

    for (let i = 0; i < branchCount; i++) {
        const branchGroup = new Group();
        branchGroup.position.y = baseHeight * 0.8;
        branchGroup.rotation.y = (i / branchCount) * Math.PI * 2;
        branchGroup.rotation.z = Math.PI / 4;

        const branchLen = 0.8 + Math.random() * 0.5;
        const branch = new Mesh(sharedGeometries.unitCylinder, stemsMat);
        branch.scale.set(0.08, branchLen, 0.08);
        branchGroup.add(branch);

        const roseGroup = new Group();
        roseGroup.position.y = branchLen;

        const hexColor = roseColors[Math.floor(Math.random() * roseColors.length)];
        
        // Use safe helper
        const petalMat = createStandardNodeMaterial({
            color: hexColor,
            roughness: 0.7,
            emissive: 0x000000,
            emissiveIntensity: 0.0
        });
        registerReactiveMaterial(petalMat);

        const outerGeo = new TorusKnotGeometry(0.25, 0.08, 64, 8, 2, 3);
        const outer = new Mesh(outerGeo, petalMat);
        outer.scale.set(1, 0.6, 1);
        roseGroup.add(outer);

        const inner = new Mesh(sharedGeometries.unitSphere, petalMat);
        inner.scale.setScalar(0.15);
        inner.position.y = 0.05;
        roseGroup.add(inner);

        const washMat = foliageMaterials.lightBeam.clone();
        washMat.colorNode = color(hexColor);
        const wash = new Mesh(sharedGeometries.unitSphere, washMat);
        wash.scale.setScalar(1.2);
        wash.userData.isWash = true;
        roseGroup.add(wash);

        branchGroup.add(roseGroup);
        group.add(branchGroup);
    }

    group.userData.animationType = pickAnimation(['sway', 'wobble']);
    group.userData.animationOffset = Math.random() * 10;
    group.userData.type = 'flower';

    return attachReactivity(group, { });
}

function createSubwooferLotus(options = {}) {
    const { color: hexColor = 0x2E8B57 } = options;
    const group = new Group();

    const pad = new Mesh(sharedGeometries.unitCylinder, createClayMaterial(hexColor));
    pad.scale.set(1.5, 0.5, 1.5);
    pad.position.y = 0;
    pad.castShadow = true;
    pad.receiveShadow = true;

    const ringMat = foliageMaterials.lotusRing.clone();
    ringMat.emissiveNode = color(0x000000); 
    pad.userData.ringMaterial = ringMat;
    registerReactiveMaterial(ringMat);

    for (let i = 1; i <= 3; i++) {
        const ringGeo = new TorusGeometry(i * 0.3, 0.05, 8, 24);
        const ring = new Mesh(ringGeo, ringMat);
        ring.rotation.x = -Math.PI / 2;
        ring.position.y = 0.51; // Just above pad
        pad.add(ring);
    }

    group.add(pad);

    group.userData.animationType = 'speakerPulse';
    group.userData.animationOffset = Math.random() * 10;
    group.userData.type = 'lotus';

    return attachReactivity(group, { }); // Lotus might be always active
}

function createVibratoViolet(options = {}) {
    const { color = 0x8A2BE2, intensity = 1.0 } = options;
    const group = new Group();

    const stemH = 0.5 + Math.random() * 0.3;
    const stem = new Mesh(sharedGeometries.unitCylinder, createClayMaterial(0x228B22));
    stem.scale.set(0.03, stemH, 0.03);
    stem.castShadow = true;
    group.add(stem);

    const headGroup = new Group();
    headGroup.position.y = stemH;
    group.add(headGroup);

    // Use Safe Material Helper
    const centerMat = createStandardNodeMaterial({
        color: color,
        emissive: color,
        emissiveIntensity: 0.8 * intensity,
        roughness: 0.3
    });
    registerReactiveMaterial(centerMat);
    const center = new Mesh(sharedGeometries.unitSphere, centerMat);
    center.scale.setScalar(0.08);
    headGroup.add(center);

    const petalCount = 5;
    const petalGeo = new CircleGeometry(0.15, 8);
    // Use TransparentNodeMaterial Helper
    const petalMat = createTransparentNodeMaterial({
        color: color,
        emissive: color,
        emissiveIntensity: 0.4 * intensity,
        roughness: 0.4,
        opacity: 0.7,
        side: DoubleSide
    });
    registerReactiveMaterial(petalMat);

    for (let i = 0; i < petalCount; i++) {
        const petal = new Mesh(petalGeo, petalMat);
        const angle = (i / petalCount) * Math.PI * 2;
        petal.position.set(Math.cos(angle) * 0.12, 0, Math.sin(angle) * 0.12);
        petal.rotation.x = -Math.PI / 2 + Math.random() * 0.3;
        petal.rotation.z = angle;
        petal.userData.vibratoPhase = Math.random() * Math.PI * 2;
        headGroup.add(petal);
    }

    const light = new PointLight(color, 0.3 * intensity, 2.0);
    light.position.y = 0;
    headGroup.add(light);

    group.userData.animationType = 'vibratoShake';
    group.userData.animationOffset = Math.random() * 10;
    group.userData.type = 'vibratoViolet';
    group.userData.headGroup = headGroup;

    return attachReactivity(group, { });
}

function createTremoloTulip(options = {}) {
    const { color = 0xFF6347, size = 1.0 } = options;
    const group = new Group();

    const stemH = (0.8 + Math.random() * 0.4) * size;
    const stem = new Mesh(sharedGeometries.unitCylinder, createClayMaterial(0x228B22));
    stem.scale.set(0.04 * size, stemH, 0.04 * size);
    stem.castShadow = true;
    group.add(stem);

    const headGroup = new Group();
    headGroup.position.y = stemH;
    group.add(headGroup);

    // Legacy geometry kept for complex shapes
    const bellGeo = new CylinderGeometry(0.2 * size, 0.05 * size, 0.25 * size, 12, 1, true);
    bellGeo.translate(0, -0.125 * size, 0);
    
    // Use TransparentNodeMaterial Helper
    const bellMat = createTransparentNodeMaterial({
        color: color,
        emissive: color,
        emissiveIntensity: 0.3,
        roughness: 0.5,
        opacity: 0.9,
        side: DoubleSide
    });
    registerReactiveMaterial(bellMat);
    const bell = new Mesh(bellGeo, bellMat);
    bell.rotation.x = Math.PI;
    headGroup.add(bell);

    // Use TransparentNodeMaterial Helper for vortex
    const vortexMat = createTransparentNodeMaterial({
        color: 0xFFFFFF,
        opacity: 0.5,
        blending: AdditiveBlending,
        depthWrite: false
    });
    const vortex = new Mesh(sharedGeometries.unitSphere, vortexMat);
    vortex.scale.setScalar(0.08 * size);
    vortex.position.y = -0.1 * size;
    headGroup.add(vortex);
    group.userData.vortex = vortex;

    const rimGeo = new TorusGeometry(0.2 * size, 0.02, 8, 16);
    // Use TransparentNodeMaterial Helper for rim
    const rimMat = createTransparentNodeMaterial({
        color: color,
        opacity: 0.6,
        blending: AdditiveBlending
    });
    const rim = new Mesh(rimGeo, rimMat);
    rim.rotation.x = Math.PI / 2;
    rim.position.y = -0.02 * size;
    headGroup.add(rim);

    group.userData.animationType = 'tremeloPulse';
    group.userData.animationOffset = Math.random() * 10;
    group.userData.type = 'tremoloTulip';
    group.userData.headGroup = headGroup;
    group.userData.bellMaterial = bellMat;

    return attachReactivity(group, { });
}

function createLanternFlower(options = {}) {
    const { color = 0xFFA500, height = 2.5 } = options; // Orange glow by default
    const group = new Group();

    // 1. Tall Curved Stem (Streetlamp shape)
    // Base Stem
    const stemMat = createClayMaterial(0x2F4F4F); // Dark slate grey/green
    const stemBase = new Mesh(sharedGeometries.unitCylinder, stemMat);
    stemBase.scale.set(0.1, height, 0.1);
    stemBase.position.y = height * 0.5;
    stemBase.castShadow = true;
    group.add(stemBase);

    // Curved Top (The "Hook")
    const hookGroup = new Group();
    hookGroup.position.set(0, height, 0);

    // We construct a simple curve using a torus segment
    const hookGeo = new TorusGeometry(0.5, 0.08, 6, 8, Math.PI);
    const hook = new Mesh(hookGeo, stemMat);
    hook.rotation.z = -Math.PI / 2; // Arch over
    hook.position.set(0.5, 0, 0); // Offset so it curves out
    hookGroup.add(hook);
    group.add(hookGroup);

    // 2. The Lantern Bulb (Hanging from the hook)
    const bulbGroup = new Group();
    bulbGroup.position.set(1.0, height - 0.2, 0); // End of the hook (0.5 radius + 0.5 offset)
    group.add(bulbGroup);

    // Cap
    const capGeo = new ConeGeometry(0.2, 0.2, 6);
    const cap = new Mesh(capGeo, stemMat);
    bulbGroup.add(cap);

    // Glowing Bulb
    const bulbMat = createStandardNodeMaterial({
        color: 0xFFFFFF,
        emissive: color,
        emissiveIntensity: 2.0,
        roughness: 0.2
    });
    registerReactiveMaterial(bulbMat);

    // Elongated sphere for bulb
    const bulb = new Mesh(sharedGeometries.unitSphere, bulbMat);
    bulb.scale.set(0.25, 0.4, 0.25);
    bulb.position.y = -0.3;
    bulbGroup.add(bulb);

    // Actual Light Source
    const light = new PointLight(color, 1.0, 8.0);
    light.position.y = -0.5;
    light.castShadow = true;
    bulbGroup.add(light);

    // 3. Animation & Reactivity
    group.userData.animationType = 'sway'; // Gentle swaying in wind
    group.userData.animationOffset = Math.random() * 10;
    group.userData.type = 'lanternFlower';

    // Reactive logic:
    // It should pulse with the music (lanterns flickering)
    // We attach reactivity but with high minLight so it's always somewhat visible (or rather, consistent visibility)
    // minLight: 0.0 means it works even in pitch black.
    const reactiveGroup = attachReactivity(group, { });

    // Custom logic: Add "flicker" on kick drum
    reactiveGroup.reactToNote = (note, colorVal, velocity) => {
        bulbMat.emissiveIntensity = 2.0 + velocity * 3.0;
        light.intensity = 1.0 + velocity * 2.0;
        // Reset handled by material decay usually, but light intensity needs manual decay or just set it
        // Since reactToNote is one-shot, we rely on the loop or just let it pop.
        // For smoother flicker we might need update logic, but this is a good start.
    };

    return reactiveGroup;
}

function createLeafParticle(options = {}) {
  const { color = 65280 } = options;
  const leafShape = new Shape();
  leafShape.moveTo(0, 0);
  leafShape.quadraticCurveTo(0.1, 0.1, 0, 0.2);
  leafShape.quadraticCurveTo(-0.1, 0.1, 0, 0);
  const geo = new ShapeGeometry(leafShape);
  const mat = createClayMaterial(color);
  const leaf = new Mesh(geo, mat);
  leaf.castShadow = true;
  return leaf;
}
function createWisteriaCluster(options = {}) {
  const { color = 13607167, strands = 4 } = options;
  const group = new Group();
  const bloomMat = createClayMaterial(color);
  registerReactiveMaterial(bloomMat);
  for (let s = 0; s < strands; s++) {
    const strand = new Group();
    const length = 3 + Math.floor(Math.random() * 3);
    for (let i = 0; i < length; i++) {
      const seg = new Mesh(sharedGeometries.cylinderLow, createClayMaterial(3050327));
      seg.scale.set(0.03, 0.4, 0.03);
      seg.position.y = -i * 0.35;
      seg.rotation.z = Math.sin(i * 0.5) * 0.15;
      strand.add(seg);
      if (i > 0 && Math.random() > 0.6) {
        const b = new Mesh(sharedGeometries.sphereLow, bloomMat);
        b.scale.setScalar(0.05);
        b.position.y = seg.position.y - 0.1;
        b.position.x = (Math.random() - 0.5) * 0.06;
        b.position.z = (Math.random() - 0.5) * 0.06;
        strand.add(b);
      }
    }
    strand.position.x = (Math.random() - 0.5) * 0.6;
    strand.position.y = 0;
    group.add(strand);
  }
  group.userData.animationType = pickAnimation(["vineSway", "spiralWave"]);
  group.userData.animationOffset = Math.random() * 10;
  group.userData.type = "vine";
  return group;
}
function createBubbleWillow(options = {}) {
  const { color = 9055202 } = options;
  const group = new Group();
  const trunkH = 2.5 + Math.random();
  const trunk = new Mesh(sharedGeometries.cylinder, createClayMaterial(6111287));
  trunk.scale.set(0.5, trunkH, 0.5);
  trunk.position.y = trunkH / 2;
  trunk.castShadow = true;
  group.add(trunk);
  const branchCount = 4 + Math.floor(Math.random() * 2);
  const branchMat = createClayMaterial(color);
  registerReactiveMaterial(branchMat);
  for (let i = 0; i < branchCount; i++) {
    const branchGroup = new Group();
    branchGroup.position.y = trunkH * 0.9;
    branchGroup.rotation.y = i / branchCount * Math.PI * 2;
    const length = 1.5 + Math.random();
    const capsuleGeo = new CapsuleGeometry(0.2, length, 8, 16);
    const capsuleMesh = new Mesh(capsuleGeo, branchMat);
    capsuleMesh.position.set(0.5, -length / 2, 0);
    capsuleMesh.rotation.z = -Math.PI / 6;
    branchGroup.add(capsuleMesh);
    group.add(branchGroup);
  }
  group.userData.animationType = "gentleSway";
  group.userData.animationOffset = Math.random() * 10;
  group.userData.type = "tree";
  return attachReactivity(group);
}
function createHelixPlant(options = {}) {
  const { color = 64154 } = options;
  const group = new Group();
  class SpiralCurve extends Curve {
    constructor(scale = 1) {
      super();
      this.scale = scale;
    }
    getPoint(t, optionalTarget = new Vector3()) {
      const tx = Math.cos(t * Math.PI * 4) * 0.2 * t * this.scale;
      const ty = t * 2 * this.scale;
      const tz = Math.sin(t * Math.PI * 4) * 0.2 * t * this.scale;
      return optionalTarget.set(tx, ty, tz);
    }
  }
  const path = new SpiralCurve(1 + Math.random() * 0.5);
  const tubeGeo = new TubeGeometry(path, 20, 0.08, 8, false);
  const mat = createClayMaterial(color);
  registerReactiveMaterial(mat);
  const mesh = new Mesh(tubeGeo, mat);
  mesh.castShadow = true;
  group.add(mesh);
  const tipMat = new MeshStandardMaterial({
    color: 16777215,
    emissive: 16775885,
    emissiveIntensity: 0.5,
    roughness: 0.5
  });
  registerReactiveMaterial(tipMat);
  const tip = new Mesh(sharedGeometries.sphereLow, tipMat);
  tip.scale.setScalar(0.15);
  const endPoint = path.getPoint(1);
  tip.position.copy(endPoint);
  group.add(tip);
  group.userData.animationType = pickAnimation(["spring", "wobble"]);
  group.userData.animationOffset = Math.random() * 10;
  group.userData.type = "shrub";
  return attachReactivity(group);
}
function createBalloonBush(options = {}) {
  const { color = 16729344 } = options;
  const group = new Group();
  const sphereCount = 5 + Math.floor(Math.random() * 5);
  const mat = createClayMaterial(color);
  registerReactiveMaterial(mat);
  for (let i = 0; i < sphereCount; i++) {
    const r = 0.3 + Math.random() * 0.4;
    const mesh = new Mesh(sharedGeometries.sphere, mat);
    mesh.scale.setScalar(r);
    mesh.position.set(
      (Math.random() - 0.5) * 0.8,
      r + Math.random() * 0.8,
      (Math.random() - 0.5) * 0.8
    );
    mesh.castShadow = true;
    group.add(mesh);
  }
  group.userData.animationType = pickAnimation(["bounce", "accordion", "hop"]);
  group.userData.animationOffset = Math.random() * 10;
  group.userData.type = "shrub";
  return attachReactivity(group);
}
function createAccordionPalm(options = {}) {
  const { color = 16766720 } = options;
  const group = new Group();
  const trunkHeight = 3;
  const segments = 10;
  const trunkGroup = new Group();
  const pleatGeo = new TorusGeometry(0.3, 0.15, 8, 16);
  const pleatMat = createClayMaterial(9127187);
  for (let i = 0; i < segments; i++) {
    const pleat = new Mesh(pleatGeo, pleatMat);
    pleat.rotation.x = Math.PI / 2;
    pleat.position.y = i * (trunkHeight / segments);
    if (i % 2 === 0) {
      pleat.material = createClayMaterial(10506797);
    }
    trunkGroup.add(pleat);
  }
  group.add(trunkGroup);
  const leafCount = 6;
  const leafGeo = new CylinderGeometry(0.05, 0.1, 1.5, 8);
  leafGeo.translate(0, 0.75, 0);
  const leafMat = createClayMaterial(color);
  registerReactiveMaterial(leafMat);
  const headGroup = new Group();
  headGroup.position.y = trunkHeight;
  trunkGroup.add(headGroup);
  for (let i = 0; i < leafCount; i++) {
    const leaf = new Mesh(leafGeo, leafMat);
    leaf.rotation.z = Math.PI / 3;
    leaf.rotation.y = i / leafCount * Math.PI * 2;
    headGroup.add(leaf);
  }
  group.userData.animationType = "accordionStretch";
  group.userData.animationOffset = Math.random() * 10;
  group.userData.type = "tree";
  group.userData.trunk = trunkGroup;
  return group;
}
function createFiberOpticWillow(options = {}) {
  const { color = 16777215 } = options;
  const group = new Group();
  const trunkH = 2.5 + Math.random();
  const trunk = new Mesh(sharedGeometries.cylinder, createClayMaterial(2236962));
  trunk.scale.set(0.3, trunkH, 0.3);
  trunk.position.y = trunkH / 2;
  trunk.castShadow = true;
  group.add(trunk);
  const branchCount = 8;
  const cableMat = foliageMaterials.opticCable;
  const tipMat = foliageMaterials.opticTip.clone();
  registerReactiveMaterial(tipMat);
  for (let i = 0; i < branchCount; i++) {
    const branchGroup = new Group();
    branchGroup.position.y = trunkH * 0.9;
    branchGroup.rotation.y = i / branchCount * Math.PI * 2;
    const len = 1.5 + Math.random();
    const whip = new Group();
    whip.rotation.z = Math.PI / 4;
    const cable = new Mesh(sharedGeometries.cylinderLow, cableMat);
    cable.scale.set(0.02, len, 0.02);
    cable.position.set(0, -len / 2, 0);
    whip.add(cable);
    const tip = new Mesh(sharedGeometries.sphereLow, tipMat);
    tip.scale.setScalar(0.08);
    tip.position.set(0, -len, 0);
    whip.add(tip);
    branchGroup.add(whip);
    group.add(branchGroup);
  }
  group.userData.animationType = "fiberWhip";
  group.userData.animationOffset = Math.random() * 10;
  group.userData.type = "willow";
  return attachReactivity(group);
}
class VineSwing {
  constructor(vineMesh, length = 8) {
    this.vine = vineMesh;
    this.anchorPoint = vineMesh.position.clone();
    this.length = length;
    this.isPlayerAttached = false;
    this.swingAngle = 0;
    this.swingAngularVel = 0;
    this.swingPlane = new Vector3(1, 0, 0);
    this.rotationAxis = new Vector3(0, 0, 1);
    this.defaultDown = new Vector3(0, -1, 0);
  }
  update(player, delta, inputState) {
    const damping = 0.99;
    const angularAccel = -20 / this.length * Math.sin(this.swingAngle);
    this.swingAngularVel += angularAccel * delta;
    this.swingAngularVel *= damping;
    if (this.isPlayerAttached && inputState) {
      const pumpForce = 3;
      if (inputState.forward) {
        if (Math.abs(this.swingAngularVel) > 0.1) {
          this.swingAngularVel += Math.sign(this.swingAngularVel) * pumpForce * delta;
        } else {
          this.swingAngularVel += pumpForce * delta;
        }
      } else if (inputState.backward) {
        this.swingAngularVel -= Math.sign(this.swingAngularVel) * pumpForce * delta;
      }
    }
    this.swingAngle += this.swingAngularVel * delta;
    const maxAngle = Math.PI * 0.45;
    if (this.swingAngle > maxAngle) {
      this.swingAngle = maxAngle;
      this.swingAngularVel *= -0.5;
    } else if (this.swingAngle < -maxAngle) {
      this.swingAngle = -maxAngle;
      this.swingAngularVel *= -0.5;
    }
    const dy = -Math.cos(this.swingAngle) * this.length;
    const dh = Math.sin(this.swingAngle) * this.length;
    const targetPos = this.anchorPoint.clone();
    targetPos.y += dy;
    targetPos.addScaledVector(this.swingPlane, dh);
    if (this.isPlayerAttached) {
      player.position.copy(targetPos);
    }
    const dir = new Vector3().subVectors(targetPos, this.anchorPoint).normalize();
    this.vine.quaternion.setFromUnitVectors(this.defaultDown, dir);
  }
  attach(player, playerVelocity) {
    this.isPlayerAttached = true;
    const horizVel = new Vector3(playerVelocity.x, 0, playerVelocity.z);
    if (horizVel.lengthSq() > 1) {
      this.swingPlane.copy(horizVel.normalize());
    } else {
      const toPlayer2 = new Vector3().subVectors(player.position, this.anchorPoint);
      toPlayer2.y = 0;
      if (toPlayer2.lengthSq() > 0.1) {
        this.swingPlane.copy(toPlayer2.normalize());
      }
    }
    const toPlayer = new Vector3().subVectors(player.position, this.anchorPoint);
    const dy = toPlayer.y;
    const dh = toPlayer.dot(this.swingPlane);
    this.swingAngle = Math.atan2(dh, -dy);
    const cosA = Math.cos(this.swingAngle);
    const sinA = Math.sin(this.swingAngle);
    const vH = horizVel.length() * (playerVelocity.dot(this.swingPlane) > 0 ? 1 : -1);
    const vY = playerVelocity.y;
    const vTangential = vH * cosA + vY * sinA;
    this.swingAngularVel = vTangential / this.length;
  }
  detach(player) {
    this.isPlayerAttached = false;
    const tangentVel = this.swingAngularVel * this.length;
    const cosA = Math.cos(this.swingAngle);
    const sinA = Math.sin(this.swingAngle);
    const vH = tangentVel * cosA;
    const vY = tangentVel * sinA;
    player.velocity.x = this.swingPlane.x * vH;
    player.velocity.z = this.swingPlane.z * vH;
    player.velocity.y = vY;
    player.velocity.y += 5;
    return Date.now();
  }
}
function createSwingableVine(options = {}) {
  const { length = 12, color = 3050327 } = options;
  const group = new Group();
  const segmentCount = 8;
  const segLen = length / segmentCount;
  for (let i = 0; i < segmentCount; i++) {
    const mat = createClayMaterial(color);
    const segmentGroup = new Group();
    segmentGroup.position.y = -i * segLen;
    const mesh = new Mesh(sharedGeometries.cylinderLow, mat);
    mesh.scale.set(0.15, segLen, 0.15);
    mesh.position.y = -segLen / 2;
    mesh.rotation.z = (Math.random() - 0.5) * 0.1;
    mesh.rotation.x = (Math.random() - 0.5) * 0.1;
    segmentGroup.add(mesh);
    if (Math.random() > 0.4) {
      const leaf = createLeafParticle({ color: 3329330 });
      leaf.position.y = -segLen * 0.5;
      leaf.position.x = 0.1;
      leaf.rotation.z = Math.PI / 4;
      segmentGroup.add(leaf);
    }
    group.add(segmentGroup);
  }
  const hitGeo = new CylinderGeometry(0.5, 0.5, length, 8);
  hitGeo.translate(0, -length / 2, 0);
  const hitMat = new MeshBasicMaterial({ color: 16776960, wireframe: true, visible: false });
  const hitbox = new Mesh(hitGeo, hitMat);
  hitbox.userData.isVineHitbox = true;
  group.add(hitbox);
  group.userData.type = "vine";
  group.userData.isSwingable = true;
  group.userData.vineLength = length;
  return group;
}

// src/foliage/clouds.js


// --- Global Uniforms (Driven by WeatherSystem) ---
const uCloudRainbowIntensity = uniform(0.0);
const uCloudLightningStrength = uniform(0.0);
const uCloudLightningColor = uniform(new Color(0xFFFFFF));

// --- Configuration ---
const puffGeometry = new IcosahedronGeometry(1, 1);

// Helper: Create the TSL Material
function createCloudMaterial() {
    const material = new MeshStandardNodeMaterial({
        color: 0xffffff,     // Pure cotton white base
        roughness: 1.0,      // Completely matte
        metalness: 0.0,
        flatShading: false,
    });

    // TSL Logic:
    // Emission = Lightning Color * Lightning Strength * Multiplier
    // FIX: Explicitly wrap multiplier in float() to prevent any type ambiguity
    const lightningGlow = uCloudLightningColor.mul(uCloudLightningStrength.mul(float(2.0)));

    material.emissiveNode = lightningGlow;

    return material;
}

const sharedCloudMaterial = createCloudMaterial();

function createRainingCloud(options = {}) {
    const { scale = 1.0, size = 1.0 } = options;
    const finalScale = scale * (typeof size === 'number' ? size : 1.0);
    return createCloud({ scale: finalScale });
}

function createCloud(options = {}) {
    const {
        scale = 1.0,
        tier = 1,
        puffCount = 12 + Math.floor(Math.random() * 8)
    } = options;

    const group = new Group();
    group.userData.type = 'cloud';
    group.userData.tier = tier;
    group.userData.isRainCloud = false;

    // Generate the cloud by clustering "puffs"
    for (let i = 0; i < puffCount; i++) {
        const puff = new Mesh(puffGeometry, sharedCloudMaterial);

        const radiusSpread = (Math.random() * 2.5 + 0.5) * scale;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);

        puff.position.set(
            radiusSpread * Math.sin(phi) * Math.cos(theta),
            radiusSpread * Math.sin(phi) * Math.sin(theta),
            radiusSpread * Math.cos(phi)
        );

        puff.position.y *= 0.6; // Flatten bottom

        const distFromCenter = puff.position.length();
        const sizeBase = 1.0 - (distFromCenter / (3.5 * scale)) * 0.5;
        const puffScaleRandom = 0.5 + Math.random() * 1.0;
        const finalPuffScale = Math.max(0.2, sizeBase * puffScaleRandom * scale);

        puff.scale.setScalar(finalPuffScale);
        puff.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);

        puff.castShadow = true;
        puff.receiveShadow = true;

        group.add(puff);
    }

    group.scale.set(1.4, 1.0, 1.2);
    group.userData.originalScale = group.scale.clone();
    group.userData.animOffset = Math.random() * 100;

    group.onAnimate = (delta, time) => {
        const t = time + group.userData.animOffset;
        group.position.y += Math.sin(t * 0.5) * 0.05 * delta;
        group.rotation.y += Math.cos(t * 0.1) * 0.02 * delta;
    };

    group.userData.onAnimate = group.onAnimate;

    return group;
}

// Helper for 'falling clouds' physics logic
function updateFallingClouds(dt, clouds, getGroundHeight) {
    for (let i = clouds.length - 1; i >= 0; i--) {
        const cloud = clouds[i];
        if (cloud.userData.isFalling) {
            cloud.userData.velocity.y -= 20.0 * dt;
            cloud.position.addScaledVector(cloud.userData.velocity, dt);

            const groundY = getGroundHeight(cloud.position.x, cloud.position.z);
            if (cloud.position.y < groundY - 2.0) {
                respawnCloud(cloud);
            }
        }
    }
}

function respawnCloud(cloud) {
    cloud.userData.isFalling = false;
    cloud.position.set(
        (Math.random() - 0.5) * 200,
        40 + Math.random() * 20,
        (Math.random() - 0.5) * 200
    );
}

/**
 * Creates a bioluminescent waterfall connecting two points.
 * @param {THREE.Vector3} startPos - Top position
 * @param {THREE.Vector3} endPos - Bottom position
 * @param {number} width - Width of the waterfall
 */
function createWaterfall(startPos, endPos, width = 5.0) {
    const group = new Group();
    group.name = 'Waterfall';

    const height = startPos.y - endPos.y;
    const midY = (startPos.y + endPos.y) / 2;

    // Geometry: Vertical plane bent slightly? Simple plane for now.
    // We align it to face roughly Z or camera, but for 3D world, a cylinder segment or curved plane is better.
    // Let's use a CylinderGeometry with open ends, scaled flat.
    const geo = new CylinderGeometry(width, width * 1.5, height, 16, 8, true);
    // Cylinder is Y-up by default.
    // We need to position it at midY.

    // Custom TSL Material for "Viscous Neon"
    const mat = new MeshStandardNodeMaterial({
        color: 0x00FFFF,
        roughness: 0.2,
        metalness: 0.1,
        transparent: true,
        side: DoubleSide
    });

    // Flow Logic
    const speed = 2.0;
    const flowUV = uv().add(vec2(0, time.mul(speed).negate())); // Scroll UV Y

    // Noise/Texture approximation using sin/cos for ripples
    // Since we don't have a noise texture loaded here easily without async, we use procedural noise.
    // Simple ripple pattern:
    const ripple = sin(flowUV.y.mul(20.0).add(flowUV.x.mul(10.0))).mul(0.5).add(0.5);
    const pulse = sin(time.mul(3.0)).mul(0.2).add(0.8);

    // Color Gradient: Cyan at top -> Purple at bottom
    // We use uv().y (0 at bottom, 1 at top) ? Cylinder UVs: y goes 0 to 1? Check Three.js docs.
    // Usually y=0 is bottom.
    const gradient = mix(color(0xFF00FF), color(0x00FFFF), uv().y);

    mat.colorNode = gradient;
    mat.opacityNode = float(0.7).mul(ripple.add(0.5)); // Semitransparent with ripples
    mat.emissiveNode = gradient.mul(pulse).mul(ripple);

    const mesh = new Mesh(geo, mat);
    mesh.position.set(startPos.x, midY, startPos.z);

    // Register for reactivity (optional, waterfalls could flash)
    registerReactiveMaterial(mat);

    group.add(mesh);

    // Add Splash Particles at bottom
    // For now, simple spheres or sprites could represent splash, but let's keep it geometry based.
    const splashCount = 5;
    for (let i = 0; i < splashCount; i++) {
        const splashGeo = new SphereGeometry(width * 0.2, 8, 8);
        const splashMat = new MeshBasicMaterial({ color: 0xFFFFFF, transparent: true, opacity: 0.5 });
        const splash = new Mesh(splashGeo, splashMat);
        // Randomize
        splash.position.set(startPos.x + (Math.random()-0.5)*width, endPos.y, startPos.z + (Math.random()-0.5)*width);
        splash.userData = {
            velocity: new Vector3((Math.random()-0.5), Math.random()*5, (Math.random()-0.5)),
            originalY: endPos.y
        };
        group.add(splash);
    }

    // Attach custom animation for splashes
    group.userData.type = 'waterfall';
    group.userData.splashes = group.children.slice(1);

    // Custom animate function
    group.onAnimate = (delta, time) => {
        group.userData.splashes.forEach(s => {
            s.position.addScaledVector(s.userData.velocity, delta);
            s.userData.velocity.y -= 9.8 * delta; // Gravity
            if (s.position.y < s.userData.originalY - 1) {
                // Reset
                s.position.y = s.userData.originalY;
                s.userData.velocity.y = Math.random() * 5 + 2;
                s.position.x = startPos.x + (Math.random()-0.5)*width;
                s.position.z = startPos.z + (Math.random()-0.5)*width;
            }
        });
    };

    return group;
}

function createFloatingOrb(options = {}) {
    const { color = 0x87CEEB, size = 0.5 } = options;
    const geo = new SphereGeometry(size, 8, 8);
    const mat = new MeshStandardMaterial({ color, emissive: color, emissiveIntensity: 0.8 });
    registerReactiveMaterial(mat);

    const orb = new Mesh(geo, mat);
    orb.castShadow = true;
    orb.userData.animationType = 'float';
    orb.userData.animationOffset = Math.random() * 10;
    orb.userData.type = 'orb';

    const light = new PointLight(color, 0.5, 4.0);
    orb.add(light);

    return attachReactivity(orb);
}

function createKickDrumGeyser(options = {}) {
    const { color = 0xFF4500, maxHeight = 5.0 } = options;
    const group = new Group();

    const baseGeo = new RingGeometry(0.1, 0.4, 8, 1);
    baseGeo.rotateX(-Math.PI / 2);
    const baseMat = new MeshStandardMaterial({
        color: 0x1A0A00,
        roughness: 0.9,
        emissive: color,
        emissiveIntensity: 0.1
    });
    const base = new Mesh(baseGeo, baseMat);
    group.add(base);

    const coreGeo = new CylinderGeometry(0.08, 0.12, 0.1, 8);
    coreGeo.translate(0, -0.05, 0);
    const coreMat = new MeshStandardMaterial({
        color: color,
        emissive: color,
        emissiveIntensity: 0.8,
        roughness: 0.3
    });
    registerReactiveMaterial(coreMat);
    const core = new Mesh(coreGeo, coreMat);
    group.add(core);

    const plumeCount = 50;
    const plumeGeo = new BufferGeometry();
    const positions = new Float32Array(plumeCount * 3);
    const normals = new Float32Array(plumeCount * 3);
    const velocities = new Float32Array(plumeCount);

    for (let i = 0; i < plumeCount; i++) {
        positions[i * 3] = (Math.random() - 0.5) * 0.2;
        positions[i * 3 + 1] = 0;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 0.2;

        // Dummy normal
        normals[i * 3] = 0; normals[i * 3 + 1] = 1; normals[i * 3 + 2] = 0;

        velocities[i] = 0.5 + Math.random() * 0.5;
    }

    plumeGeo.setAttribute('position', new BufferAttribute(positions, 3));
    plumeGeo.setAttribute('normal', new BufferAttribute(normals, 3));
    plumeGeo.setAttribute('velocity', new BufferAttribute(velocities, 1));

    const plumeMat = new PointsMaterial({
        color: color,
        size: 0.15,
        transparent: true,
        opacity: 0.8,
        blending: AdditiveBlending,
        depthWrite: false
    });

    const plume = new Points(plumeGeo, plumeMat);
    plume.visible = false;
    group.add(plume);

    const light = new PointLight(color, 0, 5.0);
    light.position.y = 1;
    group.add(light);

    group.userData.animationType = 'geyserErupt';
    group.userData.animationOffset = Math.random() * 10;
    group.userData.type = 'geyser';
    group.userData.plume = plume;
    group.userData.plumeLight = light;
    group.userData.coreMaterial = coreMat;
    group.userData.maxHeight = maxHeight;
    group.userData.eruptionStrength = 0;

    return attachReactivity(group);
}

// src/foliage/fireflies.js


function createFireflies(count = 80, areaSize = 100) {
    const geo = new BufferGeometry();
    const positions = new Float32Array(count * 3);
    const normals = new Float32Array(count * 3); // NEW
    const phases = new Float32Array(count);
    const speeds = new Float32Array(count);

    for (let i = 0; i < count; i++) {
        positions[i * 3] = (Math.random() - 0.5) * areaSize;
        positions[i * 3 + 1] = 0.5 + Math.random() * 4;
        positions[i * 3 + 2] = (Math.random() - 0.5) * areaSize;

        // Dummy Normals
        normals[i * 3] = 0; normals[i * 3 + 1] = 1; normals[i * 3 + 2] = 0;

        phases[i] = Math.random() * Math.PI * 2;
        speeds[i] = 0.5 + Math.random() * 1.5;
    }

    geo.setAttribute('position', new BufferAttribute(positions, 3));
    geo.setAttribute('normal', new BufferAttribute(normals, 3)); // NEW
    geo.setAttribute('phase', new BufferAttribute(phases, 1));
    geo.setAttribute('speed', new BufferAttribute(speeds, 1));

    const mat = new PointsNodeMaterial({
        size: 0.2,
        transparent: true,
        depthWrite: false,
        blending: AdditiveBlending
    });

    const phaseAttr = attribute('phase');
    const speedAttr = attribute('speed');
    const blink = sin(time.mul(speedAttr).add(phaseAttr));

    const glowIntensity = blink.sub(0.7).max(0.0).mul(3.33);

    const fireflyColor = mix(
        color(0x88FF00),
        color(0xFFFF00),
        glowIntensity
    );

    mat.colorNode = fireflyColor.mul(glowIntensity.add(0.1));
    mat.opacityNode = glowIntensity.add(0.05).min(1.0);

    const fireflies = new Points(geo, mat);
    fireflies.userData.isFireflies = true;
    fireflies.visible = false;

    return fireflies;
}

function updateFireflies(fireflies, time, delta) {
    if (!fireflies || !fireflies.visible) return;

    const positions = fireflies.geometry.attributes.position.array;
    const phases = fireflies.geometry.attributes.phase.array;

    for (let i = 0; i < positions.length / 3; i++) {
        const idx = i * 3;
        const phase = phases[i];

        const driftX = Math.sin(time * 0.3 + phase) * 0.02;
        const driftY = Math.cos(time * 0.5 + phase * 1.3) * 0.01;
        const driftZ = Math.sin(time * 0.4 + phase * 0.7) * 0.02;

        positions[idx] += driftX;
        positions[idx + 1] += driftY;
        positions[idx + 2] += driftZ;

        if (positions[idx] > 50) positions[idx] = -50;
        if (positions[idx] < -50) positions[idx] = 50;
        if (positions[idx + 1] < 0.3) positions[idx + 1] = 0.3;
        if (positions[idx + 1] > 5) positions[idx + 1] = 5;
        if (positions[idx + 2] > 50) positions[idx + 2] = -50;
        if (positions[idx + 2] < -50) positions[idx + 2] = 50;
    }

    fireflies.geometry.attributes.position.needsUpdate = true;
}

const scriptRel = 'modulepreload';const assetsURL = function(dep) { return "/"+dep };const seen = {};const __vitePreload = function preload(baseModule, deps, importerUrl) {
	let promise = Promise.resolve();
	if (true               && deps && deps.length > 0) {
		document.getElementsByTagName("link");
		const cspNonceMeta = document.querySelector("meta[property=csp-nonce]");
		const cspNonce = cspNonceMeta?.nonce || cspNonceMeta?.getAttribute("nonce");
		function allSettled(promises$2) {
			return Promise.all(promises$2.map((p) => Promise.resolve(p).then((value$1) => ({
				status: "fulfilled",
				value: value$1
			}), (reason) => ({
				status: "rejected",
				reason
			}))));
		}
		promise = allSettled(deps.map((dep) => {
			dep = assetsURL(dep);
			if (dep in seen) return;
			seen[dep] = true;
			const isCss = dep.endsWith(".css");
			const cssSelector = isCss ? "[rel=\"stylesheet\"]" : "";
			if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) return;
			const link = document.createElement("link");
			link.rel = isCss ? "stylesheet" : scriptRel;
			if (!isCss) link.as = "script";
			link.crossOrigin = "";
			link.href = dep;
			if (cspNonce) link.setAttribute("nonce", cspNonce);
			document.head.appendChild(link);
			if (isCss) return new Promise((res, rej) => {
				link.addEventListener("load", res);
				link.addEventListener("error", () => rej(/* @__PURE__ */ new Error(`Unable to preload CSS for ${dep}`)));
			});
		}));
	}
	function handlePreloadError(err$2) {
		const e$1 = new Event("vite:preloadError", { cancelable: true });
		e$1.payload = err$2;
		window.dispatchEvent(e$1);
		if (!e$1.defaultPrevented) throw err$2;
	}
	return promise.then((res) => {
		for (const item of res || []) {
			if (item.status !== "rejected") continue;
			handlePreloadError(item.reason);
		}
		return baseModule().catch(handlePreloadError);
	});
};

// Updated for Emscripten Pthreads Support

const LOADING_PHASES = {
    WASM_INIT: 0,
    READY: 4
};

const PHASE_STATUS = {
    PENDING: 0,
    IN_PROGRESS: 1,
    COMPLETE: 2,
    ERROR: -1
};

// --- Shared Memory Utilities (Keep your existing code here) ---
let syncBuffer = null;
let syncView = null;

function isSharedMemoryAvailable() {
    try {
        if (typeof SharedArrayBuffer === 'undefined') return false;
        const test = new SharedArrayBuffer(4);
        const view = new Int32Array(test);
        Atomics.store(view, 0, 1);
        return Atomics.load(view, 0) === 1;
    } catch (e) {
        return false;
    }
}

function initSharedBuffer() {
    if (syncBuffer !== null) return true;
    if (!isSharedMemoryAvailable()) return false;
    try {
        syncBuffer = new SharedArrayBuffer(5 * Int32Array.BYTES_PER_ELEMENT);
        syncView = new Int32Array(syncBuffer);
        for (let i = 0; i < 5; i++) Atomics.store(syncView, i, PHASE_STATUS.PENDING);
        console.log('[WASMOrchestrator] Shared coordination buffer initialized');
        return true;
    } catch (e) {
        return false;
    }
}

function signalPhaseComplete(phase) {
    if (!syncView) return;
    Atomics.store(syncView, phase, PHASE_STATUS.COMPLETE);
    Atomics.notify(syncView, phase);
    console.log(`[WASMOrchestrator] Phase ${phase} complete`);
}

function signalPhaseStart(phase) {
    if (!syncView) return;
    Atomics.store(syncView, phase, PHASE_STATUS.IN_PROGRESS);
}

// --- HYBRID LOADER (The Fix) ---

/**
 * Parallel WASM Module Loader
 * - ASC: Loaded Manually (Standalone)
 * - EMCC: Loaded via Generated Loader (Pthreads)
 */
async function parallelWasmLoad(options = {}) {
    const {
        onProgress = () => {},
        ascWasmUrl = './candy_physics.wasm',
        cacheVersion = ''
    } = options;

    const buildUrl = (baseUrl) => cacheVersion ? `${baseUrl}?v=${cacheVersion}` : baseUrl;

    initSharedBuffer();
    
    onProgress(LOADING_PHASES.WASM_INIT, 'Initializing WASM modules...');
    signalPhaseStart(LOADING_PHASES.WASM_INIT);

    const results = { asc: null, emcc: null };

    // ---------------------------------------------------------
    // 1. Start Loading ASC (Manual / Standalone)
    // ---------------------------------------------------------
    const ascPromise = (async () => {
        try {
            // Minimal WASI stubs for AssemblyScript
            const wasiStubs = {
                fd_write: () => 0,
                abort: () => {},
                clock_time_get: () => performance.now()
            };

            const importObject = {
                env: {
                    abort: () => console.error("ASC Abort"),
                    seed: () => Math.random()
                },
                wasi_snapshot_preview1: wasiStubs
            };

            // Try streaming instantiation first for faster compilation
            let instance;
            try {
                const result = await WebAssembly.instantiateStreaming(
                    fetch(buildUrl(ascWasmUrl)),
                    importObject
                );
                instance = result.instance;
                console.log('[WASMOrchestrator] ASC module compiled (streaming)');
            } catch (streamError) {
                console.log('[WASMOrchestrator] Streaming failed, using fallback:', streamError);
                // Fallback to traditional method
                const response = await fetch(buildUrl(ascWasmUrl));
                if (!response.ok) return null;
                const bytes = await response.arrayBuffer();
                const result = await WebAssembly.instantiate(bytes, importObject);
                instance = result.instance;
                console.log('[WASMOrchestrator] ASC module compiled (buffer)');
            }
            
            return instance;
        } catch (e) {
            console.warn('[WASMOrchestrator] ASC load error:', e);
            return null;
        }
    })();

    // ---------------------------------------------------------
    // 2. Start Loading Emscripten (Via Loader / Pthreads)
    // ---------------------------------------------------------
    const emccPromise = (async () => {
        let createCandyNative;
        let locatePrefix = '/candy-world'; // Default for production/GitHub Pages

        try {
            // Try production path first
            const module = await __vitePreload(() => import(/* @vite-ignore */ `/candy-world/candy_native.js?v=${Date.now()}`),true              ?[]:void 0);
            createCandyNative = module.default;
        } catch (e) {
            // Fallback to root (local dev)
            try {
                console.log('[WASMOrchestrator] Production path failed, trying local fallback...');
                const module = await __vitePreload(() => import(/* @vite-ignore */ `/candy_native.js?v=${Date.now()}`),true              ?[]:void 0);
                createCandyNative = module.default;
                locatePrefix = ''; // Reset prefix for local dev
            } catch (e2) {
                console.warn('[WASMOrchestrator] Failed to load native module:', e2);
                return null;
            }
        }

        try {
            const instance = await createCandyNative({
                locateFile: (path, prefix) => {
                    if (path.endsWith('.wasm')) return `${locatePrefix}/candy_native.wasm`;
                    if (path.endsWith('.worker.js')) return `${locatePrefix}/candy_native.worker.js`;
                    return prefix + path;
                },
                print: (text) => console.log('[Native]', text),
                printErr: (text) => console.warn('[Native Err]', text),
                // IMPORTANT: Pass our coordination buffer to C++ if needed
                // orchestratorBuffer: syncBuffer 
            });

            console.log('[WASMOrchestrator] EMCC Pthreads module ready');
            return instance;
        } catch (e) {
            console.warn('[WASMOrchestrator] EMCC instantiation error:', e);
            return null;
        }
    })();

    // ---------------------------------------------------------
    // 3. Wait for Both
    // ---------------------------------------------------------
    const [ascInstance, emccInstance] = await Promise.all([ascPromise, emccPromise]);

    results.asc = ascInstance;
    results.emcc = emccInstance; // This is the Module object, not just the instance

    signalPhaseComplete(LOADING_PHASES.WASM_INIT);
    
    // ... Continue with your pipeline phases ...
    onProgress(LOADING_PHASES.READY, 'Ready');
    signalPhaseComplete(LOADING_PHASES.READY);

    return results;
}

let wasmInstance = null;
let wasmMemory = null;
let positionView = null;   // Float32Array for object positions
let animationView = null;  // Float32Array for animation data
let outputView = null;     // Float32Array for reading results

// Cached WASM function references (more reliable than accessing exports repeatedly)
let wasmGetGroundHeight = null;
let wasmFreqToHue = null;
let wasmLerp = null;
let wasmBatchMushroomSpawnCandidates = null;
let wasmUpdateFoliageBatch = null;

// Emscripten module (native C functions)
let emscriptenInstance = null;
// With Pthreads/MODULARIZE, the instance itself is the Module object
// and memory is typically accessed via Module.HEAP8, Module.HEAPF32 etc.
// or exports if using specific bindings.
// However, the original code used `emscriptenMemory` which might be irrelevant if we don't access it directly.
// We will keep the variable for consistency but it might be unused.
let emscriptenMemory = null;

// Memory layout constants (must match AssemblyScript)
const POSITION_OFFSET = 0;
const ANIMATION_OFFSET = 4096;
const OUTPUT_OFFSET = 8192;

// =============================================================================
// UPDATED: Load Emscripten Module (Pthreads/Worker Version)
// =============================================================================

/**
 * Load the Emscripten-generated JS module which handles WASM & Workers
 */
async function loadEmscriptenModule() {
    // 0. Safety Check for SharedArrayBuffer
    if (typeof SharedArrayBuffer === 'undefined') {
        console.error('[Native] SharedArrayBuffer is missing. Pthreads will NOT work.');
        console.error('[Native] If hosting statically, ensure you have COOP/COEP headers configured.');
        console.error('[Native] (Cross-Origin-Opener-Policy: same-origin, Cross-Origin-Embedder-Policy: require-corp)');
        // We return false here to prevent a crash during instantiation
        return false;
    }

    try {
        await updateProgress('Loading Native Engine...');

        // --- FIX START ---
        // Ensure we are using the Native WebAssembly object for Emscripten.
        // libopenmpt or other libraries might have hijacked the global WebAssembly object
        // and stripped instantiateStreaming, causing spurious errors and slower loading.
        if (typeof window !== 'undefined' && window.NativeWebAssembly) {
            if (window.WebAssembly !== window.NativeWebAssembly) {
                console.warn('[WASM] Restoring Native WebAssembly API (was hijacked by third-party lib)');
                window.WebAssembly = window.NativeWebAssembly;
            }
        }
        // --- FIX END ---

        // 1. Dynamic Import the generated loader
        // Note: build.sh now outputs to public/candy_native.js
        // Robust strategy for module loading
        let createCandyNative;
        let locatePrefix = '/candy-world';

        try {
            const module = await __vitePreload(() => import(/* @vite-ignore */ `/candy-world/candy_native.js?v=${Date.now()}`),true              ?[]:void 0);
            createCandyNative = module.default;
        } catch (e) {
            console.log('[WASM] Production path failed, trying local fallback...');
            const module = await __vitePreload(() => import(/* @vite-ignore */ `/candy_native.js?v=${Date.now()}`),true              ?[]:void 0);
            createCandyNative = module.default;
            locatePrefix = '';
        }

        // 2. Instantiate (This spawns the worker pool automatically)
        await updateProgress('Spawning Physics Workers...');

        emscriptenInstance = await createCandyNative({
            locateFile: (path, prefix) => {
                if (path.endsWith('.wasm')) return `${locatePrefix}/candy_native.wasm`;
                if (path.endsWith('.worker.js')) return `${locatePrefix}/candy_native.worker.js`;
                return prefix + path;
            },
            print: (text) => console.log('[Native]', text),
            printErr: (text) => console.warn('[Native Err]', text),
        });

        console.log('[WASM] Emscripten Pthreads Ready');

        // Expose memory buffer if needed by legacy code (scratch buffers, etc.)
        if (emscriptenInstance.wasmMemory) {
            emscriptenMemory = emscriptenInstance.wasmMemory;
        } else if (emscriptenInstance.HEAP8) {
            emscriptenMemory = emscriptenInstance.HEAP8.buffer;
        }

        return true;
    } catch (e) {
        console.warn('Failed to load Native Emscripten module:', e);
        return false;
    }
}

/**
 * Helper to safely get an Emscripten export (handles _ prefix)
 */
function getNativeFunc(name) {
    if (!emscriptenInstance) return null;
    // Emscripten MODULARIZE puts exports directly on the instance using the underscore name
    // e.g. Module._valueNoise2D
    return emscriptenInstance['_' + name] || null;
}


/**
 * Helper function to start bootstrap terrain pre-computation
 * @param {Object} instance - The Emscripten module instance
 */
let bootstrapStarted = false; // Guard to prevent duplicate initialization

async function startBootstrapIfAvailable(instance) {
    if (!instance || bootstrapStarted) return;
    
    try {
        const { startBootstrap } = await __vitePreload(async () => { const { startBootstrap } = await import('./bootstrap-loader-CnH2pKW9.js');return { startBootstrap }},true              ?[]:void 0);
        if (startBootstrap && startBootstrap(instance)) {
            bootstrapStarted = true;
            console.log('[WASM] Bootstrap terrain pre-computation started');
        }
    } catch (e) {
        console.warn('[WASM] Bootstrap loader error:', e);
    }
}

/**
 * Initialize the WASM module
 * @returns {Promise<boolean>} True if loaded successfully
 */
// Helper to update UI status and yield to main thread to prevent hanging
async function updateProgress(msg) {
    if (window.setLoadingStatus) window.setLoadingStatus(msg);

    const startButton = document.getElementById('startButton');
    if (startButton) {
        startButton.textContent = msg;
    }
    console.log('[WASM Progress]', msg);
    // Yield to browser event loop
    await new Promise(r => setTimeout(r, 20));
}

async function initWasm() {
    if (wasmInstance) return true;

    // UX: Update button state to indicate loading
    const startButton = document.getElementById('startButton');
    if (startButton) {
        startButton.disabled = true;
        startButton.style.cursor = 'wait';
    }

    console.log('[WASM] initWasm started');
    await updateProgress('Downloading Physics Engine...');

    try {
        // Load WASM binary with cache buster
        const wasmUrl = './candy_physics.wasm?v=' + Date.now();
        console.log('[WASM] Fetching:', wasmUrl);
        const response = await fetch(wasmUrl);
        console.log('[WASM] Fetch response:', response.status, response.statusText);

        if (!response.ok) {
            console.warn('WASM not found, using JS fallbacks');
            // UX: Restore button even on failure (fallback mode)
            if (startButton) {
                startButton.disabled = false;
                startButton.textContent = 'Start Exploration ';
                startButton.style.cursor = 'pointer';
            }
            return false;
        }

        const wasmBytes = await response.arrayBuffer();
        console.log('WASM buffer size:', wasmBytes.byteLength, 'bytes');

        // Check if we got HTML instead of WASM (common 404 issue)
        const firstBytes = new Uint8Array(wasmBytes.slice(0, 4));
        const magic = Array.from(firstBytes).map(b => b.toString(16).padStart(2, '0')).join('');
        console.log('[WASM] Magic number:', magic, '(expected: 0061736d)');

        if (magic !== '0061736d') {
            console.error('[WASM] Invalid file - not a WebAssembly binary!');
            // UX: Restore button even on failure
            if (startButton) {
                startButton.disabled = false;
                startButton.textContent = 'Start Exploration ';
                startButton.style.cursor = 'pointer';
            }
            return false;
        }

        // WASI stubs (required for some runtime features)
        const wasiStubs = {
            fd_close: () => 0,
            fd_seek: () => 0,
            fd_write: () => 0,
            fd_read: () => 0,
            fd_fdstat_get: () => 0,
            fd_prestat_get: () => 0,
            fd_prestat_dir_name: () => 0,
            path_open: () => 0,
            environ_sizes_get: () => 0,
            environ_get: () => 0,
            proc_exit: () => { },
            clock_time_get: () => 0,
        };

        await updateProgress('Compiling Physics (WASM)...');

        // Use NativeWebAssembly to bypass libopenmpt's WebAssembly override
        const WA = window.NativeWebAssembly || WebAssembly;
        console.log('Using WebAssembly API:', WA === WebAssembly ? 'Standard (potentially hijacked)' : 'Native (saved)');

        const importObject = {
            env: {
                abort: (msg, file, line, col) => {
                    console.error(`WASM abort at ${file}:${line}:${col}: ${msg}`);
                }
            },
            wasi_snapshot_preview1: wasiStubs
        };

        // Try streaming instantiation first for faster compilation
        let result;
        try {
            console.log('Attempting WebAssembly.instantiateStreaming...');
            result = await WA.instantiateStreaming(
                fetch(wasmUrl),
                importObject
            );
            console.log('Streaming instantiation successful');
        } catch (streamError) {
            console.log('Streaming instantiation failed, falling back to buffer method:', streamError);
            // Fallback to traditional method if streaming fails
            result = await WA.instantiate(wasmBytes, importObject);
            console.log('Buffer instantiation successful');
        }

        console.log('Instantiation successful');
        if (window.setLoadingStatus) window.setLoadingStatus("Physics Engine Ready...");
        wasmInstance = result.instance;

        // Log available exports for debugging
        const exportKeys = Object.keys(wasmInstance.exports);
        console.log('WASM exports:', exportKeys);
        console.log('Export count:', exportKeys.length);

        // Verify exports exist
        if (!wasmInstance.exports.getGroundHeight) {
            console.error('WASM exports missing getGroundHeight. Available:', exportKeys);
            wasmInstance = null;
            // UX: Restore button even on failure
            if (startButton) {
                startButton.disabled = false;
                startButton.textContent = 'Start Exploration ';
                startButton.style.cursor = 'pointer';
            }
            return false;
        }

        // Use WASM's exported memory (AssemblyScript manages its own)
        if (wasmInstance.exports.memory) {
            wasmMemory = wasmInstance.exports.memory;
            const memBuffer = wasmMemory.buffer;
            positionView = new Float32Array(memBuffer, POSITION_OFFSET, 1024);
            animationView = new Float32Array(memBuffer, ANIMATION_OFFSET, 1024);
            outputView = new Float32Array(memBuffer, OUTPUT_OFFSET, 1024);
        }

        // Cache function references for reliable access
        wasmGetGroundHeight = wasmInstance.exports.getGroundHeight;
        wasmFreqToHue = wasmInstance.exports.freqToHue;
        wasmLerp = wasmInstance.exports.lerp;
        wasmBatchMushroomSpawnCandidates = wasmInstance.exports.batchMushroomSpawnCandidates || null;
        wasmUpdateFoliageBatch = wasmInstance.exports.updateFoliageBatch || null;

        console.log('[WASM] AssemblyScript module loaded successfully');

        // =====================================================================
        // LOAD EMSCRIPTEN MODULE (Pthreads/Workers)
        // =====================================================================
        await loadEmscriptenModule();

        // Start bootstrap loader for terrain pre-computation if Emscripten loaded
        if (emscriptenInstance) {
            await startBootstrapIfAvailable(emscriptenInstance);
        }

        // UX: Restore button on success
        if (startButton) {
            startButton.disabled = false;
            startButton.textContent = 'Start Exploration ';
            startButton.style.cursor = 'pointer';
        }

        return true;
    } catch (error) {
        console.warn('Failed to load WASM:', error);
        wasmInstance = null;
        // UX: Restore button on failure
        if (startButton) {
            startButton.disabled = false;
            startButton.textContent = 'Start Exploration ';
            startButton.style.cursor = 'pointer';
        }
        return false;
    }
}

/**
 * WASM-First Parallel Initialization (Strategy 1)
 * * Loads both AssemblyScript and Emscripten modules in parallel for faster startup.
 * Uses SharedArrayBuffer for cross-module coordination when available.
 * * @param {Object} options
 * @param {Function} options.onProgress - Progress callback (phase, message)
 * @returns {Promise<boolean>} True if at least ASC module loaded successfully
 */
async function initWasmParallel(options = {}) {
    if (wasmInstance) return true;

    const { onProgress = (phase, msg) => {
        if (window.setLoadingStatus) window.setLoadingStatus(msg);
    } } = options;

    const startButton = document.getElementById('startButton');
    if (startButton) {
        startButton.disabled = true;
        startButton.style.cursor = 'wait';
    }

    console.log('[WASM] initWasmParallel started (WASM-First Architecture)');

    try {
        // Use the parallel orchestrator for concurrent module loading
        const result = await parallelWasmLoad({
            onProgress,
            ascWasmUrl: './candy_physics.wasm',
            emccWasmUrl: './candy_native.wasm'
        });

        // Wire up the ASC module
        if (result.asc) {
            wasmInstance = result.asc;

            // Verify exports exist
            if (!wasmInstance.exports.getGroundHeight) {
                console.error('[WASM] ASC exports missing getGroundHeight');
                wasmInstance = null;
            } else {
                // Use WASM's exported memory
                if (wasmInstance.exports.memory) {
                    wasmMemory = wasmInstance.exports.memory;
                    const memBuffer = wasmMemory.buffer;
                    positionView = new Float32Array(memBuffer, POSITION_OFFSET, 1024);
                    animationView = new Float32Array(memBuffer, ANIMATION_OFFSET, 1024);
                    outputView = new Float32Array(memBuffer, OUTPUT_OFFSET, 1024);
                }

                // Cache function references
                wasmGetGroundHeight = wasmInstance.exports.getGroundHeight;
                wasmFreqToHue = wasmInstance.exports.freqToHue;
                wasmLerp = wasmInstance.exports.lerp;
                wasmBatchMushroomSpawnCandidates = wasmInstance.exports.batchMushroomSpawnCandidates || null;
                wasmUpdateFoliageBatch = wasmInstance.exports.updateFoliageBatch || null;

                console.log('[WASM] AssemblyScript module loaded via parallel orchestrator');
            }
        }

        // Wire up the EMCC module
        if (result.emcc) {
            emscriptenInstance = result.emcc;
            emscriptenMemory = emscriptenInstance.exports && emscriptenInstance.exports.memory;
            console.log('[WASM] Emscripten module loaded via parallel orchestrator');

            // Call init if available
            const initFn = getNativeFunc('init_native');
            if (initFn) {
                setTimeout(() => {
                    try { initFn(); console.log('[WASM] init_native() invoked'); }
                    catch (e) { console.warn(e); }
                }, 0);
            }

            // Start bootstrap loader for terrain pre-computation
            await startBootstrapIfAvailable(emscriptenInstance);
        }

        // Log shared memory status
        if (result.sharedBuffer) {
            console.log('[WASM] SharedArrayBuffer coordination active');
        }

        // UX: Restore button
        if (startButton) {
            startButton.disabled = false;
            startButton.textContent = 'Start Exploration ';
            startButton.style.cursor = 'pointer';
        }

        return wasmInstance !== null;
    } catch (error) {
        console.warn('[WASM] Parallel init failed, falling back to sequential:', error);
        
        // Fallback to original sequential loading
        return await initWasm();
    }
}

/**
 * Check if WASM is available
 */
function isWasmReady() {
    return wasmInstance !== null;
}

/**
 * Get the raw WASM instance (for advanced usage like direct memory access)
 */
function getWasmInstance() {
    return wasmInstance;
}

// =============================================================================
// SIMPLE MATH FUNCTIONS (with JS fallbacks)
// =============================================================================

/**
 * Get procedural ground height at coordinates
 */
function getGroundHeight(x, z) {
    if (wasmGetGroundHeight) {
        return wasmGetGroundHeight(x, z);
    }
    // JS fallback
    if (isNaN(x) || isNaN(z)) return 0;
    return Math.sin(x * 0.05) * 2 + Math.cos(z * 0.05) * 2 +
        Math.sin(x * 0.2) * 0.3 + Math.cos(z * 0.15) * 0.3;
}

/**
 * Convert audio frequency to HSL hue
 */
function freqToHue(freq) {
    if (wasmFreqToHue) {
        return wasmFreqToHue(freq);
    }
    // JS fallback
    if (!freq || freq < 50) return 0;
    const logF = Math.log2(freq / 55.0);
    return (logF * 0.1) % 1.0;
}

// =============================================================================
// BATCH PROCESSING FUNCTIONS
// =============================================================================

/**
 * Upload object positions to WASM memory
 * @param {Array<{x: number, y: number, z: number, radius?: number}>} objects
 */
function uploadPositions(objects) {
    if (!positionView) return;

    const count = Math.min(objects.length, 256);
    for (let i = 0; i < count; i++) {
        const obj = objects[i];
        const idx = i * 4;
        positionView[idx] = obj.x || 0;
        positionView[idx + 1] = obj.y || 0;
        positionView[idx + 2] = obj.z || 0;
        positionView[idx + 3] = obj.radius || 1.0;
    }
}

/**
 * Upload mushroom data (positions + animation specs) directly to WASM memory.
 * Optimized to avoid creating intermediate objects (GC pressure reduction).
 * @param {Array<THREE.Object3D>} mushrooms Array of mushroom meshes
 */
function uploadMushroomSpecs(mushrooms) {
    if (!positionView || !animationView) return;

    const count = Math.min(mushrooms.length, 256);
    for (let i = 0; i < count; i++) {
        const m = mushrooms[i];
        const idx = i * 4;

        // Position Data
        positionView[idx] = m.position.x;
        positionView[idx + 1] = m.position.y;
        positionView[idx + 2] = m.position.z;
        positionView[idx + 3] = m.userData?.radius || 0.5;

        // Animation Data
        animationView[idx] = 0; // offset
        animationView[idx + 1] = 0; // type
        animationView[idx + 2] = m.position.y; // originalY
        animationView[idx + 3] = m.userData?.colorIndex || 0;
    }
}

/**
 * Run WASM batch function to generate mushroom spawn candidates.
 * Returns candidateCount and writes candidates into the existing output buffer.
 */
function batchMushroomSpawnCandidates(time, windX, windZ, windSpeed, objectCount, spawnThreshold, minDistance, maxDistance) {
    if (wasmBatchMushroomSpawnCandidates && wasmInstance) {
        const count = wasmBatchMushroomSpawnCandidates(time, windX, windZ, windSpeed, objectCount, spawnThreshold, minDistance, maxDistance);
        return count;
    }
    return 0;
}

/**
 * Read candidate data from output buffer, each candidate is 4 floats: x,y,z,colorIndex
 */
function readSpawnCandidates(candidateCount) {
    if (!outputView) return [];
    const arr = [];
    const maxCount = Math.min(candidateCount, 128);
    for (let i = 0; i < maxCount; i++) {
        const idx = i * 4;
        const x = outputView[idx];
        const y = outputView[idx + 1];
        const z = outputView[idx + 2];
        const colorIndex = outputView[idx + 3];
        if (isNaN(x) || isNaN(y) || isNaN(z)) continue;
        arr.push({ x, y, z, colorIndex: Math.round(colorIndex) });
    }
    return arr;
}

/**
 * Batch animation calculations
 * @param {number} time 
 * @param {number} intensity 
 * @param {number} kick 
 * @param {number} objectCount 
 * @returns {Float32Array} Results array [yOffset, rotX, rotZ, 0, ...] per object
 */
function batchAnimationCalc(time, intensity, kick, objectCount) {
    if (!wasmInstance) return null;

    wasmInstance.exports.batchAnimationCalc(time, intensity, kick, objectCount);

    // Return slice of output buffer (4 floats per object)
    return outputView.slice(0, objectCount * 4);
}
let arpeggioResult = { targetStep: 0, unfurlStep: 0 }; // New result cache

/**
 * Arpeggio Animation (WASM wrapper)
 *
 * Optimized to prefer C++ Native WASM if available, then AssemblyScript, then JS fallback.
 */
function calcArpeggioStep(currentUnfurl, currentTarget, lastTrigger, arpeggioActive, noteTrigger, maxSteps) {
    // 1. Try Native C++ (fastest)
    const calcFn = getNativeFunc('calcArpeggioStep_c');
    if (calcFn) {
        calcFn(currentUnfurl, currentTarget, lastTrigger ? 1 : 0, arpeggioActive ? 1 : 0, noteTrigger ? 1 : 0, maxSteps);

        // Retrieve results from C global storage
        const getTarget = getNativeFunc('getArpeggioTargetStep_c');
        const getUnfurl = getNativeFunc('getArpeggioUnfurlStep_c');

        if (getTarget && getUnfurl) {
            arpeggioResult.targetStep = getTarget();
            arpeggioResult.unfurlStep = getUnfurl();
            return arpeggioResult;
        }
    }

    // 2. Try AssemblyScript (fast)
    if (wasmInstance && wasmInstance.exports.calcArpeggioStep) {
        wasmInstance.exports.calcArpeggioStep(currentUnfurl, currentTarget, lastTrigger ? 1 : 0, arpeggioActive ? 1 : 0, noteTrigger ? 1 : 0, maxSteps);
        arpeggioResult.targetStep = wasmInstance.exports.getArpeggioTargetStep();
        arpeggioResult.unfurlStep = wasmInstance.exports.getArpeggioUnfurlStep();
        return arpeggioResult;
    }

    // 3. JS Fallback (slowest)
    let nextTarget = currentTarget;
    if (arpeggioActive) {
        if (noteTrigger && !lastTrigger) {
            nextTarget = Math.min(maxSteps, nextTarget + 1);
        }
    } else {
        nextTarget = 0;
    }
    const speed = (nextTarget > currentUnfurl) ? 0.3 : 0.05;
    const nextUnfurl = currentUnfurl + (nextTarget - currentUnfurl) * speed;
    return { targetStep: nextTarget, unfurlStep: nextUnfurl };
}

/**
 * Calculate rain droplet Y position
 */
function calcRainDropY(startY, time, speed, cycleHeight) {
    if (wasmInstance) {
        return wasmInstance.exports.calcRainDropY(startY, time, speed, cycleHeight);
    }
    const totalDrop = time * speed;
    const cycled = totalDrop % cycleHeight;
    return startY - cycled;
}

// =============================================================================
// EMSCRIPTEN NATIVE FUNCTIONS (from candy_native.c)
// =============================================================================

function updatePhysicsCPP(delta, inputX, inputZ, speed, jump, sprint, sneak, grooveGravity) {
    const f = getNativeFunc('updatePhysicsCPP');
    if (f) return f(delta, inputX, inputZ, speed, jump ? 1 : 0, sprint ? 1 : 0, sneak ? 1 : 0, grooveGravity);
    return -1; // Fallback
}

function initPhysics(x, y, z) {
    const f = getNativeFunc('initPhysics');
    if (f) f(x, y, z);
}

function addObstacle(type, x, y, z, r, h, p1, p2, p3) {
    const f = getNativeFunc('addObstacle');
    if (f) f(type, x, y, z, r, h, p1, p2, p3 ? 1.0 : 0.0);
}

function setPlayerState(x, y, z, vx, vy, vz) {
    const f = getNativeFunc('setPlayerState');
    if (f) f(x, y, z, vx, vy, vz);
}

function getPlayerState() {
    const x = getNativeFunc('getPlayerX')();
    const y = getNativeFunc('getPlayerY')();
    const z = getNativeFunc('getPlayerZ')();
    const vx = getNativeFunc('getPlayerVX')();
    const vy = getNativeFunc('getPlayerVY')();
    const vz = getNativeFunc('getPlayerVZ')();
    return { x, y, z, vx, vy, vz };
}

// src/core/config.js


// Cycle: Sunrise (1m), Day (7m), Sunset (1m), Night (7m) = Total 16m = 960s
const DURATION_SUNRISE = 60;
const DURATION_DAY = 420;
const DURATION_SUNSET = 60;
const DURATION_DUSK_NIGHT = 180; // 3 min
const DURATION_DEEP_NIGHT = 120; // 2 min
const DURATION_PRE_DAWN = 120;   // 2 min
const CYCLE_DURATION = DURATION_SUNRISE + DURATION_DAY + DURATION_SUNSET + DURATION_DUSK_NIGHT + DURATION_DEEP_NIGHT + DURATION_PRE_DAWN; // 960s

const PALETTE = {
    // Standard Season (Spring/Default)
    day: {
        skyTop: new Color(0x87CEEB),   // Brighter sky blue for day
        skyBot: new Color(0xB8E6F0),   // Softer transition to horizon
        horizon: new Color(0xFFE5CC),  // Warm peachy horizon glow
        fog: new Color(0xFFC5D3),      // Warmer pastel pink fog
        sun: new Color(0xFFFAF0),      // Warm white sunlight
        amb: new Color(0xFFF5EE),      // Soft seashell ambient
        sunInt: 0.9,
        ambInt: 0.65,
        atmosphereIntensity: 0.3
    },
    // Pattern 1: Neon Synthwave (D01-D20 range)
    neon: {
        skyTop: new Color(0x220044),   // Deep purple
        skyBot: new Color(0xFF00FF),   // Neon magenta
        horizon: new Color(0x00FFFF),  // Cyan horizon
        fog: new Color(0x5500AA),      // Purple fog
        sun: new Color(0xFF00AA),      // Pink sun
        amb: new Color(0x440088),      // Purple ambient
        sunInt: 0.8,
        ambInt: 0.7,
        atmosphereIntensity: 0.9
    },
    // Pattern 2: Glitch/Monochrome (D21+ range)
    glitch: {
        skyTop: new Color(0x000000),   // Black
        skyBot: new Color(0x888888),   // Grey
        horizon: new Color(0xFFFFFF),  // White
        fog: new Color(0xAAAAAA),      // Grey fog
        sun: new Color(0xFFFFFF),      // White sun
        amb: new Color(0x444444),      // Grey ambient
        sunInt: 1.0,
        ambInt: 0.5,
        atmosphereIntensity: 0.0
    },
    sunset: {
        skyTop: new Color(0x4B3D8F),   // Rich purple-blue
        skyBot: new Color(0xFF6B4A),   // Warm coral-orange glow
        horizon: new Color(0xFFB347),  // Vibrant orange-gold horizon
        fog: new Color(0xE87B9F),      // Candy pink-coral fog
        sun: new Color(0xFFA040),      // Golden-orange sun
        amb: new Color(0x9B5050),      // Warm reddish ambient
        sunInt: 0.55,
        ambInt: 0.45,
        atmosphereIntensity: 0.7            // Strong atmospheric effect at sunset
    },
    night: {
        skyTop: new Color(0x0A0A2E),   // Deeper night blue with slight color
        skyBot: new Color(0x1A1A35),   // Slightly lighter horizon at night
        horizon: new Color(0x2A2A4A),  // Subtle purple-blue horizon glow
        fog: new Color(0x0A0A18),      // Dark blue-tinted fog
        sun: new Color(0x334466),      // Moonlight blue tint
        amb: new Color(0x080815),      // Very dim ambient
        sunInt: 0.12,
        ambInt: 0.08,
        atmosphereIntensity: 0.15           // Subtle night atmosphere
    },
    sunrise: {
        skyTop: new Color(0x48D8E8),   // Bright turquoise dawn sky
        skyBot: new Color(0xFF9BAC),   // Warm rosy pink
        horizon: new Color(0xFFD4A3),  // Golden peachy horizon
        fog: new Color(0xFFE4CA),      // Peachy-warm fog
        sun: new Color(0xFFE066),      // Golden morning light
        amb: new Color(0xFFC8D8),      // Soft pink ambient
        sunInt: 0.65,
        ambInt: 0.55,
        atmosphereIntensity: 0.6            // Strong morning atmosphere
    }
};

const CONFIG = {
    colors: { ground: 0x90EE90 },
    noteColorMap: {
        // Standard Global Palette (Fallback)
        'global': {
            'C': 0xFF0000, 'C#': 0xFF7F00, 'D': 0xFFFF00, 'D#': 0x7FFF00,
            'E': 0x00FF00, 'F': 0x00FF7F, 'F#': 0x00FFFF, 'G': 0x007FFF,
            'G#': 0x0000FF, 'A': 0x7F00FF, 'A#': 0xFF00FF, 'B': 0xFF007F
        },
        // Species: Mushroom (Shader-matched palette)
        'mushroom': {
            'C':  0xFF4040, // Red
            'C#': 0xEF1280, // Magenta-Red
            'D':  0xC020C0, // Magenta
            'D#': 0x8020EF, // Violet
            'E':  0x4040FF, // Blue (Peak)
            'F':  0x1280EF, // Azure
            'F#': 0x00C0C0, // Cyan
            'G':  0x12EF80, // Spring Green
            'G#': 0x40FF40, // Green (Peak)
            'A':  0x80EF12, // Lime
            'A#': 0xC0C000, // Yellow
            'B':  0xEF8012  // Orange
        },
        // Species: Flower (Vibrant Pastels)
        'flower': {
            'C': 0xFF69B4, 'C#': 0xFF1493, 'D': 0xFFB6C1, 'D#': 0xFFC0CB,
            'E': 0xDDA0DD, 'F': 0xEE82EE, 'F#': 0xDA70D6, 'G': 0xBA55D3,
            'G#': 0x9370DB, 'A': 0x8A2BE2, 'A#': 0x9400D3, 'B': 0x9932CC
        },
        // Species: Tree (Nature + Biolum)
        'tree': {
            'C': 0x006400, 'C#': 0x228B22, 'D': 0x32CD32, 'D#': 0x90EE90,
            'E': 0x98FB98, 'F': 0x00FF00, 'F#': 0xADFF2F, 'G': 0x7FFF00,
            'G#': 0x7CFC00, 'A': 0x6B8E23, 'A#': 0x556B2F, 'B': 0x808000
        },
        // Species: Cloud (Ethereal)
        'cloud': {
            'C': 0xF0F8FF, 'C#': 0xE6E6FA, 'D': 0xB0C4DE, 'D#': 0xADD8E6,
            'E': 0x87CEEB, 'F': 0x87CEFA, 'F#': 0x00BFFF, 'G': 0x1E90FF,
            'G#': 0x6495ED, 'A': 0x4682B4, 'A#': 0x5F9EA0, 'B': 0x2F4F4F
        }
    },
    // Per-species reaction tuning
    reactivity: {
        mushroom: { smoothingRate: 8, scale: 0.6, maxAmplitude: 1.0, minThreshold: 0.02 }
    },
    // Global flash strength scaler
    flashScale: 2.0};

function updateArpeggio(foliageObject, time, audioData) {
  let arpeggioActive = false;
  let noteTrigger = false;
  if (audioData && audioData.channelData) {
    for (const ch of audioData.channelData) {
      if (ch.activeEffect === 4 || ch.activeEffect === 0 && ch.effectValue && ch.effectValue > 0) {
        arpeggioActive = true;
      }
      if (ch.trigger > 0.1) {
        noteTrigger = true;
      }
    }
  }
  if (foliageObject.userData.unfurlStep === void 0) foliageObject.userData.unfurlStep = 0;
  if (foliageObject.userData.targetStep === void 0) foliageObject.userData.targetStep = 0;
  if (foliageObject.userData.lastTrigger === void 0) foliageObject.userData.lastTrigger = false;
  const maxSteps = 12;
  const result = calcArpeggioStep(
    foliageObject.userData.unfurlStep,
    foliageObject.userData.targetStep,
    foliageObject.userData.lastTrigger,
    arpeggioActive,
    noteTrigger,
    maxSteps
  );
  foliageObject.userData.targetStep = result.targetStep;
  foliageObject.userData.unfurlStep = result.unfurlStep;
  foliageObject.userData.lastTrigger = noteTrigger;
  const unfurlFactor = (foliageObject.userData.unfurlStep || 0) / maxSteps;
  const fronds = foliageObject.userData.fronds;
  if (fronds) {
    fronds.forEach((segments, fIdx) => {
      segments.forEach((segData, sIdx) => {
        const targetRot = MathUtils.lerp(segData.initialCurl, 0.2, unfurlFactor);
        const wave = Math.sin(time * 5 + sIdx * 0.5) * 0.1 * unfurlFactor;
        segData.pivot.rotation.x = targetRot + wave;
      });
    });
  }
  if (foliageObject.userData.originalY === void 0) {
    foliageObject.userData.originalY = foliageObject.position.y;
  }
  foliageObject.position.y = foliageObject.userData.originalY + unfurlFactor * 0.2;
}

const BATCH_SIZE = 4e3;
const BATCH_MEMORY_START = 16384;
const BATCH_ARRAY_SIZE = BATCH_SIZE * 4;
class FoliageBatcher {
  constructor() {
    this.initialized = false;
    this.batches = {
      sway: this.createBatch(),
      bounce: this.createBatch(true),
      // needs originalY
      hop: this.createBatch(true),
      gentleSway: this.createBatch(),
      wobble: this.createBatch(false, true, true)
      // needs wobbleBoosts, 2 outputs
    };
  }
  static getInstance() {
    if (!FoliageBatcher.instance) {
      FoliageBatcher.instance = new FoliageBatcher();
    }
    return FoliageBatcher.instance;
  }
  createBatch(needsOriginalY = false, needsWobble = false, twoOutputs = false) {
    return {
      count: 0,
      offsets: new Float32Array(BATCH_SIZE),
      intensities: new Float32Array(BATCH_SIZE),
      originalYs: needsOriginalY ? new Float32Array(BATCH_SIZE) : void 0,
      wobbleBoosts: needsWobble ? new Float32Array(BATCH_SIZE) : void 0,
      outScalars: new Float32Array(BATCH_SIZE),
      outScalars2: twoOutputs ? new Float32Array(BATCH_SIZE) : void 0,
      objects: new Array(BATCH_SIZE),
      ptrOffsets: 0,
      ptrIntensities: 0,
      ptrOriginalYs: 0,
      ptrWobbleBoosts: 0,
      ptrOutScalars: 0,
      ptrOutScalars2: 0
    };
  }
  initBatchMemory(batch, memoryOffset) {
    if (batch.ptrOffsets !== 0) return;
    const instance = getWasmInstance();
    if (!instance) return;
    let currentOffset = memoryOffset;
    batch.ptrOffsets = currentOffset;
    currentOffset += BATCH_ARRAY_SIZE;
    batch.ptrIntensities = currentOffset;
    currentOffset += BATCH_ARRAY_SIZE;
    batch.ptrOutScalars = currentOffset;
    currentOffset += BATCH_ARRAY_SIZE;
    if (batch.originalYs) {
      batch.ptrOriginalYs = currentOffset;
      currentOffset += BATCH_ARRAY_SIZE;
    }
    if (batch.wobbleBoosts) {
      batch.ptrWobbleBoosts = currentOffset;
      currentOffset += BATCH_ARRAY_SIZE;
    }
    if (batch.outScalars2) {
      batch.ptrOutScalars2 = currentOffset;
      currentOffset += BATCH_ARRAY_SIZE;
    }
  }
  init() {
    const instance = getWasmInstance();
    if (this.initialized || !instance) return;
    let currentOffset = BATCH_MEMORY_START;
    this.initBatchMemory(this.batches.sway, currentOffset);
    currentOffset += BATCH_ARRAY_SIZE * 3;
    this.initBatchMemory(this.batches.bounce, currentOffset);
    currentOffset += BATCH_ARRAY_SIZE * 4;
    this.initBatchMemory(this.batches.hop, currentOffset);
    currentOffset += BATCH_ARRAY_SIZE * 4;
    this.initBatchMemory(this.batches.gentleSway, currentOffset);
    currentOffset += BATCH_ARRAY_SIZE * 3;
    this.initBatchMemory(this.batches.wobble, currentOffset);
    currentOffset += BATCH_ARRAY_SIZE * 5;
    this.initialized = true;
    console.log("[FoliageBatcher] WASM memory allocated using fixed offsets for batching");
    console.log(`[FoliageBatcher] Total memory used: ${currentOffset - BATCH_MEMORY_START} bytes`);
  }
  queue(obj, type, intensity, time) {
    if (!this.initialized) this.init();
    if (!this.initialized) return false;
    let batch;
    if (type === "sway") batch = this.batches.sway;
    else if (type === "bounce") batch = this.batches.bounce;
    else if (type === "hop") batch = this.batches.hop;
    else if (type === "gentleSway") batch = this.batches.gentleSway;
    else if (type === "wobble") batch = this.batches.wobble;
    if (!batch) return false;
    if (batch.count >= BATCH_SIZE) return false;
    const i = batch.count;
    batch.objects[i] = obj;
    batch.offsets[i] = obj.userData.animationOffset || 0;
    batch.intensities[i] = intensity;
    if (batch.originalYs) {
      if (obj.userData.originalY === void 0) obj.userData.originalY = obj.position.y;
      batch.originalYs[i] = obj.userData.originalY;
    }
    if (batch.wobbleBoosts) {
      batch.wobbleBoosts[i] = obj.userData.wobbleCurrent || 0;
    }
    batch.count++;
    return true;
  }
  flush(time, kick) {
    if (!this.initialized) return;
    this.processSimpleBatch(this.batches.sway, "computeSway", time, (obj, val) => {
      obj.rotation.z = val;
    });
    this.processSimpleBatch(this.batches.gentleSway, "computeGentleSway", time, (obj, val) => {
      obj.rotation.z = val;
    });
    this.processPhysicsBatch(this.batches.bounce, "computeBounce", time, kick, (obj, val) => {
      obj.position.y = val;
    });
    this.processPhysicsBatch(this.batches.hop, "computeHop", time, kick, (obj, val) => {
      obj.position.y = val;
    });
    this.processWobbleBatch(this.batches.wobble, time);
  }
  processSimpleBatch(batch, funcName, time, apply) {
    if (batch.count === 0) return;
    const instance = getWasmInstance();
    if (!instance) return;
    const F32 = new Float32Array(instance.exports.memory.buffer);
    const offPtr = batch.ptrOffsets >>> 2;
    const intPtr = batch.ptrIntensities >>> 2;
    F32.set(batch.offsets.subarray(0, batch.count), offPtr);
    F32.set(batch.intensities.subarray(0, batch.count), intPtr);
    const func = instance.exports[funcName];
    if (func) {
      func(batch.count, time, batch.ptrOffsets, batch.ptrIntensities, batch.ptrOutScalars);
      const outPtr = batch.ptrOutScalars >>> 2;
      const res = F32.subarray(outPtr, outPtr + batch.count);
      for (let i = 0; i < batch.count; i++) {
        apply(batch.objects[i], res[i]);
        batch.objects[i] = void 0;
      }
    }
    batch.count = 0;
  }
  processPhysicsBatch(batch, funcName, time, kick, apply) {
    if (batch.count === 0) return;
    const instance = getWasmInstance();
    if (!instance) return;
    const F32 = new Float32Array(instance.exports.memory.buffer);
    const offPtr = batch.ptrOffsets >>> 2;
    const intPtr = batch.ptrIntensities >>> 2;
    const orgPtr = batch.ptrOriginalYs >>> 2;
    F32.set(batch.offsets.subarray(0, batch.count), offPtr);
    F32.set(batch.intensities.subarray(0, batch.count), intPtr);
    F32.set(batch.originalYs.subarray(0, batch.count), orgPtr);
    const func = instance.exports[funcName];
    if (func) {
      func(batch.count, time, batch.ptrOriginalYs, batch.ptrOffsets, batch.ptrIntensities, kick, batch.ptrOutScalars);
      const outPtr = batch.ptrOutScalars >>> 2;
      const res = F32.subarray(outPtr, outPtr + batch.count);
      for (let i = 0; i < batch.count; i++) {
        apply(batch.objects[i], res[i]);
        batch.objects[i] = void 0;
      }
    }
    batch.count = 0;
  }
  processWobbleBatch(batch, time) {
    if (batch.count === 0) return;
    const instance = getWasmInstance();
    if (!instance) return;
    const F32 = new Float32Array(instance.exports.memory.buffer);
    const offPtr = batch.ptrOffsets >>> 2;
    const intPtr = batch.ptrIntensities >>> 2;
    const boostPtr = batch.ptrWobbleBoosts >>> 2;
    F32.set(batch.offsets.subarray(0, batch.count), offPtr);
    F32.set(batch.intensities.subarray(0, batch.count), intPtr);
    F32.set(batch.wobbleBoosts.subarray(0, batch.count), boostPtr);
    const func = instance.exports["computeWobble"];
    if (func) {
      func(batch.count, time, batch.ptrOffsets, batch.ptrIntensities, batch.ptrWobbleBoosts, batch.ptrOutScalars, batch.ptrOutScalars2);
      const outPtr1 = batch.ptrOutScalars >>> 2;
      const outPtr2 = batch.ptrOutScalars2 >>> 2;
      for (let i = 0; i < batch.count; i++) {
        const obj = batch.objects[i];
        obj.rotation.x = F32[outPtr1 + i];
        obj.rotation.z = F32[outPtr2 + i];
        if (obj.userData.wobbleCurrent) {
          obj.userData.wobbleCurrent *= 0.9;
        }
        batch.objects[i] = void 0;
      }
    }
    batch.count = 0;
  }
}
const foliageBatcher = FoliageBatcher.getInstance();

function triggerGrowth(plants, intensity) {
  plants.forEach((plant) => {
    if (!plant.userData.maxScale) {
      plant.userData.maxScale = plant.scale.x * 1.5;
    }
    if (plant.scale.x < plant.userData.maxScale) {
      const growthRate = intensity * 0.01;
      const newScale = plant.scale.x + growthRate;
      plant.scale.setScalar(newScale);
    }
  });
}
function triggerBloom(flowers, intensity) {
  flowers.forEach((flower) => {
    if (flower.userData.type === "flower") {
      if (flower.userData.isFlower || flower.userData.type === "flower") {
        if (!flower.userData.maxBloom) {
          flower.userData.maxBloom = flower.scale.x * 1.3;
        }
        if (flower.scale.x < flower.userData.maxBloom) {
          const bloomRate = intensity * 0.02;
          flower.scale.addScalar(bloomRate);
        }
      }
    }
  });
}
function applyWetEffect(material, wetAmount) {
  if (material.userData.dryRoughness === void 0) {
    material.userData.dryRoughness = material.roughness || 0.5;
    material.userData.dryMetalness = material.metalness || 0;
    if (material.color) {
      material.userData.dryColor = material.color.clone();
    }
  }
  if (material.roughness !== void 0 && material.userData.dryRoughness !== void 0) {
    const targetRoughness = MathUtils.lerp(material.userData.dryRoughness, 0.2, wetAmount);
    material.roughness = targetRoughness;
  }
  if (material.metalness !== void 0 && material.userData.dryMetalness !== void 0) {
    const targetMetalness = MathUtils.lerp(material.userData.dryMetalness, 0.15, wetAmount);
    material.metalness = targetMetalness;
  }
  if (material.color && material.userData.dryColor) {
    const darkColor = material.userData.dryColor.clone().multiplyScalar(1 - wetAmount * 0.3);
    material.color.lerp(darkColor, 0.1);
  }
}
function updateMaterialsForWeather(materials, weatherState, weatherIntensity) {
  materials.forEach((mat) => {
    if (!mat || !mat.isMaterial) return;
    let wetAmount = 0;
    if (weatherState === "rain") {
      wetAmount = weatherIntensity * 0.5;
    } else if (weatherState === "storm") {
      wetAmount = weatherIntensity * 0.8;
    }
    applyWetEffect(mat, wetAmount);
  });
}
function updateFoliageMaterials(audioData, isNight, weatherState = null, weatherIntensity = 0) {
  if (!audioData) return;
  if (isNight) {
    const channels = audioData.channelData;
    if (channels && channels.length > 0) {
      reactiveMaterials.forEach((mat, i) => {
        const chIndex = i % 4 + 1;
        const ch = channels[Math.min(chIndex, channels.length - 1)];
        if (ch && ch.freq > 0) {
          const hue = freqToHue(ch.freq);
          _foliageReactiveColor.setHSL(hue, 1, 0.6);
          if (mat.isMeshBasicMaterial && mat.color) {
            mat.color.lerp(_foliageReactiveColor, 0.3);
          } else if (mat.emissive) {
            mat.emissive.lerp(_foliageReactiveColor, 0.3);
          }
        }
        const intensity = 0.2 + (ch?.volume || 0) + (ch?.trigger || 0) * 2;
        if (!mat.isMeshBasicMaterial && mat.emissiveIntensity !== void 0) {
          mat.emissiveIntensity = intensity;
        }
      });
    }
  } else {
    reactiveMaterials.forEach((mat) => {
      if (mat.emissive) {
        mat.emissive.setHex(0);
        mat.emissiveIntensity = 0;
      }
    });
  }
  if (weatherState && weatherIntensity > 0) {
    updateMaterialsForWeather(reactiveMaterials, weatherState, weatherIntensity);
  }
}
function animateFoliage(foliageObject, time, audioData, isDay, isDeepNight = false) {
  const offset = foliageObject.userData.animationOffset || 0;
  const type = foliageObject.userData.animationType;
  const reactive = foliageObject.userData.reactiveMeshes;
  if (reactive && reactive.length > 0) {
    let hasActiveFlash = false;
    let needsFadeBack = false;
    for (let i = 0; i < reactive.length; i++) {
      const child = reactive[i];
      if ((child.userData.flashIntensity || 0) > 0) {
        hasActiveFlash = true;
      }
      if (child.userData._needsFadeBack) {
        needsFadeBack = true;
      }
      if (hasActiveFlash && needsFadeBack) break;
    }
    if (hasActiveFlash || needsFadeBack) {
      for (let i = 0; i < reactive.length; i++) {
        const child = reactive[i];
        let fi = child.userData.flashIntensity || 0;
        const decay = child.userData.flashDecay ?? 0.05;
        const mats = Array.isArray(child.material) ? child.material : child.material ? [child.material] : [];
        if (fi > 0) {
          const fc = child.userData.flashColor || new Color(16777215);
          for (const mat of mats) {
            if (!mat) continue;
            const t = Math.min(1, fi * 1.2) * 0.8;
            if (mat.isMeshBasicMaterial && mat.color) {
              if (fi > 0.7) mat.color.copy(fc);
              else mat.color.lerp(fc, t);
            } else if (mat.emissive) {
              if (fi > 0.7) mat.emissive.copy(fc);
              else mat.emissive.lerp(fc, t);
              mat.emissiveIntensity = Math.max(0.2, fi * (CONFIG.flashScale));
            }
          }
          child.userData.flashIntensity = Math.max(0, fi - decay);
          if (child.userData.flashIntensity === 0) {
            delete child.userData.flashColor;
            delete child.userData.flashDecay;
            child.userData._needsFadeBack = true;
          }
        } else if (child.userData._needsFadeBack) {
          const fadeT = CONFIG.reactivity?.fadeSpeed ?? 0.06;
          const snapThreshold = CONFIG.reactivity?.fadeSnapThreshold ?? 0.06;
          const snapThresholdSq = snapThreshold * snapThreshold;
          let allFadedBack = true;
          for (const mat of mats) {
            if (!mat) continue;
            if (mat.isMeshBasicMaterial) {
              if (mat.userData && mat.userData.baseColor && mat.color) {
                const distSq = mat.color.distanceToSquared(mat.userData.baseColor);
                if (distSq > snapThresholdSq) {
                  mat.color.lerp(mat.userData.baseColor, fadeT);
                  allFadedBack = false;
                } else {
                  mat.color.copy(mat.userData.baseColor);
                }
              }
            } else if (mat.emissive) {
              if (mat.userData && mat.userData.baseEmissive) {
                mat.emissive.lerp(mat.userData.baseEmissive, fadeT);
              }
              const current = mat.emissiveIntensity || 0;
              if (current > snapThreshold) {
                mat.emissiveIntensity = MathUtils.lerp(current, 0, fadeT);
                allFadedBack = false;
              } else {
                if (mat.userData && mat.userData.baseEmissive) {
                  mat.emissive.copy(mat.userData.baseEmissive);
                }
                mat.emissiveIntensity = 0;
              }
            }
          }
          if (allFadedBack) {
            child.userData._needsFadeBack = false;
          }
        }
      }
    }
  }
  if (foliageObject.userData.glowLight && foliageObject.userData.isBioluminescent) {
    const light = foliageObject.userData.glowLight;
    const baseIntensity = light.userData.baseIntensity || 0.8;
    if (light.intensity > baseIntensity * 1.2) {
      light.intensity = MathUtils.lerp(light.intensity, baseIntensity, 0.08);
    } else {
      const pulseSpeed = 2 + (foliageObject.userData.animationOffset || 0) * 0.3;
      const pulse = Math.sin(time * pulseSpeed) * 0.2 + 1;
      light.intensity = baseIntensity * pulse;
    }
  }
  if (foliageObject.userData.scaleAnimStart) {
    const elapsed = Date.now() - foliageObject.userData.scaleAnimStart;
    const duration = foliageObject.userData.scaleAnimTime || 0.08;
    const t = Math.min(1, elapsed / (duration * 1e3));
    if (t < 1) {
      const target = foliageObject.userData.scaleTarget || 1;
      const current = foliageObject.scale.x;
      const newScale = MathUtils.lerp(current, target, t * 0.5);
      foliageObject.scale.setScalar(newScale);
    } else {
      foliageObject.scale.setScalar(foliageObject.userData.scaleTarget || 1);
      delete foliageObject.userData.scaleAnimStart;
      delete foliageObject.userData.scaleTarget;
      delete foliageObject.userData.scaleAnimTime;
    }
  }
  if (foliageObject.userData.type === "mushroom") {
    const buf = foliageObject.userData.noteBuffer || [];
    const medianVel = median(buf);
    const cfg = CONFIG.reactivity?.mushroom || {};
    const scale = cfg.scale || 1;
    const target = Math.min(cfg.maxAmplitude ?? 1, Math.max(cfg.minThreshold ?? 0.01, medianVel * scale));
    const cur = foliageObject.userData.wobbleCurrent || 0;
    const lerpT = Math.min(0.25, (cfg.smoothingRate || 8) * 0.02);
    foliageObject.userData.wobbleCurrent = MathUtils.lerp(cur, target, lerpT);
  }
  if (isDeepNight) {
    const isNightFlower = foliageObject.userData.type === "flower" && foliageObject.userData.animationType === "glowPulse";
    if (!isNightFlower) {
      const sleepSpeed = 0.5;
      const sleepAmount = 0.02;
      const shiver = Math.sin(time * sleepSpeed + offset) * sleepAmount;
      foliageObject.rotation.z = shiver;
      foliageObject.rotation.x = shiver * 0.5;
      return;
    }
  }
  let kick = 0, groove = 0, beatPhase = 0, leadVol = 0;
  if (audioData) {
    kick = audioData.kickTrigger || 0;
    groove = audioData.grooveAmount || 0;
    beatPhase = audioData.beatPhase || 0;
    leadVol = audioData.channelData?.[2]?.volume || 0;
  }
  const isActive = !isDay;
  const intensity = isActive ? 1 + groove * 5 : 0.2;
  const animTime = time + beatPhase;
  if (type && foliageBatcher.queue(foliageObject, type, intensity, animTime, kick)) {
    return;
  }
  if (type === "speakerPulse") {
    foliageObject.position.y = (foliageObject.userData.originalY || 0) + Math.sin(time + offset) * 0.2;
    const pump = kick * 0.5;
    const pad = foliageObject.children[0];
    if (pad) {
      pad.scale.set(1 + pump * 0.2, 1 - pump * 0.5, 1 + pump * 0.2);
      if (isActive && pad.userData.ringMaterial) {
        const ringMat = pad.userData.ringMaterial;
        const glow = pump * 5;
        ringMat.emissive?.setHSL(0 + pump * 0.21, 1, 0.5);
        ringMat.emissiveIntensity = glow;
      }
    }
  } else if (type === "arpeggioUnfurl") {
    updateArpeggio(foliageObject, time, audioData);
  } else if (type === "snareSnap") {
    let snareTrigger = 0;
    if (audioData && audioData.channelData && audioData.channelData[1]) {
      snareTrigger = audioData.channelData[1].trigger || 0;
    }
    const left = foliageObject.userData.leftJaw;
    const right = foliageObject.userData.rightJaw;
    if (left && right) {
      if (snareTrigger > 0.2) {
        foliageObject.userData.snapState = 1;
      } else {
        foliageObject.userData.snapState = Math.max(0, (foliageObject.userData.snapState || 0) - 0.1);
      }
      const s = foliageObject.userData.snapState || 0;
      left.rotation.x = MathUtils.lerp(-0.5, 0, s);
      right.rotation.x = MathUtils.lerp(0.5 + Math.PI, Math.PI, s);
    }
  } else if (type === "accordionStretch") {
    const trunkGroup = foliageObject.userData.trunk;
    if (trunkGroup) {
      const stretch = 1 + Math.max(0, Math.sin(animTime * 10 + offset)) * 0.31 * intensity;
      trunkGroup.scale.y = stretch;
      const width = 1 / Math.sqrt(stretch);
      trunkGroup.scale.x = width;
      trunkGroup.scale.z = width;
    }
  } else if (type === "fiberWhip") {
    foliageObject.rotation.y = Math.sin(time * 0.5 + offset) * 0.111;
    const whip = leadVol * 2;
    foliageObject.children.forEach((branchGroup, i) => {
      if (branchGroup === foliageObject.children[0]) return;
      const childOffset = i * 0.51;
      const cable = branchGroup.children[0];
      let rotZ = Math.PI / 4 + Math.sin(time * 2 + childOffset) * 0.13;
      if (isActive) {
        rotZ += Math.sin(time * 10 + childOffset) * whip;
        const tip = cable.children[0];
        if (tip) {
          tip.visible = Math.random() < 0.5 + whip;
        }
      }
      if (cable) cable.rotation.z = rotZ;
    });
  } else if (type === "bounce") {
    const y = foliageObject.userData.originalY ?? foliageObject.position.y;
    foliageObject.userData.originalY = y;
    foliageObject.position.y = y + Math.sin(animTime * 3 + offset) * 0.12 * intensity;
    if (isActive && kick > 0.12) foliageObject.position.y += kick * 0.21;
  } else if (type === "sway") {
    foliageObject.rotation.z = Math.sin(time + offset) * 0.11 * intensity;
  } else if (type === "wobble") {
    const wobbleBoost = foliageObject.userData.wobbleCurrent || 0;
    foliageObject.rotation.x = Math.sin(animTime * 3 + offset) * 0.15 * intensity * (1 + wobbleBoost);
    foliageObject.rotation.z = Math.cos(animTime * 3 + offset) * 0.16 * intensity * (1 + wobbleBoost);
  } else if (type === "accordion") {
    const target = foliageObject.userData.trunk || foliageObject;
    const stretch = 1 + Math.max(0, Math.sin(animTime * 10 + offset)) * 0.3 * intensity;
    target.scale.y = stretch;
    if (foliageObject.userData.trunk) {
      const w = 1 / Math.sqrt(stretch);
      target.scale.x = w;
      target.scale.z = w;
    }
  } else if (type === "hop") {
    const y = foliageObject.userData.originalY ?? foliageObject.position.y;
    foliageObject.userData.originalY = y;
    const hopTime = animTime * 4 + offset;
    const bounce = Math.max(0, Math.sin(hopTime)) * 0.3 * intensity;
    foliageObject.position.y = y + bounce;
    if (isActive && kick > 0.1) foliageObject.position.y += kick * 0.15;
  } else if (type === "shiver") {
    const shiver = Math.sin(animTime * 20 + offset) * 0.05 * intensity;
    foliageObject.rotation.z = shiver;
    foliageObject.rotation.x = shiver * 0.5;
  } else if (type === "spring") {
    const springTime = animTime * 5 + offset;
    foliageObject.scale.y = 1 + Math.sin(springTime) * 0.1 * intensity;
    foliageObject.scale.x = 1 - Math.sin(springTime) * 0.05 * intensity;
    foliageObject.scale.z = 1 - Math.sin(springTime) * 0.05 * intensity;
  } else if (type === "gentleSway") {
    foliageObject.rotation.z = Math.sin(time * 0.5 + offset) * 0.05 * intensity;
  } else if (type === "vineSway") {
    foliageObject.rotation.z = Math.sin(time * 1.5 + offset) * 0.2 * intensity;
    foliageObject.rotation.x = Math.cos(time * 1.2 + offset) * 0.1 * intensity;
  } else if (type === "spiralWave") {
    foliageObject.children.forEach((child, i) => {
      child.rotation.y = Math.sin(time * 2 + offset + i * 0.5) * 0.3 * intensity;
    });
  } else if (type === "float") {
    const y = foliageObject.userData.originalY ?? foliageObject.position.y;
    foliageObject.userData.originalY = y;
    foliageObject.position.y = y + Math.sin(time * 2 + offset) * 0.5 * intensity;
  } else if (type === "spin") {
    foliageObject.rotation.y += 0.01 * intensity;
  } else if (type === "glowPulse") {
    const y = foliageObject.userData.originalY ?? foliageObject.position.y;
    foliageObject.userData.originalY = y;
    foliageObject.position.y = y + Math.sin(time * 2 + offset) * 0.1;
  } else if (type === "rain") {
    const rainChild = foliageObject.children.find((c) => c.type === "Points");
    if (rainChild && rainChild.geometry && rainChild.geometry.attributes.position) {
      const positions = rainChild.geometry.attributes.position.array;
      for (let i = 0; i < positions.length; i += 3) {
        positions[i + 1] -= 0.1;
        if (positions[i + 1] < -6) positions[i + 1] = 0;
      }
      rainChild.geometry.attributes.position.needsUpdate = true;
    }
    const y = foliageObject.userData.originalY ?? foliageObject.position.y;
    foliageObject.userData.originalY = y;
    foliageObject.position.y = y + Math.sin(time * 0.3 + offset) * 0.2;
  } else if (type === "cloudBob") {
    const y = foliageObject.userData.originalY ?? foliageObject.position.y;
    foliageObject.userData.originalY = y;
    foliageObject.position.y = y + Math.sin(time * 0.5 + offset) * 0.3;
    foliageObject.rotation.y = Math.sin(time * 0.2 + offset * 0.5) * 0.05;
  } else if (type === "vibratoShake") {
    const headGroup = foliageObject.userData.headGroup;
    if (headGroup) {
      let vibratoAmount = 0;
      if (audioData && audioData.channelData) {
        for (const ch of audioData.channelData) {
          if (ch.activeEffect === 1) {
            vibratoAmount = Math.max(vibratoAmount, ch.effectValue || 0);
          }
        }
      }
      vibratoAmount = Math.max(vibratoAmount, groove * 0.5);
      const shakeSpeed = 50 + vibratoAmount * 100;
      const shakeAmount = 0.05 + vibratoAmount * 0.25;
      headGroup.children.forEach((child, i) => {
        if (i === 0) return;
        const phase = child.userData.vibratoPhase || i * 0.5;
        child.rotation.x = -Math.PI / 2 + Math.sin(time * shakeSpeed + phase) * shakeAmount;
        child.rotation.y = Math.cos(time * shakeSpeed * 1.3 + phase) * shakeAmount * 0.8;
        const jitter = 1 + Math.random() * vibratoAmount * 0.2;
        child.scale.setScalar(jitter);
      });
      headGroup.rotation.z = Math.sin(time * 15 + offset) * 0.1 * intensity;
    }
  } else if (type === "tremeloPulse") {
    const headGroup = foliageObject.userData.headGroup;
    const bellMat = foliageObject.userData.bellMaterial;
    const vortex = foliageObject.userData.vortex;
    let tremoloAmount = 0;
    if (audioData && audioData.channelData) {
      for (const ch of audioData.channelData) {
        if (ch.activeEffect === 3) {
          tremoloAmount = Math.max(tremoloAmount, ch.effectValue || 0);
        }
      }
    }
    tremoloAmount = Math.max(tremoloAmount, Math.sin(beatPhase * Math.PI * 2) * 0.3);
    if (headGroup) {
      const pulseSpeed = 8 + tremoloAmount * 15;
      const pulseAmount = 0.1 + tremoloAmount * 0.3;
      const pulse = 1 + Math.sin(time * pulseSpeed + offset) * pulseAmount;
      headGroup.scale.set(pulse, pulse, pulse);
      if (bellMat) {
        bellMat.opacity = 0.7 + Math.sin(time * pulseSpeed + offset) * 0.2 * intensity;
        bellMat.emissiveIntensity = 0.3 + tremoloAmount * 0.7;
      }
      if (vortex) {
        vortex.scale.setScalar(1 - Math.sin(time * pulseSpeed + offset) * 0.4);
        vortex.material.opacity = 0.3 + Math.sin(time * pulseSpeed + offset + Math.PI) * 0.4;
      }
    }
    foliageObject.rotation.z = Math.sin(time + offset) * 0.03 * intensity;
  } else if (type === "cymbalShake") {
    const head = foliageObject.children[1];
    if (head) {
      let highFreq = 0;
      if (audioData && audioData.channelData) {
        const ch3 = audioData.channelData[3]?.volume || 0;
        const ch4 = audioData.channelData[4]?.volume || 0;
        highFreq = Math.max(ch3, ch4);
      }
      if (highFreq > 0.05) {
        const twitch = highFreq * 0.2;
        head.rotation.z = (Math.random() - 0.5) * twitch;
        head.rotation.x = (Math.random() - 0.5) * twitch;
        head.children.forEach((stalk) => {
          stalk.rotation.z += (Math.random() - 0.5) * twitch * 2;
          stalk.rotation.z *= 0.8;
        });
      } else {
        head.rotation.z *= 0.9;
        head.rotation.x *= 0.9;
      }
      if (highFreq > 0.4) {
        const s = 1 + (highFreq - 0.4) * 0.5;
        head.scale.set(s, s, s);
      } else {
        head.scale.lerp(new Vector3(1, 1, 1), 0.1);
      }
    }
  } else if (type === "panningBob") {
    const panBias = foliageObject.userData.panBias || 0;
    let targetBob = 0;
    if (audioData && audioData.channelData) {
      for (const ch of audioData.channelData) {
        const vol = ch.volume || 0;
        const pan = ch.pan || 0;
        if (panBias * pan > 0) {
          targetBob += vol * Math.abs(pan);
        }
        if (Math.abs(pan) < 0.2) {
          targetBob += vol * 0.3;
        }
      }
    }
    const currentBob = foliageObject.userData.currentBob || 0;
    const nextBob = MathUtils.lerp(currentBob, targetBob, 0.1);
    foliageObject.userData.currentBob = nextBob;
    const bobHeight = nextBob * 1.5 * intensity;
    const baseY = foliageObject.userData.originalY ?? foliageObject.position.y;
    foliageObject.userData.originalY = baseY;
    foliageObject.position.y = baseY + Math.sin(time * 2 + offset) * 0.1 + bobHeight;
    foliageObject.rotation.z = panBias * bobHeight * 0.2;
    const glowMat = foliageObject.userData.glowMaterial;
    const glowUni = foliageObject.userData.glowUniform;
    if (glowUni) {
      glowUni.value = 0.6 + bobHeight * 0.8;
    } else if (glowMat) {
      glowMat.opacity = 0.6 + bobHeight * 0.5;
    }
  } else if (type === "spiritFade") {
    const mat = foliageObject.userData.spiritMaterial;
    let volume = 1;
    if (audioData) {
      let sum = 0;
      if (audioData.channelData) {
        for (const ch of audioData.channelData) {
          sum += ch.volume || 0;
        }
        volume = sum / 4;
      }
    }
    const threshold = 0.1;
    if (volume < threshold) {
      foliageObject.userData.targetOpacity = 0.8;
      foliageObject.userData.fleeSpeed = Math.max(0, foliageObject.userData.fleeSpeed - 0.01);
    } else {
      foliageObject.userData.targetOpacity = 0;
      if (foliageObject.userData.currentOpacity > 0.1) {
        foliageObject.userData.fleeSpeed = Math.min(0.2, foliageObject.userData.fleeSpeed + 0.01);
      }
    }
    const cur = foliageObject.userData.currentOpacity || 0;
    const target = foliageObject.userData.targetOpacity;
    const next = MathUtils.lerp(cur, target, 0.05);
    foliageObject.userData.currentOpacity = next;
    if (mat) {
      mat.opacity = next;
      mat.visible = next > 0.01;
    }
    if (foliageObject.userData.fleeSpeed > 0) {
      foliageObject.position.z -= foliageObject.userData.fleeSpeed;
    }
    if (next > 0.01) {
      const baseY = foliageObject.userData.originalY ?? foliageObject.position.y;
      foliageObject.userData.originalY = baseY;
      foliageObject.position.y = baseY + Math.sin(time * 1.5 + offset) * 0.2;
    }
  } else if (type === "geyserErupt") {
    const plume = foliageObject.userData.plume;
    const plumeLight = foliageObject.userData.plumeLight;
    const coreMat = foliageObject.userData.coreMaterial;
    const maxHeight = foliageObject.userData.maxHeight || 5;
    const kickThreshold = 0.3;
    let eruptionStrength = foliageObject.userData.eruptionStrength || 0;
    if (kick > kickThreshold) {
      eruptionStrength = Math.min(1, eruptionStrength + kick * 0.5);
    } else {
      eruptionStrength = Math.max(0, eruptionStrength - 0.03);
    }
    foliageObject.userData.eruptionStrength = eruptionStrength;
    if (plume) {
      plume.visible = eruptionStrength > 0.05;
      if (plume.visible && plume.geometry.attributes.position) {
        const positions = plume.geometry.attributes.position.array;
        const velocities = plume.geometry.attributes.velocity.array;
        const currentMaxH = maxHeight * eruptionStrength;
        for (let i = 0; i < positions.length / 3; i++) {
          const idx = i * 3;
          const vel = velocities[i];
          positions[idx + 1] += vel * eruptionStrength * 0.3;
          const heightRatio = positions[idx + 1] / currentMaxH;
          positions[idx] += (Math.random() - 0.5) * 0.02 * heightRatio;
          positions[idx + 2] += (Math.random() - 0.5) * 0.02 * heightRatio;
          if (positions[idx + 1] > currentMaxH || positions[idx + 1] < 0) {
            positions[idx] = (Math.random() - 0.5) * 0.2;
            positions[idx + 1] = 0;
            positions[idx + 2] = (Math.random() - 0.5) * 0.2;
          }
        }
        plume.geometry.attributes.position.needsUpdate = true;
      }
      if (plume.material.opacity !== void 0) {
        plume.material.opacity = 0.5 + eruptionStrength * 0.5;
      }
    }
    if (plumeLight) {
      plumeLight.intensity = eruptionStrength * 2;
      plumeLight.position.y = 1 + eruptionStrength * maxHeight * 0.3;
    }
    if (coreMat) {
      coreMat.emissiveIntensity = 0.3 + eruptionStrength * 1.5 + Math.sin(time * 20) * 0.2 * eruptionStrength;
    }
  }
}

// src/foliage/water.js


const uAudioLow = uniform(0.0);   
const uAudioHigh = uniform(0.0);  
const uWaveHeight = uniform(1.0); 

function createWaveformWater(width = 400, depth = 400) {
    const geometry = new PlaneGeometry(width, depth, 128, 128);
    geometry.rotateX(-Math.PI / 2); 

    const waterDisplacement = Fn((pos) => {
        // FIX: Wrap all raw numbers in float()
        const bigWave = sin(pos.x.mul(float(0.05)).add(time.mul(float(0.5)))).mul(float(2.0));
        const bassWave = cos(pos.z.mul(float(0.1)).sub(time.mul(float(1.0))))
            .mul(uAudioLow.mul(float(3.0)).add(float(0.5))); 

        const rippleX = sin(pos.x.mul(float(0.5)).add(time.mul(float(2.0))));
        const rippleZ = cos(pos.z.mul(float(0.4)).sub(time.mul(float(2.5))));
        const trebleRipples = rippleX.mul(rippleZ).mul(uAudioHigh.mul(float(1.5)));

        return bigWave.add(bassWave).add(trebleRipples).mul(uWaveHeight);
    });

    const material = CandyPresets.SeaJelly(0x44AAFF, {
        roughness: 0.1,
        metalness: 0.1,
        transmission: 0.9,
        ior: 1.33,
        thickness: 2.0,
        animateMoisture: true 
    });

    const pos = positionLocal;
    const displacement = waterDisplacement(pos);

    const newPos = vec3(pos.x, pos.y.add(displacement), pos.z);
    material.positionNode = newPos;

    // FIX: smoothstep edges must be nodes (floats)
    const heightFactor = smoothstep(float(2.0), float(5.0), displacement); 
    const foamColor = color(0xFFFFFF);
    const waterColor = material.colorNode; 

    // FIX: float(0.5)
    material.colorNode = mix(waterColor, foamColor, heightFactor.mul(float(0.5)));
    
    const beatGlow = uAudioLow.mul(float(0.2)); 
    
    material.emissiveNode = vec3(float(0.1), float(0.3), float(0.6)).mul(beatGlow);

    const mesh = new Mesh(geometry, material);
    mesh.userData.type = 'water';
    mesh.receiveShadow = true;
    mesh.frustumCulled = false;

    return mesh;
}

// src/foliage/sky.js


// Export uniforms
const uSkyTopColor = uniform(new Color(0x7EC8E3));     
const uSkyBottomColor = uniform(new Color(0xFFC5D3)); 
const uHorizonColor = uniform(new Color(0xFFE5CC));   
const uAtmosphereIntensity = uniform(0.3);        
const uSkyDarkness = uniform(0.0); 

function createSky() {
    const skyGeo = new SphereGeometry(1000, 32, 24); 

    const offsetVal = float(40.0);
    const exponent = float(0.6);  

    // Explicitly wrap 0.0 in float() for vec3 construction
    const offsetVec = vec3(float(0.0), offsetVal, float(0.0));
    
    // Add to positionWorld safely
    const h = positionWorld.add(offsetVec).normalize().y;

    // FIX: Wrap 0.0 in float() for max()
    const heightFactor = h.max(float(0.0)).pow(exponent);
    
    // FIX: Wrap all raw numbers in float() for smoothstep
    const horizonBand = smoothstep(float(0.0), float(0.15), h).mul(smoothstep(float(0.4), float(0.15), h));
    const atmosphereGlow = horizonBand.mul(uAtmosphereIntensity);
    
    // Gradient Mix
    // FIX: Wrap 0.0, 0.3, 0.2, 1.0 in float()
    const midColor = mix(uHorizonColor, uSkyBottomColor, smoothstep(float(0.0), float(0.3), heightFactor));
    const skyColor = mix(midColor, uSkyTopColor, smoothstep(float(0.2), float(1.0), heightFactor));
    
    const baseColor = mix(skyColor, uHorizonColor, atmosphereGlow);

    // Apply Darkness
    const finalColor = baseColor.mul(float(1.0).sub(uSkyDarkness));

    const skyMat = new MeshBasicNodeMaterial();
    skyMat.colorNode = finalColor;
    skyMat.side = BackSide;

    const sky = new Mesh(skyGeo, skyMat);
    return sky;
}

// src/foliage/stars.js


// Global uniform for star pulse (driven by music)
const uStarPulse = uniform(0.0); // 0 to 1
const uStarColor = uniform(new Color(0xFFFFFF));
const uStarOpacity = uniform(0.0); 

function createStars(count = 1500) {
    const geo = new BufferGeometry();
    const positions = new Float32Array(count * 3);
    const sizes = new Float32Array(count);
    const offsets = new Float32Array(count);
    const colors = new Float32Array(count * 3);
    const normals = new Float32Array(count * 3);

    const radius = 400;

    for (let i = 0; i < count; i++) {
        const u = Math.random();
        const v = Math.random();
        const theta = 2 * Math.PI * u;
        const phi = Math.acos(2 * v - 1);

        const r = radius * (0.9 + Math.random() * 0.2);
        const x = r * Math.sin(phi) * Math.cos(theta);
        const y = r * Math.sin(phi) * Math.sin(theta);
        const z = r * Math.cos(phi);

        positions[i * 3] = x;
        positions[i * 3 + 1] = Math.abs(y);
        positions[i * 3 + 2] = z;

        normals[i * 3] = 0; normals[i * 3 + 1] = 1; normals[i * 3 + 2] = 0;

        sizes[i] = Math.random() * 2.5 + 0.3;
        offsets[i] = Math.random() * 100;
        
        const colorType = Math.random();
        if (colorType < 0.7) {
            colors[i * 3] = 1.0; colors[i * 3 + 1] = 1.0; colors[i * 3 + 2] = 1.0;
        } else if (colorType < 0.85) {
            colors[i * 3] = 0.8; colors[i * 3 + 1] = 0.9; colors[i * 3 + 2] = 1.0;
        } else {
            colors[i * 3] = 1.0; colors[i * 3 + 1] = 0.9; colors[i * 3 + 2] = 0.7;
        }
    }

    geo.setAttribute('position', new BufferAttribute(positions, 3));
    geo.setAttribute('normal', new BufferAttribute(normals, 3));
    geo.setAttribute('size', new BufferAttribute(sizes, 1));
    geo.setAttribute('offset', new BufferAttribute(offsets, 1));
    geo.setAttribute('starColor', new BufferAttribute(colors, 3));

    const mat = new PointsNodeMaterial({
        size: 1.5,
        transparent: true,
        opacity: 0.0,
        blending: AdditiveBlending,
        depthWrite: false,
        fog: false
    });

    const aOffset = attribute('offset', 'float');
    const aSize = attribute('size', 'float');
    // Attribute 'starColor' is already a vec3 node
    const aStarColor = attribute('starColor', 'vec3');

    // Twinkle logic
    // FIX: Wrap numbers in float()
    const twinkle1 = time.add(aOffset).sin().mul(float(0.3)).add(float(0.5));
    const twinkle2 = time.mul(float(2.3)).add(aOffset.mul(float(0.7))).sin().mul(float(0.2)).add(float(0.5));
    const twinkle = twinkle1.mul(twinkle2);

    const intensity = twinkle.add(uStarPulse.mul(float(1.5))); 

    // Use nodes directly - uStarColor is already a uniform node
    const musicColorVec3 = uStarColor; 

    // Mix factor
    const finalRGB = mix(aStarColor, musicColorVec3, uStarPulse.mul(float(0.8)));

    // FIX: Don't multiply vec4 by color node - just use finalRGB directly with opacity
    // mat.color is a THREE.Color used for fallback/multiplier, already handled by PointsNodeMaterial
    mat.colorNode = vec4(finalRGB, uStarOpacity);
    
    // FIX: Wrap 0.3 in float()
    mat.sizeNode = aSize.mul(intensity.max(float(0.3)));

    // Star Warp
    const pos = positionLocal;
    const warpFactor = uStarPulse.mul(float(20.0)); 
    const warpedPos = pos.add(pos.normalize().mul(warpFactor));

    // Rotation
    const angle = time.mul(float(0.02));
    const rotatedX = warpedPos.x.mul(cos(angle)).sub(warpedPos.z.mul(sin(angle)));
    const rotatedZ = warpedPos.x.mul(sin(angle)).add(warpedPos.z.mul(cos(angle)));

    mat.positionNode = vec3(rotatedX, warpedPos.y, rotatedZ);

    const stars = new Points(geo, mat);
    stars.userData.isStars = true;

    return stars;
}

// src/foliage/moon.js


// Moon Configuration
const moonConfig = {
    blinkDuration: 0.2, // seconds
    danceAmplitude: 0.5,
    danceSpeed: 2.0};

function createMoon() {
    const group = new Group();
    group.name = 'Moon';

    // 1. Moon Body (Sphere)
    const geo = new SphereGeometry(15, 32, 32);

    // TSL Material for Moon Surface + Blink
    const mat = new MeshStandardNodeMaterial({
        roughness: 0.8,
        metalness: 0.1
    });

    // Base Color (Pale Blue/White)
    const baseColor = color(0xDDEEFF);

    // Blink Effect (Emissive Pulse)
    const uBlink = uniform(0.0); // 0 to 1
    mat.uBlink = uBlink; // Expose to JS

    // Emissive node: Base glow + Blink intensity
    // FIX: Wrap 2.0 in float() to prevent mixed-type errors
    const glow = uBlink.mul(float(2.0));
    
    mat.colorNode = baseColor;
    mat.emissiveNode = color(0xFFFFFF).mul(glow);

    const moonMesh = new Mesh(geo, mat);
    moonMesh.castShadow = true; 
    group.add(moonMesh);

    // 2. Moon Face (Optional - purely decorative geometry)
    const faceGroup = new Group();
    faceGroup.position.z = 14.5; // Surface

    const eyeGeo = new SphereGeometry(1.5, 16, 16);
    const eyeMat = new MeshStandardMaterial({ color: 0x111111, roughness: 0.2 });

    const leftEye = new Mesh(eyeGeo, eyeMat);
    leftEye.position.set(-4, 3, 0);
    leftEye.scale.z = 0.5; // Flatten

    const rightEye = new Mesh(eyeGeo, eyeMat);
    rightEye.position.set(4, 3, 0);
    rightEye.scale.z = 0.5;

    group.userData.eyes = [leftEye, rightEye];

    const mouthGeo = new TorusGeometry(3, 0.5, 8, 16, Math.PI);
    const mouthMat = new MeshStandardMaterial({ color: 0x111111, roughness: 0.5 });
    const mouth = new Mesh(mouthGeo, mouthMat);
    mouth.rotation.z = Math.PI;
    mouth.position.set(0, -2, 0);

    faceGroup.add(leftEye, rightEye, mouth);
    faceGroup.lookAt(0, 0, 100); // Face forward
    group.add(faceGroup);

    // Store state
    group.userData.isMoon = true;
    group.userData.originalPosition = new Vector3(); // Set when added
    group.userData.velocity = new Vector3();
    group.userData.blinkTimer = 0;

    // Tag as Sky object
    group.userData.type = 'moon'; 
    group.userData.reactivityType = 'sky';

    return attachReactivity(group);
}

/**
 * Update Moon Animation
 */
function updateMoon(moon, delta, audioData) {
    if (!moon || !moon.userData.isMoon) return;

    // 1. Dance (Bobbing to beat)
    const timeVal = performance.now() * 0.001;
    const beatPhase = audioData?.beatPhase || 0;
    const groove = audioData?.grooveAmount || 0;

    // Gentle bob always
    const bob = Math.sin(timeVal * moonConfig.danceSpeed) * moonConfig.danceAmplitude;

    // Beat bounce
    const beatBounce = Math.max(0, Math.sin(beatPhase * Math.PI * 2)) * groove * 2.0;

    // Blink on Beat: Check if we are on a strong beat (phase near 0 or 1)
    if (groove > 0.5) {
        // Trigger blink if near the beat (within 0.1 phase window) and debounce
        if (beatPhase < 0.1 && moon.userData.blinkTimer <= 0) {
            triggerMoonBlink(moon);
        }
    }

    const mesh = moon.children[0];
    if (mesh) {
        mesh.position.y = bob + beatBounce;
        mesh.rotation.z = Math.sin(timeVal) * 0.05; // Gentle tilt
    }

    // 2. Blink Logic
    if (moon.userData.blinkTimer > 0) {
        moon.userData.blinkTimer -= delta;
        // Update uniform
        if (mesh.material.uBlink) {
             const t = 1.0 - (moon.userData.blinkTimer / moonConfig.blinkDuration);
             const val = Math.sin(t * Math.PI);
             mesh.material.uBlink.value = val;
        }

        // Squash eyes
        const eyes = moon.userData.eyes;
        if (eyes) {
            eyes.forEach(eye => eye.scale.y = 0.1 + (1.0 - Math.sin(Math.PI * (1.0 - moon.userData.blinkTimer/moonConfig.blinkDuration))) * 0.9);
        }
    } else {
        // Reset eyes
        const eyes = moon.userData.eyes;
        if (eyes) eyes.forEach(eye => eye.scale.y = 1.0);

        if (mesh.material.uBlink) mesh.material.uBlink.value = 0;

        // Random chance to blink
        if (Math.random() < 0.005) {
            triggerMoonBlink(moon);
        }

        // React to channel trigger via system
        if (moon.userData.flashIntensity > 0.1) {
             triggerMoonBlink(moon);
             moon.userData.flashIntensity = 0;
        }
    }
}

function triggerMoonBlink(moon) {
    moon.userData.blinkTimer = moonConfig.blinkDuration;
}

// src/foliage/aurora.js


const uAuroraIntensity = uniform(0.0); 
const uAuroraColor = uniform(new Color(0x00FF99)); 
const uAuroraSpeed = uniform(0.2); 

function createAurora() {
    const geometry = new CylinderGeometry(800, 800, 400, 64, 16, true);
    geometry.translate(0, 300, 0); 

    const mainAurora = Fn(() => {
        const vUv = uv();
        const timeScaled = mul(time, uAuroraSpeed);

        // FIX: Wrap all raw numbers in float()
        const wave1 = mul(sin(add(mul(vUv.x, float(20.0)), timeScaled)), float(0.1));
        const wave2 = mul(sin(sub(mul(vUv.x, float(45.0)), mul(timeScaled, float(1.5)))), float(0.05));
        const distortedX = add(add(vUv.x, wave1), wave2);

        const rayIntensity = add(mul(sin(mul(distortedX, float(60.0))), float(0.5)), float(0.5));
        
        // FIX: Wrap primitives in float() for smoothstep
        const verticalFade = mul(smoothstep(float(0.0), float(0.2), vUv.y), smoothstep(float(1.0), float(0.6), vUv.y));

        // FIX: Wrap primitives in float() for vec3 and mul
        const spectralShift = vec3(mul(vUv.y, float(0.5)), float(0.0), mul(vUv.y, float(0.2)).negate()); 
        
        // FIX: uAuroraColor is already a uniform node (contains THREE.Color), don't wrap in vec3()
        const baseColor = uAuroraColor; 
        const finalColor = add(baseColor, spectralShift);

        const finalAlpha = mul(mul(mul(rayIntensity, verticalFade), uAuroraIntensity), float(0.6)); 

        return vec4(finalColor, finalAlpha);
    });

    const material = new MeshBasicNodeMaterial();
    
    // FIX: Split the vec4 result into RGB and Alpha
    const auroraNode = mainAurora();
    material.colorNode = auroraNode.xyz;    // Use RGB for color
    material.opacityNode = auroraNode.w;    // Use Alpha for opacity
    
    material.transparent = true;
    material.blending = AdditiveBlending;
    material.side = DoubleSide;
    material.depthWrite = false;
    material.fog = false;

    const mesh = new Mesh(geometry, material);
    mesh.userData.type = 'aurora';
    mesh.userData.isAurora = true; 
    mesh.frustumCulled = false;

    return mesh;
}

// src/foliage/panning-pads.js


function createPanningPad(options = {}) {
    const {
        radius = 1.0,
        baseColor = 0x2E8B57,
        glowColor = 0x00FFFF
    } = options;

    const group = new Group();

    // 1. The Pad (Flattened Cylinder)
    // We want a mercury/holographic look.
    // Use OilSlick preset but tweak for "mercury" (high metalness, high smoothness)
    const padMat = createUnifiedMaterial(0xCCCCCC, {
        roughness: 0.1,
        metalness: 0.9,
        iridescenceStrength: 0.8,
        iridescenceFresnelPower: 2.0,
        bumpStrength: 0.05,
        noiseScale: 4.0,
        sheen: 0.5,
        sheenColor: glowColor
    });
    registerReactiveMaterial(padMat);

    const pad = new Mesh(sharedGeometries.unitCylinder, padMat);
    pad.scale.set(radius, 0.1, radius);
    pad.position.y = 0; // Pivot at bottom
    pad.castShadow = true;
    pad.receiveShadow = true;
    group.add(pad);

    // 2. Radial Glow (Holographic Overlay)
    // Add a slightly larger disc on top with additive blending
    const glowMat = createStandardNodeMaterial({
        color: glowColor,
        roughness: 1.0,
        transparent: true,
        opacity: 0.6,
        blending: AdditiveBlending,
        depthWrite: false,
        side: DoubleSide
    });

    // TSL Shader logic for radial pulse
    // Distance from center UV (0.5, 0.5)
    const center = vec2(0.5, 0.5);
    const d = distance(uv(), center).mul(2.0); // 0 at center, 1 at edge
    const ring = smoothstep(0.8, 0.9, d).sub(smoothstep(0.9, 1.0, d)); // A ring at edge
    const core = float(1.0).sub(d); // Gradient from center

    // Mix them
    const uGlowOpacity = uniform(0.6); // Default 0.6
    glowMat.opacityNode = core.mul(0.3).add(ring).mul(uGlowOpacity);
    glowMat.emissiveNode = color(glowColor).mul(glowMat.opacityNode);

    const glowDisc = new Mesh(sharedGeometries.quad, glowMat);
    glowDisc.rotation.x = -Math.PI / 2;
    glowDisc.position.y = 0.11; // Just above pad
    glowDisc.scale.set(radius * 2.2, radius * 2.2, 1); // Plane is 1x1, so scale to diameter
    pad.add(glowDisc);

    // Store reference to glow mat for pulsing intensity
    group.userData.glowMaterial = glowMat;
    group.userData.glowUniform = uGlowOpacity;

    // 3. Configuration
    group.userData.type = 'panningPad';
    group.userData.animationType = 'panningBob';
    group.userData.animationOffset = Math.random() * 100;

    // Reactivity: Map to specific channels for stereo effect
    // We will assign left/right bias in the generation step or randomly here
    // For now, let's assume random assignment if not provided
    const panBias = options.panBias !== undefined ? options.panBias : (Math.random() > 0.5 ? -1 : 1);
    group.userData.panBias = panBias; // -1 Left, 1 Right

    // Set reactivity ID: if left, map to channel 0/2; if right, map to 1/3 (simplified heuristic)
    // Or we let MusicReactivitySystem handle it.
    // Actually, `panningBob` animation logic will look at explicit pan values.

    // Attach standard reactivity (color shifts)
    attachReactivity(group, { });

    return group;
}

// src/foliage/silence-spirits.js


function createSilenceSpirit(options = {}) {
    const group = new Group();
    const { scale = 1.0 } = options;

    // A Spirit is an ephemeral creature made of stardust/light.
    // We'll use a combination of a ghost mesh and a particle cloud.

    // 1. Ghost Body (Translucent, Dissolving)
    const bodyMat = createTransparentNodeMaterial({
        color: 0xEEFFFF,
        emissive: 0x88CCFF,
        emissiveIntensity: 0.5,
        roughness: 0.2,
        opacity: 0.0, // Start invisible
        transparent: true,
        depthWrite: false,
        blending: AdditiveBlending
    });

    // Custom TSL for "Stardust" body
    // We want it to shimmer and fade based on noise
    // But since we are in JS, we can just use standard node material properties for now
    // and animate opacity in the loop.

    const bodyGeo = new CapsuleGeometry(0.3 * scale, 1.0 * scale, 4, 8);
    bodyGeo.translate(0, 0.8 * scale, 0);
    const body = new Mesh(bodyGeo, bodyMat);
    group.add(body);

    // Antlers / Head
    const headGeo = new SphereGeometry(0.25 * scale, 8, 8);
    const head = new Mesh(headGeo, bodyMat);
    head.position.y = 1.4 * scale;
    body.add(head);

    // 2. State
    group.userData.type = 'silenceSpirit';
    group.userData.animationType = 'spiritFade'; // Custom animation type
    group.userData.isVisible = false;
    group.userData.targetOpacity = 0.0;
    group.userData.currentOpacity = 0.0;
    group.userData.fleeSpeed = 0.0;

    // Store material reference for opacity animation
    group.userData.spiritMaterial = bodyMat;

    return group;
}

// src/foliage/instrument.js


function createInstrumentShrine(options = {}) {
    const {
        instrumentID = 0,
        scale = 1.0
    } = options;

    const group = new Group();

    // The Shrine is a monolith that displays patterns based on the Instrument ID.
    // 0 = Drums, 1 = Bass, etc (in standard MOD files instruments are 1-based usually).

    const shrineMat = createUnifiedMaterial(0x333333, {
        roughness: 0.2,
        metalness: 0.8,
        bumpStrength: 0.1
    });

    // Custom TSL override for Color based on Instrument ID
    // We create a procedural pattern
    const id = float(instrumentID);

    // Pattern Logic:
    // Generate a pattern based on UV and ID
    const pUV = uv().mul(10.0);

    // Different math for different ID ranges for variety
    const patternA = sin(pUV.x.add(id)).mul(cos(pUV.y.add(id))); // Grid-like
    const patternB = mx_noise_float(vec3(pUV.x, pUV.y, id)); // Noise-like

    // Mix based on ID modulo
    // We can't use modulo easily in TSL without some work, so let's just use sin(id) to mix
    const mixFactor = sin(id.mul(0.5)).add(1.0).mul(0.5); // 0 to 1

    const pattern = mix(patternA, patternB, mixFactor);

    // Colorize
    // Map ID to Hue (Calculate in JS since ID is constant per instance)
    const jsHue = (instrumentID * 0.1) % 1.0;
    const jsColor = new Color().setHSL(jsHue, 1.0, 0.5);

    const baseCol = color(jsColor);

    // Apply pattern to emissive
    shrineMat.emissiveNode = baseCol.mul(pattern.add(0.5).mul(2.0)); // Glow

    // Geometry: Monolith
    const geo = new BoxGeometry(1, 3, 1);
    const mesh = new Mesh(geo, shrineMat);
    mesh.scale.set(scale, scale, scale);
    mesh.position.y = 1.5 * scale;
    mesh.castShadow = true;

    group.add(mesh);

    // Floating symbol on top (Sphere)
    const orbMat = createUnifiedMaterial(0xFFFFFF, {
        transmission: 1.0,
        thickness: 1.0,
        roughness: 0.0,
        ior: 1.5,
        iridescenceStrength: 1.0
    });
    const orb = new Mesh(sharedGeometries.unitSphere, orbMat);
    orb.position.y = 3.5 * scale;
    orb.scale.setScalar(0.5 * scale);
    group.add(orb);

    group.userData.type = 'instrumentShrine';
    group.userData.instrumentID = instrumentID;

    // Simple float animation
    group.userData.animationType = 'float';
    group.userData.animationOffset = Math.random() * 100;

    // Reactivity
    attachReactivity(group, { });

    return group;
}

// --- Category 1: Melodic Flora ---

function createArpeggioFern(options = {}) {
    const { color = 0x00FF88, scale = 1.0 } = options;
    const group = new Group();

    // Base
    const baseGeo = new ConeGeometry(0.2 * scale, 0.5 * scale, 6);
    const baseMat = createClayMaterial(0x2E8B57);
    const base = new Mesh(baseGeo, baseMat);
    base.position.y = 0.25 * scale;
    group.add(base);

    // Fronds (Segmented for unfurling animation)
    const frondCount = 5;
    const segCount = 8;
    const frondMat = createCandyMaterial(color);
    registerReactiveMaterial(frondMat);

    group.userData.fronds = []; // Store references for animation

    for (let i = 0; i < frondCount; i++) {
        const frondRoot = new Group();
        frondRoot.rotation.y = (i / frondCount) * Math.PI * 2;
        frondRoot.position.y = 0.4 * scale;
        
        const frondSegments = [];
        let currentSeg = frondRoot;
        
        // Create chain of segments
        for (let j = 0; j < segCount; j++) {
            const segGeo = new BoxGeometry(0.1 * scale, 0.3 * scale, 0.02 * scale);
            // Tapering
            segGeo.scale(1.0 - (j/segCount)*0.8, 1.0, 1.0);
            segGeo.translate(0, 0.15 * scale, 0);
            
            const seg = new Mesh(segGeo, frondMat);
            const pivot = new Group();
            pivot.position.y = (j === 0) ? 0 : 0.28 * scale; // Pivot at top of prev
            
            // Initial curl state
            const initialCurl = -0.5;
            pivot.rotation.x = initialCurl; // Curled inward
            
            pivot.add(seg);
            currentSeg.add(pivot);
            currentSeg = pivot; // Next segment attaches to this pivot

            frondSegments.push({ pivot, initialCurl });
        }

        group.add(frondRoot);
        group.userData.fronds.push(frondSegments);
    }

    group.userData.animationType = 'arpeggioUnfurl';
    group.userData.type = 'fern';
    return attachReactivity(group);
}

function createPortamentoPine(options = {}) {
    const { color = 0xCD7F32, height = 4.0 } = options;
    const group = new Group();

    // Trunk (Segmented for bending)
    const segments = 6;
    const segHeight = height / segments;
    const trunkMat = createClayMaterial(0x8B4513); // Copper-ish
    const needleMat = createCandyMaterial(0x2E8B57);

    let currentParent = group;

    for (let i = 0; i < segments; i++) {
        const pivot = new Group();
        pivot.position.y = (i === 0) ? 0 : segHeight;
        
        const rBot = 0.4 * (1 - i/segments) + 0.1;
        const rTop = 0.4 * (1 - (i+1)/segments) + 0.1;
        
        const geo = new CylinderGeometry(rTop, rBot, segHeight, 8);
        geo.translate(0, segHeight/2, 0);
        const mesh = new Mesh(geo, trunkMat);
        
        // Needles
        if (i > 1) {
            const needleCount = 8;
            for(let n=0; n<needleCount; n++) {
                const needle = new Mesh(new ConeGeometry(0.1, 0.6, 4), needleMat);
                needle.position.y = segHeight * 0.5;
                needle.rotation.y = (n/needleCount) * Math.PI * 2;
                needle.rotation.z = 1.5;
                needle.position.x = rBot;
                mesh.add(needle);
            }
        }

        pivot.add(mesh);
        currentParent.add(pivot);
        currentParent = pivot;
        
        // Store reference to pivots for animation
        if (!group.userData.segments) group.userData.segments = [];
        group.userData.segments.push(pivot);
    }

    group.userData.animationType = 'portamentoBend';
    group.userData.type = 'tree';
    return group;
}

// --- Category 2: Rhythmic Structures ---

function createCymbalDandelion(options = {}) {
    const { scale = 1.0 } = options;
    const group = new Group();

    // Stem
    const stem = new Mesh(
        new CylinderGeometry(0.02 * scale, 0.02 * scale, 1.5 * scale),
        createClayMaterial(0x556B2F)
    );
    stem.position.y = 0.75 * scale;
    group.add(stem);

    // Head (The Cymbal Seeds)
    const head = new Group();
    head.position.y = 1.5 * scale;
    group.add(head);

    const seedCount = 24;
    const seedGeo = new CylinderGeometry(0.01, 0.01, 0.4 * scale);
    seedGeo.translate(0, 0.2 * scale, 0);
    const tipGeo = new SphereGeometry(0.04 * scale);
    const seedMat = createCandyMaterial(0xFFD700); // Gold
    registerReactiveMaterial(seedMat);

    for(let i=0; i<seedCount; i++) {
        const seedGroup = new Group();
        const phi = Math.acos(-1 + (2 * i) / seedCount);
        const theta = Math.sqrt(seedCount * Math.PI) * phi;
        
        seedGroup.rotation.setFromVector3(new Vector3(
            Math.sin(phi) * Math.cos(theta),
            Math.sin(phi) * Math.sin(theta),
            Math.cos(phi)
        ).normalize().multiplyScalar(1.5)); // Direction
        
        seedGroup.lookAt(seedGroup.position.clone().add(new Vector3(0,1,0))); // Hacky alignment

        const stalk = new Mesh(seedGeo, createClayMaterial(0xFFFFFF));
        const tip = new Mesh(tipGeo, seedMat);
        tip.position.y = 0.4 * scale;
        
        stalk.add(tip);
        head.add(stalk);
        
        // Distribute spherically
        stalk.quaternion.setFromUnitVectors(new Vector3(0,1,0), new Vector3(
             Math.sin(phi) * Math.cos(theta),
             Math.cos(phi),
             Math.sin(phi) * Math.sin(theta)
        ));
    }

    group.userData.animationType = 'cymbalShake'; // Needs high freq trigger
    group.userData.type = 'flower';
    return attachReactivity(group);
}

function createSnareTrap(options = {}) {
    const { color = 0xFF4500, scale = 1.0 } = options;
    const group = new Group();

    // Base
    const base = new Mesh(new CylinderGeometry(0.4, 0.5, 0.2), createClayMaterial(0x2E2E2E));
    group.add(base);

    // Jaws
    const jawMat = createCandyMaterial(color);
    registerReactiveMaterial(jawMat);
    const toothMat = createClayMaterial(0xFFFFFF);

    const leftJaw = new Group();
    const rightJaw = new Group();
    
    // Jaw Shape (Half Torus ish)
    const jawGeo = new TorusGeometry(0.5 * scale, 0.1 * scale, 8, 16, Math.PI);
    
    const meshL = new Mesh(jawGeo, jawMat);
    meshL.rotation.x = Math.PI / 2;
    leftJaw.add(meshL);

    const meshR = new Mesh(jawGeo, jawMat);
    meshR.rotation.x = Math.PI / 2;
    rightJaw.add(meshR);

    // Teeth
    for(let i=0; i<5; i++) {
        const t = new Mesh(new ConeGeometry(0.05, 0.2), toothMat);
        t.position.set((i-2)*0.2, 0, 0.1);
        t.rotation.x = -1;
        leftJaw.add(t);
        
        const t2 = t.clone();
        t2.rotation.x = 1.0;
        t2.position.z = -0.1;
        rightJaw.add(t2);
    }

    leftJaw.position.set(0, 0.2, -0.2);
    rightJaw.position.set(0, 0.2, 0.2);
    
    // Default open state
    leftJaw.rotation.x = -0.5;
    rightJaw.rotation.x = 0.5 + Math.PI; // Face opposite

    group.add(leftJaw);
    group.add(rightJaw);

    group.userData.leftJaw = leftJaw;
    group.userData.rightJaw = rightJaw;
    group.userData.animationType = 'snareSnap';
    group.userData.type = 'trap'; // Reacts to snare
    
    return attachReactivity(group);
}

/**
 * MANAGER CLASS
 * Handles batch updates for thousands of instanced objects efficiently.
 */
class MusicalFloraManager {
    constructor() {
        this.systems = new Map(); // Stores registered mesh systems
        this.dummy = new Object3D();
        this._position = new Vector3();
        this._quaternion = new Quaternion();
        this._scale = new Vector3();
        
        // Performance: Reusable arrays
        this.instanceColors = null; 
    }

    /**
     * Register an InstancedMesh to be animated by WASM
     * @param {string} id - Unique ID (e.g., 'mushrooms')
     * @param {THREE.InstancedMesh} mesh - The mesh
     * @param {Array} initialData - Array of {x, y, z, scale} objects
     */
    register(id, mesh, initialData) {
        if (!mesh || !initialData || initialData.length === 0) return;

        console.log(`[MusicalFlora] Registering system: ${id} (${initialData.length} items)`);

        // Upload initial positions to WASM so it knows where they are
        // Note: If you have multiple systems, we currently share one WASM position buffer.
        // For a complex game, you'd offset them. For now, we'll just upload the active one or
        // you can call uploadPositions() right before animate() for that system.
        uploadPositions(initialData);

        this.systems.set(id, {
            mesh,
            data: initialData,
            count: initialData.length
        });
    }

    /**
     * Main update loop - Call this in your tick/render loop
     */
    update(time, deltaTime, audioState) {
        const kick = audioState?.kickTrigger || 0;
        const intensity = audioState?.energy || 0;

        for (const [id, system] of this.systems) {
            this.animateSystem(system, time, intensity, kick);
        }
    }

    animateSystem(system, time, intensity, kick) {
        const { mesh, count, data } = system;

        // 1. Run Physics/Animation in WASM
        // Returns [yOffset, rotX, rotZ, 0, yOffset, rotX, ...]
        const results = batchAnimationCalc(time, intensity, kick, count);
        
        if (!results) return;

        // 2. Apply results to InstancedMesh
        for (let i = 0; i < count; i++) {
            const base = data[i];
            const idx = i * 4;

            // WASM outputs
            const animY = results[idx];      // Bounce
            const animRotX = results[idx+1]; // Wobble
            const animRotZ = results[idx+2]; // Sway

            // Position (Original + Animation)
            this._position.set(base.x, base.y + animY, base.z);

            // Rotation (Combine base + Animation)
            // Assuming base rotation is 0 for simplicity, or store it in 'data'
            this._quaternion.setFromEuler(new Euler(
                animRotX, 
                0, // Keep Y rotation fixed or add slow spin
                animRotZ
            ));

            // Scale (React to kick)
            const scalePulse = 1.0 + (kick * 0.2 * intensity);
            const stretch = 1.0 + (animY * 0.5); // Stretch when bouncing up
            
            const s = base.scale || 1.0;
            this._scale.set(
                s * scalePulse, 
                s * stretch, 
                s * scalePulse
            );

            // Compose Matrix
            this.dummy.position.copy(this._position);
            this.dummy.quaternion.copy(this._quaternion);
            this.dummy.scale.copy(this._scale);
            this.dummy.updateMatrix();

            mesh.setMatrixAt(i, this.dummy.matrix);
        }

        mesh.instanceMatrix.needsUpdate = true;
    }
}

// Global instance
new MusicalFloraManager();

/**
 * Creates a "Note Trail Ribbon" system.
 * It follows a target (e.g., player) and creates a trailing ribbon.
 * Since dynamic geometry update is CPU intensive, we use a fixed circular buffer of vertices
 * and update a window of them each frame.
 */
class MelodyRibbon {
    constructor(scene, target, maxSegments = 50, width = 0.5) {
        this.scene = scene;
        this.target = target;
        this.maxSegments = maxSegments;
        this.width = width;

        this.segmentCount = 0;
        this.writeIndex = 0;

        // Geometry: Triangle Strip
        // Each segment has 2 vertices (top, bottom).
        // Total vertices = maxSegments * 2
        this.geometry = new BufferGeometry();

        const positions = new Float32Array(maxSegments * 2 * 3);
        const uvs = new Float32Array(maxSegments * 2 * 2);
        const indices = []; // Not needed for drawMode = TriangleStrip if supported, else we need indexed triangles

        // Three.js doesn't support TriangleStrip easily in WebGPU yet without index trickery or drawRange?
        // Actually, indexed triangles are safer.
        // For N segments (N-1 quads), we need:
        // Quad i: Verts 2*i, 2*i+1, 2*(i+1), 2*(i+1)+1

        for (let i = 0; i < maxSegments - 1; i++) {
            const v0 = i * 2;
            const v1 = i * 2 + 1;
            const v2 = (i + 1) * 2;
            const v3 = (i + 1) * 2 + 1;

            // Triangle 1
            indices.push(v0, v1, v2);
            // Triangle 2
            indices.push(v2, v1, v3);
        }

        this.geometry.setAttribute('position', new BufferAttribute(positions, 3));
        this.geometry.setAttribute('uv', new BufferAttribute(uvs, 2));
        this.geometry.setIndex(indices);

        // Material: Glowing, shifting color
        // We use TSL for a scrolling gradient effect along UVs
        const mat = CandyPresets.Gummy(0x00FFFF, {
            side: DoubleSide,
            transparent: true,
            opacity: 0.8,
            transmission: 0.5
        });

        // Dynamic color based on UV.x (length) and Time
        // UV.x will be the segment index normalized
        // Replaced timerLocal(1.0) with global time
        // functional math: fract(time * 0.2 + uv.x)
        const hue = fract(add(mul(time, 0.2), uv().x));

        // Simple HSL to RGB approximation or just mix
        const col1 = vec3(0.0, 1.0, 1.0); // Cyan
        const col2 = vec3(1.0, 0.0, 1.0); // Magenta

        // mix(col1, col2, sin(hue * 6.28) * 0.5 + 0.5)
        const mixFactor = add(mul(sin(mul(hue, 6.28)), 0.5), 0.5);
        const finalColor = mix(col1, col2, mixFactor);

        mat.colorNode = finalColor;
        mat.emissiveNode = finalColor; // Glow (implicit 1.0 intensity)

        // Fade out at tail (uv.x near 0 assuming we shift UVs, or just based on index)
        // We'll manage UVs manually. Let's say UV.x goes from 0 (tail) to 1 (head).
        // uv.x^2 * 0.8
        mat.opacityNode = mul(pow(uv().x, 2.0), 0.8);

        this.mesh = new Mesh(this.geometry, mat);
        this.mesh.frustumCulled = false; // Always render
        this.scene.add(this.mesh);

        // Local buffer for path points
        this.path = [];
        this.lastPos = new Vector3();
    }

    update(t) {
        if (!this.target) return;

        const currentPos = new Vector3();
        this.target.getWorldPosition(currentPos);

        // Only add point if moved enough
        if (currentPos.distanceToSquared(this.lastPos) > 0.01) {
            this.path.push(currentPos.clone());
            if (this.path.length > this.maxSegments) {
                this.path.shift();
            }
            this.lastPos.copy(currentPos);
            this.updateGeometry();
        }
    }

    updateGeometry() {
        const positions = this.geometry.attributes.position.array;
        const uvs = this.geometry.attributes.uv.array;

        // Rebuild geometry from path
        // We extrude a ribbon perpendicular to the camera? Or just Up?
        // Let's assume Up vector for simplicity (vertical ribbon)
        new Vector3(0, 1, 0);

        for (let i = 0; i < this.path.length; i++) {
            const p = this.path[i];
            const i2 = i * 2;

            // Top vertex
            positions[i2 * 3] = p.x;
            positions[i2 * 3 + 1] = p.y + this.width;
            positions[i2 * 3 + 2] = p.z;

            // Bottom vertex
            positions[(i2 + 1) * 3] = p.x;
            positions[(i2 + 1) * 3 + 1] = p.y - this.width;
            positions[(i2 + 1) * 3 + 2] = p.z;

            // UVs: x = progress (0 to 1), y = 0 or 1
            const progress = i / (this.maxSegments - 1);
            uvs[i2 * 2] = progress;
            uvs[i2 * 2 + 1] = 1;

            uvs[(i2 + 1) * 2] = progress;
            uvs[(i2 + 1) * 2 + 1] = 0;
        }

        // Degenerate triangles for the rest of the buffer if path is short
        // Or just set drawRange?
        this.geometry.setDrawRange(0, (this.path.length - 1) * 6);

        this.geometry.attributes.position.needsUpdate = true;
        this.geometry.attributes.uv.needsUpdate = true;
        this.geometry.computeBoundingSphere();
    }
}

// Global uniform for Kick Intensity (driven by BeatSync in main.js)
const uKickIntensity = uniform(0.0);

/**
 * Creates a "Kick Overlay" - a lens in front of the camera that distorts the view
 * on heavy kicks, simulating Chromatic Aberration Pulse.
 *
 * Strategy:
 * Use a Mesh with Transmission (Glass).
 * Use IOR ~1.0 (air) normally.
 * On Kick, increase Thickness or modify Normal to bend light.
 * Ideally, we'd split RGB, but Transmission usually just refracts the whole image.
 * To get RGB split (Chromatic Aberration), we need 'iridescence' or dispersion.
 * Three.js standard transmission doesn't support dispersion (yet).
 *
 * Alternative:
 * Use the 'Iridescence' parameter of MeshStandardNodeMaterial to add rainbow fringes.
 * And 'Thickness' distortion to warp the image.
 */
function createKickOverlay(camera) {
    // 1. Create a plane that covers the camera view
    // Placed at z = -1 (in front of camera).
    // Size needs to cover the frustum at that distance.
    // Tan(FOV/2) logic.
    const fov = camera.fov * (Math.PI / 180);
    const height = 2 * Math.tan(fov / 2) * 1.1; // * distance (1.0)
    const width = height * camera.aspect;

    const geometry = new PlaneGeometry(width * 2, height * 2); // Oversize to be safe

    // 2. Material: Invisible Glass that warps
    // We use 'CandyPresets.Crystal' but tweaked for invisibility
    const mat = CandyPresets.Crystal(0xFFFFFF, {
        transmission: 1.0,  // Fully transparent glass
        roughness: 0.0,
        ior: 1.0,           // No refraction by default (Air)
        thickness: 0.0,     // No thickness
        iridescenceStrength: 0.0, // No rainbows by default
    });

    // 3. Bind Reactivity to uKickIntensity

    // A) Refraction Pulse (Warp)
    // We modulate IOR or Thickness.
    // Modulating IOR from 1.0 to 1.1 on kick.
    // Using TSL to bind uniform.
    // Note: 'ior' in createUnifiedMaterial is a float, but we can assign a Node if we modify it.
    // CandyPresets returns a material with .iorNode set.

    // Warping IOR based on radial distance from center?
    // Let's just warp the whole thing or use a normal map.
    // Better: Perturb Normal based on UV distance from center + Kick.

    const centeredUV = uv().sub(0.5);
    const dist = centeredUV.length();

    // Radial distortion strength: stronger at edges
    dist.mul(uKickIntensity).mul(0.5);

    // Perturb normal away from center
    // Normal is (0,0,1) in local space. We add (x, y, 0).
    vec3(centeredUV.x, centeredUV.y, 0.0);
    // mat.normalNode is usually in Tangent or World space depending on context?
    // UnifiedMaterial uses 'normalNode' assigned to 'perturbNormal' result (World Space typically).
    // Let's override normalNode carefully.

    // We add a wobble to the existing normal (which is flat for a plane).
    // Local Normal: (0, 0, 1)
    // Distorted: (x*k, y*k, 1)
    // We can use 'normalMap' logic essentially.

    // Since we are parented to camera, World Normal is mostly -Z (or +Z depending on look).
    // Let's operate in View Space or just assume planar.

    // Simpler: Just modulate IOR.
    // Kick 0 -> IOR 1.0
    // Kick 1 -> IOR 1.2
    mat.iorNode = float(1.0).add(uKickIntensity.mul(0.3));

    // B) Chromatic Aberration (Iridescence)
    // Kick 0 -> Iridescence 0.0
    // Kick 1 -> Iridescence 1.0
    mat.iridescenceNode = uKickIntensity;
    mat.iridescenceIORNode = float(1.5);
    mat.iridescenceThicknessNode = float(400); // Thin film

    // C) Thickness for absorption/distortion
    mat.thicknessNode = uKickIntensity.mul(2.0);

    // D) Color Tint (Red/Magenta on kick)
    // Mix white (transparent) with Red based on Kick
    // But transmission absorbs color.
    // We want the glass itself to be clear.

    const mesh = new Mesh(geometry, mat);
    mesh.position.set(0, 0, -1); // 1 meter in front of camera
    mesh.renderOrder = 9999; // Render last (on top)

    // Parenting:
    camera.add(mesh);

    return mesh;
}

// src/foliage/celestial-bodies.js


// Helper to place objects on a distant sky sphere
function getRandomSkyPosition(radius) {
    const phi = Math.acos((Math.random() * 2) - 1); // 0 to PI
    const theta = Math.random() * Math.PI * 2;       // 0 to 2PI

    // Convert spherical to cartesian
    const x = radius * Math.sin(phi) * Math.cos(theta);
    const y = Math.abs(radius * Math.cos(phi)); // Ensure mostly upper hemisphere (positive Y)
    const z = radius * Math.sin(phi) * Math.sin(theta);

    return new Vector3(x, Math.max(100, y), z);
}

// --- 1. THE PULSAR (High Freq / Sky Reactivity) ---
function createPulsar() {
    const group = new Group();

    // Core Star
    const geo = new SphereGeometry(4, 16, 16);
    const mat = new MeshBasicMaterial({ color: 0xAAFFFF });
    const core = new Mesh(geo, mat);
    group.add(core);

    // Glow Halo (Billboard Sprite logic or simple transparent sphere)
    const glowGeo = new SphereGeometry(8, 16, 16);
    const glowMat = new MeshBasicMaterial({
        color: 0x00FFFF,
        transparent: true,
        opacity: 0.3,
        blending: AdditiveBlending,
        side: BackSide
    });
    const glow = new Mesh(glowGeo, glowMat);
    group.add(glow);

    // Reactivity Config
    group.userData.type = 'pulsar';
    group.userData.reactivityType = 'sky'; // Reacts to Drums
    // Pulsars are visible even in day, but best at night
    group.userData.minLight = 0.0;
    group.userData.maxLight = 1.0;

    return attachReactivity(group);
}

// --- 2. THE BASS PLANET (Low Freq / Flora Reactivity) ---
function createBassPlanet() {
    const group = new Group();

    // Planet Body
    const planetGeo = new IcosahedronGeometry(15, 2);
    const planetMat = new MeshStandardMaterial({
        color: 0xFF4444,
        flatShading: true,
        roughness: 0.8
    });
    const planet = new Mesh(planetGeo, planetMat);
    group.add(planet);

    // Rings
    const ringGeo = new RingGeometry(20, 35, 32);
    const ringMat = new MeshBasicMaterial({
        color: 0xFFAA88,
        side: DoubleSide,
        transparent: true,
        opacity: 0.6
    });
    const ring = new Mesh(ringGeo, ringMat);
    ring.rotation.x = Math.PI / 2.5; // Tilt the ring
    group.add(ring);

    // Reactivity Config
    group.userData.type = 'planet';
    group.userData.reactivityType = 'flora';
    group.userData.reactivityId = 0; // Lock to Kick/Bass channel

    return attachReactivity(group);
}

// --- 3. THE SPIRAL GALAXY (Melody Reactivity) ---
function createGalaxy() {
    const particles = 1000;
    const geo = new BufferGeometry();
    const positions = new Float32Array(particles * 3);
    const colors = new Float32Array(particles * 3);
    const sizes = new Float32Array(particles);

    const colorInside = new Color(0xff6030);
    const colorOutside = new Color(0x1b3984);

    for (let i = 0; i < particles; i++) {
        // Logarithmic Spiral Math
        const radius = Math.random() * 40;
        const spinAngle = radius * 0.5; // Tighter spiral near center
        const branchAngle = (i % 3) * ((Math.PI * 2) / 3); // 3 Arms

        const randomX = Math.pow(Math.random(), 3) * (Math.random() < 0.5 ? 1 : -1);
        const randomY = Math.pow(Math.random(), 3) * (Math.random() < 0.5 ? 1 : -1);
        const randomZ = Math.pow(Math.random(), 3) * (Math.random() < 0.5 ? 1 : -1);

        const x = Math.cos(spinAngle + branchAngle) * radius + randomX;
        const y = Math.random() * 2 + randomY; // Flattened disk
        const z = Math.sin(spinAngle + branchAngle) * radius + randomZ;

        positions[i * 3] = x;
        positions[i * 3 + 1] = y;
        positions[i * 3 + 2] = z;

        // Color Mix
        const mixedColor = colorInside.clone();
        mixedColor.lerp(colorOutside, radius / 40);

        colors[i * 3] = mixedColor.r;
        colors[i * 3 + 1] = mixedColor.g;
        colors[i * 3 + 2] = mixedColor.b;

        sizes[i] = Math.random() * 2;
    }

    geo.setAttribute('position', new BufferAttribute(positions, 3));

    // TSL Compatibility: Add dummy normals
    const normals = new Float32Array(particles * 3);
    for(let i=0; i<particles*3; i+=3) { normals[i] = 0; normals[i+1] = 1; normals[i+2] = 0; }
    geo.setAttribute('normal', new BufferAttribute(normals, 3));

    geo.setAttribute('color', new BufferAttribute(colors, 3));
    geo.setAttribute('size', new BufferAttribute(sizes, 1)); // For shader if used, or size attenuation

    const mat = new PointsMaterial({
        size: 0.8,
        vertexColors: true,
        blending: AdditiveBlending,
        depthWrite: false,
        transparent: true
    });

    const galaxy = new Points(geo, mat);

    // Reactivity Config
    galaxy.userData.type = 'galaxy';
    galaxy.userData.reactivityType = 'flora'; // Melody channels
    galaxy.userData.baseRotationSpeed = 0.0005;

    return attachReactivity(galaxy);
}

function initCelestialBodies(scene) {
    const bodies = [];

    // Create 1 Galaxy
    const galaxy = createGalaxy();
    galaxy.position.copy(getRandomSkyPosition(900));
    galaxy.lookAt(0, 0, 0); // Face the world
    scene.add(galaxy);
    bodies.push(galaxy);

    // Create 2 Pulsars
    for (let i = 0; i < 2; i++) {
        const pulsar = createPulsar();
        pulsar.position.copy(getRandomSkyPosition(950));
        scene.add(pulsar);
        bodies.push(pulsar);
    }

    // Create 1 Bass Planet
    const planet = createBassPlanet();
    planet.position.copy(getRandomSkyPosition(800));
    scene.add(planet);
    bodies.push(planet);

    return bodies;
}

const _frustum = new Frustum();
const _projScreenMatrix = new Matrix4();
const _scratchSphere = new Sphere();
const CHROMATIC_SCALE = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
const _speciesMapCache = {};
const _noteNameCache = {};
function getNoteColor(note, species = "global") {
  let noteName = "";
  if (typeof note === "number") {
    const index = note % 12;
    noteName = CHROMATIC_SCALE[index];
  } else if (typeof note === "string") {
    if (_noteNameCache[note]) {
      noteName = _noteNameCache[note];
    } else {
      noteName = note.replace(/[0-9-]/g, "");
      if (Object.keys(_noteNameCache).length < 200) {
        _noteNameCache[note] = noteName;
      }
    }
  }
  let map = CONFIG.noteColorMap[species];
  if (!map) {
    if (_speciesMapCache[species]) {
      map = _speciesMapCache[species];
    } else {
      const s = (species || "").toLowerCase();
      if (s.includes("flower") || s.includes("tulip") || s.includes("violet") || s.includes("rose") || s.includes("bloom") || s.includes("lotus") || s.includes("puff")) {
        map = CONFIG.noteColorMap["flower"];
      } else if (s.includes("mushroom") || s.includes("mush")) {
        map = CONFIG.noteColorMap["mushroom"];
      } else if (s.includes("tree") || s.includes("willow") || s.includes("palm") || s.includes("bush")) {
        map = CONFIG.noteColorMap["tree"];
      } else if (s.includes("cloud") || s.includes("orb") || s.includes("geyser") || s.includes("moon")) {
        map = CONFIG.noteColorMap["cloud"] || CONFIG.noteColorMap["global"];
      } else {
        map = CONFIG.noteColorMap["global"];
      }
      _speciesMapCache[species] = map;
    }
  }
  return map[noteName] || 16777215;
}
class MusicReactivitySystem {
  constructor(scene, config = {}) {
    this.scene = scene;
    this.config = config;
    this.updateStartIndex = 0;
    this._lastCameraVersion = -1;
  }
  /**
   * Get the current staggered update index (for testing)
   * @returns {number} The current start index for round-robin processing
   */
  getUpdateStartIndex() {
    return this.updateStartIndex;
  }
  /**
   * Apply reaction to a specific object
   * Merged: Handles standard foliage AND celestial objects from jules-dev
   */
  reactObject(object, note, velocity) {
    if (!object.userData.type) return;
    const species = object.userData.type;
    if (typeof object.reactToNote === "function") {
      const color = getNoteColor(note, species);
      object.reactToNote(note, color, velocity);
    }
    if (object.userData.type === "pulsar") {
      const scale = 1 + velocity * 0.5;
      object.scale.setScalar(scale);
      if (object.children[1]) {
        const childMat = object.children[1].material;
        if (childMat && childMat.opacity !== void 0) {
          childMat.opacity = 0.3 + velocity * 0.7;
        }
      }
    } else if (object.userData.type === "planet") {
      const scale = 1 + velocity * 0.1;
      object.scale.setScalar(scale);
      if (object.children[1]) {
        object.children[1].rotation.z += velocity * 0.1;
      }
    } else if (object.userData.type === "galaxy") {
      const baseSpeed = object.userData.baseRotationSpeed || 0;
      object.rotation.y -= baseSpeed + velocity * 0.02;
    }
  }
  // Helper to check if object is currently active (User Change)
  isObjectActive(object) {
    return object.visible;
  }
  /**
   * Main update loop for foliage animation and reactivity.
   * Integrates Photosensitivity (Feature Branch) with Channel Mapping (Jules Dev).
   *
   * @param {number} t - Current game time
   * @param {object} audioState - Current audio analysis state
   * @param {object} weatherSystem - Reference to weather system (for light level)
   * @param {Array} animatedFoliage - List of objects to update
   * @param {THREE.Camera} camera - Camera for distance culling
   * @param {boolean} isNight - Is it currently night?
   * @param {boolean} isDeepNight - Is it deep night (for fireflies etc)?
   * @param {THREE.Object3D} moon - Reference to moon for blinking
   */
  update(t, audioState, weatherSystem, animatedFoliage, camera, isNight, isDeepNight, moon) {
    if (audioState && audioState.channelData && isNight && moon) {
      for (const ch of audioState.channelData) {
        if (ch.trigger > 0.5 && ch.instrument === 2) {
          triggerMoonBlink(moon);
          break;
        }
      }
    }
    const globalLight = weatherSystem && typeof weatherSystem.getGlobalLightLevel === "function" ? weatherSystem.currentLightLevel : 1;
    const cameraVersion = camera.matrixWorldAutoUpdate ? camera.matrixWorld.elements[0] : this._lastCameraVersion;
    if (cameraVersion !== this._lastCameraVersion) {
      _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
      _frustum.setFromProjectionMatrix(_projScreenMatrix);
      this._lastCameraVersion = cameraVersion;
    }
    const camPos = camera.position;
    const camX = camPos.x;
    const camY = camPos.y;
    const camZ = camPos.z;
    const maxAnimationDistance = 300;
    const maxDistanceSq = maxAnimationDistance * maxAnimationDistance;
    const maxFoliageUpdateTime = 2;
    const frameStartTime = typeof performance !== "undefined" ? performance.now() : Date.now();
    let foliageUpdatesThisFrame = 0;
    const maxFoliageUpdates = 300;
    const budgetCheckInterval = 30;
    const channels = audioState && audioState.channelData ? audioState.channelData : null;
    const totalChannels = channels ? channels.length : 0;
    const splitIndex = Math.ceil(totalChannels / 2);
    const totalObjects = animatedFoliage.length;
    const startIdx = this.updateStartIndex;
    let processedCount = 0;
    for (let offset = 0; offset < totalObjects; offset++) {
      const i = (startIdx + offset) % totalObjects;
      const f = animatedFoliage[i];
      const dx = f.position.x - camX;
      const dy = f.position.y - camY;
      const dz = f.position.z - camZ;
      const distSq = dx * dx + dy * dy + dz * dz;
      if (distSq > maxDistanceSq) continue;
      let isVisible = false;
      const fAny = f;
      if (fAny.geometry && fAny.geometry.boundingSphere) {
        isVisible = _frustum.intersectsObject(f);
      } else {
        _scratchSphere.center.copy(f.position);
        _scratchSphere.radius = f.userData.radius || 5;
        isVisible = _frustum.intersectsSphere(_scratchSphere);
      }
      if (!isVisible) {
        continue;
      }
      const shouldCheckBudget = processedCount % budgetCheckInterval === 0;
      if (shouldCheckBudget) {
        const hasPerformance = typeof performance !== "undefined";
        if (hasPerformance && performance.now() - frameStartTime > maxFoliageUpdateTime) {
          break;
        }
      }
      if (foliageUpdatesThisFrame >= maxFoliageUpdates) {
        break;
      }
      processedCount++;
      if (f.userData.animationType === "wobble") {
        f.userData.animationOffset = (f.userData.animationOffset || 0) + 0.05;
      }
      animateFoliage(f, t, audioState, !isNight, isDeepNight);
      foliageUpdatesThisFrame++;
      if (channels) {
        const min = f.userData.minLight !== void 0 ? f.userData.minLight : 0;
        const max = f.userData.maxLight !== void 0 ? f.userData.maxLight : 1;
        const feather = 0.1;
        const lowerEdge = (globalLight - min) / feather;
        const upperEdge = (max - globalLight) / feather;
        const lightFactor = Math.min(Math.max(lowerEdge, 0), Math.max(upperEdge, 0), 1);
        if (lightFactor > 0) {
          let targetChannelIndex = f.userData._cacheIdx;
          if (targetChannelIndex === void 0 || f.userData._cacheTotal !== totalChannels) {
            const type = f.userData.reactivityType || "flora";
            const id = f.userData.reactivityId || 0;
            if (type === "sky") {
              const skyCount = totalChannels - splitIndex;
              targetChannelIndex = skyCount > 0 ? splitIndex + id % skyCount : totalChannels - 1;
            } else {
              const floraCount = splitIndex;
              targetChannelIndex = floraCount > 0 ? id % floraCount : 0;
            }
            f.userData._cacheIdx = targetChannelIndex;
            f.userData._cacheTotal = totalChannels;
          }
          if (targetChannelIndex < totalChannels) {
            const info = channels[targetChannelIndex];
            if (info && info.trigger > 0.1) {
              this.reactObject(f, info.note, info.trigger * lightFactor);
            }
          }
        }
      }
    }
    let kick = 0;
    if (audioState) {
      kick = audioState.kickTrigger || 0;
    }
    const beatPhase = audioState && audioState.beatPhase ? audioState.beatPhase : 0;
    foliageBatcher.flush(t + beatPhase, kick);
    const minIncrement = Math.min(10, totalObjects);
    const actualIncrement = Math.max(processedCount, minIncrement);
    this.updateStartIndex = (startIdx + actualIncrement) % totalObjects;
    if (typeof window !== "undefined" && window.updatePerfStats) {
      window.updatePerfStats(totalObjects, processedCount, foliageUpdatesThisFrame);
    }
  }
  // Alias for backward compatibility if needed
  applyReaction(object, note, velocity) {
    this.reactObject(object, note, velocity);
  }
}

// AudioSystem.js - With Playlist Queue & Stability Fixes

const SAMPLE_RATE = 44100;

// Helper functions
const lerp = (a, b, t) => a + (b - a) * t;
const decayTowards = (value, target, rate, dt) => lerp(value, target, 1 - Math.exp(-rate * dt));
const noteToFreq = (note) => {
    if (!note) return 0;
    const n = note.toUpperCase();
    const map = { C: 0, 'C#': 1, DB: 1, D: 2, 'D#': 3, EB: 3, E: 4, F: 5, 'F#': 6, GB: 6, G: 7, 'G#': 8, AB: 8, A: 9, 'A#': 10, BB: 10, B: 11 };
    const match = n.match(/^([A-G](?:#|B)?)\-?(\d)$/);
    if (!match) return 0;
    const semitone = map[match[1]] ?? 0;
    const midi = (parseInt(match[2], 10) + 1) * 12 + semitone;
    return 440 * Math.pow(2, (midi - 69) / 12);
};

class AudioSystem {
    constructor() {
        this.libopenmpt = null;
        this.currentModulePtr = 0;
        this.audioContext = null;
        this.scriptNode = null;
        this.stereoPanner = null;
        this.gainNode = null;

        // Memory management for WASM buffers
        this.leftBufferPtr = 0;
        this.rightBufferPtr = 0;

        this.moduleInfo = { title: '...', order: 0, row: 0, bpm: 0, numChannels: 0 };
        this.patternMatrices = {};
        this.isPlaying = false;
        this.isReady = false;
        this.volume = 1.0;

        // Playlist State
        this.playlist = []; // Array of File objects
        this.currentIndex = -1;

        // --- NEW: Callbacks for UI ---
        this.onPlaylistUpdate = null; // Called when songs added
        this.onTrackChange = null;    // Called when song changes

        // Visual state
        this.visualState = {
            beatPhase: 0,
            kickTrigger: 0,
            grooveAmount: 0,
            activeChannels: 0,
            channelData: [],
            bpm: 120, // Current estimated BPM
            patternIndex: 0 // Current pattern/order index
        };

        this.init();
    }

    async init() {
        if (window.setLoadingStatus) window.setLoadingStatus("Starting Audio System...");

        try {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            this.audioContext = new AudioContext();

            // --- PATH DEBUGGING & PRE-FETCH FIX ---
            // Calculate the absolute path to the 'js' folder based on the current page
            // This works for localhost, production, and subdirectories (e.g. GitHub Pages)
            const basePath = window.location.href.substring(0, window.location.href.lastIndexOf('/') + 1);
            const workletUrl = basePath + 'js/audio-processor.js';

            console.log(`[AudioSystem] Attempting to load Worklet from: ${workletUrl}`);

            try {
                // First fetch the file to inspect status and content (helps detect SPA rewrites or HTML 404 responses)
                const res = await fetch(workletUrl, { cache: 'no-store' });
                if (!res.ok) {
                    console.error(`[AudioSystem] Worklet fetch failed with status=${res.status} for ${workletUrl}`);
                    throw new Error(`Worklet fetch failed: ${res.status}`);
                }

                const contentType = res.headers.get('content-type') || '';
                let text = await res.text();

                // If the response looks like HTML (SPA fallback) or is unexpectedly small, try root '/js/' fallback
                const looksLikeHTML = text.trim().startsWith('<');
                if (text.trim().length < 20 || looksLikeHTML) {
                    console.warn(`[AudioSystem] Worklet content at ${workletUrl} looks suspicious (length=${text.length}, looksLikeHTML=${looksLikeHTML}). Trying root '/js/audio-processor.js' as a fallback.`);
                    try {
                        const rootRes = await fetch('/js/audio-processor.js', { cache: 'no-store' });
                        if (rootRes.ok) {
                            const rootCT = rootRes.headers.get('content-type') || '';
                            const rootText = await rootRes.text();
                            if (rootText.trim().length > 20 && (/javascript|ecmascript|module/.test(rootCT) || /\b(import|registerProcessor|class)\b/.test(rootText.slice(0, 200)))) {
                                console.log('[AudioSystem] Fallback /js/audio-processor.js looks like valid JS. Using it.');
                                text = rootText;
                            } else {
                                console.warn('[AudioSystem] Fallback /js/audio-processor.js did not contain valid JS.');
                            }
                        } else {
                            console.warn(`[AudioSystem] Fallback fetch failed with status=${rootRes.status}`);
                        }
                    } catch (fallbackErr) {
                        console.warn('[AudioSystem] Fallback fetch for /js/audio-processor.js failed', fallbackErr);
                    }

                    if (text.trim().length < 20 || text.trim().startsWith('<')) {
                        console.error(`[AudioSystem] Worklet content is invalid after fallback. First chars: ${text.slice(0, 160)}`);
                        throw new Error('Worklet content invalid or HTML fallback');
                    }
                }

                if (!/javascript|ecmascript|module/.test(contentType) && !/\b(import|registerProcessor|class)\b/.test(text.slice(0, 200))) {
                    console.warn(`[AudioSystem] Worklet content-type="${contentType}" and file does not look like JS. First chars: ${text.slice(0, 120)}`);
                }

                // Before creating the blob, rewrite relative import/export specifiers to absolute URLs
                // This fixes failures when the module is loaded from a blob URL (blob URLs are not hierarchical)
                let rewritten = text;
                try {
                    const makeAbsolute = (spec) => {
                        // Leave full URLs and protocol-relative URLs alone
                        if (/^[a-zA-Z][a-zA-Z0-9+-.]*:\/\//.test(spec) || spec.startsWith('//')) return spec;
                        // Non-relative bare specifiers (like 'three') should be left unchanged
                        if (!spec.startsWith('.') && !spec.startsWith('/')) return spec;
                        try {
                            return new URL(spec, workletUrl).href;
                        } catch (err) {
                            return spec;
                        }
                    };

                    // from '...'
                    rewritten = rewritten.replace(/(from\s+)(['"])([^'"\n]+)\2/g, (m, p1, q, spec) => {
                        const abs = makeAbsolute(spec);
                        return `${p1}${q}${abs}${q}`;
                    });
                    // import '...'
                    rewritten = rewritten.replace(/(import\s+)(['"])([^'"\n]+)\2/g, (m, p1, q, spec) => {
                        const abs = makeAbsolute(spec);
                        return `${p1}${q}${abs}${q}`;
                    });
                    // dynamic import('...')
                    rewritten = rewritten.replace(/(import\()(['"])([^'"\n]+)\2(\))/g, (m, p1, q, spec, p4) => {
                        const abs = makeAbsolute(spec);
                        return `${p1}${q}${abs}${q}${p4}`;
                    });

                    if (rewritten !== text) {
                        console.log('[AudioSystem] Rewrote import specifiers in worklet to absolute URLs to avoid blob-relative resolution issues.');
                    }
                } catch (err) {
                    console.warn('[AudioSystem] Failed to rewrite import specifiers, proceeding with original text', err);
                }

                const blobUrl = URL.createObjectURL(new Blob([rewritten], { type: 'application/javascript' }));
                try {
                    await this.audioContext.audioWorklet.addModule(blobUrl);
                    if (window.setLoadingStatus) window.setLoadingStatus("Audio Worklet Ready...");
                    URL.revokeObjectURL(blobUrl);
                } catch (e) {
                    console.error(`[AudioSystem] addModule failed for blob derived from ${workletUrl}`);
                    throw e;
                }
            } catch (e) {
                console.error(`[AudioSystem] Failed to load worklet at ${workletUrl}. Check the Network tab in DevTools for 404s or HTML responses.`);
                throw e;
            }
            // --------------------------

            this.workletNode = new AudioWorkletNode(this.audioContext, 'chiptune-processor');

            // Wire up messages from the audio thread
            this.workletNode.port.onmessage = (event) => {
                // ... keep existing handler ...
                const { type, data } = event.data || {};
                if (type === 'VISUAL_UPDATE') {
                    this.handleVisualUpdate(data);
                } else if (type === 'SONG_END') {
                    console.log("AudioSystem: Song finished (Worklet).");
                    this.playNext();
                } else if (type === 'READY') {
                    this.isReady = true;
                    console.log("AudioSystem: Worklet Ready.");
                    if (this.playlist.length > 0 && this.currentIndex === -1) {
                        this.playNext(0);
                    }
                }
            };

            // Connect audio graph
            this.gainNode = this.audioContext.createGain();
            this.gainNode.gain.value = this.volume;

            this.workletNode.connect(this.gainNode);
            this.gainNode.connect(this.audioContext.destination);

        } catch (e) {
            console.error("AudioSystem Init Failed:", e);
        }
    }

    // --- Playlist Management ---

    async addToQueue(fileList) {
        if (!this.isReady) return;

        const initialLength = this.playlist.length;
        for (let i = 0; i < fileList.length; i++) {
            this.playlist.push(fileList[i]);
            console.log(`Added to queue: ${fileList[i].name}`);
        }

        // Notify UI
        if (this.onPlaylistUpdate) this.onPlaylistUpdate(this.playlist);

        // If we weren't playing anything, start the first new song
        if (this.currentIndex === -1 || !this.isPlaying) {
            this.playNext(initialLength); // Start from the first new file
        }
    }

    async playNext(forceIndex = null) {
        if (this.playlist.length === 0) return;

        let nextIndex = (forceIndex !== null) ? forceIndex : this.currentIndex + 1;

        if (nextIndex >= this.playlist.length) {
            console.log("Playlist finished. Looping to start.");
            nextIndex = 0;
        }

        this.currentIndex = nextIndex;
        
        // Notify UI of track change
        if (this.onTrackChange) this.onTrackChange(this.currentIndex);
        
        const file = this.playlist[this.currentIndex];
        console.log(`Loading track ${this.currentIndex + 1}/${this.playlist.length}: ${file.name}`);
        await this.loadModule(file);
    }
    
    // --- NEW: Helper for UI clicking ---
    playAtIndex(index) {
        if (index >= 0 && index < this.playlist.length) {
            this.playNext(index);
        }
    }
    
    getPlaylist() {
        return this.playlist;
    }
    
    getCurrentIndex() {
        return this.currentIndex;
    }

    // --- Core Loading ---

    async loadModule(file) {
        if (this.audioContext && this.audioContext.state === 'suspended') {
            await this.audioContext.resume();
        }

        try {
            const arrayBuffer = await file.arrayBuffer();
            // Send to worklet for loading/decoding (transfer the buffer)
            if (this.workletNode && this.workletNode.port) {
                try {
                    this.workletNode.port.postMessage({ type: 'LOAD', fileData: arrayBuffer, fileName: file.name }, [arrayBuffer]);
                } catch (e) {
                    // Some browsers may not accept transferred buffer if already neutered; fall back to structured clone
                    this.workletNode.port.postMessage({ type: 'LOAD', fileData: arrayBuffer, fileName: file.name });
                }
            } else {
                console.warn('Worklet not ready to receive LOAD message. Attempting to init worklet and retry.');
                await this.init();
                if (this.workletNode && this.workletNode.port) {
                    this.workletNode.port.postMessage({ type: 'LOAD', fileData: arrayBuffer, fileName: file.name }, [arrayBuffer]);
                }
            }

            // Start playback (worklet will decode/play once module loaded)
            await this.play();
        } catch (e) {
            console.error("Error loading file:", e);
            this.playNext();
        }
    }

    processModuleData(fileData, fileName) {
        if (!this.libopenmpt) return;

        // CRITICAL FIX: Stop cleanly before destroying memory
        this.stop(false);

        if (this.currentModulePtr !== 0) {
            this.libopenmpt._openmpt_module_destroy(this.currentModulePtr);
            this.currentModulePtr = 0;
        }

        try {
            const lib = this.libopenmpt;
            const bufferPtr = lib._malloc(fileData.length);
            lib.HEAPU8.set(fileData, bufferPtr);

            const modPtr = lib._openmpt_module_create_from_memory2(bufferPtr, fileData.length, 0, 0, 0, 0, 0, 0, 0);
            lib._free(bufferPtr);

            if (modPtr === 0) {
                throw new Error(`Failed to load module "${fileName}".`);
            }
            this.currentModulePtr = modPtr;

            const titleKeyPtr = lib.stringToUTF8("title");
            const titleValuePtr = lib._openmpt_module_get_metadata(modPtr, titleKeyPtr);
            const title = lib.UTF8ToString(titleValuePtr) || fileName;
            lib._free(titleKeyPtr);
            lib._openmpt_free_string(titleValuePtr);

            this.moduleInfo.title = title;
            this.preCachePatternData(modPtr);
            this.play();

        } catch (e) {
            console.error("Failed to load module:", e);
            this.playNext(); // Skip broken files
        }
    }

    preCachePatternData(modPtr) {
        const lib = this.libopenmpt;
        this.patternMatrices = {};
        try {
            const numOrders = lib._openmpt_module_get_num_orders(modPtr);
            const numChannels = lib._openmpt_module_get_num_channels(modPtr);
            this.moduleInfo.numChannels = numChannels;

            for (let o = 0; o < numOrders; o++) {
                const pattern = lib._openmpt_module_get_order_pattern(modPtr, o);
                if (pattern >= lib._openmpt_module_get_num_patterns(modPtr)) continue;
                const numRows = lib._openmpt_module_get_pattern_num_rows(modPtr, pattern);
                const matrixRows = [];
                for (let r = 0; r < numRows; r++) {
                    const rowCells = [];
                    for (let c = 0; c < numChannels; c++) {
                        const commandPtr = lib._openmpt_module_format_pattern_row_channel(modPtr, pattern, r, c, 12, 1);
                        const commandStr = lib.UTF8ToString(commandPtr);
                        lib._openmpt_free_string(commandPtr);
                        rowCells.push({ text: (commandStr || '').trim() });
                    }
                    matrixRows.push(rowCells);
                }
                this.patternMatrices[o] = { rows: matrixRows, numRows, numChannels };
            }
        } catch (e) {
            console.error("Pattern caching error:", e);
        }
    }

    async play() {
        if (this.isPlaying) return;

        // Ensure audio context is resumed
        if (!this.audioContext) {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            this.audioContext = new AudioContext({ sampleRate: SAMPLE_RATE });
        }
        if (this.audioContext.state === 'suspended') await this.audioContext.resume();

        // Ensure worklet is initialized
        if (!this.workletNode) {
            try { await this.init(); } catch (e) { console.warn('Worklet init failed in play()', e); }
        }

        this.isPlaying = true;
    }

    stop(fullReset = true) {
        // Notify worklet to stop and clean up
        try {
            if (this.workletNode && this.workletNode.port) this.workletNode.port.postMessage({ type: 'STOP' });
        } catch (e) {
            console.warn('Failed to signal STOP to worklet', e);
        }

        // Disconnect audio graph parts
        try {
            if (this.workletNode) {
                try { this.workletNode.disconnect(); } catch(e) {}
                this.workletNode = null;
            }
            if (this.gainNode) {
                try { this.gainNode.disconnect(); } catch(e) {}
                this.gainNode = null;
            }
        } catch (e) {
            console.warn('Error disconnecting audio nodes:', e);
        }

        // Backwards-compat: free any local WASM buffers if present
        if (this.libopenmpt) {
            try {
                if (this.leftBufferPtr) {
                    this.libopenmpt._free(this.leftBufferPtr);
                    this.leftBufferPtr = 0;
                }
                if (this.rightBufferPtr) {
                    this.libopenmpt._free(this.rightBufferPtr);
                    this.rightBufferPtr = 0;
                }
            } catch (e) { /* ignore */ }
        }

        this.isPlaying = false;

        // There's no longer a main-thread module pointer we reset here; Worklet handles its own reset
    }

    handleVisualUpdate(data) {
        const { bpm, channelData, anyTrigger, order, row } = data; // Ensure Worklet sends order/row!
        this.visualState.bpm = bpm || 120;

        // Update Pattern Index (using order as proxy for global pattern progress)
        // If 'order' isn't available, we might default to 0, but hopefully worklet sends it.
        if (order !== undefined) {
            this.visualState.patternIndex = order;
        }

        if (anyTrigger) this.visualState.kickTrigger = 1.0;

        while (this.visualState.channelData.length < channelData.length) {
            this.visualState.channelData.push({ volume: 0, pan: 0, trigger: 0, note: '', freq: 0, instrument: 0, activeEffect: 0, effectValue: 0 });
        }

        for (let i = 0; i < channelData.length; i++) {
            const src = channelData[i];
            const dest = this.visualState.channelData[i];
            dest.volume = src.volume;
            if (src.note) {
                dest.trigger = 1.0;
                dest.note = src.note;
                dest.freq = noteToFreq(src.note);
            }
            dest.instrument = src.instrument;
            dest.activeEffect = src.activeEffect;
            dest.effectValue = src.effectValue;
        }
    }

    update() {
        // Run decay logic on the main thread for smooth animations
        this.visualState.kickTrigger = decayTowards(this.visualState.kickTrigger, 0, 8, 1 / 60);
        this.visualState.grooveAmount = decayTowards(this.visualState.grooveAmount, 0 , 3, 1 / 60);
        this.visualState.beatPhase = (this.visualState.beatPhase + (this.visualState.bpm / 60) * (1 / 60)) % 1;

        for (const ch of this.visualState.channelData) {
            ch.trigger = decayTowards(ch.trigger, 0, 10, 1 / 60);
        }

        return this.visualState;
    }
}

class BeatSync {
    constructor(audioSystem) {
        this.audio = audioSystem;
        this.lastBeatPhase = 0;
        this.beatCallbacks = [];
    }

    onBeat(cb) {
        if (typeof cb !== 'function') return;
        this.beatCallbacks.push(cb);
    }

    offBeat(cb) {
        const i = this.beatCallbacks.indexOf(cb);
        if (i >= 0) this.beatCallbacks.splice(i, 1);
    }

    update() {
        const state = this.audio.visualState || (this.audio.update && this.audio.update()) || { beatPhase: 0 };
        const beatPhase = state && state.beatPhase ? state.beatPhase : 0;

        if (beatPhase < this.lastBeatPhase && this.lastBeatPhase > 0.8) {
            for (const cb of this.beatCallbacks) {
                try { cb(state); } catch (e) { console.warn('BeatSync callback error', e); }
            }
        }

        this.lastBeatPhase = beatPhase;
    }

    getState() {
        return this.audio.visualState;
    }
}

const uRainbowOpacity = uniform(0.0);

function createRainbow() {
    // Large Ring Geometry
    const innerRadius = 80;
    const outerRadius = 90;
    const geometry = new RingGeometry(innerRadius, outerRadius, 64, 1, 0, Math.PI);

    // Position it: Center at (0, -10, -50) so it arcs over the world
    // We'll let the caller position it, but default logic needs to be upright.

    // TSL Material
    const material = new MeshStandardNodeMaterial();
    material.transparent = true;
    material.side = DoubleSide;
    material.depthWrite = false;
    material.blending = AdditiveBlending;

    // Rainbow Gradient
    // UV.x goes 0->1 along the arc
    // UV.y goes 0->1 from inner to outer radius

    // Colors
    const cRed = color(0xFF0000);
    const cOrange = color(0xFFA500);
    const cYellow = color(0xFFFF00);
    const cGreen = color(0x008000);
    const cBlue = color(0x0000FF);
    const cIndigo = color(0x4B0082);
    const cViolet = color(0xEE82EE);

    // Multi-stop gradient helper
    // 0.0-0.16: Red->Orange
    // 0.16-0.33: Orange->Yellow
    // ...

    // We use smoothstep logic for bands, or just a simple mix chain.
    // For TSL, it's easier to map uv.y (width of band) to spectrum if we want stripes across the width.
    // Usually rainbows have colors arranged RADIALLY (inner to outer).
    // So we use UV.y.

    const t = uv().y;

    let col = mix(cRed, cOrange, smoothstep(0.0, 0.16, t));
    col = mix(col, cYellow, smoothstep(0.16, 0.33, t));
    col = mix(col, cGreen, smoothstep(0.33, 0.5, t));
    col = mix(col, cBlue, smoothstep(0.5, 0.66, t));
    col = mix(col, cIndigo, smoothstep(0.66, 0.83, t));
    col = mix(col, cViolet, smoothstep(0.83, 1.0, t));

    // Soften edges
    const edgeAlpha = smoothstep(0.0, 0.2, t).mul(smoothstep(1.0, 0.8, t));

    // Soften ends of the arc
    const arcAlpha = smoothstep(0.0, 0.1, uv().x).mul(smoothstep(1.0, 0.9, uv().x));

    // Beat pulse?
    const pulse = sin(time.mul(2.0)).mul(0.1).add(0.9);

    material.colorNode = col;
    material.opacityNode = uRainbowOpacity.mul(edgeAlpha).mul(arcAlpha).mul(pulse);
    material.emissiveNode = col.mul(0.5); // Slight glow

    const mesh = new Mesh(geometry, material);
    mesh.name = 'Rainbow';

    // Default transform: upright facing Z
    // RingGeometry creates a flat ring on XY plane.
    // We want it arcing over the ground.
    // Default is perfect. Just need to ensure it's high enough.

    return mesh;
}

// src/core/cycle.js


// --- Reusable Color Pool for Render Loop (prevents GC pressure) ---
const _scratchPalette = {
    skyTop: new Color(),
    skyBot: new Color(),
    horizon: new Color(),
    fog: new Color(),
    sun: new Color(),
    amb: new Color(),
    sunInt: 0,
    ambInt: 0,
    atmosphereIntensity: 0
};

function lerpPalette(p1, p2, t) {
    _scratchPalette.skyTop.copy(p1.skyTop).lerp(p2.skyTop, t);
    _scratchPalette.skyBot.copy(p1.skyBot).lerp(p2.skyBot, t);
    _scratchPalette.horizon.copy(p1.horizon).lerp(p2.horizon, t);
    _scratchPalette.fog.copy(p1.fog).lerp(p2.fog, t);
    _scratchPalette.sun.copy(p1.sun).lerp(p2.sun, t);
    _scratchPalette.amb.copy(p1.amb).lerp(p2.amb, t);
    _scratchPalette.sunInt = MathUtils.lerp(p1.sunInt, p2.sunInt, t);
    _scratchPalette.ambInt = MathUtils.lerp(p1.ambInt, p2.ambInt, t);
    _scratchPalette.atmosphereIntensity = MathUtils.lerp(p1.atmosphereIntensity, p2.atmosphereIntensity, t);
    return _scratchPalette;
}

// --- Cycle Interpolation ---
function getCycleState(tRaw, paletteMode = 'standard') {
    const t = tRaw % CYCLE_DURATION;

    // Determine target palettes based on mode
    let targetDay = PALETTE.day;
    let targetSunset = PALETTE.sunset;
    let targetNight = PALETTE.night;
    let targetSunrise = PALETTE.sunrise;

    if (paletteMode === 'neon') {
        targetDay = PALETTE.neon; // Neon Day
        // We could define neon_sunset etc, but for now reuse or mix
        targetSunset = PALETTE.sunset;
        targetNight = PALETTE.neon; // Neon Night is same as Day for intense look
        targetSunrise = PALETTE.neon;
    } else if (paletteMode === 'glitch') {
        targetDay = PALETTE.glitch;
        targetSunset = PALETTE.glitch;
        targetNight = PALETTE.glitch;
        targetSunrise = PALETTE.glitch;
    }

    // 1. Sunrise (0-60)
    if (t < DURATION_SUNRISE) {
        return lerpPalette(targetNight, targetSunrise, t / DURATION_SUNRISE);
    }

    let elapsed = DURATION_SUNRISE;

    // 2. Day (60-480)
    if (t < elapsed + DURATION_DAY) {
        const localT = t - elapsed;
        if (localT < 60) return lerpPalette(targetSunrise, targetDay, localT / 60);
        return targetDay;
    }
    elapsed += DURATION_DAY;

    // 3. Sunset (480-540)
    if (t < elapsed + DURATION_SUNSET) {
        const localT = t - elapsed;
        return lerpPalette(targetDay, targetSunset, localT / DURATION_SUNSET);
    }
    elapsed += DURATION_SUNSET;

    // 4. Dusk Night (540-720)
    if (t < elapsed + DURATION_DUSK_NIGHT) {
        const localT = t - elapsed;
        // Fade to Night
        if (localT < 60) return lerpPalette(targetSunset, targetNight, localT / 60);
        return targetNight;
    }
    elapsed += DURATION_DUSK_NIGHT;

    // 5. Deep Night (720-840)
    if (t < elapsed + DURATION_DEEP_NIGHT) {
        return targetNight;
    }
    elapsed += DURATION_DEEP_NIGHT;

    // 6. Pre-Dawn (840-960)
    if (t < elapsed + DURATION_PRE_DAWN) {
        return targetNight;
    }

    return targetNight; // Fallback
}


// --- NEW: Helper to get celestial intensities ---
function getCelestialState(tRaw) {
    const t = tRaw % CYCLE_DURATION;
    const SUNRISE_END = DURATION_SUNRISE;
    const SUNSET_START = DURATION_SUNRISE + DURATION_DAY;
    const SUNSET_END = SUNSET_START + DURATION_SUNSET;

    let sunIntensity = 0;
    let moonIntensity = 0;

    // Day Logic
    if (t >= SUNRISE_END && t <= SUNSET_START) {
        sunIntensity = 1.0;
        moonIntensity = 0.0;
    } else if (t < SUNRISE_END) {
        // Sunrise: Sun fades in, Moon fades out
        sunIntensity = t / DURATION_SUNRISE;
        moonIntensity = 1.0 - sunIntensity;
    } else if (t > SUNSET_START && t < SUNSET_END) {
        // Sunset: Sun fades out, Moon fades in
        const fade = (t - SUNSET_START) / DURATION_SUNSET;
        sunIntensity = 1.0 - fade;
        moonIntensity = fade;
    } else {
        // Night
        sunIntensity = 0.0;
        moonIntensity = 1.0;
    }

    return { sunIntensity, moonIntensity };
}


// --- NEW: Seasonal & Yearly Calculations ---

// Year = 40 Days (10 days per season)
const YEAR_LENGTH = CYCLE_DURATION * 40; // 40 in-game days per year
// Moon cycle = 8 days so it slowly drifts against the 10-day seasons
const MOON_CYCLE_LENGTH = CYCLE_DURATION * 8; // Full moon every 8 days

function getSeasonalState(tRaw) {
    // 1. Calculate Year Progress (0.0 to 1.0)
    // 0.0 = Spring Start
    // 0.25 = Summer Start
    // 0.5 = Autumn Start
    // 0.75 = Winter Start
    const yearProgress = (tRaw % YEAR_LENGTH) / YEAR_LENGTH;
    
    let season = 'Spring';
    if (yearProgress > 0.75) season = 'Winter';
    else if (yearProgress > 0.5) season = 'Autumn';
    else if (yearProgress > 0.25) season = 'Summer';

    // 2. Calculate Sun Inclination (Declination)
    // Summer (0.25) = Highest (+23.5 deg equiv), Winter (0.75) = Lowest (-23.5 deg equiv)
    // We map this to a factor 0.0 (Winter) to 1.0 (Summer)
    // Sine wave peaks at 0.25 (Summer Solstice)
    const sunInclination = (Math.sin((yearProgress * Math.PI * 2) - (Math.PI / 2)) * 0.5) + 0.5;

    // 3. Calculate Moon Phase
    // 0.0 = New Moon, 0.5 = Full Moon, 1.0 = New Moon
    const moonProgress = (tRaw % MOON_CYCLE_LENGTH) / MOON_CYCLE_LENGTH;
    
    // Simple visual phase (0 = Empty, 1 = Full)
    // Full at 0.5
    const moonPhase = 1.0 - Math.abs(moonProgress - 0.5) * 2.0;

    return {
        season,
        sunInclination, // 0.0 (Low/Winter) to 1.0 (High/Summer)
        moonPhase,      // 0.0 (New) to 1.0 (Full)
        yearProgress
    };
}

// src/foliage/cave.js


function createCaveEntrance(options = {}) {
    const {
        scale = 1.0,
        depth = 20.0,
        width = 8.0,
        height = 6.0
    } = options;

    const group = new Group();
    group.userData.type = 'cave';
    group.userData.isBlocked = false;

    // 1. Create the Tunnel Structure (Procedural Rocks)
    const rockMat = new MeshStandardMaterial({
        color: 0x4a4a4a,
        roughness: 0.9,
        flatShading: true,
        side: DoubleSide
    });

    // IMPROVED: A 4-point curve for a better tunnel shape
    const tunnelCurve = new CatmullRomCurve3([
        new Vector3(0, 0, 0),
        new Vector3(0, -2, -depth * 0.3),
        new Vector3(4, -4, -depth * 0.6),
        new Vector3(10, -6, -depth)
    ]);

    const tubeGeo = new TubeGeometry(tunnelCurve, 12, width/2, 8, false);

    // FIX: Iterate i++ (not i+=3) to displace EVERY vertex
    const positions = tubeGeo.attributes.position;
    for(let i = 0; i < positions.count; i++) {
        const x = positions.getX(i);
        const y = positions.getY(i);
        const z = positions.getZ(i);
        // Simple noise displacement
        positions.setX(i, x + (Math.random()-0.5) * 0.5);
        positions.setY(i, y + (Math.random()-0.5) * 0.5);
        positions.setZ(i, z + (Math.random()-0.5) * 0.5);
    }
    tubeGeo.computeVertexNormals();

    const tunnelMesh = new Mesh(tubeGeo, rockMat);
    tunnelMesh.castShadow = true;
    tunnelMesh.receiveShadow = true;
    group.add(tunnelMesh);

    // 2. The Water Gate (Waterfall)
    const gatePos = new Vector3(0, height * 0.7, -2);
    const floorPos = new Vector3(0, -1, -2);

    const waterfall = createWaterfall(gatePos, floorPos, width * 0.7);
    waterfall.visible = false; // Starts dry
    waterfall.name = 'WaterGate';
    group.add(waterfall);

    group.userData.waterfall = waterfall;
    group.userData.gatePosition = new Vector3(0, 0, -2);

    group.scale.setScalar(scale);

    return group;
}

function updateCaveWaterLevel(caveGroup, waterLevel) {
    const waterfall = caveGroup.userData.waterfall;
    const threshold = 0.2;

    if (waterLevel > threshold) {
        if (!waterfall.visible) waterfall.visible = true;

        const intensity = (waterLevel - threshold) / (1.0 - threshold);
        // Scale thickness based on intensity
        waterfall.scale.set(1.0, 1.0, 0.5 + intensity * 0.5);

        caveGroup.userData.isBlocked = intensity > 0.1;
    } else {
        if (waterfall.visible) waterfall.visible = false;
        caveGroup.userData.isBlocked = false;
    }

    if (waterfall.visible && waterfall.onAnimate) {
        waterfall.onAnimate(0.016, Date.now() / 1000);
    }
}

// src/systems/weather.js


// Weather states
const WeatherState = {
    CLEAR: 'clear',
    RAIN: 'rain',
    STORM: 'storm'
};

const _UP = new Vector3(0, 1, 0);
const _scratchSunDir = new Vector3();
const _scratchCelestialForce = new Vector3();
const _scratchAttraction = new Vector3();
const _scratchBlack = new Color(0x000000);

class WeatherSystem {
    constructor(scene) {
        this.scene = scene;
        this.state = WeatherState.CLEAR;
        this.intensity = 0;
        this.stormCharge = 0;
        
        // Player Control Factor
        this.cloudDensity = 1.0;
        this.cloudRegenRate = 0.0005;
        
        // Ground Water Logic
        this.groundWaterLevel = 0.0; // 0.0 = Dry, 1.0 = Flooded
        this.trackedCaves = [];

        // Particle systems
        this.percussionRain = null;
        this.melodicMist = null;

        this.mushroomWaterfalls = new Map();

        this.lightningLight = null;
        this.lightningTimer = 0;
        this.lightningActive = false;

        this.rainbow = null;
        this.rainbowTimer = 0;
        this.lastState = WeatherState.CLEAR;

        this.trackedTrees = [];
        this.trackedShrubs = [];
        this.trackedFlowers = [];
        this.trackedMushrooms = [];

        this.targetIntensity = 0;
        this.transitionSpeed = 0.02;

        this.windDirection = new Vector3(1, 0, 0.3).normalize();
        this.windSpeed = 0;
        this.windTargetSpeed = 0;
        this.onSpawnFoliage = null;

        this._lastSpawnCheck = 0;
        this._spawnCapPerFrame = 3;
        this._spawnThrottle = 0.5;
        this._spawnQueue = [];
        
        this.fog = scene.fog;
        this.baseFogNear = scene.fog ? scene.fog.near : 20;
        this.baseFogFar = scene.fog ? scene.fog.far : 100;

        this.initParticles();
        this.initLightning();
        this.initRainbow();
    }

    initRainbow() {
        this.rainbow = createRainbow();
        this.rainbow.position.set(0, -20, -100);
        this.rainbow.scale.setScalar(2.0);
        this.scene.add(this.rainbow);
    }

    initParticles() {
        const rainCount = 500;
        const rainGeo = new BufferGeometry();
        const rainPositions = new Float32Array(rainCount * 3);
        const rainNormals = new Float32Array(rainCount * 3);
        const rainVelocities = new Float32Array(rainCount);
        const rainOffsets = new Float32Array(rainCount);

        for (let i = 0; i < rainCount; i++) {
            rainPositions[i * 3] = (Math.random() - 0.5) * 100;
            rainPositions[i * 3 + 1] = 20 + Math.random() * 30;
            rainPositions[i * 3 + 2] = (Math.random() - 0.5) * 100;
            rainNormals[i * 3] = 0; rainNormals[i * 3 + 1] = 1; rainNormals[i * 3 + 2] = 0;
            rainVelocities[i] = 5 + Math.random() * 5;
            rainOffsets[i] = Math.random() * 50;
        }

        rainGeo.setAttribute('position', new BufferAttribute(rainPositions, 3));
        rainGeo.setAttribute('normal', new BufferAttribute(rainNormals, 3));
        rainGeo.userData = { velocities: rainVelocities, offsets: rainOffsets };

        const rainMat = new PointsMaterial({
            color: 0x88CCFF,
            size: 0.3,
            transparent: true,
            opacity: 0.8,
            blending: AdditiveBlending
        });

        this.percussionRain = new Points(rainGeo, rainMat);
        this.percussionRain.visible = false;
        this.scene.add(this.percussionRain);

        const mistCount = 300;
        const mistGeo = new BufferGeometry();
        const mistPositions = new Float32Array(mistCount * 3);
        const mistNormals = new Float32Array(mistCount * 3);

        for (let i = 0; i < mistCount; i++) {
            mistPositions[i * 3] = (Math.random() - 0.5) * 80;
            mistPositions[i * 3 + 1] = Math.random() * 5;
            mistPositions[i * 3 + 2] = (Math.random() - 0.5) * 80;
            mistNormals[i * 3] = 0; mistNormals[i * 3 + 1] = 1; mistNormals[i * 3 + 2] = 0;
        }

        mistGeo.setAttribute('position', new BufferAttribute(mistPositions, 3));
        mistGeo.setAttribute('normal', new BufferAttribute(mistNormals, 3));

        const mistMat = new PointsMaterial({
            color: 0xAAFFAA,
            size: 0.15,
            transparent: true,
            opacity: 0.4,
            blending: AdditiveBlending
        });

        this.melodicMist = new Points(mistGeo, mistMat);
        this.melodicMist.visible = false;
        this.scene.add(this.melodicMist);
    }

    registerMushroom(mushroom) {
        if (!mushroom) return;
        if (!this.trackedMushrooms.includes(mushroom)) this.trackedMushrooms.push(mushroom);
    }

    registerCave(cave) {
        if (!this.trackedCaves.includes(cave)) {
            this.trackedCaves.push(cave);
        }
    }

    initLightning() {
        this.lightningLight = new PointLight(0xFFFFFF, 0, 200);
        this.lightningLight.position.set(0, 50, 0);
        this.scene.add(this.lightningLight);
    }

    registerTree(tree) { this.trackedTrees.push(tree); }
    registerShrub(shrub) { this.trackedShrubs.push(shrub); }
    registerFlower(flower) { this.trackedFlowers.push(flower); }

    notifyCloudShot(isDaytime) {
        this.cloudDensity = Math.max(0.2, this.cloudDensity - 0.05);
    }

    getGlobalLightLevel(celestial, seasonal) {
        const sun = celestial.sunIntensity * (seasonal ? seasonal.sunInclination : 1.0);
        const moon = celestial.moonIntensity * (seasonal ? seasonal.moonPhase : 1.0) * 0.25;
        const stars = 0.05;
        const cloudCover = this.cloudDensity;
        const totalLight = (sun + moon + stars) * (1.0 - (cloudCover * 0.8));
        return Math.min(1.0, totalLight);
    }

    update(time, audioData, cycleWeatherBias = null) {
        if (!audioData) return;
        const dt = 0.016;

        this.cloudDensity = Math.min(1.0, this.cloudDensity + this.cloudRegenRate);

        const bassIntensity = audioData.kickTrigger || 0;
        const groove = audioData.grooveAmount || 0;
        const channels = audioData.channelData || [];
        const melodyVol = channels[2]?.volume || 0;
        const celestial = getCelestialState(time); 
        const seasonal = getSeasonalState(time);
        this.currentSeason = seasonal.season;

        const currentPattern = audioData.patternIndex || 0;
        if (currentPattern !== this.lastPatternIndex) {
            this.lastPatternIndex = currentPattern;
        }

        this.updateWeatherState(bassIntensity, melodyVol, groove, cycleWeatherBias, seasonal);

        // --- Ground Water Update ---
        if (this.state === WeatherState.RAIN) {
            this.groundWaterLevel = Math.min(1.0, this.groundWaterLevel + 0.0005);
        } else if (this.state === WeatherState.STORM) {
            this.groundWaterLevel = Math.min(1.0, this.groundWaterLevel + 0.0015);
        } else {
            this.groundWaterLevel = Math.max(0.0, this.groundWaterLevel - 0.0003);
        }

        // Update Caves
        if (this.trackedCaves.length > 0) {
            this.trackedCaves.forEach(cave => {
                updateCaveWaterLevel(cave, this.groundWaterLevel);
            });
        }
        // ---------------------------

        if (this.lastState === WeatherState.STORM && this.state !== WeatherState.STORM) {
            this.rainbowTimer = 45.0;
        }
        this.lastState = this.state;

        if (this.rainbowTimer > 0) {
            this.rainbowTimer -= dt;
            let opacity = 1.0;
            if (this.rainbowTimer > 40.0) opacity = (45.0 - this.rainbowTimer) / 5.0;
            else if (this.rainbowTimer < 5.0) opacity = this.rainbowTimer / 5.0;
            uRainbowOpacity.value = opacity * 0.6;
        } else {
            uRainbowOpacity.value = 0.0;
        }

        this.currentLightLevel = this.getGlobalLightLevel(celestial, seasonal);
        this.targetIntensity *= this.cloudDensity;

        const highVol = channels[3]?.volume || 0;
        const rainbowTarget = (melodyVol * 0.5 + highVol * 0.5) * this.cloudDensity;
        try { if(uCloudRainbowIntensity) uCloudRainbowIntensity.value += (rainbowTarget - uCloudRainbowIntensity.value) * 0.05; } catch(e) {}

        if (this.state === WeatherState.STORM && (bassIntensity > 0.8 || Math.random() < 0.01)) {
            try { if(uCloudLightningStrength) uCloudLightningStrength.value = 1.0; } catch(e) {}
            
            const paletteKeys = Object.keys((CONFIG.noteColorMap && CONFIG.noteColorMap.cloud) || {});
            if (paletteKeys.length > 0) {
                const randomKey = paletteKeys[Math.floor(Math.random() * paletteKeys.length)];
                const colorHex = CONFIG.noteColorMap.cloud[randomKey];
                try { if (uCloudLightningColor && uCloudLightningColor.value && uCloudLightningColor.value.setHex) uCloudLightningColor.value.setHex(colorHex); } catch(e) {}
                this.lightningLight.color.setHex(colorHex);
                this.lightningLight.intensity = 10 * this.cloudDensity;
                this.lightningLight.position.set((Math.random()-0.5)*100, 50, (Math.random()-0.5)*100);
                this.lightningActive = true;
            }
        } else {
            try { if(uCloudLightningStrength) uCloudLightningStrength.value *= 0.85; } catch(e) {}
            if (this.lightningActive) {
                this.lightningLight.intensity *= 0.85;
                if (this.lightningLight.intensity < 0.1) this.lightningActive = false;
            }
        }

        this.applyDarknessLogic(celestial, seasonal.moonPhase);

        const sunPower = celestial.sunIntensity * (1.0 - this.cloudDensity * 0.7);
        const moonPower = celestial.moonIntensity * 0.3;
        const globalLight = Math.max(0, sunPower + moonPower);
        const moisture = this.intensity + (this.stormCharge * 0.5);

        let floraFavorability = globalLight * (0.5 + moisture);
        if (moisture > 0.9) floraFavorability *= 0.5;

        let fungiFavorability = (1.0 - globalLight) * (0.2 + moisture * 1.5);
        let lanternFavorability = (this.state === WeatherState.STORM ? 1.0 : 0.0) + (1.0 - globalLight) * 0.2;

        if (this.percussionRain.visible) {
            if (this.trackedTrees.length > 0) {
                triggerGrowth(this.trackedTrees, floraFavorability * bassIntensity * 0.1);
            }
            if (this.trackedFlowers.length > 0) {
                triggerGrowth(this.trackedFlowers, floraFavorability * bassIntensity * 0.1);
            }
            if (this.trackedMushrooms.length > 0) {
                triggerGrowth(this.trackedMushrooms, fungiFavorability * bassIntensity * 0.15);
            }
        }

        this.handleSpawning(time, fungiFavorability, lanternFavorability, globalLight);
        this.updateMushroomWaterfalls(time, bassIntensity);

        this.intensity += (this.targetIntensity - this.intensity) * this.transitionSpeed;

        this.updatePercussionRain(time, bassIntensity);
        this.updateMelodicMist(time, melodyVol);

        if (this.state === WeatherState.STORM) {
            this.updateLightning(time, bassIntensity);
            this.chargeBerryGlow(bassIntensity);
        }

        if (this.state !== WeatherState.CLEAR) {
            this.stormCharge = Math.min(2.0, this.stormCharge + 0.001);
        } else {
            this.stormCharge = Math.max(0, this.stormCharge - 0.0005);
        }

        this.updateWind(time, audioData, celestial);
        this.updateFog(audioData);
    }

    handleSpawning(time, fungiScore, lanternScore, globalLight) {
        if (time - this._lastSpawnCheck < this._spawnThrottle) return;
        this._lastSpawnCheck = time;

        if (fungiScore > 0.8) {
            if (Math.random() < 0.4) this.spawnFoliage('mushroom', true);
        }
        if (lanternScore > 0.6) {
            if (Math.random() < 0.3) this.spawnFoliage('lantern', false);
        }
        if (globalLight > 0.7 && fungiScore < 0.3) {
             if (Math.random() < 0.2) this.spawnFoliage('flower', false);
        }
    }

    spawnFoliage(type, isGlowing) {
        if (!this.onSpawnFoliage) return;

        const x = (Math.random() - 0.5) * 60;
        const z = (Math.random() - 0.5) * 60;
        const y = getGroundHeight(x, z);

        let object;
        if (type === 'mushroom') {
            object = createMushroom({
                size: 'regular',
                scale: 0.5 + Math.random() * 0.5,
                isBioluminescent: isGlowing
            });
        } else if (type === 'lantern') {
            object = createLanternFlower({
                height: 2.0 + Math.random() * 1.5,
                color: 0xFFaa00
            });
        }

        if (object) {
            object.position.set(x, y, z);
            object.scale.setScalar(0.01);
            this.onSpawnFoliage(object, true, 0);
            if (type === 'mushroom') this.registerMushroom(object);
            if (type === 'lantern') this.registerFlower(object);
        }
    }

    updateWind(time, audioData, celestial) {
        const channels = audioData.channelData || [];
        const highFreqVol = channels[3]?.volume || 0;
        const melodyVol = channels[2]?.volume || 0;

        this.windTargetSpeed = Math.max(highFreqVol, melodyVol * 0.5);
        this.windSpeed += (this.windTargetSpeed - this.windSpeed) * 0.02;

        const rotSpeed = (audioData.beatPhase || 0) * 0.001;
        this.windDirection.applyAxisAngle(_UP, rotSpeed);

        const dayProgress = (time % CYCLE_DURATION) / CYCLE_DURATION;
        const sunAngle = dayProgress * Math.PI * 2;
        _scratchSunDir.set(Math.cos(sunAngle), Math.sin(sunAngle), 0);
        _scratchCelestialForce.copy(_scratchSunDir).negate();
        this.windDirection.lerp(_scratchCelestialForce, 0.1);
        this.windDirection.normalize();

        let giantsX = 0, giantsZ = 0, giantsCount = 0;
        this.trackedMushrooms.forEach(m => {
            if (m.userData.size === 'giant') {
                giantsX += m.position.x;
                giantsZ += m.position.z;
                giantsCount++;
            }
        });

        if (giantsCount > 0) {
            const centerX = giantsX / giantsCount;
            const centerZ = giantsZ / giantsCount;
            _scratchAttraction.set(centerX, 0, centerZ).normalize();
            this.windDirection.lerp(_scratchAttraction, 0.05);
            this.windDirection.normalize();
        }

        const count = this.trackedMushrooms.length;
        if (this.windSpeed > 0.4 && count > 0) {
            const now = time;
            if (now - this._lastSpawnCheck > this._spawnThrottle) {
                this._lastSpawnCheck = now;

                if (!isWasmReady() || typeof batchMushroomSpawnCandidates !== 'function') {
                    let spawned = 0;
                    for (let i = 0; i < this.trackedMushrooms.length && spawned < this._spawnCapPerFrame; i++) {
                        const m = this.trackedMushrooms[i];
                        const colorIndex = m.userData?.colorIndex ?? -1;
                        const colorWeight = (colorIndex >= 0 && colorIndex <= 3) ? 0.02 : 0.005;
                        const spawnChance = colorWeight * this.windSpeed;
                        if (Math.random() < spawnChance) {
                            const distance = 3 + Math.random() * 8;
                            const jitter = 2 + Math.random() * 3;
                            const nx = m.position.x + this.windDirection.x * distance + (Math.random() - 0.5) * jitter;
                            const nz = m.position.z + this.windDirection.z * distance + (Math.random() - 0.5) * jitter;
                            const ny = getGroundHeight(nx, nz);
                            const newM = createMushroom({ size: 'regular', scale: 0.7, colorIndex: colorIndex });
                            newM.position.set(nx, ny, nz);
                            newM.rotation.y = Math.random() * Math.PI * 2;
                            if (this.onSpawnFoliage) {
                                try { this.onSpawnFoliage(newM, true, 0.5); } catch (e) {}
                            } else {
                                this.scene.add(newM);
                                this.registerMushroom(newM);
                            }
                            spawned++;
                        }
                    }
                } else {
                    try {
                        uploadMushroomSpecs(this.trackedMushrooms);
                        const spawnThreshold = 1.0;
                        const minDistance = 3.0;
                        const maxDistance = 8.0;
                        const candidateCount = batchMushroomSpawnCandidates(time, this.windDirection.x, this.windDirection.z, this.windSpeed, count, spawnThreshold, minDistance, maxDistance);
                        if (candidateCount > 0) {
                            const candidates = readSpawnCandidates(candidateCount);
                            let spawned = 0;
                            for (const c of candidates) {
                                if (spawned >= this._spawnCapPerFrame) break;
                                const newM = createMushroom({ size: 'regular', scale: 0.7, colorIndex: c.colorIndex });
                                newM.position.set(c.x, c.y, c.z);
                                newM.rotation.y = Math.random() * Math.PI * 2;
                                if (this.onSpawnFoliage) {
                                    try { this.onSpawnFoliage(newM, true, 0.5); } catch (e) {}
                                } else {
                                    this.scene.add(newM);
                                    this.registerMushroom(newM);
                                }
                                spawned++;
                            }
                        }
                    } catch (e) {
                        console.warn('WASM spawn path failed, falling back to JS:', e);
                    }
                }
            }
        }
    }

    updateMushroomWaterfalls(time, bassIntensity) {
        const isRaining = this.state !== WeatherState.CLEAR && this.intensity > 0.4;
        
        this.trackedMushrooms.forEach(mushroom => {
            if (mushroom.userData.size === 'giant') {
                const uuid = mushroom.uuid;
                
                if (isRaining) {
                    if (!this.mushroomWaterfalls.has(uuid)) {
                        const radius = mushroom.userData.capRadius || 5.0;
                        const height = mushroom.userData.capHeight || 8.0;
                        
                        const wf = createWaterfall(
                            new Vector3(mushroom.position.x + radius * 0.8, height * 0.8, mushroom.position.z),
                            new Vector3(mushroom.position.x + radius * 1.1, 0, mushroom.position.z),
                            2.0
                        );
                        
                        this.scene.add(wf);
                        this.mushroomWaterfalls.set(uuid, wf);
                    }
                    const wf = this.mushroomWaterfalls.get(uuid);
                    if (wf.onAnimate) wf.onAnimate(0.016, time);
                    if (bassIntensity > 0.5) wf.scale.setScalar(1.0 + bassIntensity * 0.1);
                } else {
                    if (this.mushroomWaterfalls.has(uuid)) {
                        const wf = this.mushroomWaterfalls.get(uuid);
                        this.scene.remove(wf);
                        this.mushroomWaterfalls.delete(uuid);
                    }
                }
            }
        });
    }

    applyDarknessLogic(celestial, moonPhase) {
        const nightFactor = celestial.moonIntensity; 
        const densityFactor = this.cloudDensity;     
        const moonDarkness = 1.0 - (moonPhase || 0) * 0.5;
        const darkness = nightFactor * densityFactor * moonDarkness * 0.95; 

        if (this.scene.fog && this.scene.fog.color) {
            this.scene.fog.color.lerp(_scratchBlack, darkness);
        }
        uSkyDarkness.value = darkness;
        this.darknessFactor = darkness; 
    }

    updateFog(audioData) {
        if (!this.fog) return;

        let fogMultiplier = 1.0;
        switch (this.state) {
            case WeatherState.RAIN: fogMultiplier = 0.8; break;
            case WeatherState.STORM: fogMultiplier = 0.6; break;
            default: fogMultiplier = 1.0;
        }

        let crescendoFactor = 0;
        if (audioData) {
            const volume = audioData.average || 0;
            crescendoFactor = volume * 0.3;
        }

        const weatherVisibility = (1.0 - this.intensity * (1.0 - fogMultiplier));
        const darknessVisibility = (1.0 - (this.darknessFactor || 0) * 0.7);
        const crescendoVisibility = (1.0 - crescendoFactor);

        const totalVisibility = weatherVisibility * darknessVisibility * crescendoVisibility;

        const targetNear = this.baseFogNear * totalVisibility;
        const targetFar = this.baseFogFar * totalVisibility;

        this.fog.near += (targetNear - this.fog.near) * 0.05;
        this.fog.far += (targetFar - this.fog.far) * 0.05;
    }

    updateBerrySeasonalSize(cyclePos, CYCLE_DURATION) {
        const SUNRISE = 60, DAY = 420, SUNSET = 60, DUSK = 180, DEEP = 120, PREDAWN = 120;
        let phase = 'day';
        let phaseProgress = 0;

        if (cyclePos < SUNRISE) {
            phase = 'sunrise';
            phaseProgress = cyclePos / SUNRISE;
        } else if (cyclePos < SUNRISE + DAY) {
            phase = 'day';
            phaseProgress = (cyclePos - SUNRISE) / DAY;
        } else if (cyclePos < SUNRISE + DAY + SUNSET) {
            phase = 'sunset';
            phaseProgress = (cyclePos - SUNRISE - DAY) / SUNSET;
        } else if (cyclePos < SUNRISE + DAY + SUNSET + DUSK) {
            phase = 'dusk';
            phaseProgress = (cyclePos - SUNRISE - DAY - SUNSET) / DUSK;
        } else if (cyclePos < SUNRISE + DAY + SUNSET + DUSK + DEEP) {
            phase = 'deepNight';
            phaseProgress = (cyclePos - SUNRISE - DAY - SUNSET - DUSK) / DEEP;
        } else {
            phase = 'preDawn';
            phaseProgress = (cyclePos - SUNRISE - DAY - SUNSET - DUSK - DEEP) / PREDAWN;
        }

        this.trackedTrees.forEach(tree => {
            if (tree.userData.berries) updateBerrySeasons(tree.userData.berries, phase, phaseProgress);
        });
        this.trackedShrubs.forEach(shrub => {
            if (shrub.userData.berries) updateBerrySeasons(shrub.userData.berries, phase, phaseProgress);
        });
    }

    updateWeatherState(bass, melody, groove, cycleWeatherBias = null, seasonal = null) {
        let audioState = WeatherState.CLEAR;
        let audioIntensity = 0;
        
        if (bass > 0.7 && groove > 0.5) {
            audioState = WeatherState.STORM;
            audioIntensity = 1.0;
        } else if (bass > 0.3 || melody > 0.4) {
            audioState = WeatherState.RAIN;
            audioIntensity = 0.5;
        }

        if (seasonal) {
            const r = Math.random();
            if (seasonal.season === 'Winter') {
                if (audioState === WeatherState.STORM && r > 0.3) audioState = WeatherState.RAIN;
            }
            if (seasonal.season === 'Summer') {
                if (audioState === WeatherState.RAIN && r > 0.7) audioState = WeatherState.STORM;
            }
            if (seasonal.season === 'Spring') {
                if (audioState === WeatherState.CLEAR && r > 0.9) {
                    audioState = WeatherState.RAIN;
                    audioIntensity = 0.3;
                }
            }
        }

        if (cycleWeatherBias) {
            const biasWeight = 0.4;
            let biasState = WeatherState.CLEAR;
            if (cycleWeatherBias.biasState === 'storm') biasState = WeatherState.STORM;
            else if (cycleWeatherBias.biasState === 'rain') biasState = WeatherState.RAIN;

            if (audioState !== biasState) {
                if (Math.random() < biasWeight) { this.state = biasState; this.targetIntensity = cycleWeatherBias.biasIntensity; }
                else { this.state = audioState; this.targetIntensity = audioIntensity; }
            } else {
                this.state = audioState;
                this.targetIntensity = audioIntensity * (1 - biasWeight) + cycleWeatherBias.biasIntensity * biasWeight;
            }
            this.weatherType = cycleWeatherBias.type || 'default';
        } else {
            this.state = audioState;
            this.targetIntensity = audioIntensity;
            this.weatherType = 'audio';
        }
    }

    updatePercussionRain(time, bassIntensity) {
        const shouldShow = bassIntensity > 0.2 || this.state !== WeatherState.CLEAR;
        this.percussionRain.visible = shouldShow;

        if (!shouldShow) return;

        const positions = this.percussionRain.geometry.attributes.position.array;
        const velocities = this.percussionRain.geometry.userData.velocities;
        const offsets = this.percussionRain.geometry.userData.offsets;

        this.percussionRain.material.size = 0.3 + bassIntensity * 0.5;
        this.percussionRain.material.opacity = 0.4 + this.intensity * 0.6;
        
        if (this.weatherType === 'mist') {
            this.percussionRain.material.color.setHex(0xE0F4FF);
        } else if (this.weatherType === 'drizzle') {
            this.percussionRain.material.color.setHex(0x9AB5C8);
        } else if (this.weatherType === 'thunderstorm' || this.state === WeatherState.STORM) {
            this.percussionRain.material.color.setHex(0x6090B0);
        } else {
            this.percussionRain.material.color.setHex(0x88CCFF);
        }

        for (let i = 0; i < positions.length / 3; i++) {
            const startY = 50 + offsets[i];
            const speed = velocities[i] * (1 + bassIntensity);
            const newY = calcRainDropY(startY, time, speed, 50);
            positions[i * 3 + 1] = newY;
            if (newY < 0) {
                positions[i * 3] = (Math.random() - 0.5) * 100;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 100;
            }
        }
        this.percussionRain.geometry.attributes.position.needsUpdate = true;
    }

    updateMelodicMist(time, melodyVol) {
        const shouldShow = melodyVol > 0.2 || (this.weatherType === 'mist' && this.state === WeatherState.RAIN);
        this.melodicMist.visible = shouldShow;

        if (!shouldShow) return;

        const positions = this.melodicMist.geometry.attributes.position.array;
        for (let i = 0; i < positions.length / 3; i++) {
            const offset = i * 0.1;
            positions[i * 3 + 1] = 1 + Math.sin(time + offset) * 2 * Math.max(melodyVol, 0.3);
            positions[i * 3] += Math.sin(time * 0.5 + offset) * 0.01;
            positions[i * 3 + 2] += Math.cos(time * 0.4 + offset) * 0.01;
        }

        this.melodicMist.material.opacity = 0.3 + melodyVol * 0.4;
        
        if (this.weatherType === 'mist') {
            this.melodicMist.material.color.setHex(0xDDFFDD);
            this.melodicMist.material.opacity = 0.6;
        } else {
            this.melodicMist.material.color.setHex(0xAAFFAA);
        }
        this.melodicMist.geometry.attributes.position.needsUpdate = true;
    }

    updateLightning(time, bassIntensity) {
        this.lightningTimer -= 0.016;

        if (bassIntensity > 0.8 && this.lightningTimer <= 0 && Math.random() > 0.7) {
            this.lightningActive = true;
            this.lightningTimer = 0.5 + Math.random() * 1.0;
            this.lightningLight.intensity = 5 + Math.random() * 5;
            this.lightningLight.position.set(
                (Math.random() - 0.5) * 60,
                40 + Math.random() * 20,
                (Math.random() - 0.5) * 60
            );
        }

        if (this.lightningActive) {
            this.lightningLight.intensity *= 0.85;
            if (this.lightningLight.intensity < 0.1) {
                this.lightningActive = false;
                this.lightningLight.intensity = 0;
            }
        }
    }

    chargeBerryGlow(bassIntensity) {
        const chargeAmount = bassIntensity * 0.05;
        this.trackedTrees.forEach(tree => { if (tree.userData.berries) chargeBerries(tree.userData.berries, chargeAmount); });
        this.trackedShrubs.forEach(shrub => { if (shrub.userData.berries) chargeBerries(shrub.userData.berries, chargeAmount); });

        if (bassIntensity > 0.6) {
            this.trackedTrees.forEach(tree => { if (tree.userData.berries) shakeBerriesLoose(tree.userData.berries, bassIntensity); });
            this.trackedShrubs.forEach(shrub => { if (shrub.userData.berries) shakeBerriesLoose(shrub.userData.berries, bassIntensity); });
        }
    }

    growPlants(intensity) {
        triggerGrowth(this.trackedTrees, intensity);
        triggerGrowth(this.trackedMushrooms, intensity);
    }
    bloomFlora(intensity) {
        triggerBloom(this.trackedFlowers, intensity);
    }
    getState() { return this.state; }
    getStormCharge() { return this.stormCharge; }
    getIntensity() { return this.intensity; }

    forceState(state) {
        this.state = state;
        switch (state) {
            case WeatherState.STORM: this.targetIntensity = 1.0; break;
            case WeatherState.RAIN: this.targetIntensity = 0.5; break;
            default: this.targetIntensity = 0;
        }
    }

    dispose() {
        if (this.percussionRain) {
            this.scene.remove(this.percussionRain);
            this.percussionRain.geometry.dispose();
            this.percussionRain.material.dispose();
        }
        if (this.melodicMist) {
            this.scene.remove(this.melodicMist);
            this.melodicMist.geometry.dispose();
            this.melodicMist.material.dispose();
        }
        if (this.lightningLight) {
            this.scene.remove(this.lightningLight);
        }
        if (this.rainbow) {
            this.scene.remove(this.rainbow);
            this.rainbow.geometry.dispose();
        }
        if (this.mushroomWaterfalls && this.mushroomWaterfalls.size > 0) {
            this.mushroomWaterfalls.forEach(wf => {
                this.scene.remove(wf);
            });
            this.mushroomWaterfalls.clear();
        }
    }
}

class Profiler {
    constructor() {
        this.enabled = false;
        this.measures = new Map(); // label -> duration
        this.frameStart = 0;
        this.frameHistory = [];

        // Config
        this.logThresholdMs = 34; // Log if frame > 34ms (~30fps)
        this.maxBars = 10;

        // UI
        this.canvas = document.createElement('canvas');
        this.canvas.style.cssText = 'position:fixed; bottom:10px; right:10px; z-index:9999; pointer-events:none; display:none; background:rgba(0,0,0,0.8); border-radius:8px;';
        this.canvas.width = 300;
        this.canvas.height = 200;
        document.body.appendChild(this.canvas);
        this.ctx = this.canvas.getContext('2d');
    }

    toggle() {
        this.enabled = !this.enabled;
        this.canvas.style.display = this.enabled ? 'block' : 'none';
        console.log(`[Profiler] ${this.enabled ? 'Enabled' : 'Disabled'}`);
    }

    startFrame() {
        if (!this.enabled) return;
        this.measures.clear();
        this.frameStart = performance.now();
    }

    /**
     * Measure a synchronous function
     */
    measure(label, fn) {
        if (!this.enabled) return fn();

        const start = performance.now();
        const result = fn();
        const end = performance.now();

        const duration = end - start;
        const existing = this.measures.get(label) || 0;
        this.measures.set(label, existing + duration);

        return result;
    }

    endFrame() {
        if (!this.enabled) return;

        const totalTime = performance.now() - this.frameStart;

        // Lag Spike Logger
        if (totalTime > this.logThresholdMs) {
            console.warn(` LAG SPIKE: ${totalTime.toFixed(1)}ms`);
            const sorted = [...this.measures.entries()].sort((a,b) => b[1] - a[1]);
            console.table(sorted.map(([name, time]) => ({
                System: name,
                'Time (ms)': time.toFixed(2),
                '% of Frame': ((time/totalTime)*100).toFixed(1) + '%'
            })));
        }

        this.drawUI(totalTime);
    }

    drawUI(totalTime) {
        const ctx = this.ctx;
        const w = this.canvas.width;
        const h = this.canvas.height;

        // Clear
        ctx.clearRect(0, 0, w, h);

        // Title
        ctx.fillStyle = '#fff';
        ctx.font = '12px monospace';
        ctx.fillText(`Frame: ${totalTime.toFixed(1)}ms (${(1000/totalTime).toFixed(0)} FPS)`, 10, 20);

        // Draw Bars
        let y = 40;
        const maxBarWidth = w - 20;
        const sorted = [...this.measures.entries()].sort((a,b) => b[1] - a[1]);

        sorted.forEach(([label, time]) => {
            if (y > h - 10) return;

            const percent = Math.min(time / totalTime, 1.0);
            const barWidth = Math.max(1, percent * maxBarWidth);

            // Color coding
            if (time > 10) ctx.fillStyle = '#ff4444'; // Red if > 10ms
            else if (time > 4) ctx.fillStyle = '#ffbb33'; // Orange
            else ctx.fillStyle = '#00C851'; // Green

            ctx.fillRect(10, y, barWidth, 14);

            // Text Label
            ctx.fillStyle = '#fff';
            ctx.fillText(`${label}: ${time.toFixed(1)}ms`, 14, y + 11);

            y += 20;
        });
    }
}

const profiler = new Profiler();

let isAvailable = ( typeof navigator !== 'undefined'  && navigator.gpu !== undefined );

if ( typeof window !== 'undefined' && isAvailable ) {

	isAvailable = await navigator.gpu.requestAdapter();

}

class WebGPU {

	static isAvailable() {

		return Boolean( isAvailable );

	}

	static getStaticAdapter() {

		return isAvailable;

	}

	static getErrorMessage() {

		const message = 'Your browser does not support <a href="https://gpuweb.github.io/gpuweb/" style="color:blue">WebGPU</a> yet';

		const element = document.createElement( 'div' );
		element.id = 'webgpumessage';
		element.style.fontFamily = 'monospace';
		element.style.fontSize = '13px';
		element.style.fontWeight = 'normal';
		element.style.textAlign = 'center';
		element.style.background = '#fff';
		element.style.color = '#000';
		element.style.padding = '1.5em';
		element.style.maxWidth = '400px';
		element.style.margin = '5em auto 0';

		element.innerHTML = message;

		return element;

	}

}

// src/utils/debug-helpers.js


/**
 * Recursively checks if a value is a valid TSL Node.
 */
function isValidTSLNode(node) {
    if (node === undefined || node === null) return true; // Optional nodes are fine
    if (typeof node === 'number') return true; // TSL handles raw numbers
    if (node.isNode === true) return true; 
    if (typeof node.build === 'function') return true; // Proxy nodes
    if (node.isVector2 || node.isVector3 || node.isColor) return true; 
    return false;
}

/**
 * Validates a single material.
 */
function validateMaterial(mat, objName) {
    if (!mat || !mat.isNodeMaterial) return [];
    
    const errors = [];
    const criticalProps = [
        'positionNode', 'colorNode', 'normalNode', 
        'roughnessNode', 'metalnessNode', 'emissiveNode'
    ];

    criticalProps.forEach(prop => {
        const node = mat[prop];
        if (node !== undefined && node !== null) {
            // Check for plain objects that aren't nodes
            if (typeof node === 'object' && !isValidTSLNode(node)) {
                errors.push(`[${objName}] material.${prop} is invalid (Found Object/Array but not Node).`);
            }
            // Check for NaN
            if (typeof node === 'number' && isNaN(node)) {
                errors.push(`[${objName}] material.${prop} is NaN.`);
            }
        }
    });
    return errors;
}

/**
 * Scans the entire scene for TSL errors.
 * Call this from the browser console via: window.debugScene()
 */
function validateSceneMaterials(scene) {
    console.group(" [Debug] Validating Scene Materials...");
    let issuesFound = 0;
    const errors = [];

    scene.traverse((obj) => {
        if (!obj.isMesh && !obj.isPoints) return;
        
        const mat = obj.material;
        if (Array.isArray(mat)) {
            mat.forEach((m, i) => {
                const errs = validateMaterial(m, `${obj.name || obj.type}[${i}]`);
                errors.push(...errs);
            });
        } else {
            const errs = validateMaterial(mat, obj.name || obj.type);
            errors.push(...errs);
        }
    });

    if (errors.length === 0) {
        console.log(" No obvious TSL structure errors found.");
    } else {
        console.warn(` Found ${errors.length} issues:`);
        errors.forEach(e => console.error(e));
        issuesFound = errors.length;
    }
    console.groupEnd();
    return issuesFound;
}

/**
 * Patches the renderer to expose debug tools to window.
 */
function enableRendererDebug(renderer, scene) {
    renderer.debug.checkShaderErrors = true;
    
    // Expose tools to global window scope for console access
    window.renderer = renderer;
    window.scene = scene;
    
    window.debugScene = () => {
        {
            console.error("Scene not captured. Pass scene to enableRendererDebug.");
            return;
        }
    };

    console.log(" [Debug] Tools enabled. Run 'window.debugScene()' in console to scan materials.");
}

// src/core/init.js


function initScene() {
    const canvas = document.querySelector('#glCanvas');
    const scene = new Scene();
    scene.fog = new Fog(PALETTE.day.fog, 20, 100);

    const camera = new PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
    camera.position.set(0, 5, 0);

    if (!WebGPU.isAvailable()) {
        const warning = WebGPU.getErrorMessage();
        document.body.appendChild(warning);
        throw new Error('WebGPU not supported');
    }

    const renderer = new WebGPURenderer({ canvas, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
    renderer.toneMapping = ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;

    // --- ENABLE DEBUGGING ---
    enableRendererDebug(renderer);
    // ------------------------

    // --- Lighting ---
    const ambientLight = new HemisphereLight(PALETTE.day.skyTop, CONFIG.colors.ground, 1.1);
    scene.add(ambientLight);

    const sunLight = new DirectionalLight(PALETTE.day.sun, 0.9);
    sunLight.position.set(50, 80, 30);
    sunLight.castShadow = true;
    sunLight.shadow.mapSize.width = 1024;
    sunLight.shadow.mapSize.height = 1024;
    scene.add(sunLight);

    // Enhanced Sun Glow with dynamic corona effect
    const sunGlowMat = new MeshBasicMaterial({
        color: 0xFFE599,  // Warmer golden glow
        transparent: true,
        opacity: 0.25,
        blending: AdditiveBlending,
        side: DoubleSide,
        depthWrite: false
    });
    const sunGlow = new Mesh(new PlaneGeometry(80, 80), sunGlowMat);
    sunGlow.position.copy(sunLight.position.clone().normalize().multiplyScalar(400));
    sunGlow.lookAt(0, 0, 0);
    scene.add(sunGlow);

    // Add additional corona layer for more dramatic effect
    const coronaMat = new MeshBasicMaterial({
        color: 0xFFF4D6,  // Soft cream white
        transparent: true,
        opacity: 0.15,
        blending: AdditiveBlending,
        side: DoubleSide,
        depthWrite: false
    });
    const sunCorona = new Mesh(new PlaneGeometry(150, 150), coronaMat);
    sunCorona.position.copy(sunLight.position.clone().normalize().multiplyScalar(390));
    sunCorona.lookAt(0, 0, 0);
    scene.add(sunCorona);

    // Add light shafts/god rays for sunrise/sunset drama
    const lightShaftGroup = new Group();
    const shaftCount = 12;
    const shaftGeometry = new PlaneGeometry(8, 200);
    const shaftMaterial = new MeshBasicMaterial({
        color: 0xFFE5A0,
        transparent: true,
        opacity: 0.0, // Will be animated
        blending: AdditiveBlending,
        side: DoubleSide,
        depthWrite: false
    });

    for (let i = 0; i < shaftCount; i++) {
        const shaft = new Mesh(shaftGeometry, shaftMaterial.clone());
        const angle = (i / shaftCount) * Math.PI * 2;
        shaft.rotation.z = angle;
        lightShaftGroup.add(shaft);
    }
    lightShaftGroup.position.copy(sunLight.position.clone().normalize().multiplyScalar(380));
    lightShaftGroup.visible = false; // Only visible during sunrise/sunset
    scene.add(lightShaftGroup);

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    return {
        scene,
        camera,
        renderer,
        ambientLight,
        sunLight,
        sunGlow,
        sunCorona,
        lightShaftGroup,
        sunGlowMat,
        coronaMat
    };
}

async function forceFullSceneWarmup(renderer, scene, camera) {
    console.log(" [Warmup] Starting scene compilation...");
    
    // 1. RUN VALIDATION BEFORE RENDER ATTEMPT
    validateSceneMaterials(scene);

    // 2. Save state
    const originalMask = camera.layers.mask;
    const originalPos = camera.position.clone();
    const originalRot = camera.rotation.clone();
    const originalAutoClear = renderer.autoClear;

    // 3. Force visibility
    const restoreList = [];
    scene.traverse((obj) => {
        if (obj.isMesh && obj.frustumCulled) {
            obj.frustumCulled = false;
            restoreList.push(obj);
        }
    });

    // 4. Render 1x1 pixel frame (SAFE WRAP)
    const scissor = new Vector4();
    renderer.getViewport(scissor);
    renderer.setViewport(0, 0, 1, 1);

    camera.layers.enableAll();
    camera.position.set(0, 50, 0);
    camera.lookAt(0,0,0);

    try {
        await renderer.compileAsync(scene, camera); // Try explicit compile first
        renderer.render(scene, camera);
        console.log(" [Warmup] Compilation successful.");
    } catch (e) { 
        console.error(" [Warmup] Critical Render Error during warmup!");
        console.error("This indicates a broken TSL shader graph in one of the materials.");
        console.error(e); 
    }

    // 5. Restore
    renderer.setViewport(scissor);
    restoreList.forEach(o => o.frustumCulled = true);
    camera.layers.mask = originalMask;
    camera.position.copy(originalPos);
    camera.rotation.copy(originalRot);
    renderer.autoClear = originalAutoClear;
    renderer.clear();
}

const _euler = new Euler( 0, 0, 0, 'YXZ' );
const _vector = new Vector3();

const _changeEvent = { type: 'change' };
const _lockEvent = { type: 'lock' };
const _unlockEvent = { type: 'unlock' };

const _PI_2 = Math.PI / 2;

class PointerLockControls extends Controls {

	constructor( camera, domElement = null ) {

		super( camera, domElement );

		this.isLocked = false;

		// Set to constrain the pitch of the camera
		// Range is 0 to Math.PI radians
		this.minPolarAngle = 0; // radians
		this.maxPolarAngle = Math.PI; // radians

		this.pointerSpeed = 1.0;

		// event listeners

		this._onMouseMove = onMouseMove.bind( this );
		this._onPointerlockChange = onPointerlockChange.bind( this );
		this._onPointerlockError = onPointerlockError.bind( this );

		if ( this.domElement !== null ) {

			this.connect();

		}

	}

	connect() {

		this.domElement.ownerDocument.addEventListener( 'mousemove', this._onMouseMove );
		this.domElement.ownerDocument.addEventListener( 'pointerlockchange', this._onPointerlockChange );
		this.domElement.ownerDocument.addEventListener( 'pointerlockerror', this._onPointerlockError );

	}

	disconnect() {

		this.domElement.ownerDocument.removeEventListener( 'mousemove', this._onMouseMove );
		this.domElement.ownerDocument.removeEventListener( 'pointerlockchange', this._onPointerlockChange );
		this.domElement.ownerDocument.removeEventListener( 'pointerlockerror', this._onPointerlockError );

	}

	dispose() {

		this.disconnect();

	}

	getObject() {

		console.warn( 'THREE.PointerLockControls: getObject() has been deprecated. Use controls.object instead.' ); // @deprecated r169

		return this.object;

	}

	getDirection( v ) {

		return v.set( 0, 0, -1 ).applyQuaternion( this.object.quaternion );

	}

	moveForward( distance ) {

		if ( this.enabled === false ) return;

		// move forward parallel to the xz-plane
		// assumes camera.up is y-up

		const camera = this.object;

		_vector.setFromMatrixColumn( camera.matrix, 0 );

		_vector.crossVectors( camera.up, _vector );

		camera.position.addScaledVector( _vector, distance );

	}

	moveRight( distance ) {

		if ( this.enabled === false ) return;

		const camera = this.object;

		_vector.setFromMatrixColumn( camera.matrix, 0 );

		camera.position.addScaledVector( _vector, distance );

	}

	lock() {

		this.domElement.requestPointerLock();

	}

	unlock() {

		this.domElement.ownerDocument.exitPointerLock();

	}

}

// event listeners

function onMouseMove( event ) {

	if ( this.enabled === false || this.isLocked === false ) return;

	const camera = this.object;
	_euler.setFromQuaternion( camera.quaternion );

	_euler.y -= event.movementX * 0.002 * this.pointerSpeed;
	_euler.x -= event.movementY * 0.002 * this.pointerSpeed;

	_euler.x = Math.max( _PI_2 - this.maxPolarAngle, Math.min( _PI_2 - this.minPolarAngle, _euler.x ) );

	camera.quaternion.setFromEuler( _euler );

	this.dispatchEvent( _changeEvent );

}

function onPointerlockChange() {

	if ( this.domElement.ownerDocument.pointerLockElement === this.domElement ) {

		this.dispatchEvent( _lockEvent );

		this.isLocked = true;

	} else {

		this.dispatchEvent( _unlockEvent );

		this.isLocked = false;

	}

}

function onPointerlockError() {

	console.error( 'THREE.PointerLockControls: Unable to use Pointer Lock API' );

}

const keyStates = {
    forward: false,
    backward: false,
    left: false,
    right: false,
    jump: false,
    sneak: false,
    sprint: false
};

// Controls and Event Listeners
function initInput(camera, audioSystem, toggleDayNightCallback) {
    const controls = new PointerLockControls(camera, document.body);
    const instructions = document.getElementById('instructions');
    const startButton = document.getElementById('startButton');
    
    // Playlist Elements
    const playlistOverlay = document.getElementById('playlist-overlay');
    const playlistList = document.getElementById('playlist-list');
    const closePlaylistBtn = document.getElementById('closePlaylistBtn');
    const playlistUploadInput = document.getElementById('playlistUploadInput');

    let isPlaylistOpen = false;

    // --- Helper: Render Playlist ---
    function renderPlaylist() {
        if (!playlistList) return;
        playlistList.innerHTML = '';
        const songs = audioSystem.getPlaylist();
        const currentIdx = audioSystem.getCurrentIndex();

        songs.forEach((file, index) => {
            const li = document.createElement('li');
            li.className = `playlist-item ${index === currentIdx ? 'active' : ''}`;

            // UX: Use a button for keyboard accessibility
            const btn = document.createElement('button');
            btn.className = 'playlist-btn';
            btn.setAttribute('aria-label', `Play ${file.name}`);
            if (index === currentIdx) {
                btn.setAttribute('aria-current', 'true');
            }

            btn.innerHTML = `
                <span class="song-title">${index + 1}. ${file.name}</span>
                <span class="status-icon" aria-hidden="true">${index === currentIdx ? '' : ''}</span>
            `;

            btn.onclick = (e) => {
                // Prevent bubbling if needed, though li has no click handler now
                e.stopPropagation();
                audioSystem.playAtIndex(index);
                renderPlaylist(); // Re-render to update active state

                // Keep focus on the clicked item (re-rendered)
                // We need to find the new button after render
                requestAnimationFrame(() => {
                    const newItems = playlistList.querySelectorAll('.playlist-btn');
                    if (newItems[index]) newItems[index].focus();
                });
            };

            li.appendChild(btn);
            playlistList.appendChild(li);
        });
        
        if (songs.length === 0) {
            // UX: Make Empty State Actionable
            const li = document.createElement('li');
            li.style.listStyle = 'none';
            li.style.padding = '20px 0';
            li.style.textAlign = 'center';

            const emptyBtn = document.createElement('button');
            emptyBtn.className = 'secondary-button'; // Reuse existing class for consistent look
            emptyBtn.style.fontSize = '1em'; // Make it slightly more prominent if needed
            emptyBtn.innerText = 'No songs... Click to Add! ';
            emptyBtn.setAttribute('aria-label', 'Playlist empty. Click to upload music files.');

            emptyBtn.onclick = (e) => {
                e.stopPropagation();
                if (playlistUploadInput) playlistUploadInput.click();
            };

            li.appendChild(emptyBtn);
            playlistList.appendChild(li);
        }
    }

    // Hook up AudioSystem callbacks
    audioSystem.onPlaylistUpdate = () => { if (isPlaylistOpen) renderPlaylist(); };

    // UX: Show toast and update playlist when track changes
    audioSystem.onTrackChange = (index) => {
        if (isPlaylistOpen) renderPlaylist();

        // Show "Now Playing" toast
        const songs = audioSystem.getPlaylist();
        if (songs && songs[index]) {
            __vitePreload(async () => { const {showToast} = await import('./toast-P0Hmq1BX.js');return { showToast }},true              ?[]:void 0).then(({ showToast }) => {
                showToast(`Now Playing: ${songs[index].name}`, '');
            });
        }
    };

    // --- Input Logic ---

    // Toggle Function
    function togglePlaylist() {
        isPlaylistOpen = !isPlaylistOpen;

        if (isPlaylistOpen) {
            controls.unlock(); // Unlock mouse so we can click
            if (instructions) instructions.style.display = 'none'; // Ensure pause menu is hidden
            playlistOverlay.style.display = 'flex';
            renderPlaylist();
            // Focus management: focus the overlay or the close button for accessibility
            requestAnimationFrame(() => {
                if (closePlaylistBtn) closePlaylistBtn.focus();
            });
        } else {
            // CLOSING
            playlistOverlay.style.display = 'none';
            controls.lock(); // Re-lock mouse to play
            // Note: We don't restore focus here because controls.lock() resumes the game
            // and hides the previous UI context.
        }
    }

    // Event Listeners for UI
    if (closePlaylistBtn) {
        closePlaylistBtn.addEventListener('click', togglePlaylist);
    }

    // Helper: Show temporary success feedback on upload buttons
    const showUploadFeedback = (labelElement, filesCount) => {
        if (!labelElement) return;

        // Save original text if not already saved
        if (!labelElement.dataset.originalText) {
            labelElement.dataset.originalText = labelElement.innerText;
        }

        const originalText = labelElement.dataset.originalText;
        labelElement.innerText = ` ${filesCount} Song${filesCount > 1 ? 's' : ''} Added!`;

        setTimeout(() => {
            labelElement.innerText = originalText;
        }, 2000);
    };

    if (playlistUploadInput) {
        playlistUploadInput.addEventListener('change', (e) => {
            const files = e.target.files;
            if (files && files.length > 0) {
                audioSystem.addToQueue(files);
                const label = document.querySelector('label[for="playlistUploadInput"]');
                showUploadFeedback(label, files.length);
            }
        });
    }

    // --- Pointer Lock & Menu Logic ---

    if (startButton) {
        startButton.addEventListener('click', () => {
            controls.lock();
        });
    }

    if (instructions) {
        instructions.addEventListener('click', (event) => {
            if (event.target === instructions) {
                controls.lock();
            }
        });
    }

    controls.addEventListener('lock', () => {
        instructions.style.display = 'none';
        
        // If we locked, force playlist closed just in case
        isPlaylistOpen = false; 
        if (playlistOverlay) playlistOverlay.style.display = 'none';
    });

    controls.addEventListener('unlock', () => {
        // CRITICAL: Only show Main Menu if Playlist ISN'T open.
        // If Playlist is open, we *want* to be unlocked, but seeing the Playlist, not the start screen.
        if (!isPlaylistOpen) {
            if (instructions) instructions.style.display = 'flex';
            if (startButton) {
                startButton.innerText = 'Resume Exploration ';
                requestAnimationFrame(() => startButton.focus());
            }
        }
    });

    // Key Handlers
    const onKeyDown = function (event) {
        // Prevent default browser actions (like Ctrl+S)
        if (event.ctrlKey && event.code !== 'ControlLeft' && event.code !== 'ControlRight') {
            event.preventDefault();
        }

        // --- UX: Focus Trap & Control Lock when Playlist is open ---
        if (isPlaylistOpen) {
            // Close on Escape or Q
            if (event.code === 'Escape' || event.code === 'KeyQ') {
                event.preventDefault();
                togglePlaylist();
                return;
            }

            // UX: Arrow Key Navigation for Playlist
            if (event.code === 'ArrowDown' || event.code === 'ArrowUp') {
                const playlistBtns = Array.from(playlistOverlay.querySelectorAll('.playlist-btn'));
                if (playlistBtns.length > 0) {
                    event.preventDefault(); // Prevent scrolling
                    const currentIndex = playlistBtns.indexOf(document.activeElement);
                    let nextIndex;

                    if (event.code === 'ArrowDown') {
                        nextIndex = currentIndex === -1 ? 0 : (currentIndex + 1) % playlistBtns.length;
                    } else {
                        nextIndex = currentIndex === -1 ? playlistBtns.length - 1 : (currentIndex - 1 + playlistBtns.length) % playlistBtns.length;
                    }
                    playlistBtns[nextIndex].focus();
                }
                return;
            }

            // Focus Trap Logic for Tab
            if (event.code === 'Tab') {
                const focusable = playlistOverlay.querySelectorAll('button, input, [href], select, textarea, [tabindex]:not([tabindex="-1"])');
                if (focusable.length === 0) return;

                const first = focusable[0];
                const last = focusable[focusable.length - 1];

                if (event.shiftKey) {
                    if (document.activeElement === first) {
                        last.focus();
                        event.preventDefault();
                    }
                } else {
                    if (document.activeElement === last) {
                        first.focus();
                        event.preventDefault();
                    }
                }
                return;
            }

            // Block game controls while in menu
            return;
        }
        // --------------------------------------------------------

        switch (event.code) {
            case 'KeyQ':
                togglePlaylist();
                break;
            case 'KeyW': keyStates.forward = true; break;
            case 'KeyA': keyStates.left = true; break;
            case 'KeyS': keyStates.backward = true; break;
            case 'KeyD': keyStates.right = true; break;
            case 'Space': keyStates.jump = true; break;
            case 'KeyN': if(toggleDayNightCallback) toggleDayNightCallback(); break;
            case 'ControlLeft':
            case 'ControlRight':
                keyStates.sneak = true;
                event.preventDefault();
                break;
            case 'ShiftLeft':
            case 'ShiftRight':
                keyStates.sprint = true;
                break;
        }
    };

    const onKeyUp = function (event) {
        switch (event.code) {
            case 'KeyW': keyStates.forward = false; break;
            case 'KeyA': keyStates.left = false; break;
            case 'KeyS': keyStates.backward = false; break;
            case 'KeyD': keyStates.right = false; break;
            case 'Space': keyStates.jump = false; break;
            case 'ControlLeft':
            case 'ControlRight': keyStates.sneak = false; break;
            case 'ShiftLeft':
            case 'ShiftRight': keyStates.sprint = false; break;
        }
    };

    // Standard Mouse State (Right click to move)
    const onMouseDown = function (event) {
        if (isPlaylistOpen) return; // Block game mouse input
        if (event.button === 2) keyStates.forward = true;
    };

    const onMouseUp = function (event) {
        if (isPlaylistOpen) return; // Block game mouse input
        if (event.button === 2) keyStates.forward = false;
    };

    document.addEventListener('keydown', onKeyDown);
    document.addEventListener('keyup', onKeyUp);
    document.addEventListener('mousedown', onMouseDown);
    document.addEventListener('mouseup', onMouseUp);

    // Existing Music Upload Handler (Main Menu) - Kept for compatibility
    const musicUpload = document.getElementById('musicUpload');
    if (musicUpload) {
        musicUpload.addEventListener('change', (event) => {
            const files = event.target.files;
            if (files && files.length > 0) {
                audioSystem.addToQueue(files);
                const label = document.querySelector('label[for="musicUpload"]');
                showUploadFeedback(label, files.length);
            }
        });
    }

    const toggleDayNightBtn = document.getElementById('toggleDayNight');
    if (toggleDayNightBtn && toggleDayNightCallback) {
        toggleDayNightBtn.addEventListener('click', toggleDayNightCallback);
    }

    // UX: Initialize Day/Night button state
    if (toggleDayNightBtn) {
        // Default to Day Mode 
        toggleDayNightBtn.innerHTML = ' Day Mode (N)';
    }

    const openJukeboxBtn = document.getElementById('openJukeboxBtn');
    if (openJukeboxBtn) {
        openJukeboxBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            togglePlaylist();
        });
    }

    return {
        controls,
        updateDayNightButtonState: (isPressed) => {
            if (toggleDayNightBtn) {
                toggleDayNightBtn.setAttribute('aria-pressed', isPressed);

                // UX: Update button text to reflect current state
                toggleDayNightBtn.innerHTML = isPressed
                    ? ' Night Mode (N)'
                    : ' Day Mode (N)';

                __vitePreload(async () => { const {showToast} = await import('./toast-P0Hmq1BX.js');return { showToast }},true              ?[]:void 0).then(({ showToast }) => {
                    const mode = isPressed ? "Night Mode Active " : "Day Mode Active ";
                    showToast(mode, isPressed ? '' : '');
                });
            }
        }
    };
}

// src/world/state.js


const animatedFoliage = [];
const obstacles = [];

// Optimization: Categorized arrays for faster collision/logic
const foliageMushrooms = [];
const foliageTrampolines = [];
const foliageClouds = [];
const vineSwings = []; // Managers for swing physics

// Groups
const worldGroup = new Group();
const foliageGroup = new Group();
worldGroup.add(foliageGroup);

let activeVineSwing = null; // Current vine player is attached to
let lastVineDetachTime = 0; // Debounce re-attach

function setActiveVineSwing(vine) {
    activeVineSwing = vine;
}

function setLastVineDetachTime(time) {
    lastVineDetachTime = time;
}

// src/utils/spatial-hash.js

/**
 * SpatialHashGrid - Efficient spatial partitioning for collision detection
 * 
 * Divides the world into a grid of cells and stores objects in their respective cells.
 * Queries only check the player's cell plus neighboring cells (3x3 grid), reducing
 * collision checks from O(N) to O(k) where k is the number of nearby objects.
 * 
 * Performance: ~70-85% reduction in collision detection time for sparse object distributions.
 * 
 * @example
 * const grid = new SpatialHashGrid(10); // 10-unit cells
 * mushrooms.forEach(m => grid.insert(m, m.position.x, m.position.z));
 * const nearby = grid.query(playerX, playerZ, 5); // Get objects within 5 units
 */
class SpatialHashGrid {
    /**
     * @param {number} cellSize - Size of each grid cell (default: 10 units)
     */
    constructor(cellSize = 10) {
        this.cellSize = cellSize;
        this.grid = new Map(); // key: "x,z", value: array of objects
        this.totalObjects = 0;
    }

    /**
     * Hash world coordinates to a grid cell key
     * @private
     */
    _hash(x, z) {
        const cellX = Math.floor(x / this.cellSize);
        const cellZ = Math.floor(z / this.cellSize);
        return `${cellX},${cellZ}`;
    }

    /**
     * Insert an object into the grid at the specified world position
     * @param {Object} object - The object to insert (e.g., mesh, collision volume)
     * @param {number} x - World X coordinate
     * @param {number} z - World Z coordinate
     */
    insert(object, x, z) {
        const key = this._hash(x, z);
        
        if (!this.grid.has(key)) {
            this.grid.set(key, []);
        }
        
        this.grid.get(key).push(object);
        this.totalObjects++;
    }

    /**
     * Query objects near a world position
     * Checks the cell containing (x,z) plus all 8 neighboring cells (3x3 grid)
     * 
     * @param {number} x - Query center X coordinate
     * @param {number} z - Query center Z coordinate
     * @param {number} radius - Optional query radius (for future use)
     * @returns {Array} Array of objects in nearby cells
     */
    query(x, z, radius = 0) {
        const results = [];
        const centerCellX = Math.floor(x / this.cellSize);
        const centerCellZ = Math.floor(z / this.cellSize);

        // Check 3x3 grid of cells (center + 8 neighbors)
        for (let dx = -1; dx <= 1; dx++) {
            for (let dz = -1; dz <= 1; dz++) {
                const key = `${centerCellX + dx},${centerCellZ + dz}`;
                const cell = this.grid.get(key);
                
                if (cell) {
                    // Add all objects from this cell to results
                    results.push(...cell);
                }
            }
        }

        return results;
    }

    /**
     * Clear all objects from the grid
     */
    clear() {
        this.grid.clear();
        this.totalObjects = 0;
    }

    /**
     * Get statistics about the grid for debugging/profiling
     * @returns {Object} { totalObjects, cellsUsed, avgObjectsPerCell }
     */
    getStats() {
        const cellsUsed = this.grid.size;
        const avgObjectsPerCell = cellsUsed > 0 ? this.totalObjects / cellsUsed : 0;
        
        return {
            totalObjects: this.totalObjects,
            cellsUsed: cellsUsed,
            avgObjectsPerCell: avgObjectsPerCell.toFixed(2),
            cellSize: this.cellSize
        };
    }

    /**
     * Rebuild the grid with a new set of objects
     * Useful for dynamic scenes where objects move frequently
     * 
     * @param {Array} objects - Array of objects with {object, x, z} properties
     */
    rebuild(objects) {
        this.clear();
        objects.forEach(({ object, x, z }) => {
            this.insert(object, x, z);
        });
    }
}

// src/systems/physics.js

const GRAVITY = 20.0;
const SWIMMING_GRAVITY = 2.0; // Much lower gravity in water
const SWIMMING_DRAG = 4.0;    // High friction in water

// Optimization: Scratch variables to prevent GC in hot loops
const _scratchGatePos = new Vector3();
const _scratchSwimDir = new Vector3();
const _scratchCamDir = new Vector3();
const _scratchCamRight = new Vector3();
const _scratchMoveVec = new Vector3();
const _scratchTargetVelocity = new Vector3();

// --- State Definitions ---
const PlayerState = {
    DEFAULT: 'default',   // Grounded or Airborne (Standard Physics)
    SWIMMING: 'swimming', // Underwater physics
    CLIMBING: 'climbing', // Wall scaling
    VINE: 'vine'          // Swinging on a vine
};

// --- Player State Object ---
const player = {
    velocity: new Vector3(),
    speed: 15.0,
    sprintSpeed: 25.0,
    sneakSpeed: 5.0,
    gravity: GRAVITY,
    energy: 0.0,
    maxEnergy: 10.0,
    currentState: PlayerState.DEFAULT,

    // Flags for external systems to query
    isGrounded: false,
    isUnderwater: false
};

// Global physics modifiers (Musical Ecosystem)
({
    direction: new Vector3(1, 0, 0)});

const grooveGravity = {
    multiplier: 1.0,
    targetMultiplier: 1.0,
    baseGravity: 20.0
};

// C++ Physics Init Flag
let cppPhysicsInitialized = false;
let foliageCaves = []; // Store caves for collision checks

// Spatial Hash Grids for Collision Optimization (Tier 1 Optimization)
// Each grid partitions space into 10x10 unit cells for fast spatial queries
let caveGrid = null;
let mushroomGrid = null;
let cloudGrid = null;
let vineGrid = null;
let spatialHashEnabled = false; // Flag to enable/disable optimization

// --- Public API ---

function registerPhysicsCave(cave) {
    foliageCaves.push(cave);
}

// Main Physics Update Loop
function updatePhysics(delta, camera, controls, keyStates, audioState) {
    // 1. Update Global Environmental Modifiers (Wind, Groove)
    updateEnvironmentalModifiers(delta, audioState);

    // 2. Check Triggers & State Transitions
    updateStateTransitions(camera, keyStates);

    // 3. Execute State Logic
    switch (player.currentState) {
        case PlayerState.VINE:
            updateVineState(delta, camera, keyStates);
            break;
        case PlayerState.SWIMMING:
            updateSwimmingState(delta, camera, controls, keyStates);
            break;
        case PlayerState.CLIMBING:
            updateClimbingState();
            break;
        case PlayerState.DEFAULT:
        default:
            updateDefaultState(delta, camera, controls, keyStates, audioState);
            break;
    }
}

// --- Internal Logic ---

function updateEnvironmentalModifiers(delta, audioState) {
    if (audioState) {
        // Groove Gravity
        const groove = audioState.grooveAmount || 0;
        grooveGravity.targetMultiplier = 1.0 - (groove * 0.4);
        grooveGravity.multiplier += (grooveGravity.targetMultiplier - grooveGravity.multiplier) * delta * 5.0;
        player.gravity = grooveGravity.baseGravity * grooveGravity.multiplier;

        // BPM Wind (Visuals only for now)
        audioState.bpm || 120;
    }
}

function updateStateTransitions(camera, keyStates) {
    const playerPos = camera.position;

    // A. Check Water Level / Cave Flooding
    // We check if the player is inside the "Water Gate" zone of a blocked cave
    let waterLevel = -100;

    foliageCaves.forEach(cave => {
        // If cave is flooded (isBlocked) AND player is near the gate
        if (cave.userData.isBlocked) {
             // Bolt Optimization: Reuse scratch vector
             _scratchGatePos.copy(cave.userData.gatePosition).applyMatrix4(cave.matrixWorld);

             // Bolt Optimization: distanceToSquared (2.5 * 2.5 = 6.25)
             // 2.5 is approx radius of water gate visual
             if (playerPos.distanceToSquared(_scratchGatePos) < 6.25) {
                 waterLevel = _scratchGatePos.y + 5; // Water exists here
             }
        }
    });

    const wasSwimming = player.currentState === PlayerState.SWIMMING;
    const isNowUnderwater = playerPos.y < waterLevel;
    player.isUnderwater = isNowUnderwater;

    // Transition: Enter/Exit Water
    if (isNowUnderwater && !wasSwimming) {
        player.currentState = PlayerState.SWIMMING;
        // Dampen velocity on entry
        player.velocity.multiplyScalar(0.5);
    } else if (!isNowUnderwater && wasSwimming) {
        // Exit water logic
        if (playerPos.y > waterLevel) {
            player.currentState = PlayerState.DEFAULT;
            if (keyStates.jump) player.velocity.y = 8.0; // Boost out
        }
    }

    // Transition: Vine Handling
    if (activeVineSwing) {
        player.currentState = PlayerState.VINE;
    } else if (player.currentState === PlayerState.VINE) {
        player.currentState = PlayerState.DEFAULT;
    }
}

// --- State: SWIMMING ---
function updateSwimmingState(delta, camera, controls, keyStates) {
    // 1. Buoyancy (Float up slowly)
    player.velocity.y += (SWIMMING_GRAVITY * delta);

    // 2. Drag (Slow down constantly)
    player.velocity.multiplyScalar(1.0 - (SWIMMING_DRAG * delta));

    // 3. Movement (3D Movement - Camera Direction)
    const swimSpeed = player.speed * 0.6; // Slower than running
    _scratchSwimDir.set(0, 0, 0);

    if (keyStates.forward) _scratchSwimDir.z += 1;
    if (keyStates.backward) _scratchSwimDir.z -= 1;
    if (keyStates.right) _scratchSwimDir.x += 1;
    if (keyStates.left) _scratchSwimDir.x -= 1;

    if (_scratchSwimDir.lengthSq() > 0) {
        _scratchSwimDir.normalize();

        // Get Camera direction
        camera.getWorldDirection(_scratchCamDir);
        _scratchCamRight.crossVectors(_scratchCamDir, new Vector3(0, 1, 0)); // Using temp vec for UP is fine or optimization target? UP is const (0,1,0)

        // Apply input relative to camera view
        // Bolt: Reuse scratch vector
        _scratchMoveVec.set(0, 0, 0)
            .addScaledVector(_scratchCamDir, _scratchSwimDir.z)
            .addScaledVector(_scratchCamRight, _scratchSwimDir.x);

        player.velocity.addScaledVector(_scratchMoveVec, swimSpeed * delta);
    }

    // 4. Vertical Input (Jump = Swim Up, Sneak = Swim Down)
    if (keyStates.jump) player.velocity.y += 10 * delta;
    if (keyStates.sneak) player.velocity.y -= 10 * delta;

    // 5. Apply
    controls.moveRight(player.velocity.x * delta);
    controls.moveForward(player.velocity.z * delta);
    camera.position.y += player.velocity.y * delta;
}

// --- State: VINE SWING ---
function updateVineState(delta, camera, keyStates) {
    if (activeVineSwing) {
        activeVineSwing.update(camera, delta, keyStates);
        if (keyStates.jump) {
            setLastVineDetachTime(activeVineSwing.detach(player));
            setActiveVineSwing(null);
            keyStates.jump = false;
            player.currentState = PlayerState.DEFAULT;
        }
    }
}

// --- State: CLIMBING (Placeholder for future platforming) ---
function updateClimbingState(delta, camera, controls, keyStates) {
    player.velocity.set(0,0,0);
    player.currentState = PlayerState.DEFAULT; // Fallback for now
}

// --- State: DEFAULT (Walking/Falling) ---
function updateDefaultState(delta, camera, controls, keyStates, audioState) {
    // Initialize C++ Physics if needed
    if (!cppPhysicsInitialized) {
        initCppPhysics(camera);
        cppPhysicsInitialized = true;
    }

    // Update Vine Visuals (even if not swinging)
    vineSwings.forEach(v => {
        if (v !== activeVineSwing) v.update(camera, delta, null);
    });

    // Vine Attachment Check
    if (Date.now() - lastVineDetachTime > 500) {
        profiler.measure('VineAttach', () => {
            checkVineAttachment(camera);
        });
    }

    // --- C++ MOVEMENT INTEGRATION ---

    let inputX = 0;
    let inputZ = 0;
    let moveSpeed = keyStates.sprint ? player.sprintSpeed : (keyStates.sneak ? player.sneakSpeed : player.speed);

    if (keyStates.forward) inputZ += 1;
    if (keyStates.backward) inputZ -= 1;
    if (keyStates.left) inputX -= 1;
    if (keyStates.right) inputX += 1;

    // Normalize
    const lenSq = inputX*inputX + inputZ*inputZ;
    if (lenSq > 0) {
        const len = Math.sqrt(lenSq);
        inputX /= len; inputZ /= len;
    }

    // Sync State
    setPlayerState(camera.position.x, camera.position.y, camera.position.z, player.velocity.x, player.velocity.y, player.velocity.z);

    // Run C++ Update
    const onGround = updatePhysicsCPP(
        delta, inputX, inputZ, moveSpeed,
        keyStates.jump ? 1 : 0,
        keyStates.sprint ? 1 : 0,
        keyStates.sneak ? 1 : 0,
        grooveGravity.multiplier
    );

    if (onGround >= 0) {
        // C++ Success
        const newState = getPlayerState();
        camera.position.set(newState.x, newState.y, newState.z);
        player.velocity.set(newState.vx, newState.vy, newState.vz);
        if (player.velocity.y > 0) keyStates.jump = false; // Clear jump
        player.isGrounded = (onGround === 1);
    } else {
        // JS Fallback (if C++ fails)
        updateJSFallbackMovement(delta, camera, controls, keyStates, moveSpeed);
    }

    // --- ADDITIONAL JS COLLISIONS (Mushrooms, Clouds, Gates) ---
    profiler.measure('Collisions', () => {
        resolveSpecialCollisions(delta, camera, keyStates, audioState);
    });
}

function updateJSFallbackMovement(delta, camera, controls, keyStates, moveSpeed) {
    _scratchTargetVelocity.set(0, 0, 0);
    if (keyStates.forward) _scratchTargetVelocity.z += moveSpeed;
    if (keyStates.backward) _scratchTargetVelocity.z -= moveSpeed;
    if (keyStates.left) _scratchTargetVelocity.x -= moveSpeed;
    if (keyStates.right) _scratchTargetVelocity.x += moveSpeed;

    if (_scratchTargetVelocity.lengthSq() > 0) _scratchTargetVelocity.normalize().multiplyScalar(moveSpeed);

    const smoothing = Math.min(1.0, 15.0 * delta);
    player.velocity.x += (_scratchTargetVelocity.x - player.velocity.x) * smoothing;
    player.velocity.z += (_scratchTargetVelocity.z - player.velocity.z) * smoothing;
    player.velocity.y -= player.gravity * delta;

    controls.moveRight(player.velocity.x * delta);
    controls.moveForward(player.velocity.z * delta);
    camera.position.y += player.velocity.y * delta;

    // Simple Ground Check
    const groundY = getGroundHeight(camera.position.x, camera.position.z);
    if (camera.position.y < groundY + 1.8 && player.velocity.y <= 0) {
        camera.position.y = groundY + 1.8;
        player.velocity.y = 0;
        player.isGrounded = true;
    } else {
        player.isGrounded = false;
    }
}

// Resolve collisions with game objects (Mushrooms, Water Gates, etc)
function resolveSpecialCollisions(delta, camera, keyStates, audioState) {
    const playerPos = camera.position;

    // 1. Water Gates (Cave Blockers)
    // If not swimming (meaning we are walking into it), push back
    const nearbyCaves = spatialHashEnabled ? caveGrid.query(playerPos.x, playerPos.z) : foliageCaves;
    
    nearbyCaves.forEach(cave => {
        if (cave.userData.isBlocked) {
            // Bolt Optimization: Reuse scratch vector
            _scratchGatePos.copy(cave.userData.gatePosition).applyMatrix4(cave.matrixWorld);
            const dx = playerPos.x - _scratchGatePos.x;
            const dz = playerPos.z - _scratchGatePos.z;

            // Bolt Optimization: Squared distance (2.5^2 = 6.25)
            const distSq = dx*dx + dz*dz;

            // If near gate and NOT already inside water (transition state handles inside)
            if (distSq < 6.25 && player.currentState !== PlayerState.SWIMMING) {
                // Push back force
                const angle = Math.atan2(dz, dx);
                const pushForce = 15.0 * delta;
                camera.position.x += Math.cos(angle) * pushForce;
                camera.position.z += Math.sin(angle) * pushForce;
                player.velocity.x *= 0.5;
                player.velocity.z *= 0.5;
            }
        }
    });

    // 2. Mushroom Caps (Trampolines/Platforms) - JS Check with Spatial Hash Optimization
    const nearbyMushrooms = spatialHashEnabled ? mushroomGrid.query(playerPos.x, playerPos.z) : foliageMushrooms;
    
    for (const mush of nearbyMushrooms) {
        if (player.velocity.y < 0) {
            const capR = mush.userData.capRadius || 2.0;
            const capRSq = capR * capR;
            const capH = mush.userData.capHeight || 3.0;
            const dx = playerPos.x - mush.position.x;
            const dz = playerPos.z - mush.position.z;

            // Bolt Optimization: Squared distance
            const distSq = dx*dx + dz*dz;

            if (distSq < capRSq) {
                const surfaceY = mush.position.y + capH;
                if (playerPos.y >= surfaceY - 0.5 && playerPos.y <= surfaceY + 2.0) {
                    if (mush.userData.isTrampoline) {
                        const audioBoost = audioState?.kickTrigger || 0.0;
                        player.velocity.y = 15 + audioBoost * 10;
                        mush.scale.y = 0.7;
                        setTimeout(() => { mush.scale.y = 1.0; }, 100);
                        keyStates.jump = false;
                    } else {
                        // Platform land
                        camera.position.y = surfaceY + 1.8;
                        player.velocity.y = 0;
                        player.isGrounded = true;
                        if (keyStates.jump) player.velocity.y = 10;
                    }
                }
            }
        }
    }

    // 3. Cloud Walking (Simplified) - with Spatial Hash Optimization
    if (playerPos.y > 15) {
        const nearbyClouds = spatialHashEnabled ? cloudGrid.query(playerPos.x, playerPos.z) : foliageClouds;
        
        for (const cloud of nearbyClouds) {
            const dx = playerPos.x - cloud.position.x;
            const dz = playerPos.z - cloud.position.z;
            const radius = (cloud.scale.x || 1.0) * 2.0;
            const radiusSq = radius * radius;

            // Bolt Optimization: Squared distance
            const distSq = dx*dx + dz*dz;

            if (distSq < radiusSq) {
                if (cloud.userData.tier === 1) {
                     const topY = cloud.position.y + (cloud.scale.y || 1.0) * 0.8;
                     if (playerPos.y >= topY - 0.5 && (playerPos.y - topY) < 3.0) {
                         if (player.velocity.y <= 0) {
                             camera.position.y = topY;
                             player.velocity.y = 0;
                             player.isGrounded = true;
                             if (keyStates.jump) player.velocity.y = 15;
                         }
                     }
                }
            }
        }
    }
}

// Helper: Initialize C++ obstacles (One-time setup)
function initCppPhysics(camera) {
    initPhysics(camera.position.x, camera.position.y, camera.position.z);

    // Add Mushrooms
    for (const m of foliageMushrooms) {
        addObstacle(0, m.position.x, m.position.y, m.position.z, 0, m.userData.capHeight||3, m.userData.stemRadius||0.5, m.userData.capRadius||2, m.userData.isTrampoline?1:0);
    }
    // Add Clouds
    for (const c of foliageClouds) {
        addObstacle(1, c.position.x, c.position.y, c.position.z, (c.scale.x||1)*2.0, (c.scale.y||1)*0.8, 0, c.userData.tier||1, 0);
    }
    // Add Trampolines
    for (const t of foliageTrampolines) {
        addObstacle(2, t.position.x, t.position.y, t.position.z, t.userData.bounceRadius||0.5, t.userData.bounceHeight||0.5, t.userData.bounceForce||12, 0, 0);
    }
    console.log('[Physics] C++ Physics Initialized.');

    // Initialize Spatial Hash Grids (Tier 1 Optimization)
    // Cell size of 10 units chosen based on typical collision radii (2-5 units)
    caveGrid = new SpatialHashGrid(10);
    mushroomGrid = new SpatialHashGrid(10);
    cloudGrid = new SpatialHashGrid(10);
    vineGrid = new SpatialHashGrid(10);

    // Populate grids with static objects
    foliageCaves.forEach(cave => {
        caveGrid.insert(cave, cave.position.x, cave.position.z);
    });

    foliageMushrooms.forEach(mush => {
        mushroomGrid.insert(mush, mush.position.x, mush.position.z);
    });

    foliageClouds.forEach(cloud => {
        cloudGrid.insert(cloud, cloud.position.x, cloud.position.z);
    });

    vineSwings.forEach(vine => {
        vineGrid.insert(vine, vine.anchorPoint.x, vine.anchorPoint.z);
    });

    spatialHashEnabled = true;

    // Log spatial hash statistics
    console.log('[Physics] Spatial Hash Grids Initialized:');
    console.log('  - Caves:', caveGrid.getStats());
    console.log('  - Mushrooms:', mushroomGrid.getStats());
    console.log('  - Clouds:', cloudGrid.getStats());
    console.log('  - Vines:', vineGrid.getStats());
}

function checkVineAttachment(camera) {
    const playerPos = camera.position;
    const nearbyVines = spatialHashEnabled ? vineGrid.query(playerPos.x, playerPos.z) : vineSwings;
    
    for (const vineManager of nearbyVines) {
        const dx = playerPos.x - vineManager.anchorPoint.x;
        const dz = playerPos.z - vineManager.anchorPoint.z;

        // Bolt Optimization: Squared distance
        const distHSq = dx*dx + dz*dz;
        const tipY = vineManager.anchorPoint.y - vineManager.length;

        // 2.0^2 = 4.0
        if (distHSq < 4.0 && playerPos.y < vineManager.anchorPoint.y && playerPos.y > tipY) {
             // 1.0^2 = 1.0
             if (distHSq < 1.0) {
                 vineManager.attach(camera, player.velocity);
                 setActiveVineSwing(vineManager);
                 break;
             }
        }
    }
}

const mapData = /* #__PURE__ */ JSON.parse("[{\"type\":\"mushroom\",\"position\":[25,0,0],\"scale\":1.2,\"variant\":\"regular\",\"note\":\"C\",\"noteIndex\":0,\"hasFace\":false},{\"type\":\"mushroom\",\"position\":[21.65,0,12.5],\"scale\":1.2,\"variant\":\"regular\",\"note\":\"C#\",\"noteIndex\":1,\"hasFace\":false},{\"type\":\"mushroom\",\"position\":[12.5,0,21.65],\"scale\":1.2,\"variant\":\"regular\",\"note\":\"D\",\"noteIndex\":2,\"hasFace\":false},{\"type\":\"mushroom\",\"position\":[0,0,25],\"scale\":1.2,\"variant\":\"regular\",\"note\":\"D#\",\"noteIndex\":3,\"hasFace\":false},{\"type\":\"mushroom\",\"position\":[-12.5,0,21.65],\"scale\":1.2,\"variant\":\"regular\",\"note\":\"E\",\"noteIndex\":4,\"hasFace\":false},{\"type\":\"mushroom\",\"position\":[-21.65,0,12.5],\"scale\":1.2,\"variant\":\"regular\",\"note\":\"F\",\"noteIndex\":5,\"hasFace\":false},{\"type\":\"mushroom\",\"position\":[-25,0,0],\"scale\":1.2,\"variant\":\"regular\",\"note\":\"F#\",\"noteIndex\":6,\"hasFace\":false},{\"type\":\"mushroom\",\"position\":[-21.65,0,-12.5],\"scale\":1.2,\"variant\":\"regular\",\"note\":\"G\",\"noteIndex\":7,\"hasFace\":false},{\"type\":\"mushroom\",\"position\":[-12.5,0,-21.65],\"scale\":1.2,\"variant\":\"regular\",\"note\":\"G#\",\"noteIndex\":8,\"hasFace\":false},{\"type\":\"mushroom\",\"position\":[0,0,-25],\"scale\":1.2,\"variant\":\"regular\",\"note\":\"A\",\"noteIndex\":9,\"hasFace\":false},{\"type\":\"mushroom\",\"position\":[12.5,0,-21.65],\"scale\":1.2,\"variant\":\"regular\",\"note\":\"A#\",\"noteIndex\":10,\"hasFace\":false},{\"type\":\"mushroom\",\"position\":[21.65,0,-12.5],\"scale\":1.2,\"variant\":\"regular\",\"note\":\"B\",\"noteIndex\":11,\"hasFace\":false},{\"type\":\"mushroom\",\"position\":[72,0,-40],\"scale\":1.5,\"variant\":\"giant\",\"hasFace\":true},{\"type\":\"mushroom\",\"position\":[66,0,-29.607695154586736],\"scale\":1.5,\"variant\":\"giant\",\"hasFace\":true},{\"type\":\"mushroom\",\"position\":[54,0,-29.607695154586736],\"scale\":1.5,\"variant\":\"giant\",\"hasFace\":true},{\"type\":\"mushroom\",\"position\":[48,0,-40],\"scale\":1.5,\"variant\":\"giant\",\"hasFace\":true},{\"type\":\"mushroom\",\"position\":[53.99999999999999,0,-50.392304845413264],\"scale\":1.5,\"variant\":\"giant\",\"hasFace\":true},{\"type\":\"mushroom\",\"position\":[66,0,-50.392304845413264],\"scale\":1.5,\"variant\":\"giant\",\"hasFace\":true},{\"type\":\"portamento_pine\",\"position\":[-47.22911016463579,0,-0.1255438425534603],\"scale\":0.9374434605235864},{\"type\":\"tremolo_tulip\",\"position\":[-40.543526587193824,0,-6.501984401399766],\"scale\":1.0453580444760104},{\"type\":\"tremolo_tulip\",\"position\":[-47.64864023911153,0,-7.174714975268854],\"scale\":1.0930116674734562},{\"type\":\"tremolo_tulip\",\"position\":[-47.83239902515943,0,-6.72533117503884],\"scale\":0.8031491105100604},{\"type\":\"tremolo_tulip\",\"position\":[-48.63930823476214,0,-7.176793236973787],\"scale\":0.9306455807912338},{\"type\":\"prism_rose_bush\",\"position\":[-48.049974851790104,0,-7.594525476036271],\"scale\":1.1636334853694503},{\"type\":\"prism_rose_bush\",\"position\":[-52.777369041429615,0,-6.311771619973262],\"scale\":0.874331714198389},{\"type\":\"prism_rose_bush\",\"position\":[-49.676046349699035,0,-11.18063119800394],\"scale\":0.9444590508448274},{\"type\":\"prism_rose_bush\",\"position\":[119.76576256388121,0,11.282430741476926],\"scale\":0.8108908930982137},{\"type\":\"tremolo_tulip\",\"position\":[124.40140164851591,0,10.30193958403372],\"scale\":1.1797933198653967},{\"type\":\"portamento_pine\",\"position\":[119.52465877947792,0,11.206682617909273],\"scale\":1.1106525614033895},{\"type\":\"portamento_pine\",\"position\":[119.18450529879063,0,7.866906129568365],\"scale\":1.1231816712992806},{\"type\":\"arpeggio_fern\",\"position\":[118.3652948449315,0,7.325511979380682],\"scale\":1.0736005067797172},{\"type\":\"vibrato_violet\",\"position\":[121.5129502246927,0,12.065561150703646],\"scale\":0.8798744832030643},{\"type\":\"tremolo_tulip\",\"position\":[120.50944629578314,0,10.73012969003906],\"scale\":1.1582220855207417},{\"type\":\"vibrato_violet\",\"position\":[116.16074926043052,0,7.0060833807841565],\"scale\":1.1687494973386434},{\"type\":\"arpeggio_fern\",\"position\":[118.91040609820976,0,12.412317576902907],\"scale\":1.003077234405893},{\"type\":\"portamento_pine\",\"position\":[119.57803860755212,0,10.527755360427552],\"scale\":1.1003052292476632},{\"type\":\"prism_rose_bush\",\"position\":[104.29205958954961,0,-8.878971313154244],\"scale\":0.8479231986446575},{\"type\":\"prism_rose_bush\",\"position\":[97.69989355674667,0,-17.640631483993353],\"scale\":0.946662538452866},{\"type\":\"portamento_pine\",\"position\":[95.28384228595107,0,-5.220051339856421],\"scale\":1.1481714622834858},{\"type\":\"prism_rose_bush\",\"position\":[97.4047452881846,0,-15.781343803804809],\"scale\":0.921761601297653},{\"type\":\"portamento_pine\",\"position\":[98.14235900800283,0,-11.679187503160001],\"scale\":0.9743284807235675},{\"type\":\"prism_rose_bush\",\"position\":[96.20048995883936,0,-18.743274581423755],\"scale\":0.9922194392383505},{\"type\":\"arpeggio_fern\",\"position\":[99.4120568739739,0,-11.046351450552823],\"scale\":1.0742663314289531},{\"type\":\"arpeggio_fern\",\"position\":[99.6642763637413,0,-10.172403990417576],\"scale\":0.9457034234272924},{\"type\":\"arpeggio_fern\",\"position\":[102.58367871622582,0,-10.633298774869342],\"scale\":1.1326173456185114},{\"type\":\"prism_rose_bush\",\"position\":[95.63961290175702,0,-8.5005662911608],\"scale\":1.1285766399365986},{\"type\":\"arpeggio_fern\",\"position\":[99.01294247742509,0,-9.679037492657544],\"scale\":1.0639822437809596},{\"type\":\"subwoofer_lotus\",\"position\":[39.918033770384966,0,2.34248769559657],\"scale\":0.8920341765134564},{\"type\":\"accordion_palm\",\"position\":[43.88268020331673,0,16.002265511515958],\"scale\":0.9665690448394947},{\"type\":\"accordion_palm\",\"position\":[40.60967918670037,0,10.206675748342915],\"scale\":0.8138140961668201},{\"type\":\"kick_drum_geyser\",\"position\":[37.04981076183964,0,11.552361276774095],\"scale\":0.9155642394617505},{\"type\":\"kick_drum_geyser\",\"position\":[45.673283591643994,0,12.723730784534336],\"scale\":1.1316616588614075},{\"type\":\"kick_drum_geyser\",\"position\":[32.74655775193414,0,11.8814106868065],\"scale\":0.8640132495050038},{\"type\":\"prism_rose_bush\",\"position\":[-99.65169122768516,0,-36.380677709583324],\"scale\":1.1334699000818218},{\"type\":\"arpeggio_fern\",\"position\":[-97.46579158948322,0,-33.7393513523269],\"scale\":1.1833276174414797},{\"type\":\"portamento_pine\",\"position\":[-95.48556747382372,0,-31.507488958036845],\"scale\":0.837793518018398},{\"type\":\"arpeggio_fern\",\"position\":[-95.97381546251576,0,-29.447162118032537],\"scale\":1.0013096456670227},{\"type\":\"arpeggio_fern\",\"position\":[-95.64106360813922,0,-32.55928153758976],\"scale\":0.8690088286979181},{\"type\":\"portamento_pine\",\"position\":[90.1046498508956,0,-42.44591134699535],\"scale\":0.8536252065682787},{\"type\":\"prism_rose_bush\",\"position\":[82.5550036309324,0,-38.98596623058435],\"scale\":1.102318085416236},{\"type\":\"vibrato_violet\",\"position\":[81.41994275286038,0,-39.53985063934537],\"scale\":1.0674201155666885},{\"type\":\"arpeggio_fern\",\"position\":[91.09436420864445,0,-41.370721372044386],\"scale\":0.8493853875562591},{\"type\":\"tremolo_tulip\",\"position\":[80.43849951517944,0,-36.43411541217942],\"scale\":1.1347610897441633},{\"type\":\"arpeggio_fern\",\"position\":[81.60695779566566,0,-35.39684489126519],\"scale\":0.944696990655058},{\"type\":\"tremolo_tulip\",\"position\":[82.60027506822583,0,-38.73706157122184],\"scale\":0.9466725515883728},{\"type\":\"prism_rose_bush\",\"position\":[84.59100053260772,0,-39.19773081498175],\"scale\":0.8750194763313562},{\"type\":\"portamento_pine\",\"position\":[89.77372002057372,0,-42.47286406099562],\"scale\":0.9945574132115639},{\"type\":\"tremolo_tulip\",\"position\":[81.87594915468183,0,-46.288160418635414],\"scale\":0.8141690528522924},{\"type\":\"accordion_palm\",\"position\":[-88.79781334771123,0,-21.47799430383231],\"scale\":1.1692633794565368},{\"type\":\"snare_trap\",\"position\":[-93.36328548677082,0,-25.097416223531713],\"scale\":0.9026880447042636},{\"type\":\"subwoofer_lotus\",\"position\":[-95.32246624484179,0,-23.777569304397947],\"scale\":1.0984448013803905},{\"type\":\"subwoofer_lotus\",\"position\":[-91.79341864776526,0,-25.014204193803696],\"scale\":1.1541500796019337},{\"type\":\"kick_drum_geyser\",\"position\":[-92.95251901435498,0,-29.616094665185095],\"scale\":0.8863258223570595},{\"type\":\"kick_drum_geyser\",\"position\":[-92.87465475196053,0,-23.455058811931234],\"scale\":0.870060281542649},{\"type\":\"kick_drum_geyser\",\"position\":[-95.50621397742366,0,-17.496688497085024],\"scale\":1.151272144007872},{\"type\":\"accordion_palm\",\"position\":[-98.60577158099797,0,-26.40784978073481],\"scale\":0.9733974941118964},{\"type\":\"accordion_palm\",\"position\":[-93.93460216667681,0,-23.375752855572227],\"scale\":0.9664986119251022},{\"type\":\"cymbal_dandelion\",\"position\":[-49.02594539931655,0,41.80285968724054],\"scale\":1.1593844099035353},{\"type\":\"subwoofer_lotus\",\"position\":[-55.7572743700053,0,38.611148162407474],\"scale\":0.8717428391365759},{\"type\":\"snare_trap\",\"position\":[-53.888109506291144,0,43.69816094730608],\"scale\":1.0631268082009424},{\"type\":\"accordion_palm\",\"position\":[-49.80795495679224,0,37.43882274864475],\"scale\":1.1426974621911639},{\"type\":\"kick_drum_geyser\",\"position\":[-52.819365828640876,0,39.16820592840743],\"scale\":1.1973553297204669},{\"type\":\"accordion_palm\",\"position\":[-47.110669231448064,0,43.066031339207],\"scale\":0.9730255980682798},{\"type\":\"snare_trap\",\"position\":[-53.929884143188964,0,44.541067389214156],\"scale\":0.8386436351003118},{\"type\":\"accordion_palm\",\"position\":[-51.05104280105699,0,43.163743917169356],\"scale\":0.894441133007592},{\"type\":\"accordion_palm\",\"position\":[-53.571898169233926,0,44.33184039918323],\"scale\":1.0716913563173793},{\"type\":\"tremolo_tulip\",\"position\":[80.0538700300257,0,-47.97461837140477],\"scale\":0.9931466331590519},{\"type\":\"arpeggio_fern\",\"position\":[83.07698620736448,0,-56.27617311301366],\"scale\":0.8861523958483911},{\"type\":\"portamento_pine\",\"position\":[79.74878747347807,0,-53.12178396584419],\"scale\":1.1612366106565035},{\"type\":\"prism_rose_bush\",\"position\":[73.26822726937327,0,-55.575242426011805],\"scale\":1.0395962617031744},{\"type\":\"prism_rose_bush\",\"position\":[72.10499020338924,0,-57.61683409908401],\"scale\":1.0352898374864716},{\"type\":\"tremolo_tulip\",\"position\":[83.05795130267002,0,-50.24113278290652],\"scale\":0.9503942362044122},{\"type\":\"vibrato_violet\",\"position\":[-15.71990977028575,0,39.20101118643635],\"scale\":1.134646217031062},{\"type\":\"portamento_pine\",\"position\":[-23.091694306750664,0,28.142528510800087],\"scale\":0.8267769608779887},{\"type\":\"tremolo_tulip\",\"position\":[-24.882413058425335,0,33.6947885176295],\"scale\":1.0167508175324467},{\"type\":\"arpeggio_fern\",\"position\":[-14.868592593420445,0,30.307129156833305],\"scale\":1.100392559261811},{\"type\":\"arpeggio_fern\",\"position\":[-20.780749893443044,0,32.50885171941463],\"scale\":1.1550058296353567},{\"type\":\"tremolo_tulip\",\"position\":[-11.664819385970105,0,30.69092538026287],\"scale\":1.0268907454210294},{\"type\":\"arpeggio_fern\",\"position\":[-20.642246118339383,0,40.61753374980115],\"scale\":0.8561804216792663},{\"type\":\"portamento_pine\",\"position\":[-18.552411988347693,0,34.575967745089095],\"scale\":1.077367955700064},{\"type\":\"portamento_pine\",\"position\":[-18.141913525522366,0,34.047334290376895],\"scale\":1.1079360549594899},{\"type\":\"vibrato_violet\",\"position\":[41.43027457741349,0,38.725662073221415],\"scale\":1.1204521709775725},{\"type\":\"vibrato_violet\",\"position\":[47.0816688555319,0,41.85834446466186],\"scale\":1.014317464960814},{\"type\":\"arpeggio_fern\",\"position\":[33.61017882998094,0,38.42058117719781],\"scale\":1.0986192346461519},{\"type\":\"tremolo_tulip\",\"position\":[39.1173923791177,0,45.035345192366215],\"scale\":0.8406542303042778},{\"type\":\"arpeggio_fern\",\"position\":[38.31824003596915,0,40.457264983806326],\"scale\":1.0604926701348498},{\"type\":\"prism_rose_bush\",\"position\":[39.40445918545167,0,41.9625565691024],\"scale\":1.0004720561820766},{\"type\":\"portamento_pine\",\"position\":[41.379974100611214,0,41.051512466018664],\"scale\":0.9460835320795433},{\"type\":\"tremolo_tulip\",\"position\":[47.18247908706261,0,41.24321669412563],\"scale\":1.174098183821479},{\"type\":\"vibrato_violet\",\"position\":[41.459549920041944,0,37.34116011843633],\"scale\":1.0599630403448388},{\"type\":\"portamento_pine\",\"position\":[43.52217285428323,0,39.54746098716194],\"scale\":1.0308405813288084},{\"type\":\"snare_trap\",\"position\":[-53.19984888470764,0,-100.6986158552477],\"scale\":1.120398482315219},{\"type\":\"accordion_palm\",\"position\":[-51.99330342931394,0,-92.1796426746822],\"scale\":0.8834521833640497},{\"type\":\"kick_drum_geyser\",\"position\":[-52.114259004061275,0,-94.72806306264009],\"scale\":0.8272330239842545},{\"type\":\"kick_drum_geyser\",\"position\":[-53.977484149797526,0,-96.03216769503626],\"scale\":0.9430323097894462},{\"type\":\"subwoofer_lotus\",\"position\":[-57.37118606552557,0,-98.69398862583571],\"scale\":1.1685840003531272},{\"type\":\"snare_trap\",\"position\":[-51.88787451438698,0,-97.40223236593638],\"scale\":1.07003823102538},{\"type\":\"cymbal_dandelion\",\"position\":[-53.74691847129073,0,-97.0894644626069],\"scale\":1.1046890666932239},{\"type\":\"subwoofer_lotus\",\"position\":[-50.95267916857115,0,-99.79015135323348],\"scale\":0.8800259850275564},{\"type\":\"subwoofer_lotus\",\"position\":[-55.51691349150403,0,-98.70619532262297],\"scale\":0.9430168103152341},{\"type\":\"snare_trap\",\"position\":[-54.822457967133175,0,-90.87841072879833],\"scale\":0.8803625042547809},{\"type\":\"kick_drum_geyser\",\"position\":[-46.49537875252543,0,-97.57283283960712],\"scale\":1.0607945299997539},{\"type\":\"cymbal_dandelion\",\"position\":[-55.97060788546942,0,-97.88582412452101],\"scale\":0.9813741495979758},{\"type\":\"fiber_optic_willow\",\"position\":[-107.83391007801761,0,-31.304563128740387],\"scale\":0.986015613534345},{\"type\":\"fiber_optic_willow\",\"position\":[71.00201806116925,0,47.76280589100914],\"scale\":1.0043558984176926},{\"type\":\"balloon_bush\",\"position\":[23.003398423838497,0,63.27106602963155],\"scale\":1.1415249369605789},{\"type\":\"floating_orb\",\"position\":[-119.91615094415577,0,-8.494360014016742],\"scale\":1.4984708133513283},{\"type\":\"cloud\",\"position\":[-112.59903565179454,41.63615848315962,-58.48214023426522],\"size\":2.034218205970102},{\"type\":\"balloon_bush\",\"position\":[-33.1085219460295,0,-11.759038496727134],\"scale\":1.2972895722937567},{\"type\":\"helix_plant\",\"position\":[3.470647443787697,0,-32.99105882090267],\"scale\":1.0790860445438026},{\"type\":\"helix_plant\",\"position\":[-125.08161389322673,0,17.361933062987198],\"scale\":0.9505704219913998},{\"type\":\"floating_orb\",\"position\":[75.59873844730139,0,75.66383441659225],\"scale\":1.0318142741849725},{\"type\":\"cloud\",\"position\":[35.448837083688474,49.47437558121186,18.146314351559887],\"size\":2.4749023472949334},{\"type\":\"floating_orb\",\"position\":[7.0740295471790935,0,39.42874167452246],\"scale\":1.001507242209681},{\"type\":\"balloon_bush\",\"position\":[-54.69964294715163,0,-109.62700645327244],\"scale\":1.1475745948672675},{\"type\":\"helix_plant\",\"position\":[3.247327553497337,0,104.60284542518704],\"scale\":1.2713343428676456},{\"type\":\"bubble_willow\",\"position\":[4.624564515986328,0,138.43005278722208],\"scale\":1.3272631436263096},{\"type\":\"balloon_bush\",\"position\":[116.95914985086107,0,-47.112467138511455],\"scale\":1.129679921064155},{\"type\":\"cloud\",\"position\":[-77.88365076416657,61.61785651135781,-29.222142191437932],\"size\":1.8485854072985317},{\"type\":\"bubble_willow\",\"position\":[-62.040498384346876,0,-131.79486809943518],\"scale\":1.4593245942918638},{\"type\":\"floating_orb\",\"position\":[-13.313135586808585,0,-26.644503750210788],\"scale\":0.9144877618712476},{\"type\":\"balloon_bush\",\"position\":[-138.95483832000707,0,4.96464566523048],\"scale\":1.2892614040242114},{\"type\":\"fiber_optic_willow\",\"position\":[10.939949542176707,0,-47.0328187392231],\"scale\":1.3572706283509077},{\"type\":\"balloon_bush\",\"position\":[-62.39315897867437,0,108.48174687940846],\"scale\":1.4320102665201349},{\"type\":\"cloud\",\"position\":[95.2820050140259,59.57592577375578,109.52125877905935],\"size\":2.148591694424708},{\"type\":\"floating_orb\",\"position\":[-1.9148714946786534,0,-52.96118856228077],\"scale\":1.3455090842904065},{\"type\":\"helix_plant\",\"position\":[-0.6722842289604921,0,81.34560605788411],\"scale\":0.9247364512251874},{\"type\":\"fiber_optic_willow\",\"position\":[72.95359853298517,0,37.095055480292444],\"scale\":1.3981079630771869},{\"type\":\"cloud\",\"position\":[-33.48024635025627,46.63904710288556,89.85322107330335],\"size\":2.1069190705797576},{\"type\":\"cloud\",\"position\":[14.930324832962643,47.826202054803005,14.161826203389708],\"size\":1.991394833695241},{\"type\":\"bubble_willow\",\"position\":[-104.21039271332185,0,-69.85011091550493],\"scale\":0.981137013030323},{\"type\":\"wisteria_cluster\",\"position\":[24.989091468563654,0,12.307082045536129],\"scale\":0.9819735000275821},{\"type\":\"fiber_optic_willow\",\"position\":[24.534021839922204,0,118.61154111078731],\"scale\":1.2548326199633824},{\"type\":\"balloon_bush\",\"position\":[-102.82792707431676,0,-9.21062646983854],\"scale\":0.913549055317636},{\"type\":\"balloon_bush\",\"position\":[14.178878921321107,0,28.89571503316916],\"scale\":1.0982100939107595},{\"type\":\"floating_orb\",\"position\":[95.30292078285586,0,61.02756011347877],\"scale\":1.0647393320123202},{\"type\":\"cloud\",\"position\":[29.982936783662442,58.16298784565561,-91.5932686219503],\"size\":2.2209575619605175},{\"type\":\"balloon_bush\",\"position\":[-44.73742867588362,0,133.22581135491507],\"scale\":1.3077755833205171},{\"type\":\"bubble_willow\",\"position\":[-45.58541603736963,0,25.335591349028064],\"scale\":1.4249678222657163},{\"type\":\"floating_orb\",\"position\":[-20.634351887090375,0,-23.779953163048646],\"scale\":1.3453369392137333},{\"type\":\"balloon_bush\",\"position\":[106.78871809610276,0,-98.41562769696642],\"scale\":1.326730174699894},{\"type\":\"fiber_optic_willow\",\"position\":[62.525230438392924,0,-37.79147650103577],\"scale\":1.2711981703221982},{\"type\":\"fiber_optic_willow\",\"position\":[29.325436278883924,0,70.65249501956262],\"scale\":1.0447878689105452},{\"type\":\"balloon_bush\",\"position\":[-11.56638016213383,0,-38.63287456836198],\"scale\":1.051979992215855},{\"type\":\"bubble_willow\",\"position\":[-57.54095389482364,0,84.56635413617391],\"scale\":1.1728122071099474},{\"type\":\"bubble_willow\",\"position\":[28.357897417889102,0,-69.33057899102269],\"scale\":1.082035145700773},{\"type\":\"bubble_willow\",\"position\":[4.905169589238176,0,91.45344555338403],\"scale\":0.9605720199825255},{\"type\":\"bubble_willow\",\"position\":[-35.682411039133186,0,-17.163509067393967],\"scale\":1.2792921808127935},{\"type\":\"balloon_bush\",\"position\":[-107.56560131801643,0,-45.96977736187065],\"scale\":1.3795107807248075},{\"type\":\"cloud\",\"position\":[53.50851949529446,57.90814990794311,-45.8710449501235],\"size\":2.318201819863587},{\"type\":\"helix_plant\",\"position\":[-110.50945836523098,0,52.760747709629165],\"scale\":1.491778130896548},{\"type\":\"bubble_willow\",\"position\":[58.03222162944969,0,-61.655233471599814],\"scale\":1.4506397184317592},{\"type\":\"fiber_optic_willow\",\"position\":[34.27681368730905,0,-4.223024146425361],\"scale\":1.4020712593181388},{\"type\":\"starflower\",\"position\":[-98.79378038230723,0,-68.61064464023659],\"scale\":0.8029768492342146},{\"type\":\"mushroom\",\"position\":[83.56862436738759,0,113.66399809023576],\"scale\":1.0881989310243456,\"variant\":\"regular\"},{\"type\":\"starflower\",\"position\":[5.570006436107278,0,32.285183744086574],\"scale\":1.1590957618300273},{\"type\":\"starflower\",\"position\":[41.212353288792045,0,-69.04035700145205],\"scale\":1.0645568353373138},{\"type\":\"flower\",\"position\":[-3.776269663569565,0,-38.500557312621005],\"scale\":0.9032645740452868},{\"type\":\"starflower\",\"position\":[-54.54162581039797,0,21.684033226602367],\"scale\":0.7280974129239981},{\"type\":\"starflower\",\"position\":[40.58140635793505,0,-61.00393179479322],\"scale\":1.0518047956384475},{\"type\":\"starflower\",\"position\":[-33.79003737619261,0,-84.3201451708588],\"scale\":0.8213772682106502},{\"type\":\"starflower\",\"position\":[-16.28595661245259,0,38.246187237442044],\"scale\":1.0154137903761857},{\"type\":\"flower\",\"position\":[53.2447116961572,0,-91.01675821591172],\"scale\":0.8111344473446112},{\"type\":\"mushroom\",\"position\":[-20.52167052064164,0,128.73583771838403],\"scale\":0.9471573969760896,\"variant\":\"regular\"},{\"type\":\"starflower\",\"position\":[67.35700360134837,0,-13.421401746483115],\"scale\":1.0374444940777259},{\"type\":\"flower\",\"position\":[-70.47955347726388,0,87.45965210683737],\"scale\":0.8656062069257846},{\"type\":\"flower\",\"position\":[11.177346625237405,0,47.04180503327607],\"scale\":1.049798092900399},{\"type\":\"starflower\",\"position\":[-65.6226279550783,0,54.15810314574154],\"scale\":1.0842171934982554},{\"type\":\"starflower\",\"position\":[104.26010302283527,0,-1.9666461290503015],\"scale\":1.1225112230015404},{\"type\":\"starflower\",\"position\":[70.19947425903855,0,17.89327607345151],\"scale\":0.9704218416640702},{\"type\":\"mushroom\",\"position\":[127.65245559388775,0,-10.521860095943325],\"scale\":0.960408182250485,\"variant\":\"regular\"},{\"type\":\"starflower\",\"position\":[54.599292958110055,0,-72.10958043082795],\"scale\":0.75481529918018},{\"type\":\"starflower\",\"position\":[47.15614033555041,0,15.207426047120213],\"scale\":0.9059248363990436},{\"type\":\"flower\",\"position\":[99.48796871329509,0,20.158728102388224],\"scale\":0.9423356832627282},{\"type\":\"starflower\",\"position\":[131.97991646529772,0,-30.747861860286346],\"scale\":0.9240290946189861},{\"type\":\"mushroom\",\"position\":[15.374004283617019,0,-64.86767645046045],\"scale\":0.8750333611668917,\"variant\":\"regular\"},{\"type\":\"flower\",\"position\":[-8.755320756200314,0,-34.24754613098226],\"scale\":1.1699437175139953,\"variant\":\"glowing\"},{\"type\":\"starflower\",\"position\":[-99.3284364203347,0,9.437123897389059],\"scale\":1.0186957925959232},{\"type\":\"mushroom\",\"position\":[10.058729128353335,0,-24.231487428774233],\"scale\":0.7051809351607388,\"variant\":\"regular\"},{\"type\":\"mushroom\",\"position\":[-3.1840933352870056,0,-52.39982925864937],\"scale\":1.0759040250392813,\"variant\":\"regular\"},{\"type\":\"mushroom\",\"position\":[44.69993273495977,0,3.7886826487617955],\"scale\":1.0643661276559597,\"variant\":\"regular\"},{\"type\":\"starflower\",\"position\":[59.39024926873719,0,84.77543522714831],\"scale\":0.7252649969339251},{\"type\":\"flower\",\"position\":[-133.2096602986952,0,9.934495192558236],\"scale\":0.9111972666354243},{\"type\":\"flower\",\"position\":[137.85458393663967,0,23.330387938583016],\"scale\":1.185868561075155},{\"type\":\"starflower\",\"position\":[-33.18145734937935,0,0.3054941981711743],\"scale\":0.9161217340495502},{\"type\":\"starflower\",\"position\":[-99.58500839882545,0,90.58686459961527],\"scale\":0.7911386626967758},{\"type\":\"starflower\",\"position\":[-9.573106641160596,0,48.003524386981596],\"scale\":0.8990114835160267},{\"type\":\"mushroom\",\"position\":[-31.307703798869326,0,37.07132263672781],\"scale\":1.1977549857047534,\"variant\":\"regular\"},{\"type\":\"mushroom\",\"position\":[-35.27021366947536,0,-9.717393511360394],\"scale\":1.0770462848132514,\"variant\":\"regular\"},{\"type\":\"flower\",\"position\":[-50.10775077340466,0,-3.3595290325641307],\"scale\":0.7182020866008991},{\"type\":\"starflower\",\"position\":[-104.58565461571501,0,82.9475093707888],\"scale\":1.1989909478262528},{\"type\":\"mushroom\",\"position\":[-68.06741741943826,0,-36.65417035427972],\"scale\":0.7787047295661882,\"variant\":\"giant\"},{\"type\":\"mushroom\",\"position\":[-14.533722590821831,0,35.99621630983983],\"scale\":0.7126591122314838,\"variant\":\"regular\"},{\"type\":\"starflower\",\"position\":[42.44703308655852,0,-120.42461373768079],\"scale\":1.1762138655600531},{\"type\":\"mushroom\",\"position\":[-82.30544173086719,0,-85.75689974349531],\"scale\":1.1591572778342645,\"variant\":\"regular\"},{\"type\":\"starflower\",\"position\":[17.74431308134437,0,-100.17371199446997],\"scale\":1.159124701704125},{\"type\":\"flower\",\"position\":[-78.63505142398535,0,77.62193417582887],\"scale\":1.0821588668690536},{\"type\":\"mushroom\",\"position\":[-13.86946547839286,0,37.615098984910965],\"scale\":0.924560198680102,\"variant\":\"regular\"},{\"type\":\"starflower\",\"position\":[-76.95866768573926,0,-123.72005428992816],\"scale\":1.062105540705579},{\"type\":\"starflower\",\"position\":[-54.185539218591956,0,103.99552217300639],\"scale\":0.8231500381519387},{\"type\":\"starflower\",\"position\":[64.5165682386841,0,22.32166677818968],\"scale\":1.0450476769449328},{\"type\":\"mushroom\",\"position\":[3.7878963745810026,0,94.0276170264386],\"scale\":1.0633484624027718,\"variant\":\"regular\"},{\"type\":\"starflower\",\"position\":[-61.218140045781745,0,-16.626953384097867],\"scale\":1.0282124616470731},{\"type\":\"grass\",\"position\":[-40.224606302122346,0,88.66716632004623],\"scale\":1.1155439666378004},{\"type\":\"grass\",\"position\":[29.49670574023934,0,-11.485414893893623],\"scale\":1.2642570900883336},{\"type\":\"grass\",\"position\":[78.87839350420535,0,45.642029960179705],\"scale\":1.1715374011178483},{\"type\":\"grass\",\"position\":[13.399435175555215,0,6.888057722321276],\"scale\":1.256902535931454},{\"type\":\"grass\",\"position\":[-8.94070652713972,0,-26.809920314078813],\"scale\":1.2489746936968593},{\"type\":\"grass\",\"position\":[-0.9644812692296744,0,0.2696649023445153],\"scale\":1.29584274279433},{\"type\":\"grass\",\"position\":[-75.04207845424102,0,-58.296982975678084],\"scale\":0.9227184537138231},{\"type\":\"grass\",\"position\":[0.2559900583920787,0,33.11773198436068],\"scale\":1.1179576592720433},{\"type\":\"grass\",\"position\":[118.38337354142848,0,-28.557459803157784],\"scale\":0.9277671782577481},{\"type\":\"grass\",\"position\":[-101.62754927076448,0,74.43192957100437],\"scale\":0.8620193157613671},{\"type\":\"grass\",\"position\":[72.26869644992071,0,46.24914757185332],\"scale\":1.00722981126795},{\"type\":\"grass\",\"position\":[-14.672605923640598,0,-12.047672299378851],\"scale\":0.7354388371688114},{\"type\":\"grass\",\"position\":[-9.537808167750951,0,-18.41845488220492],\"scale\":1.1730594024382723},{\"type\":\"grass\",\"position\":[31.426693792322183,0,-12.711792148335114],\"scale\":0.7044156248131238},{\"type\":\"grass\",\"position\":[-101.31012795084501,0,-53.1181267588117],\"scale\":1.0476540522148385},{\"type\":\"grass\",\"position\":[-100.87663990202613,0,10.536084404174968],\"scale\":0.9661387102818664},{\"type\":\"grass\",\"position\":[-40.3080550413268,0,-34.65671934411471],\"scale\":1.0177272081775828},{\"type\":\"grass\",\"position\":[56.57395741385441,0,-3.3773113662074596],\"scale\":1.0317886364310742},{\"type\":\"grass\",\"position\":[-45.2404789319899,0,7.466772125231933],\"scale\":1.0809817528640036},{\"type\":\"grass\",\"position\":[16.068111889448797,0,64.86985327628564],\"scale\":1.085284103553197},{\"type\":\"grass\",\"position\":[-41.62818670907434,0,-87.38687555497019],\"scale\":0.8356481578697109},{\"type\":\"grass\",\"position\":[-65.42175138047715,0,108.3615457698386],\"scale\":1.0099896105693928},{\"type\":\"grass\",\"position\":[3.971881311012148,0,136.78749839508885],\"scale\":1.1073403205007701},{\"type\":\"grass\",\"position\":[-24.369870185780854,0,-32.79727000866275],\"scale\":1.253983845504835},{\"type\":\"grass\",\"position\":[-87.87587192136053,0,-92.86017642291407],\"scale\":1.0642044837496578},{\"type\":\"grass\",\"position\":[-19.888944562819358,0,3.828110019535847],\"scale\":0.744752744852209},{\"type\":\"grass\",\"position\":[-78.42132942612078,0,-78.6380032844276],\"scale\":0.9062331823518183},{\"type\":\"grass\",\"position\":[1.7479739568467076,0,2.1786920014301656],\"scale\":0.7674758288094435},{\"type\":\"grass\",\"position\":[126.21233285670827,0,35.41415752493337],\"scale\":0.7455646044452199},{\"type\":\"grass\",\"position\":[-82.26408504962181,0,-111.60783572264003],\"scale\":1.2692399559114054},{\"type\":\"grass\",\"position\":[-62.957600523471946,0,-135.83717108837172],\"scale\":1.1483042328075783},{\"type\":\"grass\",\"position\":[49.37886864212827,0,5.653326857734159],\"scale\":0.7756680556480327},{\"type\":\"grass\",\"position\":[-17.490174341284597,0,-104.1916436877125],\"scale\":1.0357750553519014},{\"type\":\"grass\",\"position\":[-11.556232869651264,0,-148.10720408246868],\"scale\":0.9793832305814709},{\"type\":\"grass\",\"position\":[66.46743977626296,0,-69.22621322948915],\"scale\":0.9702030918129629},{\"type\":\"grass\",\"position\":[38.52857435396466,0,69.56232389189513],\"scale\":0.725192081200262},{\"type\":\"grass\",\"position\":[53.2902661504508,0,-87.40592258401516],\"scale\":0.7549662615789835},{\"type\":\"grass\",\"position\":[36.47060835392114,0,4.094128987448922],\"scale\":0.9315459821818255},{\"type\":\"grass\",\"position\":[-0.5802479146083404,0,-13.51591832464047],\"scale\":0.7653801114268988},{\"type\":\"grass\",\"position\":[-53.432468492533665,0,4.184783760021439],\"scale\":0.9751625305040141},{\"type\":\"grass\",\"position\":[-41.23659227571577,0,-11.152974027741402],\"scale\":1.0129793324556147},{\"type\":\"grass\",\"position\":[-107.41014996111174,0,29.829447610531236],\"scale\":1.096008669466166},{\"type\":\"grass\",\"position\":[-60.015246624834255,0,84.04451260143894],\"scale\":1.1524489956983919},{\"type\":\"grass\",\"position\":[14.262701827865138,0,-83.96253227276596],\"scale\":1.226132738113743},{\"type\":\"grass\",\"position\":[29.986461958201907,0,-97.25707725941047],\"scale\":1.2820111919711197},{\"type\":\"grass\",\"position\":[77.93517982344933,0,-86.01117356637063],\"scale\":0.9285565658237587},{\"type\":\"grass\",\"position\":[-122.95180133598735,0,3.734761362566861],\"scale\":1.0909808830839767},{\"type\":\"grass\",\"position\":[-59.16438138400367,0,9.885803081603564],\"scale\":0.9471807240113808},{\"type\":\"grass\",\"position\":[-72.48111655270569,0,-19.24235058541695],\"scale\":0.7355273855412952},{\"type\":\"grass\",\"position\":[46.03616717814444,0,-22.958051844609383],\"scale\":0.7086354314425614},{\"type\":\"grass\",\"position\":[26.37926469110247,0,-67.62543348055861],\"scale\":1.101147680898334},{\"type\":\"grass\",\"position\":[3.871258035747109,0,-6.305249289625429],\"scale\":0.835335021876676},{\"type\":\"grass\",\"position\":[28.881993886275296,0,-143.65781298623992],\"scale\":0.820149041437413},{\"type\":\"grass\",\"position\":[-67.28800115376366,0,-125.34102037278332],\"scale\":1.1095847141427932},{\"type\":\"grass\",\"position\":[3.3357624673472825,0,25.95123783555957],\"scale\":0.9567340409941774},{\"type\":\"grass\",\"position\":[-38.97863663844068,0,-23.340201333473207],\"scale\":1.0964229385256783},{\"type\":\"grass\",\"position\":[75.86050703822835,0,14.981788568422889],\"scale\":1.2589169852509818},{\"type\":\"grass\",\"position\":[-3.182962957042341,0,-15.605750919440668],\"scale\":0.8929342238237636},{\"type\":\"grass\",\"position\":[12.62315173755678,0,8.397871443563881],\"scale\":1.246297702121991},{\"type\":\"grass\",\"position\":[-2.438376981172182,0,2.9546385029455418],\"scale\":0.9476291176531797},{\"type\":\"grass\",\"position\":[65.2586796587984,0,40.811120473340154],\"scale\":1.0919341288392412},{\"type\":\"grass\",\"position\":[-94.59676406253925,0,-113.02463265123276],\"scale\":1.297706187260823},{\"type\":\"grass\",\"position\":[33.571238307956406,0,15.696813697512633],\"scale\":1.1517099317812785},{\"type\":\"grass\",\"position\":[26.786718006246947,0,-45.36669674016031],\"scale\":0.9188595363697846},{\"type\":\"grass\",\"position\":[-34.583516368154235,0,47.43458344228923],\"scale\":0.982543322257561},{\"type\":\"grass\",\"position\":[132.1083331454044,0,64.23942120450255],\"scale\":0.7579322367735626},{\"type\":\"grass\",\"position\":[84.47661745777776,0,32.13634127267056],\"scale\":0.9574729488534842},{\"type\":\"grass\",\"position\":[4.225476128647864,0,-136.2286997261639],\"scale\":1.1553559764635464},{\"type\":\"grass\",\"position\":[-31.22936655173142,0,-58.36328471846716],\"scale\":0.7978409360448993},{\"type\":\"grass\",\"position\":[-79.07403735904492,0,18.34538990505383],\"scale\":0.8640403005014148},{\"type\":\"grass\",\"position\":[53.06023881341177,0,-38.84548375586767],\"scale\":1.1755632981129944},{\"type\":\"grass\",\"position\":[-25.92963926760198,0,14.269163447425788],\"scale\":1.1069476571635037},{\"type\":\"grass\",\"position\":[-98.21111158201454,0,-40.41767800187973],\"scale\":0.7627131997969783},{\"type\":\"grass\",\"position\":[-8.989363125916668,0,21.750818840253764],\"scale\":1.1355597944426061},{\"type\":\"grass\",\"position\":[68.21535070417103,0,129.30889198883114],\"scale\":0.7785988530141723},{\"type\":\"grass\",\"position\":[-120.59468602339827,0,-63.557219591057596],\"scale\":1.174990824412318},{\"type\":\"grass\",\"position\":[-97.22178539733324,0,-2.196180166481396],\"scale\":1.2596998280451182},{\"type\":\"grass\",\"position\":[38.88113456361245,0,2.2833717713519888],\"scale\":0.9552813215163449},{\"type\":\"grass\",\"position\":[-2.3062701719183463,0,9.553126297272447],\"scale\":1.2167048319309415},{\"type\":\"grass\",\"position\":[63.76774932483908,0,1.9757017700868549],\"scale\":0.7728121965770454},{\"type\":\"grass\",\"position\":[66.39205640539981,0,40.226409240915956],\"scale\":1.1004284667198472},{\"type\":\"grass\",\"position\":[10.900691156026,0,18.327557053344616],\"scale\":0.9565960933300692},{\"type\":\"grass\",\"position\":[-60.69477845029607,0,18.7140336409257],\"scale\":1.2124293922007814},{\"type\":\"grass\",\"position\":[68.48457527581287,0,119.18598998421061],\"scale\":1.0796497928324233},{\"type\":\"grass\",\"position\":[-40.02642733317911,0,-8.879242690664865],\"scale\":1.212372194739609},{\"type\":\"grass\",\"position\":[-33.74773885069591,0,-24.03254590383261],\"scale\":1.2848592126944782},{\"type\":\"grass\",\"position\":[82.17638854402222,0,-111.97144179771927],\"scale\":0.8797457253478534},{\"type\":\"grass\",\"position\":[-17.47298866734567,0,-9.63145457612079],\"scale\":0.8495715915189389},{\"type\":\"grass\",\"position\":[18.020082621441933,0,36.869687132061024],\"scale\":1.0527448716865697},{\"type\":\"grass\",\"position\":[-107.26716409027023,0,37.03109348082953],\"scale\":1.006342680253177},{\"type\":\"grass\",\"position\":[73.20331680029467,0,6.796817425733018],\"scale\":0.7514542560463259},{\"type\":\"grass\",\"position\":[90.2495008941049,0,-4.950676756320516],\"scale\":1.162959274471382},{\"type\":\"grass\",\"position\":[-29.497846985344623,0,-2.8962142908417583],\"scale\":0.9518168170419025},{\"type\":\"grass\",\"position\":[40.81243281664545,0,72.41243720861506],\"scale\":1.1881407607888659},{\"type\":\"grass\",\"position\":[-99.39689396788162,0,99.6687403927573],\"scale\":0.9241058091321123},{\"type\":\"grass\",\"position\":[16.82445162997113,0,-13.363781112466215],\"scale\":1.199425265270488},{\"type\":\"grass\",\"position\":[69.12624955246363,0,-109.18066996710493],\"scale\":0.906962460027425},{\"type\":\"grass\",\"position\":[105.74020279794098,0,14.542997525355494],\"scale\":0.8661279956047803},{\"type\":\"grass\",\"position\":[69.37961668258872,0,-132.86388108517735],\"scale\":1.2797788930387188},{\"type\":\"grass\",\"position\":[3.5679298720038473,0,-53.50321454671526],\"scale\":1.2337801600134752},{\"type\":\"grass\",\"position\":[58.822363045620484,0,42.164812905633966],\"scale\":0.837139500363596},{\"type\":\"grass\",\"position\":[-45.087399920015706,0,-20.63737199824753],\"scale\":0.8165825398330686},{\"type\":\"grass\",\"position\":[18.20478243642269,0,-58.27135333060699],\"scale\":0.9825989418284244},{\"type\":\"grass\",\"position\":[-30.596292555242268,0,120.01635672967058],\"scale\":0.7619032915999128},{\"type\":\"grass\",\"position\":[7.115612927757553,0,-38.39253285373722],\"scale\":1.2680267723384664},{\"type\":\"grass\",\"position\":[27.294591856016666,0,-100.64078016379078],\"scale\":0.8848519067976846},{\"type\":\"grass\",\"position\":[-40.00927881398752,0,128.05491036419193],\"scale\":1.1230902266573688},{\"type\":\"grass\",\"position\":[51.95600922694237,0,-16.448722927836137],\"scale\":0.9125142470871089},{\"type\":\"grass\",\"position\":[11.115434623527168,0,-25.56189661738778],\"scale\":0.9940955465251295},{\"type\":\"grass\",\"position\":[124.94179194251853,0,39.640017297819384],\"scale\":0.9360241845232811},{\"type\":\"grass\",\"position\":[-1.234415980536876,0,-10.93507894278297],\"scale\":0.9466137166514864},{\"type\":\"grass\",\"position\":[-81.46042280550279,0,31.01526981935986],\"scale\":0.8603365965140133},{\"type\":\"grass\",\"position\":[-20.443173518626956,0,24.353662770343757],\"scale\":1.2452134261114667},{\"type\":\"grass\",\"position\":[50.45894721231636,0,-47.315117825036225],\"scale\":1.1411953482418558},{\"type\":\"grass\",\"position\":[95.36423403051465,0,70.62487536389473],\"scale\":0.9024007967116973},{\"type\":\"grass\",\"position\":[129.6928056745914,0,-68.99239117079242],\"scale\":0.8847689272902186},{\"type\":\"grass\",\"position\":[1.3432165667064246,0,-24.679635362721836],\"scale\":1.288368977908338},{\"type\":\"grass\",\"position\":[-7.617108322124396,0,-14.00583882371436],\"scale\":0.9185627050053469},{\"type\":\"grass\",\"position\":[79.79125889705239,0,38.91633066877678],\"scale\":1.1853640533067524},{\"type\":\"grass\",\"position\":[-17.707975128657477,0,71.58123583990907],\"scale\":0.8885369625802138},{\"type\":\"grass\",\"position\":[-20.297980752926637,0,-15.295896084810877],\"scale\":1.062349142705759},{\"type\":\"grass\",\"position\":[7.524420481646106,0,-7.396444841829288],\"scale\":1.252747953420119},{\"type\":\"grass\",\"position\":[-3.5214087081339907,0,1.5472164996784858],\"scale\":1.0312610989725175},{\"type\":\"grass\",\"position\":[50.34676726826115,0,-66.18159847195496],\"scale\":1.0964591288241756},{\"type\":\"grass\",\"position\":[145.23269593433395,0,15.143487987173172],\"scale\":0.7405223862964222},{\"type\":\"grass\",\"position\":[59.39712003345788,0,58.01662381750592],\"scale\":0.7824587142730901},{\"type\":\"grass\",\"position\":[59.62595401518529,0,38.059369899739835],\"scale\":1.1279431330381864},{\"type\":\"grass\",\"position\":[70.48692167374313,0,53.58682544460579],\"scale\":1.048091778275365},{\"type\":\"grass\",\"position\":[37.72046463162383,0,53.24193796982694],\"scale\":0.9832612185308076},{\"type\":\"grass\",\"position\":[-2.7461959203503437,0,1.1866331220418662],\"scale\":1.2648869103156226},{\"type\":\"grass\",\"position\":[38.957176548362504,0,-43.738171633984045],\"scale\":1.05694747981522},{\"type\":\"grass\",\"position\":[34.785859799201226,0,132.73625909018705],\"scale\":1.2469940448617625},{\"type\":\"grass\",\"position\":[-13.32359201840515,0,-68.65843824148907],\"scale\":0.8268691004988262},{\"type\":\"grass\",\"position\":[-25.63762867797389,0,42.530542503039015],\"scale\":1.290117651433453},{\"type\":\"grass\",\"position\":[102.4622466578651,0,103.87709799178009],\"scale\":1.1605086547296026},{\"type\":\"grass\",\"position\":[-34.0785593189208,0,-26.927677544103382],\"scale\":1.2055610561400942},{\"type\":\"grass\",\"position\":[-36.33219973519261,0,-143.98354405300543],\"scale\":0.7541482332892452},{\"type\":\"grass\",\"position\":[17.449888781044667,0,-146.90391335931704],\"scale\":0.8733539193158654},{\"type\":\"grass\",\"position\":[10.868461710317852,0,-7.01230392844783],\"scale\":1.044419418375287},{\"type\":\"grass\",\"position\":[26.05307950882642,0,92.76414921188459],\"scale\":0.8261639467175707},{\"type\":\"grass\",\"position\":[72.83420293576187,0,-15.027691418067164],\"scale\":1.2384427781525602},{\"type\":\"grass\",\"position\":[148.13320828135176,0,5.4484203100501345],\"scale\":0.9105897556980781},{\"type\":\"grass\",\"position\":[-32.285450704302484,0,81.43287601909033],\"scale\":1.2753119666771209},{\"type\":\"grass\",\"position\":[-59.20789280293197,0,-24.88119227995956],\"scale\":1.0721616174855337},{\"type\":\"grass\",\"position\":[46.240469559014485,0,35.80974153990875],\"scale\":1.146926334139364},{\"type\":\"grass\",\"position\":[-42.840184905603486,0,1.7596100994103798],\"scale\":0.879369486552138},{\"type\":\"grass\",\"position\":[-15.65933723208958,0,112.21488879153115],\"scale\":0.7761293193337429},{\"type\":\"grass\",\"position\":[-56.81443665080664,0,-17.564588794574764],\"scale\":0.8345906044971283},{\"type\":\"grass\",\"position\":[-24.151655781665323,0,30.690287523448962],\"scale\":1.1375824541591022},{\"type\":\"grass\",\"position\":[-44.348414860027795,0,109.07293976394934],\"scale\":0.7096742968755095},{\"type\":\"grass\",\"position\":[-127.82215325278719,0,43.06606793880819],\"scale\":0.7396849763450158},{\"type\":\"grass\",\"position\":[-9.443102605200856,0,116.31351915024248],\"scale\":1.216661790024172},{\"type\":\"grass\",\"position\":[-84.74596839126035,0,14.18139874007135],\"scale\":1.2694524676288816},{\"type\":\"grass\",\"position\":[-4.521638749791105,0,-2.1873990325911015],\"scale\":0.9545803874605205},{\"type\":\"grass\",\"position\":[85.42179965935324,0,-82.66865772963186],\"scale\":1.0574430809438413},{\"type\":\"grass\",\"position\":[-26.622744206088775,0,-60.09973206499013],\"scale\":0.9234576403343066},{\"type\":\"grass\",\"position\":[39.65360307748638,0,101.84437736108357],\"scale\":0.9126502477997942},{\"type\":\"grass\",\"position\":[18.899665301984104,0,-80.2068784638265],\"scale\":1.1917818461617407},{\"type\":\"grass\",\"position\":[102.07496773050401,0,35.767837452574206],\"scale\":0.720343726691334},{\"type\":\"grass\",\"position\":[97.33935644564765,0,-0.9239341730813263],\"scale\":0.9722499743171693},{\"type\":\"grass\",\"position\":[-83.25393310692475,0,-47.28744589920778],\"scale\":0.8899242046477293},{\"type\":\"grass\",\"position\":[17.38430083111663,0,-0.38205017044511846],\"scale\":0.9958083244866308},{\"type\":\"grass\",\"position\":[-8.886058510121066,0,5.817955644939584],\"scale\":0.7933525775572026},{\"type\":\"grass\",\"position\":[-8.775833185442748,0,38.039141565498745],\"scale\":0.8454611895653577},{\"type\":\"grass\",\"position\":[16.520015655596275,0,86.85528077091735],\"scale\":0.7812238079730128},{\"type\":\"grass\",\"position\":[-8.227890481046225,0,-17.547631410319063],\"scale\":0.9678484429212852},{\"type\":\"grass\",\"position\":[9.10638845308136,0,51.56851237197381],\"scale\":1.209947320573832},{\"type\":\"grass\",\"position\":[-91.3009120257776,0,99.12582384304133],\"scale\":1.005434576378637},{\"type\":\"grass\",\"position\":[93.59987669163357,0,76.61664778675878],\"scale\":1.1000596370081528},{\"type\":\"grass\",\"position\":[-1.016673158917464,0,-6.656289786066545],\"scale\":1.1731602549399058},{\"type\":\"grass\",\"position\":[66.53388798777246,0,52.24710466269961],\"scale\":0.7534773288334299},{\"type\":\"grass\",\"position\":[37.90019563918074,0,-11.191452422252304],\"scale\":1.1913963423210456},{\"type\":\"grass\",\"position\":[-148.04452324579466,0,-12.69364268125356],\"scale\":1.1272422567132536},{\"type\":\"grass\",\"position\":[72.32318080411001,0,106.49655264352718],\"scale\":0.8993345479215611},{\"type\":\"grass\",\"position\":[-76.77702829433937,0,-4.509956296218764],\"scale\":0.8707132545504399},{\"type\":\"grass\",\"position\":[-4.510858115349918,0,-44.47453171351764],\"scale\":0.919920216887648},{\"type\":\"grass\",\"position\":[-72.23624545951137,0,-38.862990120358184],\"scale\":0.9858983555744414},{\"type\":\"grass\",\"position\":[41.19299520789998,0,4.580603579411891],\"scale\":1.2412662635237512},{\"type\":\"grass\",\"position\":[-0.5435184586024664,0,-0.09103534048253643],\"scale\":1.1730513401095677},{\"type\":\"grass\",\"position\":[-24.456833054952277,0,11.604677698250237],\"scale\":1.1613308499563817},{\"type\":\"grass\",\"position\":[120.797996087196,0,57.405458404818575],\"scale\":1.2299916298943103},{\"type\":\"grass\",\"position\":[-29.350235535136502,0,72.90409846033177],\"scale\":0.9204262847523583},{\"type\":\"grass\",\"position\":[6.39509560218622,0,104.95448245735399],\"scale\":0.7798375194285542},{\"type\":\"grass\",\"position\":[37.60564883418944,0,78.16841160547652],\"scale\":0.9308642717445313},{\"type\":\"grass\",\"position\":[113.02663924207218,0,-33.73797545644238],\"scale\":1.0835738553482712},{\"type\":\"grass\",\"position\":[102.6552528247468,0,-71.75546469735424],\"scale\":1.126310396493666},{\"type\":\"grass\",\"position\":[-0.3704434176303861,0,-1.5256259574691227],\"scale\":1.241150370272407},{\"type\":\"grass\",\"position\":[-32.04855480188744,0,1.5692356974688992],\"scale\":0.8008215370123453},{\"type\":\"grass\",\"position\":[-99.59985870600033,0,43.93503227442674],\"scale\":1.110195936178879},{\"type\":\"grass\",\"position\":[-43.06479895101122,0,71.59083446551689],\"scale\":0.9623867600426691},{\"type\":\"grass\",\"position\":[-148.76271497383138,0,4.623855853527239],\"scale\":0.7815454924243685},{\"type\":\"grass\",\"position\":[70.81613195769235,0,39.08174487063695],\"scale\":0.8089767631712371},{\"type\":\"grass\",\"position\":[133.11960703625198,0,-43.69010843812184],\"scale\":1.1717033306414502},{\"type\":\"grass\",\"position\":[95.08641088367814,0,-83.26009536896893],\"scale\":0.7926681440900515},{\"type\":\"grass\",\"position\":[31.105524952916486,0,6.2816006161874585],\"scale\":1.0108419583066128},{\"type\":\"grass\",\"position\":[-10.2906911012679,0,-133.3405365227227],\"scale\":1.0418690246714621},{\"type\":\"grass\",\"position\":[-28.665831307186657,0,-10.571448062729752],\"scale\":1.2303607459138999},{\"type\":\"grass\",\"position\":[9.166488176792258,0,-8.792990580525409],\"scale\":0.9864973643865113},{\"type\":\"grass\",\"position\":[-63.935978124796684,0,47.28448596539051],\"scale\":1.1769404281756606},{\"type\":\"grass\",\"position\":[4.650487162407939,0,-64.6921587207435],\"scale\":1.062003428717598},{\"type\":\"grass\",\"position\":[-44.94991603417729,0,67.27971779845267],\"scale\":1.1769500322592368},{\"type\":\"grass\",\"position\":[-131.09127290565868,0,-59.35353372031855],\"scale\":0.7656364385867788},{\"type\":\"grass\",\"position\":[48.805488120415994,0,-17.787379628772904],\"scale\":0.7497939863990112},{\"type\":\"grass\",\"position\":[22.24448168919144,0,66.09396324776273],\"scale\":0.8220126610188393},{\"type\":\"grass\",\"position\":[66.16112756182204,0,-104.3482166182268],\"scale\":0.7713769823826204},{\"type\":\"grass\",\"position\":[134.6853986162883,0,22.341843950368517],\"scale\":0.7963784554197731},{\"type\":\"grass\",\"position\":[10.223468743292033,0,-12.602376859852116],\"scale\":1.0129214291108606},{\"type\":\"grass\",\"position\":[102.23964718858161,0,-30.11652910336166],\"scale\":1.1716121605378633},{\"type\":\"grass\",\"position\":[-33.64871161959679,0,-0.4468989078060573],\"scale\":0.8452922758548734},{\"type\":\"grass\",\"position\":[82.98265674471371,0,73.06023048323623],\"scale\":1.021333007046529},{\"type\":\"grass\",\"position\":[0.5203529057461291,0,0.38840260882492356],\"scale\":0.8344355533395977},{\"type\":\"grass\",\"position\":[25.85390372616859,0,20.43773543639258],\"scale\":0.9723245473838072},{\"type\":\"grass\",\"position\":[55.40568133687721,0,-25.20695676267458],\"scale\":1.2382355162628171},{\"type\":\"grass\",\"position\":[-11.81527225328515,0,3.644366464111925],\"scale\":1.0547626641618877},{\"type\":\"grass\",\"position\":[-1.8402607807257703,0,0.8385649611738513],\"scale\":1.297252005784732},{\"type\":\"grass\",\"position\":[8.02759253140476,0,-3.3140658957794784],\"scale\":1.1667943605942979},{\"type\":\"grass\",\"position\":[-7.8828591259374985,0,-96.02260524719489],\"scale\":1.09948556886026},{\"type\":\"grass\",\"position\":[-93.8728652152619,0,32.14444012455027],\"scale\":0.8148342002595091},{\"type\":\"grass\",\"position\":[-110.6311146254265,0,-90.78769204665507],\"scale\":1.0936939175286189},{\"type\":\"grass\",\"position\":[-50.23849713543384,0,132.43323142532043],\"scale\":0.7880696827115307},{\"type\":\"grass\",\"position\":[83.76312288649977,0,47.59051929444255],\"scale\":0.8133488845995638},{\"type\":\"grass\",\"position\":[135.9052167362978,0,10.535801896142406],\"scale\":0.7875999667957335},{\"type\":\"grass\",\"position\":[9.081205747489468,0,-21.015999342651963],\"scale\":0.8946843830601817},{\"type\":\"grass\",\"position\":[-122.7366049193326,0,13.661023145227698],\"scale\":1.2104787202366212},{\"type\":\"grass\",\"position\":[-5.063812003801405,0,114.59721437621477],\"scale\":0.9112987247655049},{\"type\":\"grass\",\"position\":[-142.23397139707834,0,10.352400340437436],\"scale\":1.148903987081618},{\"type\":\"grass\",\"position\":[107.52558284655713,0,-8.899485749182332],\"scale\":1.2092602176744327},{\"type\":\"grass\",\"position\":[-45.081700711490875,0,110.70818114180746],\"scale\":0.9026313818425805},{\"type\":\"grass\",\"position\":[41.27307875958696,0,13.418878620219045],\"scale\":0.7130512282805896},{\"type\":\"grass\",\"position\":[117.86835206112607,0,84.50214513735966],\"scale\":1.0284786111215034},{\"type\":\"grass\",\"position\":[-37.90214717477938,0,30.13411275676683],\"scale\":0.9079897210074269},{\"type\":\"grass\",\"position\":[-71.73936360442524,0,-56.17530689580969],\"scale\":0.9925938892963833},{\"type\":\"grass\",\"position\":[-57.83031007048966,0,8.718394048389344],\"scale\":1.067623435452634},{\"type\":\"grass\",\"position\":[-15.880830589457913,0,-83.37239063991504],\"scale\":1.2827249641025469},{\"type\":\"grass\",\"position\":[-76.40930267733599,0,-47.920853861370595],\"scale\":0.8162965723375948},{\"type\":\"grass\",\"position\":[-65.4712661247593,0,-50.355238686540986],\"scale\":0.954843126949187},{\"type\":\"grass\",\"position\":[-83.66216814322422,0,-25.071676693147904],\"scale\":1.1628025915528852},{\"type\":\"grass\",\"position\":[1.788967912467652,0,-2.841403194450765],\"scale\":0.7646807273752201},{\"type\":\"grass\",\"position\":[15.353699348111782,0,3.7175261280804803],\"scale\":1.0699408386572984},{\"type\":\"grass\",\"position\":[-57.18246163149962,0,-125.50360814623416],\"scale\":1.1154199837961498},{\"type\":\"grass\",\"position\":[-56.04504481789258,0,-104.87333729501518],\"scale\":1.155987081017504},{\"type\":\"grass\",\"position\":[13.53449475779047,0,37.92055256762537],\"scale\":1.1551970020283537},{\"type\":\"grass\",\"position\":[18.230665449799055,0,-12.782728702635486],\"scale\":1.2654169089795642},{\"type\":\"grass\",\"position\":[-40.14341506316663,0,31.644524239489353],\"scale\":0.8693154216927593},{\"type\":\"grass\",\"position\":[33.445604039279424,0,51.26218659239685],\"scale\":1.0859393949579472},{\"type\":\"grass\",\"position\":[0.8616445830655316,0,1.1020739166944191],\"scale\":0.9413280240882425},{\"type\":\"grass\",\"position\":[2.7775698737158687,0,-58.86050800999703],\"scale\":0.9723777895225532},{\"type\":\"grass\",\"position\":[-6.251838286528276,0,5.461560480699522],\"scale\":0.9968424625200731},{\"type\":\"grass\",\"position\":[-38.27300074126379,0,-66.46548337448812],\"scale\":0.721359057495271},{\"type\":\"grass\",\"position\":[79.96950238233057,0,85.33861592339908],\"scale\":0.9388370129318381},{\"type\":\"grass\",\"position\":[6.693302647298839,0,-2.1472616509855604],\"scale\":1.126450240895759},{\"type\":\"grass\",\"position\":[6.765984448684301,0,-59.96033226027662],\"scale\":0.7497830875116899},{\"type\":\"grass\",\"position\":[-133.95237617998677,0,-23.16131957055671],\"scale\":0.9846207857083846},{\"type\":\"grass\",\"position\":[-21.2871160329136,0,-125.18943140371854],\"scale\":0.8333240839150429},{\"type\":\"grass\",\"position\":[-69.63119147015426,0,104.17097845774711],\"scale\":1.2446914519221295},{\"type\":\"grass\",\"position\":[4.288390749285088,0,-70.32756583896152],\"scale\":0.7925646273289663},{\"type\":\"grass\",\"position\":[-51.56369346862107,0,69.92556488817245],\"scale\":1.0226090721395695},{\"type\":\"grass\",\"position\":[-110.80592092925767,0,78.36114306179037],\"scale\":1.2886548932774942},{\"type\":\"grass\",\"position\":[-8.022492631484354,0,-14.05182664361155],\"scale\":1.053106477752945},{\"type\":\"grass\",\"position\":[-11.691396399575005,0,-139.8496760470369],\"scale\":1.0499048330454939},{\"type\":\"grass\",\"position\":[-32.42216947386779,0,26.035117024545933],\"scale\":0.8291060863698108},{\"type\":\"grass\",\"position\":[-41.363038300020335,0,-79.8133011085671],\"scale\":1.060730264048222},{\"type\":\"grass\",\"position\":[-75.6206650818336,0,61.364654765657114],\"scale\":1.2433487196675705},{\"type\":\"grass\",\"position\":[-26.586968570679108,0,32.6035503665551],\"scale\":0.7339515198930558},{\"type\":\"grass\",\"position\":[-28.051409751144664,0,-58.90321315695843],\"scale\":0.9658440066802902},{\"type\":\"grass\",\"position\":[134.67511444592026,0,30.97974172784888],\"scale\":0.7374630341343823},{\"type\":\"grass\",\"position\":[-136.21265385586588,0,3.1654592349380946],\"scale\":1.1597118454931257},{\"type\":\"grass\",\"position\":[-138.69726628104377,0,-39.38771445976873],\"scale\":0.956092677809337},{\"type\":\"grass\",\"position\":[-7.198416246683235,0,-21.151125073027522],\"scale\":1.1692826439361603},{\"type\":\"grass\",\"position\":[87.63788966949606,0,-93.4520825404099],\"scale\":0.8612752661548893},{\"type\":\"grass\",\"position\":[-21.111186227804676,0,93.47878443213855],\"scale\":1.1980746615751656},{\"type\":\"grass\",\"position\":[44.79694442485528,0,59.23849119036464],\"scale\":0.7119856805425743},{\"type\":\"grass\",\"position\":[59.178372935580384,0,-107.68862427770034],\"scale\":1.2035388405385599},{\"type\":\"grass\",\"position\":[-29.249277564631253,0,42.056683274774244],\"scale\":1.268207081940342},{\"type\":\"grass\",\"position\":[-0.42512747795255773,0,-0.591105029395798],\"scale\":0.9420141688145963},{\"type\":\"grass\",\"position\":[-62.18846329219887,0,-27.317277082943267],\"scale\":0.7669981245258047},{\"type\":\"grass\",\"position\":[34.458822020672145,0,-59.22457336928772],\"scale\":0.877198164347179},{\"type\":\"grass\",\"position\":[-29.524743484545215,0,-14.35798638989075],\"scale\":1.0639049000836476},{\"type\":\"grass\",\"position\":[83.43830880918414,0,8.596037897661843],\"scale\":0.7638824871244876},{\"type\":\"grass\",\"position\":[9.920519742442641,0,148.6647292603153],\"scale\":0.7284098620536614},{\"type\":\"grass\",\"position\":[5.021804123924353,0,-13.28151509930096],\"scale\":1.1886452256006959},{\"type\":\"grass\",\"position\":[55.588344002385035,0,-11.682029743201522],\"scale\":0.8977662126989925},{\"type\":\"grass\",\"position\":[109.22306634085588,0,-63.48632224565416],\"scale\":0.7122970464163272},{\"type\":\"grass\",\"position\":[21.08672031118623,0,99.2718369733624],\"scale\":1.0156393665923724},{\"type\":\"grass\",\"position\":[-18.265824479150837,0,-12.677515316424353],\"scale\":0.7479444943081148},{\"type\":\"grass\",\"position\":[-75.48572368157566,0,-50.64522505545194],\"scale\":1.1489590459095036},{\"type\":\"grass\",\"position\":[-14.41364162049793,0,114.90720804164603],\"scale\":0.8666304210840309},{\"type\":\"grass\",\"position\":[-58.66229862311642,0,-2.8353791677084823],\"scale\":1.281466901970666},{\"type\":\"grass\",\"position\":[34.816829686110985,0,-25.755054943851068],\"scale\":1.1489414375043272},{\"type\":\"grass\",\"position\":[92.2116762306731,0,13.240962860849518],\"scale\":1.124709788891288},{\"type\":\"grass\",\"position\":[-84.65340677606055,0,46.41675181284883],\"scale\":0.9691524947431523},{\"type\":\"grass\",\"position\":[103.00810228219308,0,-39.89575269372713],\"scale\":0.8070089253732904},{\"type\":\"grass\",\"position\":[-48.04482269387033,0,-80.47995482970441],\"scale\":1.2676021296553979},{\"type\":\"grass\",\"position\":[15.852912212178083,0,80.9101783927362],\"scale\":0.8835791612142135},{\"type\":\"grass\",\"position\":[117.06862110896056,0,88.32489187601801],\"scale\":1.2629464533086345},{\"type\":\"grass\",\"position\":[-72.03175985871397,0,-18.02481340341031],\"scale\":1.0514294026348332},{\"type\":\"grass\",\"position\":[-6.684654217340148,0,20.539159784923815],\"scale\":1.2221432350225792},{\"type\":\"grass\",\"position\":[61.89069419454507,0,10.861392552085757],\"scale\":1.288394577033761},{\"type\":\"grass\",\"position\":[19.192541211092106,0,17.892091535168383],\"scale\":0.9218447131851368},{\"type\":\"grass\",\"position\":[-41.97740311553453,0,-49.61224170482325],\"scale\":0.8907405412552554},{\"type\":\"grass\",\"position\":[31.29012237643316,0,60.77395237678874],\"scale\":1.014393892300885},{\"type\":\"grass\",\"position\":[74.86499445793118,0,62.067262814123445],\"scale\":1.2900856549690696},{\"type\":\"grass\",\"position\":[-18.292441117589046,0,-19.237442921251525],\"scale\":1.1274855504679153},{\"type\":\"grass\",\"position\":[-82.60648616047942,0,64.82069368352198],\"scale\":1.0284321604995394},{\"type\":\"grass\",\"position\":[-83.00336416505817,0,-54.05644517148292],\"scale\":0.8187226968348225},{\"type\":\"grass\",\"position\":[18.22497324092379,0,57.427829012339345],\"scale\":1.2283163773219554},{\"type\":\"grass\",\"position\":[16.91482187750713,0,-10.06380830933839],\"scale\":0.7539139420601393},{\"type\":\"grass\",\"position\":[-15.722499946642415,0,47.4725825024522],\"scale\":0.7706397907223194},{\"type\":\"grass\",\"position\":[7.158362180835462,0,-9.446035249526805],\"scale\":0.8148444987827653},{\"type\":\"grass\",\"position\":[-24.094721288058228,0,3.539114030781778],\"scale\":1.2558604787338636},{\"type\":\"grass\",\"position\":[61.06621114685452,0,-5.122477096256399],\"scale\":0.8777444054891353},{\"type\":\"grass\",\"position\":[1.0746479106830578,0,-21.533674281459543],\"scale\":0.7401538424754323},{\"type\":\"grass\",\"position\":[121.00862256653471,0,-67.77953737838877],\"scale\":1.0812705225423673},{\"type\":\"grass\",\"position\":[-0.3384719637316736,0,-20.61465326536465],\"scale\":0.9659801670593098},{\"type\":\"grass\",\"position\":[-28.006711709317617,0,-21.17814348858852],\"scale\":0.9764627723582645},{\"type\":\"grass\",\"position\":[5.472410717541728,0,-8.82346497585996],\"scale\":0.9508148604480229},{\"type\":\"grass\",\"position\":[-36.171465621171826,0,-4.1865155956198326],\"scale\":0.9064627457389445},{\"type\":\"grass\",\"position\":[85.09825848192368,0,-17.538328967976636],\"scale\":0.8692572377505228},{\"type\":\"grass\",\"position\":[-48.55251917684539,0,1.7714458176758443],\"scale\":0.9428576959142448},{\"type\":\"grass\",\"position\":[-7.402427608290567,0,37.44019351241781],\"scale\":0.8621396406805728},{\"type\":\"grass\",\"position\":[-34.24951773929265,0,85.53707000825013],\"scale\":0.8594815818633466},{\"type\":\"grass\",\"position\":[-33.36766150430807,0,-88.7427890663606],\"scale\":1.0047009647988805},{\"type\":\"grass\",\"position\":[-0.9444609526102855,0,1.7973464469613916],\"scale\":0.8583387673764029},{\"type\":\"grass\",\"position\":[-89.50325834767803,0,19.98466360244836],\"scale\":1.2603877289737437},{\"type\":\"grass\",\"position\":[-32.38257124526802,0,130.73526368741292],\"scale\":1.272602680239019},{\"type\":\"grass\",\"position\":[-90.52769152348039,0,21.614169326979894],\"scale\":1.2971512818355895},{\"type\":\"grass\",\"position\":[46.859600443262416,0,58.92893332410013],\"scale\":0.8102638271940125},{\"type\":\"grass\",\"position\":[94.11407554304627,0,36.50422488378933],\"scale\":1.2537447152024845},{\"type\":\"grass\",\"position\":[-9.902866762371879,0,-52.20729387093034],\"scale\":0.9356184007610379},{\"type\":\"grass\",\"position\":[33.135154866795794,0,-56.75313941830468],\"scale\":0.8125169082267583},{\"type\":\"grass\",\"position\":[-29.440180970271292,0,-42.53787598103186],\"scale\":1.2107632231582015},{\"type\":\"grass\",\"position\":[-66.230911078944,0,-1.2510843444663435],\"scale\":0.8480758549045708},{\"type\":\"grass\",\"position\":[-2.793702982813962,0,134.4409188016091],\"scale\":0.7655032264700906},{\"type\":\"grass\",\"position\":[0.4598865864555295,0,2.1691316826304425],\"scale\":1.0673828042237918},{\"type\":\"grass\",\"position\":[-47.79093985063159,0,-108.71774285129274],\"scale\":1.0354027630795941},{\"type\":\"grass\",\"position\":[51.97990257623591,0,122.76047432855658],\"scale\":1.0680196433315179},{\"type\":\"grass\",\"position\":[-36.919290855614406,0,1.6246383311583936],\"scale\":0.7457585546628878},{\"type\":\"grass\",\"position\":[-75.92866061039967,0,8.5660099086562],\"scale\":0.9493797443558456},{\"type\":\"grass\",\"position\":[68.20554358654887,0,30.51610539596162],\"scale\":1.0846038228420098},{\"type\":\"grass\",\"position\":[54.63055878401002,0,100.34612539756982],\"scale\":0.9318816769416045},{\"type\":\"grass\",\"position\":[6.5331552764761955,0,-0.23981520987418561],\"scale\":0.7890905464260325},{\"type\":\"grass\",\"position\":[62.60764345611234,0,23.689366595015436],\"scale\":1.006158990331301},{\"type\":\"grass\",\"position\":[-10.302931558006696,0,64.78106475804404],\"scale\":0.8571782269371706},{\"type\":\"grass\",\"position\":[54.12534030917137,0,-138.79923175673034],\"scale\":0.9661911723727532},{\"type\":\"grass\",\"position\":[-61.30416381553412,0,-81.37136646493036],\"scale\":0.7777293352504864},{\"type\":\"grass\",\"position\":[-120.4156489509308,0,71.19051958998557],\"scale\":1.1254296444799472},{\"type\":\"grass\",\"position\":[0.3926733757299216,0,3.4274835906577725],\"scale\":1.2022331978870358},{\"type\":\"grass\",\"position\":[-44.23564527949983,0,38.9959875120617],\"scale\":1.135895877597717},{\"type\":\"grass\",\"position\":[33.576528386456154,0,13.411219037880194],\"scale\":1.0226676113671278},{\"type\":\"grass\",\"position\":[111.88798786727183,0,-10.959056365927424],\"scale\":1.20330151018015},{\"type\":\"grass\",\"position\":[2.248953566509486,0,31.98949170157453],\"scale\":1.1593482946770695},{\"type\":\"grass\",\"position\":[148.92944706440838,0,15.854911611061612],\"scale\":1.1316604087455342},{\"type\":\"grass\",\"position\":[54.33645177413451,0,-64.19923659021379],\"scale\":0.925911896261375},{\"type\":\"grass\",\"position\":[10.49326903229477,0,-59.79793286914531],\"scale\":1.1222703716269804},{\"type\":\"grass\",\"position\":[-47.52067184289811,0,-60.09327109730929],\"scale\":1.0112837752643173},{\"type\":\"grass\",\"position\":[-11.791481859548679,0,-17.743507099576746],\"scale\":1.0931798039716618},{\"type\":\"grass\",\"position\":[14.899824223199616,0,25.164661226449844],\"scale\":0.9394561655173189},{\"type\":\"grass\",\"position\":[0.7354923467710963,0,1.9203772723235806],\"scale\":0.8224999923709563},{\"type\":\"grass\",\"position\":[24.171012823452777,0,11.453409238864115],\"scale\":1.2567814585842414},{\"type\":\"grass\",\"position\":[-97.78358858497214,0,51.27881107842127],\"scale\":0.7389074548242262},{\"type\":\"grass\",\"position\":[-21.254099219192167,0,-13.917558277362392],\"scale\":1.1562593649934036},{\"type\":\"grass\",\"position\":[-46.31189480310255,0,-1.2476170085859861],\"scale\":1.1859697437921013},{\"type\":\"grass\",\"position\":[-22.817261079749322,0,-47.40025115321626],\"scale\":1.0992899586798832},{\"type\":\"grass\",\"position\":[29.704152367638002,0,-120.39232417565523],\"scale\":0.8265263774907643},{\"type\":\"grass\",\"position\":[115.23963206637278,0,-37.187005336363605],\"scale\":0.8466663505588927},{\"type\":\"grass\",\"position\":[-18.64000157007229,0,29.385883157090223],\"scale\":0.8546887075851105},{\"type\":\"grass\",\"position\":[38.11541303950987,0,89.7202615222463],\"scale\":1.1939808613112333},{\"type\":\"grass\",\"position\":[-37.765836765361996,0,1.999722866359534],\"scale\":1.2249936147544869},{\"type\":\"grass\",\"position\":[20.85425401445283,0,-65.55277365355143],\"scale\":0.7252254994568081},{\"type\":\"grass\",\"position\":[87.43223543848244,0,60.745992658688166],\"scale\":1.2225040788471326},{\"type\":\"grass\",\"position\":[111.30444501488101,0,-10.910026942541256],\"scale\":0.834466411185154},{\"type\":\"grass\",\"position\":[18.859567620016794,0,-8.245677348553956],\"scale\":0.7376584223673047},{\"type\":\"grass\",\"position\":[-14.97380751657055,0,38.11870014491613],\"scale\":0.9406091682235108},{\"type\":\"grass\",\"position\":[-76.80885097236155,0,-119.2144151935299],\"scale\":1.138969210056777},{\"type\":\"grass\",\"position\":[86.33350948042639,0,31.004883131444387],\"scale\":0.830166399714081},{\"type\":\"grass\",\"position\":[-3.8310171748600257,0,55.733401722127375],\"scale\":0.7334291996017839},{\"type\":\"grass\",\"position\":[136.51957298742093,0,-9.311897334359855],\"scale\":1.018869525837158},{\"type\":\"grass\",\"position\":[-120.9275684198425,0,62.08985644553526],\"scale\":1.1382203637082422},{\"type\":\"grass\",\"position\":[-77.08522731691595,0,40.21906529497571],\"scale\":0.7013805906464521},{\"type\":\"grass\",\"position\":[26.983806424011178,0,-20.81537383939352],\"scale\":1.1730442379796007},{\"type\":\"grass\",\"position\":[-35.26169186689458,0,-67.41223370091078],\"scale\":0.82488941009591},{\"type\":\"grass\",\"position\":[-86.94123329320529,0,62.441508367199255],\"scale\":0.9773425372382958},{\"type\":\"grass\",\"position\":[8.084177291506895,0,-6.8935121070672185],\"scale\":0.7510543461117021},{\"type\":\"grass\",\"position\":[6.260245897392326,0,-65.8068280642452],\"scale\":1.2779720086915463},{\"type\":\"grass\",\"position\":[-44.898591707571896,0,-51.66421008463892],\"scale\":1.0241074154994045},{\"type\":\"grass\",\"position\":[-83.28057568236999,0,42.35104711992507],\"scale\":0.8152407627726861},{\"type\":\"grass\",\"position\":[68.43284804557901,0,-46.285266575258355],\"scale\":1.1648418832861407},{\"type\":\"grass\",\"position\":[33.565427500741315,0,-131.45405831714027],\"scale\":1.239696012467172},{\"type\":\"grass\",\"position\":[1.9089931495350154,0,7.3168917026703255],\"scale\":0.8739859224510924},{\"type\":\"grass\",\"position\":[-66.87571901830727,0,-29.952534848762205],\"scale\":1.2239886351607208},{\"type\":\"grass\",\"position\":[-125.72042600296326,0,76.13545003525066],\"scale\":0.7451931671276872},{\"type\":\"grass\",\"position\":[38.41893644478999,0,-33.76954593671161],\"scale\":1.0171091034224606},{\"type\":\"grass\",\"position\":[26.34936470468538,0,-98.43090661558459],\"scale\":1.0682270326006655},{\"type\":\"grass\",\"position\":[-115.58737963553581,0,3.5933164112271974],\"scale\":0.9454652080149912},{\"type\":\"grass\",\"position\":[-57.13902888275774,0,-110.8042885960015],\"scale\":1.0609000484411233},{\"type\":\"grass\",\"position\":[-1.4184447137577227,0,68.08437465025673],\"scale\":0.9648994450351849},{\"type\":\"grass\",\"position\":[-27.983325310660394,0,0.8605070407502483],\"scale\":1.2528389209999031},{\"type\":\"grass\",\"position\":[5.571265951051654,0,9.35971069971843],\"scale\":0.9675562530544204},{\"type\":\"grass\",\"position\":[-95.1366534774482,0,-89.28830092046434],\"scale\":0.8489998946182647},{\"type\":\"grass\",\"position\":[-52.25015456164494,0,56.89799425628376],\"scale\":1.2091281967920626},{\"type\":\"grass\",\"position\":[63.506725646493365,0,-102.9567309832388],\"scale\":0.9798380637915322},{\"type\":\"grass\",\"position\":[-50.848199152925346,0,103.07353150373372],\"scale\":1.1718389713552742},{\"type\":\"grass\",\"position\":[35.407102412680324,0,-106.49342187593864],\"scale\":0.9364206992112671},{\"type\":\"grass\",\"position\":[109.51083143948742,0,-6.808249503726643],\"scale\":0.8800586033361225},{\"type\":\"grass\",\"position\":[-17.49323469989518,0,75.327280820045],\"scale\":1.0237705615697383},{\"type\":\"grass\",\"position\":[-49.93539261335588,0,48.3395875322935],\"scale\":0.8074807745270454},{\"type\":\"grass\",\"position\":[22.824312768698597,0,-139.93183205854396],\"scale\":0.9717273106962603},{\"type\":\"grass\",\"position\":[54.676229357605365,0,93.37913357459256],\"scale\":0.8205606852012637},{\"type\":\"grass\",\"position\":[-38.10449327520156,0,36.300906879489006],\"scale\":1.0563395249751266},{\"type\":\"grass\",\"position\":[-33.07031859390367,0,118.82993795429189],\"scale\":0.8934234017141569},{\"type\":\"grass\",\"position\":[87.57363623852561,0,34.098452838177344],\"scale\":0.8588983805373467},{\"type\":\"grass\",\"position\":[-8.18362956781252,0,26.924776030483592],\"scale\":1.0000832423239971},{\"type\":\"grass\",\"position\":[92.4038133350479,0,111.99605670019845],\"scale\":1.2779102106436717},{\"type\":\"grass\",\"position\":[29.186816155967783,0,62.28891727504923],\"scale\":0.8056831297245356},{\"type\":\"grass\",\"position\":[-36.134986838494704,0,133.18930337503824],\"scale\":1.13183388594611},{\"type\":\"grass\",\"position\":[1.04172966008171,0,-77.80068224318444],\"scale\":0.7990309411932344},{\"type\":\"grass\",\"position\":[1.8955553872240434,0,-7.1058227708017805],\"scale\":1.0823399454843425},{\"type\":\"grass\",\"position\":[-70.4738937491019,0,10.564183383573994],\"scale\":0.8249148514693908},{\"type\":\"grass\",\"position\":[58.374146542021926,0,76.89679247851304],\"scale\":0.7845293882524387},{\"type\":\"grass\",\"position\":[-119.04800669494038,0,49.35486917454294],\"scale\":0.7753433028956097},{\"type\":\"grass\",\"position\":[49.39409906304431,0,67.40970350983925],\"scale\":0.7905018198206691},{\"type\":\"grass\",\"position\":[-1.2896207937113502,0,4.125026630467853],\"scale\":1.1962760392762215},{\"type\":\"grass\",\"position\":[-92.15263797811386,0,-36.117089336297695],\"scale\":1.2026374446252146},{\"type\":\"grass\",\"position\":[-48.27912274504681,0,115.50619375940983],\"scale\":0.7231583197784869},{\"type\":\"grass\",\"position\":[-77.43966662355953,0,46.58227537933286],\"scale\":0.8021498836857566},{\"type\":\"grass\",\"position\":[68.44490036755104,0,33.60566826924531],\"scale\":1.1294819937376437},{\"type\":\"grass\",\"position\":[15.945320808897486,0,10.47032539203331],\"scale\":0.9526791673843037},{\"type\":\"grass\",\"position\":[10.620268818697339,0,6.81629718121216],\"scale\":0.7600269867776288},{\"type\":\"grass\",\"position\":[-27.23354656209147,0,112.22480432480286],\"scale\":1.1894538060189788},{\"type\":\"grass\",\"position\":[-81.62652197128395,0,35.40769445759137],\"scale\":1.2651073539162216},{\"type\":\"grass\",\"position\":[23.422869507464046,0,-6.029178471084719],\"scale\":1.0632836621681523},{\"type\":\"grass\",\"position\":[-0.003974166610292439,0,0.00037589583091545857],\"scale\":0.9150364239761442},{\"type\":\"grass\",\"position\":[27.94620721964353,0,40.53390167696827],\"scale\":1.0416682707508933},{\"type\":\"grass\",\"position\":[-141.18535361941673,0,-38.27161629375428],\"scale\":1.1356479226733318},{\"type\":\"grass\",\"position\":[106.05002737061753,0,38.61597287638563],\"scale\":0.9371003084475955},{\"type\":\"grass\",\"position\":[7.85800153314533,0,-21.818040863615582],\"scale\":1.0612573144538102},{\"type\":\"grass\",\"position\":[5.248450841281217,0,16.44502507949929],\"scale\":0.9791158630312315},{\"type\":\"grass\",\"position\":[-112.55860423817315,0,53.969781256262706],\"scale\":1.0319853812865294},{\"type\":\"grass\",\"position\":[106.45944610914415,0,-3.758291810791275],\"scale\":0.9060708223163787},{\"type\":\"grass\",\"position\":[45.35074620620554,0,-34.427145586590676],\"scale\":0.79735729894791},{\"type\":\"grass\",\"position\":[-51.352096348654754,0,-65.16266376362232],\"scale\":1.288366791202353},{\"type\":\"grass\",\"position\":[-77.25361443469029,0,12.553664875291226],\"scale\":1.1319590616365},{\"type\":\"grass\",\"position\":[-72.00901607615609,0,-108.5202528309267],\"scale\":1.0315681724603687},{\"type\":\"grass\",\"position\":[-80.92762123991275,0,66.31926652530169],\"scale\":0.7592402986884961},{\"type\":\"grass\",\"position\":[-54.94275124843274,0,55.6517387928703],\"scale\":0.7199092660302844},{\"type\":\"grass\",\"position\":[-21.181992775638275,0,20.96133187379889],\"scale\":0.8090760231804648},{\"type\":\"grass\",\"position\":[47.82513620133359,0,-17.26716194562707],\"scale\":0.8156585647500482},{\"type\":\"grass\",\"position\":[51.67884870465661,0,-60.59868158015683],\"scale\":1.1400325748688855},{\"type\":\"grass\",\"position\":[-44.47845898675043,0,-2.8698809867278006],\"scale\":0.9689573379467117},{\"type\":\"grass\",\"position\":[27.14450016344144,0,20.211946151609105],\"scale\":0.7359304134906255},{\"type\":\"grass\",\"position\":[-141.19849842940764,0,0.4690657865273368],\"scale\":1.0709509024630333},{\"type\":\"grass\",\"position\":[-3.653710350542833,0,7.951225791477319],\"scale\":0.8784340088757794},{\"type\":\"grass\",\"position\":[119.97429488501136,0,3.0693172203584336],\"scale\":0.8490936411323416},{\"type\":\"grass\",\"position\":[-19.936282984491427,0,-40.23582887799084],\"scale\":1.0453921252043226},{\"type\":\"grass\",\"position\":[57.353551309068415,0,24.580042454961003],\"scale\":1.0969500722967036},{\"type\":\"grass\",\"position\":[103.56942520798812,0,-67.21213279837977],\"scale\":0.8113684841082526},{\"type\":\"grass\",\"position\":[-42.362308278396476,0,24.780495682778135],\"scale\":1.0637532518722408},{\"type\":\"grass\",\"position\":[-13.880497242078421,0,63.086990297780105],\"scale\":0.961871306228085},{\"type\":\"grass\",\"position\":[-34.73741023241831,0,-36.596299400574644],\"scale\":1.034333064835716},{\"type\":\"grass\",\"position\":[28.632634456725416,0,-138.35092150803234],\"scale\":1.0361562304917609},{\"type\":\"grass\",\"position\":[41.47450925571619,0,-60.868586290337255],\"scale\":1.0405804165424983},{\"type\":\"grass\",\"position\":[28.8761779006969,0,4.755872118611254],\"scale\":0.8024769196869803},{\"type\":\"grass\",\"position\":[-45.50955509199043,0,-23.680583816544225],\"scale\":1.181449022525702},{\"type\":\"grass\",\"position\":[3.4833581130133418,0,128.5204111432674],\"scale\":0.7492053990791937},{\"type\":\"grass\",\"position\":[-12.960297656786922,0,7.85645290802352],\"scale\":1.2461855956503989},{\"type\":\"grass\",\"position\":[12.499517740184997,0,-10.564110826834376],\"scale\":1.1444592310566164},{\"type\":\"grass\",\"position\":[12.93411118095195,0,-16.410125923857382],\"scale\":0.7527797668374736},{\"type\":\"grass\",\"position\":[28.606804731960306,0,35.69250395750095],\"scale\":1.213486465332261},{\"type\":\"grass\",\"position\":[93.31017944365193,0,-70.24745509332173],\"scale\":1.046797513762967},{\"type\":\"grass\",\"position\":[-1.8695343029952973,0,79.55223642741088],\"scale\":1.1256804771656794},{\"type\":\"grass\",\"position\":[-38.75225830797506,0,-17.261584387443893],\"scale\":1.231024066324093},{\"type\":\"grass\",\"position\":[62.18809520380949,0,5.13944259311481],\"scale\":0.81141061189688},{\"type\":\"grass\",\"position\":[47.0422003699972,0,-1.220489958298453],\"scale\":1.0695891997716507},{\"type\":\"grass\",\"position\":[-14.505546023209885,0,4.541507519027084],\"scale\":0.9865921501154149},{\"type\":\"grass\",\"position\":[-22.418987300306288,0,113.91171715445729],\"scale\":1.2400896884358752},{\"type\":\"grass\",\"position\":[13.19030830123815,0,-16.61935092946531],\"scale\":0.9827725147853449},{\"type\":\"grass\",\"position\":[-26.90863852715308,0,49.053413421846805],\"scale\":0.8568755180114096},{\"type\":\"grass\",\"position\":[-143.94956498447002,0,0.21069667210226312],\"scale\":0.9140862623118602},{\"type\":\"grass\",\"position\":[-39.624827265590945,0,140.4943829107537],\"scale\":1.0703245210994496},{\"type\":\"grass\",\"position\":[11.069185566112182,0,-17.80185156558458],\"scale\":1.0447501265393715},{\"type\":\"grass\",\"position\":[47.2739887998126,0,68.32615115629963],\"scale\":0.7204690731201652},{\"type\":\"grass\",\"position\":[30.07988345042894,0,-30.74586414172152],\"scale\":0.9958953082528069},{\"type\":\"grass\",\"position\":[-52.67451944014011,0,-45.46045555665085],\"scale\":1.1256023377316253},{\"type\":\"grass\",\"position\":[145.15489786135328,0,-4.908875894784155],\"scale\":0.7979665583750001},{\"type\":\"grass\",\"position\":[57.718073531473216,0,3.7206325340015147],\"scale\":1.1345050870584472},{\"type\":\"grass\",\"position\":[-22.977554380625026,0,2.18623217896553],\"scale\":1.281244762579099},{\"type\":\"grass\",\"position\":[-1.5863092666036622,0,-6.964635583299546],\"scale\":0.7303695324252623},{\"type\":\"grass\",\"position\":[-87.91424923771775,0,31.456696032266418],\"scale\":0.8670443384821186},{\"type\":\"grass\",\"position\":[-12.040029389764598,0,-34.4477478462656],\"scale\":0.9277264290837509},{\"type\":\"grass\",\"position\":[0.28903899838550545,0,0.13403365255803928],\"scale\":1.212877298966967},{\"type\":\"grass\",\"position\":[44.380260901247865,0,15.767125369628973],\"scale\":0.9794776471263008},{\"type\":\"grass\",\"position\":[-88.29485316940118,0,12.757061327677292],\"scale\":1.2339126858616893},{\"type\":\"grass\",\"position\":[-9.045851642306628,0,91.02386148264767],\"scale\":1.1460619303604402},{\"type\":\"grass\",\"position\":[104.41186060390808,0,33.96107787359231],\"scale\":0.9931161097282168},{\"type\":\"grass\",\"position\":[-12.366268926464409,0,-21.79824442488188],\"scale\":0.7073910780026557},{\"type\":\"grass\",\"position\":[-31.99296336797077,0,16.59381577283514],\"scale\":1.1420161566017384},{\"type\":\"grass\",\"position\":[46.095902851994644,0,103.29379556840571],\"scale\":0.7304098505012926},{\"type\":\"grass\",\"position\":[-20.917325276264798,0,2.088362284237216],\"scale\":1.2971296309171003},{\"type\":\"grass\",\"position\":[-58.22435521432834,0,-39.674245662330335],\"scale\":1.0738483374190975},{\"type\":\"grass\",\"position\":[-140.63950435354536,0,48.61368490992222],\"scale\":1.0954401595471646},{\"type\":\"grass\",\"position\":[-25.916629385624077,0,24.005421958942378],\"scale\":0.8580394822397619},{\"type\":\"grass\",\"position\":[-17.99733670328578,0,19.509370416434766],\"scale\":1.0609132439087465},{\"type\":\"grass\",\"position\":[110.5691560892234,0,-77.0764831327529],\"scale\":1.258513425084474},{\"type\":\"grass\",\"position\":[46.77643333704643,0,-75.63611914760027],\"scale\":1.1021354275118123},{\"type\":\"grass\",\"position\":[-8.11309384567668,0,-18.426344461826766],\"scale\":1.0239286749096015},{\"type\":\"grass\",\"position\":[4.060130484677053,0,46.60854002003068],\"scale\":1.2703962750652775},{\"type\":\"grass\",\"position\":[-63.32538819239594,0,-31.258584116107272],\"scale\":0.9613145082678174},{\"type\":\"grass\",\"position\":[17.66166537348703,0,-41.336227534760944],\"scale\":1.0967079518485545},{\"type\":\"grass\",\"position\":[97.5094639356732,0,-18.76217897967178],\"scale\":1.153775879726904},{\"type\":\"grass\",\"position\":[-28.442610049702214,0,-19.201333899871006],\"scale\":1.164005895807784},{\"type\":\"grass\",\"position\":[103.1425574555459,0,72.06492510804357],\"scale\":0.7040595573080556},{\"type\":\"grass\",\"position\":[-27.535728880025186,0,-34.27656602282497],\"scale\":0.9291472004172444},{\"type\":\"grass\",\"position\":[-91.90937527171549,0,67.76065736514617],\"scale\":0.8554031312108434},{\"type\":\"grass\",\"position\":[33.46237534271627,0,-31.306668578146688],\"scale\":1.21812245887858},{\"type\":\"grass\",\"position\":[9.141228183717667,0,-4.492514501074457],\"scale\":1.048389086483478},{\"type\":\"grass\",\"position\":[-52.47796954560709,0,-19.68650200578416],\"scale\":0.9887784294662522},{\"type\":\"grass\",\"position\":[-29.881770668530702,0,-89.03545592748293],\"scale\":0.8402013707674072},{\"type\":\"grass\",\"position\":[-0.21692118275237893,0,-0.04925471119238776],\"scale\":0.9631279473673279},{\"type\":\"grass\",\"position\":[-17.552482711350176,0,117.32155565877889],\"scale\":1.2234529805915595},{\"type\":\"grass\",\"position\":[-6.799950664209201,0,39.84093071379454],\"scale\":1.1356775930855783},{\"type\":\"grass\",\"position\":[23.410236034567276,0,29.453713129033957],\"scale\":0.797471258739922},{\"type\":\"grass\",\"position\":[-40.236638810051595,0,-18.317442126204416],\"scale\":1.167915086672815},{\"type\":\"grass\",\"position\":[-1.402715035425916,0,69.34951403580224],\"scale\":0.7755323048253011},{\"type\":\"grass\",\"position\":[-0.01766512005272864,0,0.12588730198473863],\"scale\":1.0653081897230228},{\"type\":\"grass\",\"position\":[-7.753521837667287,0,9.086537484332089],\"scale\":1.0848363167092157},{\"type\":\"grass\",\"position\":[-52.02106457631991,0,-40.606390358951586],\"scale\":0.9030103942043138},{\"type\":\"grass\",\"position\":[-11.610807748669744,0,1.033777564690687],\"scale\":0.8004299894058349},{\"type\":\"grass\",\"position\":[-60.16840805316001,0,-105.68922612657788],\"scale\":1.2678438082045111},{\"type\":\"grass\",\"position\":[-99.27084174605795,0,26.410510692616853],\"scale\":0.7303402825910009},{\"type\":\"grass\",\"position\":[-121.50904946131547,0,-33.93917121218624],\"scale\":1.1111344908370533},{\"type\":\"grass\",\"position\":[-54.42607823471696,0,-53.309193636327585],\"scale\":0.9240913677138034},{\"type\":\"grass\",\"position\":[-97.66371779306586,0,90.31526583142522],\"scale\":0.9523550188219914},{\"type\":\"grass\",\"position\":[8.717242997670125,0,2.596455483117563],\"scale\":0.7314799760419686},{\"type\":\"grass\",\"position\":[126.1970763707593,0,21.25721862561648],\"scale\":1.1126996665360425},{\"type\":\"grass\",\"position\":[63.59099016075191,0,49.102288983539054],\"scale\":0.8886961102485147},{\"type\":\"grass\",\"position\":[-78.30786588193011,0,-125.34963592728387],\"scale\":1.1142140891793404},{\"type\":\"grass\",\"position\":[-80.79519407959252,0,-108.42583188271188],\"scale\":1.008296783115049},{\"type\":\"grass\",\"position\":[-64.62483644248853,0,-32.078088741793636],\"scale\":0.95880698469892},{\"type\":\"grass\",\"position\":[-65.56268104840329,0,91.96027796230905],\"scale\":0.9588105461416679},{\"type\":\"grass\",\"position\":[58.54886312693533,0,-98.7213827500498],\"scale\":0.9983238716378284},{\"type\":\"grass\",\"position\":[-32.192810317302836,0,110.39115465727653],\"scale\":0.9948523684705983},{\"type\":\"grass\",\"position\":[-85.79233121808798,0,90.0034848953007],\"scale\":0.7125092543214625},{\"type\":\"grass\",\"position\":[62.77083829407724,0,-4.114519576137876],\"scale\":0.7883147777735584},{\"type\":\"grass\",\"position\":[-5.684506728915529,0,32.18552642141149],\"scale\":1.147011128418949},{\"type\":\"grass\",\"position\":[12.632826112739933,0,22.587439100468647],\"scale\":0.9285693381488563},{\"type\":\"grass\",\"position\":[121.36126895182616,0,-18.113034552699947],\"scale\":0.9160023028659311},{\"type\":\"grass\",\"position\":[42.21851139180833,0,17.2946500052783],\"scale\":1.1132004909522175},{\"type\":\"grass\",\"position\":[-136.3895161708975,0,-32.32384737328831],\"scale\":1.1628102697378613},{\"type\":\"grass\",\"position\":[4.740080925603335,0,-12.754844787401721],\"scale\":0.8564532124516846},{\"type\":\"grass\",\"position\":[-54.403353054188116,0,87.10461690550588],\"scale\":0.7029949204070679},{\"type\":\"grass\",\"position\":[4.479805972883503,0,93.23556746746182],\"scale\":1.0030119742953505},{\"type\":\"grass\",\"position\":[-18.993442199557858,0,28.950365187811347],\"scale\":0.9802001546370835},{\"type\":\"grass\",\"position\":[44.187110780916285,0,-24.645440235815325],\"scale\":0.7744211774407881},{\"type\":\"grass\",\"position\":[-111.10895934564013,0,26.871836889899622],\"scale\":1.0665281354627196},{\"type\":\"grass\",\"position\":[37.71370912542471,0,-3.826357618981638],\"scale\":1.1060948795014385},{\"type\":\"grass\",\"position\":[-40.12439920376124,0,41.7963639552829],\"scale\":1.0128328578797172},{\"type\":\"grass\",\"position\":[-54.06287500350307,0,-42.88752619994321],\"scale\":0.8192896457687971},{\"type\":\"grass\",\"position\":[28.082108371340233,0,-3.408105545950272],\"scale\":0.7835628623527493},{\"type\":\"grass\",\"position\":[-11.47344724852992,0,-19.896495256250798],\"scale\":0.7620111135832239},{\"type\":\"grass\",\"position\":[2.706689390633042,0,28.17201289185195],\"scale\":0.9537214590288559},{\"type\":\"grass\",\"position\":[3.732149763611451,0,-32.810994469423385],\"scale\":0.8096791995645317},{\"type\":\"grass\",\"position\":[34.91834111119037,0,-63.592731150934235],\"scale\":1.2434469855526173},{\"type\":\"grass\",\"position\":[23.4299813289859,0,-22.021218575688955],\"scale\":1.2406420209931728},{\"type\":\"grass\",\"position\":[87.16473044983802,0,-102.18728382506154],\"scale\":1.1489298881195893},{\"type\":\"grass\",\"position\":[-81.94595012227468,0,34.659977953731726],\"scale\":0.92142815203962},{\"type\":\"grass\",\"position\":[-4.66797491707622,0,-8.346760208547035],\"scale\":0.9322210788917176},{\"type\":\"grass\",\"position\":[-22.574216861003276,0,-119.67206231848573],\"scale\":0.8647455108228677},{\"type\":\"grass\",\"position\":[-34.11681081844184,0,-76.76230344302498],\"scale\":0.9125853084280079},{\"type\":\"grass\",\"position\":[58.21438101819651,0,-65.65503121891192],\"scale\":0.8332203193100586},{\"type\":\"grass\",\"position\":[-48.100374144454776,0,-53.27288750969651],\"scale\":0.8738460124017222},{\"type\":\"grass\",\"position\":[4.882340002608481,0,-6.9706419009284115],\"scale\":0.8141252950616609},{\"type\":\"grass\",\"position\":[-33.71598684739894,0,46.92829864035218],\"scale\":1.1372607853448935},{\"type\":\"grass\",\"position\":[12.382092109102539,0,88.21156939482192],\"scale\":0.9693805727693792},{\"type\":\"grass\",\"position\":[1.3502073042700438,0,-2.239719717724072],\"scale\":0.9488633203488891},{\"type\":\"grass\",\"position\":[-31.134915982292277,0,-61.45072829078923],\"scale\":0.8851492855648238},{\"type\":\"grass\",\"position\":[-74.01991034090565,0,-31.536016336526025],\"scale\":0.861725160249603},{\"type\":\"grass\",\"position\":[10.063130868066006,0,0.003937211710288755],\"scale\":1.0847828245903295},{\"type\":\"grass\",\"position\":[3.5808081426738014,0,-1.8723860870177043],\"scale\":1.0852873336633744},{\"type\":\"grass\",\"position\":[-26.14215785623991,0,30.678182254450746],\"scale\":0.9798884409740543},{\"type\":\"grass\",\"position\":[9.0382612484736,0,-102.57241870493833],\"scale\":0.8695539348799409},{\"type\":\"grass\",\"position\":[7.6498397645996645,0,-31.677498864548898],\"scale\":0.8944302142522865},{\"type\":\"grass\",\"position\":[-71.89843568654193,0,-121.03274631830877],\"scale\":0.9324182214801972},{\"type\":\"grass\",\"position\":[23.026350003650585,0,50.790627045676594],\"scale\":1.1265406394865252},{\"type\":\"grass\",\"position\":[-34.63536395667089,0,20.806486460432556],\"scale\":0.9780595064751377},{\"type\":\"grass\",\"position\":[-62.19757205421783,0,91.19723556250196],\"scale\":1.0707488984224482},{\"type\":\"grass\",\"position\":[113.66773974140473,0,37.62241858110347],\"scale\":0.7240871335039526},{\"type\":\"grass\",\"position\":[1.0325705676847337,0,-1.9324274904097107],\"scale\":0.8750180365175027},{\"type\":\"grass\",\"position\":[33.058860633260785,0,-60.06217128880244],\"scale\":1.0448929001477285},{\"type\":\"grass\",\"position\":[-34.3736668012419,0,-19.348803794202716],\"scale\":1.012395594878637},{\"type\":\"grass\",\"position\":[-98.80637363779084,0,-106.85584820276328],\"scale\":1.1296021097677333},{\"type\":\"grass\",\"position\":[-7.93784769137117,0,62.15580506566835],\"scale\":0.8871476155018463},{\"type\":\"grass\",\"position\":[37.03830231501048,0,24.596419219314306],\"scale\":0.7300270891107729},{\"type\":\"grass\",\"position\":[55.19632690895752,0,43.7430490122226],\"scale\":1.1580623040816147},{\"type\":\"grass\",\"position\":[18.018164257413684,0,16.023332896993875],\"scale\":0.7054320163102528},{\"type\":\"grass\",\"position\":[-60.88426156563824,0,-60.7214547739457],\"scale\":1.0312025121126898},{\"type\":\"grass\",\"position\":[4.862876395105168,0,81.58264681012918],\"scale\":0.749404254998907},{\"type\":\"grass\",\"position\":[7.548585939282296,0,125.12636842029055],\"scale\":1.1503103694707124},{\"type\":\"grass\",\"position\":[108.50905747507441,0,94.36292251937168],\"scale\":0.8317802421904371},{\"type\":\"grass\",\"position\":[-1.819845743714497,0,-7.646788777510515],\"scale\":1.0628318488351334},{\"type\":\"grass\",\"position\":[58.94280809732476,0,59.64897928982907],\"scale\":1.0881139497631775},{\"type\":\"grass\",\"position\":[-11.775597259106322,0,22.22961337899936],\"scale\":0.7594206390901204},{\"type\":\"grass\",\"position\":[59.02121688850415,0,125.44382927340988],\"scale\":1.2402676073595722},{\"type\":\"grass\",\"position\":[-5.4806495363599925,0,4.2648440884019205],\"scale\":0.8760813040243038},{\"type\":\"grass\",\"position\":[-28.164894186810706,0,25.04041904856549],\"scale\":0.8495083212803817},{\"type\":\"grass\",\"position\":[3.441358591757946,0,-0.030299415487117055],\"scale\":1.0348756399508403},{\"type\":\"grass\",\"position\":[-80.90810903538463,0,58.920997174448864],\"scale\":1.0356837957074783},{\"type\":\"grass\",\"position\":[-74.45303377659693,0,11.99624063254811],\"scale\":1.0259246851303274},{\"type\":\"grass\",\"position\":[-94.22014550649604,0,-4.137487284243129],\"scale\":1.284554669478497},{\"type\":\"grass\",\"position\":[-89.01768003272635,0,95.72407958795134],\"scale\":0.7048252622658155},{\"type\":\"grass\",\"position\":[77.95704673001764,0,-71.13659002158965],\"scale\":0.8398326663178125},{\"type\":\"grass\",\"position\":[93.68283695988735,0,116.0275499247705],\"scale\":0.9319492596488913},{\"type\":\"grass\",\"position\":[-3.3223692639948217,0,-42.022257242782054],\"scale\":0.9214624138508137},{\"type\":\"grass\",\"position\":[-90.84832131460566,0,37.520524643243135],\"scale\":1.1711547270194707},{\"type\":\"grass\",\"position\":[65.48017955899496,0,-62.99273396822155],\"scale\":1.120252441018339},{\"type\":\"grass\",\"position\":[-10.345961507624788,0,8.804357967492075],\"scale\":1.0936770323744567},{\"type\":\"grass\",\"position\":[21.8012888535596,0,2.2145481238229285],\"scale\":1.1444243596423422},{\"type\":\"grass\",\"position\":[112.64670464697127,0,-6.886791910618539],\"scale\":1.0250032844094423},{\"type\":\"grass\",\"position\":[59.153870135552104,0,115.19597424824735],\"scale\":1.002930876688687},{\"type\":\"grass\",\"position\":[-0.6386950462943122,0,1.796198154170951],\"scale\":1.2174165126115666},{\"type\":\"grass\",\"position\":[-24.3916521509815,0,-143.81605129181455],\"scale\":1.0777951468041094},{\"type\":\"grass\",\"position\":[88.1266154021718,0,-32.316143643330676],\"scale\":1.296786985728055},{\"type\":\"grass\",\"position\":[8.470425076984972,0,-92.40716907579686],\"scale\":1.2859299985592119},{\"type\":\"grass\",\"position\":[28.568919830969552,0,-19.88683698003555],\"scale\":1.191132562410491},{\"type\":\"grass\",\"position\":[-6.77366144256417,0,-134.82243336547157],\"scale\":0.905095734335558},{\"type\":\"grass\",\"position\":[-0.35826015048893756,0,-8.495204259708872],\"scale\":1.0061937461631303},{\"type\":\"grass\",\"position\":[-79.8993158173071,0,60.34104548392955],\"scale\":0.9814367233649148},{\"type\":\"grass\",\"position\":[58.9929619890578,0,-116.84650717276635],\"scale\":0.7598971542373225},{\"type\":\"grass\",\"position\":[-2.6702212069076454,0,-6.111280928370383],\"scale\":0.7195302152310756},{\"type\":\"grass\",\"position\":[16.769162517190864,0,0.24114664912960454],\"scale\":1.2954137217182464},{\"type\":\"grass\",\"position\":[-16.862938001314358,0,-5.9997083974085],\"scale\":1.2395961254947632},{\"type\":\"grass\",\"position\":[23.371884082395265,0,-3.718320094226128],\"scale\":1.244668049421024},{\"type\":\"grass\",\"position\":[-0.021009378485247168,0,-32.354488989120846],\"scale\":1.1770276849458856},{\"type\":\"grass\",\"position\":[-70.76380617512191,0,128.37556170770515],\"scale\":1.2667271423568727},{\"type\":\"grass\",\"position\":[-86.54876394165746,0,113.78026280300368],\"scale\":0.9742229365914348},{\"type\":\"grass\",\"position\":[-35.73447738483675,0,-23.251771879687873],\"scale\":0.9373168914424599},{\"type\":\"grass\",\"position\":[-2.23449696371005,0,-63.997267660572106],\"scale\":1.0191058927402352},{\"type\":\"grass\",\"position\":[-34.341645530668245,0,67.65965603976365],\"scale\":1.111278744461417},{\"type\":\"grass\",\"position\":[-95.17841323585412,0,91.02307748276573],\"scale\":1.126163897218034},{\"type\":\"grass\",\"position\":[51.519929011406035,0,-2.9567589193821204],\"scale\":0.7885917325289168},{\"type\":\"grass\",\"position\":[-21.12494672277622,0,35.561736154705365],\"scale\":1.2389339082534763},{\"type\":\"grass\",\"position\":[91.74406866381162,0,50.38503084824401],\"scale\":0.8346716757751589},{\"type\":\"grass\",\"position\":[-39.35601906434334,0,-3.1668853862295476],\"scale\":0.8409537157301965},{\"type\":\"grass\",\"position\":[-2.8311848684098138,0,9.23684523082907],\"scale\":1.1713370976368926},{\"type\":\"grass\",\"position\":[45.295816518739514,0,90.25444140564792],\"scale\":1.2049115632740808},{\"type\":\"grass\",\"position\":[-74.17432646270233,0,25.440688895272174],\"scale\":1.0053476354962103},{\"type\":\"grass\",\"position\":[-72.46090943327357,0,126.81847561221582],\"scale\":0.749585621126255},{\"type\":\"grass\",\"position\":[-91.75992232776959,0,34.3920090952286],\"scale\":0.954765945015476},{\"type\":\"grass\",\"position\":[26.148595388180627,0,-57.41412207364265],\"scale\":0.7288004068570018},{\"type\":\"grass\",\"position\":[25.46896243903341,0,-108.16375197781129],\"scale\":0.9716669073929174},{\"type\":\"grass\",\"position\":[72.91578446206799,0,13.527826200709034],\"scale\":0.7036134927869274},{\"type\":\"grass\",\"position\":[-90.7836793492837,0,-40.77534587299],\"scale\":0.8436967983522465},{\"type\":\"grass\",\"position\":[10.161529586670992,0,-28.116745440227184],\"scale\":0.8902699244824712},{\"type\":\"grass\",\"position\":[-79.90246052062655,0,0.29488430134554816],\"scale\":1.2741853749627028},{\"type\":\"grass\",\"position\":[-78.98352421885274,0,-27.768002724689953],\"scale\":1.0461050989320264},{\"type\":\"grass\",\"position\":[1.9984677550044372,0,-3.876257198211653],\"scale\":1.0111049682837767},{\"type\":\"grass\",\"position\":[-79.60485579002146,0,-16.56524457238431],\"scale\":1.1522548998861006},{\"type\":\"grass\",\"position\":[61.8116833476774,0,-97.68838285359789],\"scale\":0.7155118938859715},{\"type\":\"grass\",\"position\":[36.78289107094423,0,-32.189150192681986],\"scale\":1.0392652936977496},{\"type\":\"grass\",\"position\":[106.46208951298452,0,-48.91518131328188],\"scale\":1.2429647356351063},{\"type\":\"grass\",\"position\":[-4.796505504092666,0,23.361325376451457],\"scale\":1.237587159271839},{\"type\":\"grass\",\"position\":[27.683842667661906,0,47.91348811304278],\"scale\":0.921936391225869},{\"type\":\"grass\",\"position\":[77.6812532981988,0,62.51909910333703],\"scale\":1.0334631746129337},{\"type\":\"grass\",\"position\":[26.301326370167075,0,-18.156312538886933],\"scale\":0.7344189107229266},{\"type\":\"grass\",\"position\":[39.81342875760503,0,-34.50674681010314],\"scale\":1.1237909101437427},{\"type\":\"grass\",\"position\":[36.93612368724726,0,-37.31256816798756],\"scale\":0.9198352562063205},{\"type\":\"grass\",\"position\":[121.86053873816365,0,-54.17041785488907],\"scale\":1.2608106416524507},{\"type\":\"grass\",\"position\":[-29.75863501198685,0,72.52895453974578],\"scale\":0.9308668892405502},{\"type\":\"grass\",\"position\":[25.467320988064063,0,-9.72559085133176],\"scale\":1.0363874437802598},{\"type\":\"grass\",\"position\":[-0.37675637664855677,0,-0.9388403957056863],\"scale\":1.2388059871314088},{\"type\":\"grass\",\"position\":[50.034821782682926,0,127.41519023165563],\"scale\":0.8656207608947873},{\"type\":\"grass\",\"position\":[-12.8091137557088,0,-37.30022932137699],\"scale\":0.8708682997166725},{\"type\":\"grass\",\"position\":[-5.410079462131746,0,39.395531442704346],\"scale\":0.7678538137670331},{\"type\":\"grass\",\"position\":[-100.96241130183215,0,42.25532620354275],\"scale\":1.0525554124714644},{\"type\":\"grass\",\"position\":[-48.87221838240452,0,7.745879821340726],\"scale\":0.923032768605585},{\"type\":\"grass\",\"position\":[-15.388766888714777,0,-17.887992098721213],\"scale\":1.1809129268999403},{\"type\":\"grass\",\"position\":[5.383026231037274,0,13.879791590650497],\"scale\":0.7001406309937107},{\"type\":\"grass\",\"position\":[59.83677392713732,0,-129.8592626599758],\"scale\":1.1332248452601328},{\"type\":\"grass\",\"position\":[57.12254616261032,0,-26.442293573677322],\"scale\":1.006452884290082},{\"type\":\"grass\",\"position\":[66.3128360692068,0,-58.1507742350808],\"scale\":1.0044051205144753},{\"type\":\"grass\",\"position\":[68.59966615039468,0,54.051634024196275],\"scale\":1.1146071080669497},{\"type\":\"grass\",\"position\":[81.28564803085054,0,-32.61973635965107],\"scale\":1.2669119523154355},{\"type\":\"grass\",\"position\":[-5.888944558141364,0,-24.498290205352962],\"scale\":1.144034981337106},{\"type\":\"grass\",\"position\":[-141.43578202798207,0,39.18414003654103],\"scale\":1.113389358069539},{\"type\":\"grass\",\"position\":[-21.69805190324523,0,1.8817402625095287],\"scale\":1.1889528778400098},{\"type\":\"grass\",\"position\":[-90.75590765732694,0,68.49122826770959],\"scale\":1.276372460686361},{\"type\":\"grass\",\"position\":[-80.67668380381149,0,-84.96427984588922],\"scale\":1.0093020171310565},{\"type\":\"grass\",\"position\":[52.676853283837374,0,-47.34323257753047],\"scale\":0.815072090573225},{\"type\":\"grass\",\"position\":[-32.9097642111507,0,-24.238434422825495],\"scale\":1.0146240482553779},{\"type\":\"grass\",\"position\":[28.400306324551423,0,144.31144497865589],\"scale\":1.296109851710086},{\"type\":\"grass\",\"position\":[26.36162921380044,0,29.64097030230515],\"scale\":1.2637415683902153},{\"type\":\"grass\",\"position\":[-31.725905233938605,0,-120.27606846891406],\"scale\":0.9680746885707002},{\"type\":\"grass\",\"position\":[-30.444800954283217,0,42.280752043375095],\"scale\":0.7011666061591348},{\"type\":\"grass\",\"position\":[-67.33840242638263,0,13.754595000339668],\"scale\":1.0637729752821061},{\"type\":\"grass\",\"position\":[-36.046918771702195,0,104.0936628404179],\"scale\":1.0189675207566917},{\"type\":\"grass\",\"position\":[-78.54607387639969,0,72.88386053235467],\"scale\":1.139140621788863},{\"type\":\"grass\",\"position\":[-63.79512592821966,0,-19.770704735189053],\"scale\":0.8604224355267576},{\"type\":\"grass\",\"position\":[23.109172802061543,0,98.74133062737366],\"scale\":1.2604953492794695},{\"type\":\"grass\",\"position\":[134.71052039572228,0,-0.5215026920161664],\"scale\":0.8892460415486343},{\"type\":\"grass\",\"position\":[-0.9734833786339798,0,-0.8450298690005182],\"scale\":1.1823606801786886},{\"type\":\"grass\",\"position\":[-10.721324142045168,0,127.22891636948566],\"scale\":1.02317129287027},{\"type\":\"grass\",\"position\":[-6.200262289281484,0,-4.311809901421721],\"scale\":1.1731411749502016},{\"type\":\"grass\",\"position\":[-86.72415307727816,0,54.34456430452203],\"scale\":0.7901456283606938},{\"type\":\"grass\",\"position\":[71.39241546251459,0,-123.33957602564071],\"scale\":1.2476718844706975},{\"type\":\"grass\",\"position\":[56.81793669669422,0,133.57106515980672],\"scale\":1.2521087372055446},{\"type\":\"grass\",\"position\":[11.886512695282217,0,62.54748526667905],\"scale\":1.1754792055660617},{\"type\":\"grass\",\"position\":[85.31145721137649,0,-5.8197727834981565],\"scale\":0.8166719995501939},{\"type\":\"grass\",\"position\":[79.65606794465855,0,8.124795955874584],\"scale\":0.7697667382723036},{\"type\":\"grass\",\"position\":[118.76056075956393,0,-88.9577196470883],\"scale\":1.0264040675024166},{\"type\":\"grass\",\"position\":[44.2332684309514,0,61.322307146592806],\"scale\":1.1783500151041095},{\"type\":\"grass\",\"position\":[5.046394798921464,0,3.497766638788714],\"scale\":1.1987939874842137},{\"type\":\"grass\",\"position\":[23.06943972456526,0,-9.575437492094501],\"scale\":1.023430257474173},{\"type\":\"grass\",\"position\":[29.166346179009583,0,-11.57788021067557],\"scale\":1.2191677806073677},{\"type\":\"grass\",\"position\":[12.055035188115994,0,-144.60365014392673],\"scale\":0.7391784656055207},{\"type\":\"grass\",\"position\":[-46.0095513327909,0,-87.84505351255271],\"scale\":0.9913373628020561},{\"type\":\"grass\",\"position\":[-87.30569346061925,0,-91.10566414084396],\"scale\":1.2907228806386535},{\"type\":\"grass\",\"position\":[-49.100183611058114,0,-34.87199449499915],\"scale\":1.141455784835149},{\"type\":\"grass\",\"position\":[-42.8915578127288,0,20.215169554859532],\"scale\":1.0436628433994306},{\"type\":\"grass\",\"position\":[105.12753124788131,0,-100.85124284215985],\"scale\":1.1349251405103793},{\"type\":\"grass\",\"position\":[15.871260340392503,0,-47.38956841839827],\"scale\":0.962584899888348},{\"type\":\"grass\",\"position\":[48.28899085848588,0,52.01832564488417],\"scale\":1.1578541745006468},{\"type\":\"grass\",\"position\":[81.16665156572847,0,-27.984472754232172],\"scale\":0.8898137205225384},{\"type\":\"grass\",\"position\":[110.08514936835142,0,-72.43243810127164],\"scale\":0.9153418764224368},{\"type\":\"grass\",\"position\":[53.39825672321954,0,5.2069020232142735],\"scale\":1.0939999164104046},{\"type\":\"grass\",\"position\":[-10.616909156127521,0,-16.898515265271918],\"scale\":0.7061646558956179},{\"type\":\"grass\",\"position\":[-21.647006450229537,0,-30.369211621426036],\"scale\":1.0013324928203198},{\"type\":\"grass\",\"position\":[55.58298871883259,0,25.872752773307006],\"scale\":1.0834859486970003},{\"type\":\"grass\",\"position\":[3.4011483075315687,0,-1.795439446217705],\"scale\":1.1445159320365277},{\"type\":\"grass\",\"position\":[-93.14035832191581,0,31.916720310479686],\"scale\":0.8504741379956484},{\"type\":\"grass\",\"position\":[86.01859641571673,0,-13.13942622315998],\"scale\":1.1064169155922576},{\"type\":\"grass\",\"position\":[71.39223377655742,0,-130.96269424363493],\"scale\":1.0333378171178547},{\"type\":\"grass\",\"position\":[12.851757842195283,0,-28.204003843448312],\"scale\":1.161457210023041},{\"type\":\"grass\",\"position\":[-16.14912401262322,0,13.86594413441061],\"scale\":0.7821908462014977},{\"type\":\"grass\",\"position\":[-47.32071305178135,0,11.226641363107266],\"scale\":0.7913148141312977},{\"type\":\"grass\",\"position\":[6.012909182340824,0,-0.6411804062886772],\"scale\":1.0040583417256204},{\"type\":\"grass\",\"position\":[-6.476254786300656,0,5.499923956989355],\"scale\":1.1509060086941798},{\"type\":\"grass\",\"position\":[26.596138789762936,0,6.814134100235667],\"scale\":0.8567388317845415},{\"type\":\"grass\",\"position\":[-40.34437711245875,0,63.75963570335224],\"scale\":0.8658705332697207},{\"type\":\"grass\",\"position\":[-46.5338845414383,0,-23.364731095725652],\"scale\":0.8149122751494337},{\"type\":\"grass\",\"position\":[-60.37464426700691,0,126.61022288750489],\"scale\":1.2776343253424214},{\"type\":\"grass\",\"position\":[32.71958238375289,0,-11.330409629719252],\"scale\":1.2050534356882507},{\"type\":\"grass\",\"position\":[-94.33352094263496,0,0.0020915432593353613],\"scale\":1.0079964324927446},{\"type\":\"grass\",\"position\":[-0.8249384902416205,0,-0.14736830385283167],\"scale\":0.9721909508924591},{\"type\":\"grass\",\"position\":[-37.24310983340154,0,-26.865302996314146],\"scale\":1.0913693218697817},{\"type\":\"grass\",\"position\":[30.340577616887956,0,-20.37269074987678],\"scale\":1.1499760988005812},{\"type\":\"grass\",\"position\":[3.7814189017814224,0,-9.24681177147535],\"scale\":1.0410935398512007},{\"type\":\"grass\",\"position\":[74.97962390193557,0,-54.712059367545244],\"scale\":1.2525116752991898},{\"type\":\"grass\",\"position\":[-29.240057892798767,0,-14.749006555020431],\"scale\":0.7303898117391768},{\"type\":\"grass\",\"position\":[-71.46261933941511,0,-34.01602329388763],\"scale\":0.9807973367619024},{\"type\":\"grass\",\"position\":[26.71225753868962,0,1.6293975580021984],\"scale\":0.9294160131520737},{\"type\":\"grass\",\"position\":[55.403675765270286,0,-54.17670802630599],\"scale\":1.039710724497793},{\"type\":\"grass\",\"position\":[-88.89499109653713,0,100.00792648830237],\"scale\":1.2863783798648736},{\"type\":\"grass\",\"position\":[2.0243328318854106,0,-21.793561143962304],\"scale\":0.7835122613602261},{\"type\":\"grass\",\"position\":[77.60346142395055,0,13.595724918925548],\"scale\":0.8869379504705691},{\"type\":\"grass\",\"position\":[-8.70519475407529,0,71.29523795386305],\"scale\":1.02153639285982},{\"type\":\"grass\",\"position\":[-19.80564401779882,0,107.33861894877323],\"scale\":0.7118607861705268},{\"type\":\"grass\",\"position\":[70.76241458284228,0,-78.84232269090334],\"scale\":1.0078649237750177},{\"type\":\"grass\",\"position\":[-25.296270744734255,0,82.36998966055185],\"scale\":1.2792677826610372},{\"type\":\"grass\",\"position\":[6.097466574661636,0,-2.3017401028281004],\"scale\":0.8727971274396619},{\"type\":\"grass\",\"position\":[-18.929720112928898,0,35.828319701631344],\"scale\":0.7201964657536076},{\"type\":\"grass\",\"position\":[-19.685213868833017,0,113.692056812456],\"scale\":0.8546005074449696},{\"type\":\"grass\",\"position\":[-7.063182396377491,0,-7.341884125154978],\"scale\":0.8099220680457421},{\"type\":\"grass\",\"position\":[-69.77468740863141,0,20.28765250676729],\"scale\":0.917208982383573},{\"type\":\"grass\",\"position\":[-92.15320189985755,0,-30.49477048214608],\"scale\":0.8207072700815796},{\"type\":\"grass\",\"position\":[32.07132766095634,0,46.900763317152446],\"scale\":0.7003990908086403},{\"type\":\"grass\",\"position\":[-3.38583898122048,0,-67.28402619677193],\"scale\":1.0624309984628317},{\"type\":\"grass\",\"position\":[-117.00049398738784,0,70.27992794648402],\"scale\":0.9374192756413651},{\"type\":\"grass\",\"position\":[-13.855931435408195,0,-22.222065494817414],\"scale\":1.1041546999732852},{\"type\":\"grass\",\"position\":[-126.66798245964276,0,-24.574981642749663],\"scale\":1.1041782123684452},{\"type\":\"grass\",\"position\":[7.588784968385687,0,-7.707038348408333],\"scale\":0.929504598564918},{\"type\":\"grass\",\"position\":[76.26840591383956,0,-31.967614495955534],\"scale\":1.0326656219773012},{\"type\":\"grass\",\"position\":[134.5201365511726,0,-20.578272673152387],\"scale\":0.9731404380249854},{\"type\":\"grass\",\"position\":[-13.82542958609317,0,-11.748943449176975],\"scale\":1.0074977396151887},{\"type\":\"grass\",\"position\":[57.35144208921766,0,-42.19604916798478],\"scale\":1.02941887705699},{\"type\":\"grass\",\"position\":[16.769911273565206,0,99.50086535151028],\"scale\":1.2175403481993883},{\"type\":\"grass\",\"position\":[128.96241610284477,0,-68.26252014227978],\"scale\":0.9966037732090383},{\"type\":\"grass\",\"position\":[-102.3130334291735,0,11.330875459788016],\"scale\":0.8686590774798184},{\"type\":\"grass\",\"position\":[47.52903961007078,0,-85.84782616763039],\"scale\":1.0871815943243872},{\"type\":\"grass\",\"position\":[20.078587755062347,0,49.34265038271255],\"scale\":1.100368765789409},{\"type\":\"grass\",\"position\":[-87.17552578388802,0,53.24056290740648],\"scale\":1.2893333294099487},{\"type\":\"grass\",\"position\":[-42.16053861293782,0,8.913817327013133],\"scale\":0.9209807952148499},{\"type\":\"grass\",\"position\":[0.7067012940293462,0,3.287411579125922],\"scale\":0.8310951980180952},{\"type\":\"grass\",\"position\":[20.896005733500548,0,27.472843262864448],\"scale\":0.7949937285452668},{\"type\":\"grass\",\"position\":[99.19269758418902,0,-48.587311698745715],\"scale\":1.2426241868848318},{\"type\":\"grass\",\"position\":[9.532267068063328,0,-4.443773976681296],\"scale\":1.0393413551619584},{\"type\":\"grass\",\"position\":[-117.33012895685528,0,-68.59765009176887],\"scale\":1.0588941412793182},{\"type\":\"grass\",\"position\":[-19.226594983619215,0,-144.36786857242876],\"scale\":1.2491948060415032},{\"type\":\"grass\",\"position\":[17.803222003329644,0,4.119131915258349],\"scale\":0.9305626150934969},{\"type\":\"grass\",\"position\":[-81.48094959209676,0,11.317083982418698],\"scale\":1.210858616019491},{\"type\":\"grass\",\"position\":[-13.092690208839997,0,-63.72208092423358],\"scale\":0.8735682948420438},{\"type\":\"grass\",\"position\":[-3.276741803078274,0,-21.29239840610362],\"scale\":1.290609626924406},{\"type\":\"grass\",\"position\":[-31.224539361139733,0,-13.13657933857649],\"scale\":0.7437103009450473},{\"type\":\"grass\",\"position\":[-61.39946527882575,0,87.33290136296685],\"scale\":0.9424617229042165},{\"type\":\"grass\",\"position\":[54.09489763737665,0,-38.20831140552339],\"scale\":0.7748011368783672},{\"type\":\"grass\",\"position\":[-42.596107848295645,0,82.33153624213216],\"scale\":1.0058020328910149},{\"type\":\"grass\",\"position\":[56.564232820310956,0,73.54148626295503],\"scale\":0.9751007726954435},{\"type\":\"grass\",\"position\":[-10.142489048532543,0,-54.99101609950411],\"scale\":1.1173461854153148},{\"type\":\"grass\",\"position\":[-10.85858654997087,0,112.99043720398608],\"scale\":1.2722249917741941},{\"type\":\"grass\",\"position\":[0.5645204809947911,0,-0.6036501093559733],\"scale\":1.2298478237268429},{\"type\":\"grass\",\"position\":[-2.3493083624264073,0,0.04295600697653107],\"scale\":1.2374696207325384},{\"type\":\"grass\",\"position\":[-5.20022817034088,0,73.48913902536547],\"scale\":0.7903559928955182},{\"type\":\"grass\",\"position\":[-12.514602400581843,0,-19.729442352904798],\"scale\":0.9530547714764721},{\"type\":\"grass\",\"position\":[-148.42312575382866,0,12.323516016015201],\"scale\":0.7176421195798998},{\"type\":\"grass\",\"position\":[-129.46037936770745,0,57.76177981428924],\"scale\":1.005426032252152},{\"type\":\"grass\",\"position\":[-35.262426335564356,0,22.56422195611274],\"scale\":1.193014378650018},{\"type\":\"grass\",\"position\":[-64.83852439141849,0,43.09430317721278],\"scale\":1.0058266584475237},{\"type\":\"grass\",\"position\":[-31.035369979046244,0,-64.74156542582472],\"scale\":1.2921519458772597},{\"type\":\"grass\",\"position\":[29.93079658360208,0,17.3810208994518],\"scale\":1.2521298793175246},{\"type\":\"grass\",\"position\":[-39.060074434006275,0,-12.14414949229512],\"scale\":1.1175833604009264},{\"type\":\"grass\",\"position\":[5.71278515210655,0,93.52679366979191],\"scale\":0.7009386894522711},{\"type\":\"grass\",\"position\":[29.019767015364142,0,2.317806856183224],\"scale\":0.7253653002852553},{\"type\":\"grass\",\"position\":[139.64426518066594,0,-13.573067383096717],\"scale\":1.227316760480094},{\"type\":\"grass\",\"position\":[-24.899410441372257,0,39.04492171779965],\"scale\":0.7332702141736651},{\"type\":\"grass\",\"position\":[0.1903127433836066,0,54.82521158597055],\"scale\":1.272579945646232},{\"type\":\"grass\",\"position\":[52.076083656875,0,134.49105990689273],\"scale\":1.0975861986067488},{\"type\":\"grass\",\"position\":[45.38160069213777,0,32.899251390823125],\"scale\":0.85357196861422},{\"type\":\"grass\",\"position\":[13.810279970967313,0,-13.006872315528234],\"scale\":1.1596707631710959},{\"type\":\"grass\",\"position\":[-111.63072525156763,0,49.85505185279438],\"scale\":0.9248718370430231},{\"type\":\"grass\",\"position\":[-82.93547751721657,0,-56.6143945082458],\"scale\":0.9415974553585325},{\"type\":\"grass\",\"position\":[50.47854951977472,0,-80.48162251764194],\"scale\":1.1513511607341447},{\"type\":\"grass\",\"position\":[107.18686466999432,0,-4.015132151243916],\"scale\":0.8252760036655113},{\"type\":\"grass\",\"position\":[55.22011747152467,0,-57.1680643031262],\"scale\":1.0041687368610808},{\"type\":\"grass\",\"position\":[-122.8035651090765,0,-74.02750730667933],\"scale\":1.0498022640281683},{\"type\":\"grass\",\"position\":[96.47449889544535,0,-6.055835528625486],\"scale\":1.175876646019816},{\"type\":\"grass\",\"position\":[135.37641331021052,0,-15.936735359531289],\"scale\":1.0800524915810215},{\"type\":\"grass\",\"position\":[50.92329200238008,0,-33.7115701287356],\"scale\":0.7365690838432635},{\"type\":\"grass\",\"position\":[-119.43176091821724,0,78.57656109725085],\"scale\":0.7134836865820058},{\"type\":\"grass\",\"position\":[-2.786891769665625,0,9.58514068115998],\"scale\":0.9644457565582467},{\"type\":\"grass\",\"position\":[3.1143945419416865,0,-28.07260060244413],\"scale\":1.0960059773239654},{\"type\":\"grass\",\"position\":[64.06655323199583,0,-37.64352829156434],\"scale\":1.2357106084047114},{\"type\":\"grass\",\"position\":[-27.940027379939675,0,-64.02240053904806],\"scale\":1.1717764553735956},{\"type\":\"grass\",\"position\":[-10.750152098817804,0,-3.2831227182981966],\"scale\":0.8202304556374468},{\"type\":\"grass\",\"position\":[65.4576405529545,0,52.19102114206312],\"scale\":0.8887842633514832},{\"type\":\"grass\",\"position\":[82.90588550377954,0,-72.64327364831667],\"scale\":1.14216561363874},{\"type\":\"grass\",\"position\":[-29.573415464393396,0,-21.144161705370337],\"scale\":1.2940998759363243},{\"type\":\"grass\",\"position\":[-94.95529876174226,0,-24.639940889213836],\"scale\":1.0368778072266998},{\"type\":\"grass\",\"position\":[-19.909135041223948,0,-40.73965670109105],\"scale\":1.173430214484237},{\"type\":\"grass\",\"position\":[33.99234783330034,0,-35.51167056303002],\"scale\":0.7656289684285761},{\"type\":\"grass\",\"position\":[44.69139945221284,0,-49.282358293587535],\"scale\":1.2385803325229237},{\"type\":\"grass\",\"position\":[5.570521942330638,0,48.08839729779631],\"scale\":1.184782750914842},{\"type\":\"grass\",\"position\":[19.549123139428236,0,36.98805244334048],\"scale\":1.2169638503948046},{\"type\":\"grass\",\"position\":[93.47159655870105,0,-26.48297652930852],\"scale\":0.7245807775563011},{\"type\":\"grass\",\"position\":[-95.71870431304359,0,-56.197859862068185],\"scale\":0.7104565672154749},{\"type\":\"grass\",\"position\":[-89.59754707035007,0,65.09781773081703],\"scale\":0.9839187890838794},{\"type\":\"grass\",\"position\":[82.68860572275554,0,-110.5392651469863],\"scale\":1.1418739558351678},{\"type\":\"grass\",\"position\":[-91.77631361200147,0,-96.23777000555303],\"scale\":0.7199787925901623},{\"type\":\"grass\",\"position\":[11.835290390330858,0,137.1753570335962],\"scale\":1.251183950755978},{\"type\":\"grass\",\"position\":[111.52398387067447,0,-9.47807295472638],\"scale\":1.015863914466153},{\"type\":\"grass\",\"position\":[-13.732117618068676,0,90.03787438807882],\"scale\":0.9134568215949347},{\"type\":\"grass\",\"position\":[89.54098821719195,0,56.01384190966044],\"scale\":1.2154939793704287},{\"type\":\"grass\",\"position\":[-43.7698121759624,0,6.921040378786402],\"scale\":0.7496972295923089},{\"type\":\"grass\",\"position\":[23.097738474942446,0,-87.32398997881103],\"scale\":1.2432684809107308},{\"type\":\"grass\",\"position\":[-0.40399691618781947,0,-0.5054098028897039],\"scale\":0.8568723358182382},{\"type\":\"grass\",\"position\":[-23.778303004357483,0,-12.599109509090269],\"scale\":0.7390772247894768},{\"type\":\"grass\",\"position\":[17.911845797838463,0,49.73431714582133],\"scale\":0.8449573318747557},{\"type\":\"grass\",\"position\":[13.783715875194828,0,110.26852720024458],\"scale\":1.0780059268329887},{\"type\":\"grass\",\"position\":[20.805954774748482,0,22.143887632713742],\"scale\":1.0415031282067937},{\"type\":\"grass\",\"position\":[123.13894184276779,0,17.17418600636792],\"scale\":1.0411248018360293},{\"type\":\"grass\",\"position\":[34.634534518272886,0,-11.542266134466432],\"scale\":0.9138246031114289},{\"type\":\"grass\",\"position\":[5.3010352554125415,0,-19.867947765261746],\"scale\":1.2429487279235407},{\"type\":\"grass\",\"position\":[-64.98191137075821,0,-90.08305697963948],\"scale\":0.704342256262914},{\"type\":\"grass\",\"position\":[9.086713655996688,0,18.090437127996612],\"scale\":1.2364289870687841},{\"type\":\"grass\",\"position\":[-110.93371250436053,0,29.472898212451568],\"scale\":0.8511378336895974},{\"type\":\"grass\",\"position\":[36.047338472348,0,41.74866174560363],\"scale\":1.0733596570198203},{\"type\":\"grass\",\"position\":[-42.66047759186064,0,96.47131864415323],\"scale\":1.132234896091554},{\"type\":\"grass\",\"position\":[-112.93023294638097,0,15.674440387475128],\"scale\":0.7009388001491476},{\"type\":\"grass\",\"position\":[78.57860986006082,0,53.444501890528095],\"scale\":0.8449503958331892},{\"type\":\"grass\",\"position\":[3.42262053254897,0,-2.3291852633137258],\"scale\":0.7209631745846004},{\"type\":\"grass\",\"position\":[121.13318854220059,0,13.23980333303765],\"scale\":1.200421036411995},{\"type\":\"grass\",\"position\":[-59.5857583993499,0,-53.60787194430611],\"scale\":1.197134548453385},{\"type\":\"grass\",\"position\":[59.40295540630998,0,33.32803252777089],\"scale\":1.0217588391069605},{\"type\":\"grass\",\"position\":[96.62114934841219,0,63.20555005181873],\"scale\":0.9566922008027141},{\"type\":\"grass\",\"position\":[-92.66847253587645,0,-90.11739636843417],\"scale\":0.8859281557052282},{\"type\":\"grass\",\"position\":[62.91909841790303,0,-2.2398346573498067],\"scale\":1.1243422573987736},{\"type\":\"grass\",\"position\":[29.33222870526339,0,62.706239141777786],\"scale\":1.1885478422762177},{\"type\":\"grass\",\"position\":[-68.78148960821056,0,-77.85428299143034],\"scale\":1.0831862578991027},{\"type\":\"grass\",\"position\":[75.44397354585469,0,5.9312514509388965],\"scale\":1.2721437833430063},{\"type\":\"grass\",\"position\":[-6.389439013521342,0,16.3988044851667],\"scale\":0.9290803784043962},{\"type\":\"grass\",\"position\":[-56.247214249992005,0,54.72141657774547],\"scale\":1.0791122035272984},{\"type\":\"grass\",\"position\":[-7.175399185755512,0,-5.126251969992807],\"scale\":1.1138443288344524},{\"type\":\"grass\",\"position\":[-105.70791514498846,0,26.548617533134728],\"scale\":1.294852700567531},{\"type\":\"grass\",\"position\":[-115.36895236673266,0,31.068215576915403],\"scale\":0.8089278414998149},{\"type\":\"grass\",\"position\":[6.827486061149816,0,8.676214298729077],\"scale\":0.9951032509409456},{\"type\":\"grass\",\"position\":[-14.90361042038975,0,-54.86682749152135],\"scale\":0.7947867453352084},{\"type\":\"grass\",\"position\":[55.21883628902268,0,41.63598908982968],\"scale\":1.0830632182690136},{\"type\":\"grass\",\"position\":[44.03936015515153,0,-42.37124232072133],\"scale\":0.7570770972682623},{\"type\":\"grass\",\"position\":[63.3840492491612,0,-22.743196909168955],\"scale\":1.2434601997487522},{\"type\":\"grass\",\"position\":[72.76053667040298,0,83.51230544992033],\"scale\":1.086279151513288},{\"type\":\"grass\",\"position\":[25.810869914927018,0,-8.283304642317246],\"scale\":1.248224950789711},{\"type\":\"grass\",\"position\":[79.12438069029658,0,-64.7736105335447],\"scale\":1.0812785645976806},{\"type\":\"grass\",\"position\":[23.917366002307276,0,-29.839813667058852],\"scale\":1.1813072821188326},{\"type\":\"grass\",\"position\":[-75.59279178275408,0,4.0486188202660465],\"scale\":0.7948292917864084},{\"type\":\"grass\",\"position\":[17.25892061004398,0,-1.642121922709176],\"scale\":1.0365472541836227},{\"type\":\"grass\",\"position\":[16.00051119151573,0,44.73007943449695],\"scale\":0.7832886672146132},{\"type\":\"grass\",\"position\":[-12.320629230520789,0,-18.41613553585099],\"scale\":1.0405216905332915},{\"type\":\"grass\",\"position\":[-7.1933117856313755,0,3.2411033860499407],\"scale\":1.0186032771315012},{\"type\":\"grass\",\"position\":[6.277745234371647,0,11.076137314989039],\"scale\":1.295174814792078},{\"type\":\"grass\",\"position\":[49.48052119143777,0,-127.89188890833404],\"scale\":0.9498400542832718},{\"type\":\"grass\",\"position\":[-32.9879889488782,0,23.308350905714295],\"scale\":0.994858300346042},{\"type\":\"grass\",\"position\":[-49.321552947863054,0,-78.51366256773169],\"scale\":0.8733505636737351},{\"type\":\"grass\",\"position\":[-73.25580316779546,0,14.556934177037826],\"scale\":1.023922161666185},{\"type\":\"grass\",\"position\":[67.1722755064863,0,81.33307602017017],\"scale\":0.8064468334397924},{\"type\":\"grass\",\"position\":[-62.9208047302725,0,-104.72746187404309],\"scale\":0.7371817611309359},{\"type\":\"grass\",\"position\":[2.8495793323734535,0,-105.53517207052062],\"scale\":0.8871833902439064},{\"type\":\"grass\",\"position\":[24.573783955263874,0,144.10356386168115],\"scale\":1.2363671380680645},{\"type\":\"grass\",\"position\":[-27.79378752148452,0,-88.59287270782305],\"scale\":1.2791565300827261},{\"type\":\"grass\",\"position\":[1.3756272641555474,0,48.214404261593955],\"scale\":0.7287108415862572},{\"type\":\"grass\",\"position\":[147.5623945397556,0,-17.951701653054894],\"scale\":1.2266210655206597},{\"type\":\"grass\",\"position\":[-27.566712764771864,0,105.79007211621087],\"scale\":1.186497533657331},{\"type\":\"grass\",\"position\":[56.78795955614579,0,45.12280911151399],\"scale\":1.162113861236112},{\"type\":\"grass\",\"position\":[-130.71485163346358,0,21.609750522329172],\"scale\":1.1574165448538225},{\"type\":\"grass\",\"position\":[-20.420239457323802,0,-95.81426211031501],\"scale\":0.7328230007495433},{\"type\":\"grass\",\"position\":[-30.85962438126337,0,38.1102926363158],\"scale\":0.9909445282056423},{\"type\":\"grass\",\"position\":[28.040114573082512,0,51.021984710317355],\"scale\":1.2146283049520514},{\"type\":\"grass\",\"position\":[89.34435037783985,0,89.96696985530153],\"scale\":0.9218489196884001},{\"type\":\"grass\",\"position\":[119.39437380297156,0,-73.85056979105282],\"scale\":1.2755859871160355},{\"type\":\"grass\",\"position\":[6.70277431133952,0,-1.0261103031195205],\"scale\":1.2425097896989743},{\"type\":\"grass\",\"position\":[-0.008648156865009988,0,35.63528600613183],\"scale\":1.1780364570485813},{\"type\":\"grass\",\"position\":[-77.79311077871053,0,14.206755747687838],\"scale\":1.1397750935469577},{\"type\":\"grass\",\"position\":[-143.00819301180334,0,4.524130225025579],\"scale\":1.0481000863428371},{\"type\":\"grass\",\"position\":[-30.69454734157696,0,-118.90238470431545],\"scale\":0.8811520633148802},{\"type\":\"grass\",\"position\":[-90.96462889531607,0,-50.86893000746647],\"scale\":0.9818395912586515},{\"type\":\"grass\",\"position\":[-16.840444135379574,0,-119.0714804203955],\"scale\":1.228846761435744},{\"type\":\"grass\",\"position\":[-2.5226293786026583,0,-84.52676207380483],\"scale\":0.8434548801388215},{\"type\":\"grass\",\"position\":[0.34091849382144335,0,-3.1891167312019966],\"scale\":1.2694059726702018},{\"type\":\"grass\",\"position\":[-9.593749996225746,0,77.12162435285138],\"scale\":0.8359762728790254},{\"type\":\"grass\",\"position\":[7.961033968189419,0,-22.94809086436209],\"scale\":1.103184737296781},{\"type\":\"grass\",\"position\":[-14.162083366865932,0,-112.99667056213701],\"scale\":1.0060446823876412},{\"type\":\"grass\",\"position\":[79.81629490128002,0,57.958454839172255],\"scale\":0.8161160391928565},{\"type\":\"grass\",\"position\":[81.92602003990726,0,-63.16882750819948],\"scale\":1.2097868885501697},{\"type\":\"grass\",\"position\":[-6.055853157054494,0,1.321810635005604],\"scale\":1.2418661663883925},{\"type\":\"grass\",\"position\":[2.2009626658071553,0,-7.242375942272993],\"scale\":1.1976161151921745},{\"type\":\"grass\",\"position\":[24.294862538309246,0,-1.5839514030368487],\"scale\":0.7247336887240069},{\"type\":\"grass\",\"position\":[-3.1381348710018346,0,14.603322813684388],\"scale\":0.819637228431606},{\"type\":\"grass\",\"position\":[-35.289003535012235,0,41.54287700084837],\"scale\":0.7427165182712726},{\"type\":\"grass\",\"position\":[-108.63483773977194,0,-5.523955201265084],\"scale\":0.8599190060147736},{\"type\":\"grass\",\"position\":[12.847867779563847,0,9.60338389850826],\"scale\":0.9190395639669326},{\"type\":\"grass\",\"position\":[96.2489984826661,0,39.926603118066176],\"scale\":1.0684196181125951},{\"type\":\"grass\",\"position\":[119.82745013431116,0,73.206140477283],\"scale\":1.2261446815644668},{\"type\":\"grass\",\"position\":[50.66862456669976,0,112.09090248222758],\"scale\":1.1187404391603348},{\"type\":\"grass\",\"position\":[-40.8589789760707,0,-25.856208240306064],\"scale\":0.9984291197572555},{\"type\":\"grass\",\"position\":[61.86097455686222,0,66.42893299171303],\"scale\":1.0494133477328957},{\"type\":\"grass\",\"position\":[-26.954470411030915,0,-30.1386041967443],\"scale\":0.9140119699519331},{\"type\":\"grass\",\"position\":[28.349228272430228,0,26.85017658243395],\"scale\":1.1101140770115854},{\"type\":\"grass\",\"position\":[2.389668551310406,0,-37.108161246725686],\"scale\":0.8163596538704185},{\"type\":\"grass\",\"position\":[-86.3909936622113,0,34.9563265371679],\"scale\":1.256967385902084},{\"type\":\"grass\",\"position\":[27.163998065928208,0,30.457260724011523],\"scale\":1.07986416726014},{\"type\":\"grass\",\"position\":[-56.639229396303115,0,12.249748678947254],\"scale\":1.1281149025276231},{\"type\":\"grass\",\"position\":[14.118837753852336,0,27.858687154008322],\"scale\":1.2902584400822112},{\"type\":\"grass\",\"position\":[-50.305330650385926,0,91.05127484501058],\"scale\":0.961099085025765},{\"type\":\"grass\",\"position\":[56.39766299457894,0,-18.7538935989486],\"scale\":1.1712914223415587},{\"type\":\"grass\",\"position\":[35.59912655718183,0,-94.34996487278597],\"scale\":1.050140195086312},{\"type\":\"grass\",\"position\":[-1.5174437779849175,0,-2.3691433324454545],\"scale\":1.0784239807256029},{\"type\":\"grass\",\"position\":[10.648369671047048,0,-0.706736573713033],\"scale\":0.8572632017128023},{\"type\":\"grass\",\"position\":[-55.15778793123925,0,2.9524697303193994],\"scale\":1.0462584739283767},{\"type\":\"grass\",\"position\":[95.90770431906618,0,-35.486122857101165],\"scale\":1.1790769318936567},{\"type\":\"grass\",\"position\":[29.29715494374421,0,29.789533612375717],\"scale\":1.2801775021615747},{\"type\":\"grass\",\"position\":[-3.626916140018804,0,-16.706014261666848],\"scale\":1.1913145279470836},{\"type\":\"grass\",\"position\":[0.9216942076729232,0,23.33745196781481],\"scale\":1.2650296013731248},{\"type\":\"grass\",\"position\":[-147.31587469787107,0,1.223194801518434],\"scale\":1.1538390150097726},{\"type\":\"grass\",\"position\":[26.737722679706664,0,-52.00225878760451],\"scale\":0.7646301065827643},{\"type\":\"grass\",\"position\":[2.097722276510505,0,-54.00044600452784],\"scale\":1.2613965750086704},{\"type\":\"grass\",\"position\":[8.147379799976635,0,60.512027370398215],\"scale\":0.730752208229965},{\"type\":\"grass\",\"position\":[76.52493911560741,0,-108.10817710455966],\"scale\":0.7949733354803521},{\"type\":\"grass\",\"position\":[0.09091346982032611,0,0.3458025595251097],\"scale\":1.2417697691240221},{\"type\":\"grass\",\"position\":[-72.65647700154987,0,-92.51375765822534],\"scale\":1.2028256029558544},{\"type\":\"grass\",\"position\":[71.41307435641176,0,-49.59948837809845],\"scale\":1.113115605887283},{\"type\":\"grass\",\"position\":[-61.62733954203283,0,77.3060716155001],\"scale\":0.8491297870306465},{\"type\":\"grass\",\"position\":[-9.119766382136278,0,-11.721914584352055],\"scale\":1.1476724965677554},{\"type\":\"grass\",\"position\":[-63.499306053017264,0,-13.521847062835453],\"scale\":1.2731020333315812},{\"type\":\"grass\",\"position\":[124.0012026010991,0,61.993387080476644],\"scale\":1.141054919208027},{\"type\":\"grass\",\"position\":[-3.7860230356957447,0,-28.66980309452079],\"scale\":0.8099519916936869},{\"type\":\"grass\",\"position\":[-66.12267203056788,0,71.34482515581543],\"scale\":0.8446571970732741},{\"type\":\"grass\",\"position\":[-86.1666075350275,0,39.17045590542745],\"scale\":0.9172414453441183},{\"type\":\"grass\",\"position\":[25.743058806296744,0,20.235890813421605],\"scale\":1.1381491671066564},{\"type\":\"grass\",\"position\":[44.751210278860135,0,87.6729245729077],\"scale\":0.9147690776400765},{\"type\":\"grass\",\"position\":[51.50362128071602,0,-10.360022984250376],\"scale\":1.1817594405358647},{\"type\":\"grass\",\"position\":[2.7665136669639168,0,-6.428771987156334],\"scale\":0.9979763070853486},{\"type\":\"grass\",\"position\":[-43.71977450641861,0,107.64840866550506],\"scale\":0.7164592045542971},{\"type\":\"grass\",\"position\":[-110.30476071712742,0,84.61371713600025],\"scale\":1.182433036488058},{\"type\":\"grass\",\"position\":[-32.45647096686186,0,16.219692885084626],\"scale\":0.9876324584313374},{\"type\":\"grass\",\"position\":[-38.08919496622584,0,-102.97689761973994],\"scale\":1.0668587192973735},{\"type\":\"grass\",\"position\":[15.902434557889881,0,-72.23858059836762],\"scale\":1.1145280462049834},{\"type\":\"grass\",\"position\":[-31.22240605945682,0,-21.173536912838724],\"scale\":0.702489288560695},{\"type\":\"grass\",\"position\":[-81.20205798095301,0,40.483435769721744],\"scale\":0.7335700971819687},{\"type\":\"grass\",\"position\":[-43.937016591555825,0,-12.71374345935024],\"scale\":0.8672176102102922},{\"type\":\"grass\",\"position\":[-130.4141717810219,0,53.72224765278745],\"scale\":1.2435097729633218},{\"type\":\"grass\",\"position\":[13.439025010834616,0,-53.02289647137559],\"scale\":0.8976336544628544},{\"type\":\"grass\",\"position\":[-28.63523445884216,0,-21.66736490148797],\"scale\":0.9472094403260104},{\"type\":\"grass\",\"position\":[-16.995456887553335,0,-3.5547247751624282],\"scale\":0.7717891956151192},{\"type\":\"grass\",\"position\":[45.84300073841738,0,-27.171328244093157],\"scale\":0.7167689058803237},{\"type\":\"grass\",\"position\":[-87.79526923661409,0,29.343611211567428],\"scale\":0.9152681601682385},{\"type\":\"grass\",\"position\":[-2.762446142799395,0,0.9559526710692783],\"scale\":1.2173596225374153},{\"type\":\"grass\",\"position\":[-9.210325410156594,0,-93.76959284282945],\"scale\":0.8181922294472631},{\"type\":\"grass\",\"position\":[59.05121869789182,0,-22.49033763673177],\"scale\":1.2311816307585328},{\"type\":\"grass\",\"position\":[13.163847013262309,0,-16.0078211490206],\"scale\":0.9204742061124674},{\"type\":\"grass\",\"position\":[91.34357999915639,0,-17.17621921935461],\"scale\":1.0804618859709163},{\"type\":\"grass\",\"position\":[43.345809731966,0,-91.48723719098342],\"scale\":0.9569302157739141},{\"type\":\"grass\",\"position\":[26.97784702124106,0,40.44163591994581],\"scale\":0.8988875523206273},{\"type\":\"grass\",\"position\":[115.26133610066061,0,44.316034531219294],\"scale\":1.2753778580659678},{\"type\":\"grass\",\"position\":[60.43770188460437,0,-8.213771200279506],\"scale\":1.0883864942147288},{\"type\":\"grass\",\"position\":[1.4393872008706534,0,82.18597399568365],\"scale\":1.1071772324578368},{\"type\":\"grass\",\"position\":[-44.96018852755751,0,18.638951747724605],\"scale\":0.7829213709568862},{\"type\":\"grass\",\"position\":[-119.20016084584502,0,-41.98819628577233],\"scale\":1.2656059120764955},{\"type\":\"grass\",\"position\":[-59.37756448394218,0,119.6575951157755],\"scale\":1.17463448736234},{\"type\":\"grass\",\"position\":[-80.54604457921265,0,-21.914288879146234],\"scale\":0.78843683161187},{\"type\":\"grass\",\"position\":[-35.1205651020132,0,60.491171948808685],\"scale\":0.9742567000190832},{\"type\":\"grass\",\"position\":[59.51396412530602,0,27.62273049975279],\"scale\":0.9034253801676699},{\"type\":\"grass\",\"position\":[90.09010959693533,0,-38.765067669347275],\"scale\":1.1075856516797138},{\"type\":\"grass\",\"position\":[87.11415562016431,0,-97.71831116172648],\"scale\":1.2020849536961715},{\"type\":\"grass\",\"position\":[94.97624770700811,0,-17.512910287689838],\"scale\":1.1958061907836204},{\"type\":\"grass\",\"position\":[54.095559216085576,0,-48.41020884573899],\"scale\":0.7468887305831526},{\"type\":\"grass\",\"position\":[-126.63928306668974,0,34.81058598452179],\"scale\":1.1424985791389461},{\"type\":\"grass\",\"position\":[-49.31898767620478,0,110.48500266304686],\"scale\":0.9745400432520667},{\"type\":\"grass\",\"position\":[-37.48315009235992,0,17.598547893845343],\"scale\":1.0617506609360035},{\"type\":\"grass\",\"position\":[-46.49491108703591,0,-114.44519565813317],\"scale\":0.9425548522447429},{\"type\":\"grass\",\"position\":[-38.276702164794074,0,-49.51137384308822],\"scale\":1.0501265819134262},{\"type\":\"grass\",\"position\":[8.557526070886613,0,6.006269507759047],\"scale\":1.135288152768793},{\"type\":\"grass\",\"position\":[46.52101163737756,0,-41.518029576318824],\"scale\":0.9494845606596933},{\"type\":\"grass\",\"position\":[-36.7127105979772,0,130.84977770232157],\"scale\":0.9659438991669114},{\"type\":\"grass\",\"position\":[6.225546008591228,0,-2.5478418819567685],\"scale\":0.7811817999927024},{\"type\":\"grass\",\"position\":[-38.628649026843654,0,-86.62632421777471],\"scale\":0.9884464112044016},{\"type\":\"grass\",\"position\":[-37.07084937242812,0,-42.898336299644306],\"scale\":0.9107449958243162},{\"type\":\"grass\",\"position\":[-38.810107755057885,0,107.79567610681107],\"scale\":1.1582586037315796},{\"type\":\"grass\",\"position\":[-18.127216831526248,0,-33.19527447126521],\"scale\":0.8990070742936872},{\"type\":\"grass\",\"position\":[-140.4864292007446,0,-50.69926288856958],\"scale\":1.227982286043722},{\"type\":\"grass\",\"position\":[47.90663698366666,0,100.82138832388567],\"scale\":0.955431356090704},{\"type\":\"grass\",\"position\":[-13.563184038907385,0,2.91548359193216],\"scale\":1.2367268583829523},{\"type\":\"grass\",\"position\":[-14.626587374526135,0,15.438859098777758],\"scale\":0.9110732830191147},{\"type\":\"grass\",\"position\":[-86.09007713607147,0,-72.63521448614988],\"scale\":0.7167263526835339},{\"type\":\"grass\",\"position\":[45.80471278560245,0,20.38153130541424],\"scale\":0.7839545934069737},{\"type\":\"grass\",\"position\":[27.857201139275887,0,94.00173536719939],\"scale\":0.776813445243706},{\"type\":\"grass\",\"position\":[-5.647675533818737,0,-14.319053041225498],\"scale\":1.2877673996995593},{\"type\":\"grass\",\"position\":[44.75477805669935,0,38.75634947146678],\"scale\":1.1556181413492932},{\"type\":\"grass\",\"position\":[50.47377617829529,0,57.5349928940084],\"scale\":0.912486739478683},{\"type\":\"grass\",\"position\":[-52.593812486827915,0,24.282710344171957],\"scale\":0.7334503692039182},{\"type\":\"grass\",\"position\":[-97.40055414303322,0,-79.50641770148196],\"scale\":0.8885010539032394},{\"type\":\"grass\",\"position\":[54.48895194139641,0,-51.3049938833286],\"scale\":0.8180791798172458},{\"type\":\"grass\",\"position\":[-7.930414026922364,0,-90.17695438889218],\"scale\":1.2204704611674393},{\"type\":\"grass\",\"position\":[-92.47105533709271,0,-81.10011628858354],\"scale\":1.1257787881305221},{\"type\":\"grass\",\"position\":[7.298461903012332,0,4.489994705879598],\"scale\":1.0849677699157607},{\"type\":\"grass\",\"position\":[32.21232323225342,0,-29.363355988715657],\"scale\":1.0868390228645837},{\"type\":\"grass\",\"position\":[21.95077299659834,0,8.505137080285882],\"scale\":1.2095211683304603},{\"type\":\"grass\",\"position\":[-80.60471549343016,0,-70.88043957688991],\"scale\":0.7831880871058898},{\"type\":\"grass\",\"position\":[-119.89618105840053,0,-1.14618648056309],\"scale\":1.0521137580824793},{\"type\":\"grass\",\"position\":[7.615179969040948,0,-124.37438612579429],\"scale\":1.040794188789684},{\"type\":\"grass\",\"position\":[4.785475927348074,0,-49.219747049569925],\"scale\":1.2155361892073226},{\"type\":\"grass\",\"position\":[9.322060157565028,0,128.4989342189353],\"scale\":1.0187866133191334},{\"type\":\"grass\",\"position\":[-20.099494203158933,0,8.549061930380548],\"scale\":1.200592269073006},{\"type\":\"grass\",\"position\":[-43.831731787855226,0,-11.738189814998421],\"scale\":1.1918528141356828},{\"type\":\"grass\",\"position\":[-72.5587261555203,0,50.501753316682375],\"scale\":0.8100447773402497},{\"type\":\"grass\",\"position\":[67.87864963566928,0,107.90612887429033],\"scale\":0.9382659961475484},{\"type\":\"grass\",\"position\":[-131.37236990036845,0,45.63382503247646],\"scale\":0.8389315301017948},{\"type\":\"grass\",\"position\":[62.434179825279855,0,0.2893629969947376],\"scale\":0.9971276445052175},{\"type\":\"grass\",\"position\":[73.42242005805248,0,-26.07497953451002],\"scale\":0.7399589694941572},{\"type\":\"grass\",\"position\":[-39.86253394471249,0,112.84194952720355],\"scale\":1.1951557503575123},{\"type\":\"grass\",\"position\":[44.72033754372919,0,-88.39647079362287],\"scale\":0.9151559245275648},{\"type\":\"grass\",\"position\":[-13.703274987867971,0,-116.48131522323106],\"scale\":1.0370079823088112},{\"type\":\"grass\",\"position\":[66.40944101337449,0,-125.77782056635789],\"scale\":0.8232295617538126},{\"type\":\"grass\",\"position\":[43.58018817560999,0,86.4309934219027],\"scale\":0.9442746476876633},{\"type\":\"grass\",\"position\":[-1.7515072465338206,0,-2.378717412555966],\"scale\":0.783018276491918},{\"type\":\"grass\",\"position\":[-1.6757204258617688,0,-124.1775101023492],\"scale\":1.1094824341148337},{\"type\":\"grass\",\"position\":[-81.20246700728838,0,-33.40587540515358],\"scale\":1.2796853770291636},{\"type\":\"grass\",\"position\":[39.33863696272224,0,136.55510547156192],\"scale\":0.9801524316281671},{\"type\":\"grass\",\"position\":[-51.939695291897245,0,118.13290361641468],\"scale\":0.7881345936081046},{\"type\":\"grass\",\"position\":[79.48393399584296,0,-22.81448431790029],\"scale\":1.1312038929083645},{\"type\":\"grass\",\"position\":[123.67256292206328,0,16.361572475565854],\"scale\":1.0473304732403126},{\"type\":\"grass\",\"position\":[1.0630872585703857,0,2.065259642666893],\"scale\":0.7878872264256267},{\"type\":\"grass\",\"position\":[-32.95842849631787,0,2.0482279272696227],\"scale\":0.8769035553264168},{\"type\":\"grass\",\"position\":[-3.5523952235517813,0,108.96144420056525],\"scale\":1.2118985453687665},{\"type\":\"grass\",\"position\":[-98.9597061310824,0,-79.47574257572828],\"scale\":0.9339238216558983},{\"type\":\"grass\",\"position\":[85.39619408166979,0,-108.4497099105753],\"scale\":0.9201249235783213},{\"type\":\"grass\",\"position\":[3.5295406739458177,0,-10.097125820243695],\"scale\":1.0650669956269476},{\"type\":\"grass\",\"position\":[-75.62542165152793,0,-109.95458493185515],\"scale\":0.7307872431109443},{\"type\":\"grass\",\"position\":[-125.66064035553381,0,-21.029483809298096],\"scale\":0.9438605541768689},{\"type\":\"grass\",\"position\":[-21.25556353482812,0,-45.52250966472478],\"scale\":1.080025832681314},{\"type\":\"grass\",\"position\":[12.922064039920098,0,25.04660669594429],\"scale\":1.162272854368826},{\"type\":\"grass\",\"position\":[-86.41237005248385,0,16.564521786246402],\"scale\":0.8827663415988196},{\"type\":\"grass\",\"position\":[-16.026023793663175,0,84.35069664312365],\"scale\":0.9630420425871936},{\"type\":\"grass\",\"position\":[-55.95516755258788,0,10.78591647992824],\"scale\":1.0185272106033645},{\"type\":\"grass\",\"position\":[24.944251677195165,0,-77.61617096838488],\"scale\":0.9302544048656212},{\"type\":\"grass\",\"position\":[15.303756368808545,0,5.641433625352341],\"scale\":1.0531829997859457},{\"type\":\"grass\",\"position\":[-56.38885676458641,0,-29.163121768345764],\"scale\":1.1455419348869538},{\"type\":\"grass\",\"position\":[56.65769591705932,0,-80.39972034189259],\"scale\":0.9705089808737707},{\"type\":\"grass\",\"position\":[-87.87064300561003,0,-94.19193715542193],\"scale\":0.8778530033926696},{\"type\":\"grass\",\"position\":[77.06338757747015,0,32.6573891473776],\"scale\":0.9636416414391329},{\"type\":\"grass\",\"position\":[147.094247806239,0,7.941042539722934],\"scale\":0.9710887445830756},{\"type\":\"grass\",\"position\":[-32.486845873453376,0,24.899133036065432],\"scale\":1.0245214945339955},{\"type\":\"grass\",\"position\":[-127.26889278011035,0,59.12092905205947],\"scale\":1.0762871135972563},{\"type\":\"grass\",\"position\":[-31.120477440613772,0,32.29964108486938],\"scale\":1.1291293020710365},{\"type\":\"grass\",\"position\":[92.27624826719959,0,92.93111965324536],\"scale\":0.9921673682311156},{\"type\":\"grass\",\"position\":[29.601172415994753,0,85.28418520578983],\"scale\":0.7572856564527648},{\"type\":\"grass\",\"position\":[2.7885660107318033,0,82.28298069845752],\"scale\":1.0602654106026717},{\"type\":\"grass\",\"position\":[-12.477695796958328,0,13.372361229664138],\"scale\":0.7212703845911429},{\"type\":\"grass\",\"position\":[55.206045880367476,0,9.30449464891544],\"scale\":0.953396189314395},{\"type\":\"grass\",\"position\":[114.50273384555005,0,-67.40221782911426],\"scale\":1.0243714542173001},{\"type\":\"grass\",\"position\":[2.1293176464763666,0,-0.49429092504183364],\"scale\":0.8154588843092782},{\"type\":\"grass\",\"position\":[6.02251220699001,0,-3.2086899834135836],\"scale\":1.1672176966864933},{\"type\":\"grass\",\"position\":[-0.3407716831002707,0,9.709503829714091],\"scale\":1.2641737160142976},{\"type\":\"grass\",\"position\":[-51.24377736236864,0,-49.36377772089373],\"scale\":1.011476016693791},{\"type\":\"grass\",\"position\":[6.827675754468614,0,22.348829164565757],\"scale\":0.9455120761780568},{\"type\":\"grass\",\"position\":[-8.790954320096896,0,-144.9428808512849],\"scale\":0.7782913086618107},{\"type\":\"grass\",\"position\":[119.63524538160017,0,-8.85853887530273],\"scale\":0.9373957070739015},{\"type\":\"grass\",\"position\":[-51.603824245369296,0,-99.3577656939001],\"scale\":1.114873670274827},{\"type\":\"grass\",\"position\":[30.235956687895175,0,46.3643241453898],\"scale\":0.8123405395415547},{\"type\":\"grass\",\"position\":[34.4447104572764,0,-39.779336280204724],\"scale\":1.2833827552307602},{\"type\":\"grass\",\"position\":[4.083159802703095,0,-61.293176010908375],\"scale\":1.011052563503391},{\"type\":\"grass\",\"position\":[60.44995633130648,0,-9.257370440540264],\"scale\":0.9967333812711089},{\"type\":\"grass\",\"position\":[34.88676551676097,0,23.4068945346642],\"scale\":1.1073711832250046},{\"type\":\"grass\",\"position\":[1.2416115884168377,0,-27.834454976633943],\"scale\":0.7985143568656236},{\"type\":\"grass\",\"position\":[-106.35252415760388,0,4.833464172259803],\"scale\":1.2212314815305574},{\"type\":\"grass\",\"position\":[-7.479451731287438,0,8.009543690276596],\"scale\":0.7716939119470168},{\"type\":\"grass\",\"position\":[-55.890886864364646,0,-37.736564225939],\"scale\":0.8324142029606535},{\"type\":\"grass\",\"position\":[98.97581285311264,0,100.99989448364815],\"scale\":1.1591806289523063},{\"type\":\"grass\",\"position\":[38.63901143064509,0,54.22530697147165],\"scale\":1.1202723390799632},{\"type\":\"grass\",\"position\":[-62.45649053580273,0,-74.14025586014462],\"scale\":0.7578292390642692},{\"type\":\"grass\",\"position\":[66.13563350698263,0,-111.409124238309],\"scale\":1.0789289909588675},{\"type\":\"grass\",\"position\":[-91.18912523171619,0,65.73590082543599],\"scale\":1.1661221112742293},{\"type\":\"grass\",\"position\":[-22.555110082113067,0,-127.54530704104931],\"scale\":0.7946221433248384},{\"type\":\"grass\",\"position\":[0.3873975043832299,0,-96.59297188433526],\"scale\":1.0835181318262885},{\"type\":\"grass\",\"position\":[36.467411372891675,0,0.42333693470900263],\"scale\":1.1281017941533222},{\"type\":\"grass\",\"position\":[-18.875889311944967,0,7.644872579519472],\"scale\":1.2478049231898907},{\"type\":\"grass\",\"position\":[98.79184437354482,0,-47.894220194339724],\"scale\":0.9291242811805163},{\"type\":\"grass\",\"position\":[-0.15298972040322967,0,-0.43699216467228297],\"scale\":0.7241124460051762},{\"type\":\"grass\",\"position\":[14.848517607785727,0,-11.948533402295714],\"scale\":1.122985264306603},{\"type\":\"grass\",\"position\":[-18.045062395456213,0,-21.021236302084944],\"scale\":0.9016768129245467},{\"type\":\"grass\",\"position\":[4.099036876982177,0,99.82851026161262],\"scale\":1.0013686366384593},{\"type\":\"grass\",\"position\":[72.7998555597347,0,39.67122429292485],\"scale\":1.1995092644603704},{\"type\":\"grass\",\"position\":[-54.22467058701013,0,-107.44176445451514],\"scale\":0.9945371260424063},{\"type\":\"grass\",\"position\":[5.266885636066713,0,80.37623728278842],\"scale\":1.2409102423012333},{\"type\":\"grass\",\"position\":[-52.28935075686053,0,114.50690931825878],\"scale\":1.206145996685025},{\"type\":\"grass\",\"position\":[-30.8344699902896,0,71.21900148841833],\"scale\":1.101978585401041},{\"type\":\"grass\",\"position\":[-3.4306061196019835,0,-108.67440151611319],\"scale\":0.9631988903862585},{\"type\":\"grass\",\"position\":[7.094738517846433,0,-1.4195048679612698],\"scale\":0.8323456131936153},{\"type\":\"grass\",\"position\":[-14.171875519821134,0,13.296264819916649],\"scale\":1.220633913662156},{\"type\":\"grass\",\"position\":[33.3809119659094,0,-74.9214712209485],\"scale\":0.8317054554729042},{\"type\":\"grass\",\"position\":[-29.179854342581372,0,-38.81300180764476],\"scale\":1.0796045037842879},{\"type\":\"grass\",\"position\":[34.48966882998194,0,87.27775204443219],\"scale\":1.2303169009007084},{\"type\":\"grass\",\"position\":[-79.96807685080296,0,64.12871805906242],\"scale\":1.1706178952231396},{\"type\":\"grass\",\"position\":[-54.876946259156476,0,48.79580913798708],\"scale\":0.8273831360931692},{\"type\":\"grass\",\"position\":[26.178378564754613,0,8.648511215918331],\"scale\":1.0933831539131234},{\"type\":\"grass\",\"position\":[99.10127883854047,0,2.6305934276646585],\"scale\":0.7703383498356837},{\"type\":\"grass\",\"position\":[-14.13663945374999,0,-24.375386488848104],\"scale\":0.9235907957196522},{\"type\":\"grass\",\"position\":[-56.461558705692376,0,9.117177040832129],\"scale\":1.0050296576464288},{\"type\":\"grass\",\"position\":[37.507994098576255,0,-35.20239264712972],\"scale\":1.066291318629545},{\"type\":\"grass\",\"position\":[4.188556100498315,0,-15.355051976968944],\"scale\":0.9820294980667853},{\"type\":\"grass\",\"position\":[-10.151685326732611,0,-68.60277327810026],\"scale\":0.8724993275608887},{\"type\":\"grass\",\"position\":[13.838599732560615,0,1.0311678636818855],\"scale\":1.218173718388711},{\"type\":\"grass\",\"position\":[42.88991198320063,0,30.16124169106708],\"scale\":0.7565415547779428},{\"type\":\"grass\",\"position\":[-10.614747803918824,0,22.963730889215395],\"scale\":1.039544157417279},{\"type\":\"grass\",\"position\":[4.021172047911144,0,-9.424255406154678],\"scale\":1.2228977384402526},{\"type\":\"grass\",\"position\":[-8.90364507439322,0,11.26475798292448],\"scale\":0.7568201504093319},{\"type\":\"grass\",\"position\":[46.09261362523647,0,1.4260885101024903],\"scale\":0.9091766825261935},{\"type\":\"grass\",\"position\":[70.56156828449171,0,-120.71871687538581],\"scale\":0.9677255444704657},{\"type\":\"grass\",\"position\":[-37.989568668021064,0,27.748873017333114],\"scale\":1.0023201609899215},{\"type\":\"grass\",\"position\":[-0.6616633222519286,0,125.5177040150694],\"scale\":0.8887722359572615},{\"type\":\"grass\",\"position\":[-22.041681683992266,0,-55.16845650702109],\"scale\":1.2136535047633945},{\"type\":\"grass\",\"position\":[-11.49574325090502,0,-3.5434673105568737],\"scale\":0.7756471642253386},{\"type\":\"grass\",\"position\":[86.22349219228329,0,-110.21169878381723],\"scale\":0.7340947414697114},{\"type\":\"grass\",\"position\":[66.67453578481137,0,-74.09452372374629],\"scale\":0.8058663087966244},{\"type\":\"grass\",\"position\":[106.95605084827082,0,-1.6779626007087605],\"scale\":0.8874098453952335},{\"type\":\"grass\",\"position\":[-8.393243898327981,0,31.165725989360617],\"scale\":0.8860153376683102},{\"type\":\"grass\",\"position\":[-24.034268343597887,0,141.9860456734035],\"scale\":0.8431163074765469},{\"type\":\"grass\",\"position\":[-83.26057862294124,0,23.74721946146269],\"scale\":1.0182991482412291},{\"type\":\"grass\",\"position\":[4.7629773901493175,0,-2.6459650714465712],\"scale\":1.2009694130130824},{\"type\":\"grass\",\"position\":[-134.1370965477067,0,-1.9969497718336535],\"scale\":1.1392086915035116},{\"type\":\"grass\",\"position\":[-35.95387840258508,0,25.985038099408143],\"scale\":0.8907221152829627},{\"type\":\"grass\",\"position\":[1.8877424884150416,0,-5.766669492709133],\"scale\":0.869810217221531},{\"type\":\"grass\",\"position\":[5.188148874610121,0,-12.396243188040202],\"scale\":1.1527712154120628},{\"type\":\"grass\",\"position\":[53.73549129760282,0,51.73906044413237],\"scale\":1.1663828090988804},{\"type\":\"grass\",\"position\":[-42.467942679060265,0,6.5916102401578405],\"scale\":0.8075193458462305},{\"type\":\"grass\",\"position\":[36.42552051995237,0,22.09102893375297],\"scale\":0.7838963197164208},{\"type\":\"grass\",\"position\":[-6.080186786384216,0,-3.969641603755028],\"scale\":1.0070990280162668},{\"type\":\"grass\",\"position\":[-92.88377013025462,0,-21.53815201611375],\"scale\":0.7928115773298067},{\"type\":\"grass\",\"position\":[-13.390211686648385,0,-1.0125611866058695],\"scale\":1.2823521937434026},{\"type\":\"grass\",\"position\":[-122.12620517440722,0,36.51321940679082],\"scale\":0.8575374170513488},{\"type\":\"grass\",\"position\":[-82.75028677010022,0,90.30935872130873],\"scale\":1.024096013167911},{\"type\":\"grass\",\"position\":[105.03189377590651,0,36.32875696891849],\"scale\":1.1916141946713517},{\"type\":\"grass\",\"position\":[-76.68514555616859,0,15.286437486845967],\"scale\":0.7777905517820821},{\"type\":\"grass\",\"position\":[103.1552598876975,0,-103.72151056994015],\"scale\":1.1281059733497742},{\"type\":\"grass\",\"position\":[-109.56405577250129,0,-96.40403035035949],\"scale\":0.8702213543564983},{\"type\":\"grass\",\"position\":[-24.52389270277205,0,-16.88705696313039],\"scale\":0.9354899046830691},{\"type\":\"grass\",\"position\":[92.89346880751654,0,-4.213432323207785],\"scale\":1.0737453329646423},{\"type\":\"grass\",\"position\":[69.51113152357277,0,-0.34627439049706504],\"scale\":1.19499540463204},{\"type\":\"grass\",\"position\":[55.9318373900179,0,-35.54479546519448],\"scale\":1.1016817340997578},{\"type\":\"grass\",\"position\":[-16.97782981974045,0,-86.84259619605851],\"scale\":1.1675720468419528},{\"type\":\"grass\",\"position\":[56.28365147310051,0,-137.85687602634516],\"scale\":0.9842904960137102},{\"type\":\"grass\",\"position\":[104.25598322666914,0,82.14507071212944],\"scale\":0.8362432258973804},{\"type\":\"grass\",\"position\":[15.049241484092168,0,1.0859744061413903],\"scale\":1.2156982529120421},{\"type\":\"grass\",\"position\":[51.678035150167865,0,12.707401486065612],\"scale\":1.033330539747511},{\"type\":\"grass\",\"position\":[-0.27073922286312246,0,106.441163641186],\"scale\":1.0607682748226956},{\"type\":\"grass\",\"position\":[3.371105310809606,0,12.426074169457214],\"scale\":1.234714808360405},{\"type\":\"grass\",\"position\":[70.94909863861383,0,0.052054757177190464],\"scale\":1.2513028803042823},{\"type\":\"grass\",\"position\":[90.62868473266566,0,-26.575476177299464],\"scale\":1.215396792875734},{\"type\":\"grass\",\"position\":[-57.632312176236745,0,-20.98645625616827],\"scale\":1.0306481472526414},{\"type\":\"grass\",\"position\":[-79.29925313724092,0,50.46394315127108],\"scale\":1.0807806445015442},{\"type\":\"grass\",\"position\":[29.742999451468624,0,-27.46974722127679],\"scale\":1.033251419527064},{\"type\":\"grass\",\"position\":[-119.85832465337843,0,80.60382567912607],\"scale\":1.028544329755892},{\"type\":\"grass\",\"position\":[-109.82098605316735,0,-1.148566689785373],\"scale\":1.1067193562161775},{\"type\":\"grass\",\"position\":[3.8662055478233714,0,-8.853063256282473],\"scale\":0.71914935622405},{\"type\":\"grass\",\"position\":[-71.27370249936868,0,-112.46757898249139],\"scale\":1.2742208159847224},{\"type\":\"grass\",\"position\":[-141.15552225412026,0,13.214217544246466],\"scale\":0.8459462212324199},{\"type\":\"grass\",\"position\":[-8.784202079093356,0,88.21463673655656],\"scale\":0.8098952999431166},{\"type\":\"grass\",\"position\":[-136.3620521780227,0,-43.200116307087185],\"scale\":1.2865406855010266},{\"type\":\"grass\",\"position\":[-19.95010300445935,0,-25.029079299451976],\"scale\":0.9172907731835815},{\"type\":\"grass\",\"position\":[-1.7053995207096238,0,-11.508981546428453],\"scale\":1.2984003321669704},{\"type\":\"grass\",\"position\":[32.203138703891845,0,-0.2654910436166888],\"scale\":1.2625887591835814},{\"type\":\"grass\",\"position\":[-62.36122789201051,0,-31.105490434354294],\"scale\":1.0682716708836553},{\"type\":\"grass\",\"position\":[79.11480857534721,0,-3.0489969078555252],\"scale\":1.0245479234348034},{\"type\":\"grass\",\"position\":[-16.746937464144228,0,86.92640836759197],\"scale\":0.9523355049754447},{\"type\":\"grass\",\"position\":[47.757340378649204,0,-132.4395626287801],\"scale\":0.7671702265450019},{\"type\":\"grass\",\"position\":[-34.48138124473756,0,-37.61822055578705],\"scale\":0.820008855293665},{\"type\":\"grass\",\"position\":[-0.0014768318376853608,0,-22.09369457512488],\"scale\":1.1905323795571607},{\"type\":\"grass\",\"position\":[-22.28774804943185,0,7.270325825196173],\"scale\":1.167792180049953},{\"type\":\"grass\",\"position\":[-24.911503735239823,0,4.930687346150095],\"scale\":0.8742635917763101},{\"type\":\"grass\",\"position\":[73.83501629104587,0,11.536691098405075],\"scale\":1.0335981363143445},{\"type\":\"grass\",\"position\":[-56.731193764386425,0,40.94470376186995],\"scale\":0.8450226612024923},{\"type\":\"grass\",\"position\":[-11.24482153992858,0,53.27739309371003],\"scale\":1.2339886220761938},{\"type\":\"grass\",\"position\":[3.911370630155537,0,-140.76108734173627],\"scale\":0.8906594036608053},{\"type\":\"grass\",\"position\":[-30.87093413102415,0,98.72592346282757],\"scale\":1.2372077304948403},{\"type\":\"grass\",\"position\":[23.22387298013185,0,-47.7401550391978],\"scale\":0.9234699279564234},{\"type\":\"grass\",\"position\":[58.705757663161606,0,-31.812213138192202],\"scale\":0.8908024351811068},{\"type\":\"grass\",\"position\":[-107.36868644079176,0,-35.58581041206578],\"scale\":1.273034030048771},{\"type\":\"grass\",\"position\":[-16.39919034011356,0,71.40936560044057],\"scale\":0.8168680149688139},{\"type\":\"grass\",\"position\":[12.938343016269172,0,20.759458713478622],\"scale\":1.1873613088271184},{\"type\":\"grass\",\"position\":[63.65986434253756,0,116.0341297786023],\"scale\":1.2912319046384888},{\"type\":\"grass\",\"position\":[0.41058888038772523,0,-0.04710197146368344],\"scale\":0.9121368181962142},{\"type\":\"grass\",\"position\":[30.329626130770077,0,59.250412569946164],\"scale\":1.186691132731242},{\"type\":\"grass\",\"position\":[13.187689885420378,0,-105.78579110795738],\"scale\":0.7186213318784981},{\"type\":\"grass\",\"position\":[19.185787090694905,0,8.592109386212092],\"scale\":1.0031850400270748},{\"type\":\"grass\",\"position\":[-29.460768610101482,0,-55.27658515350261],\"scale\":0.9762612172960993},{\"type\":\"grass\",\"position\":[-43.88285235327991,0,-20.34988423458584],\"scale\":0.9969101727373602},{\"type\":\"grass\",\"position\":[7.052253803088018,0,-113.49550157759457],\"scale\":1.056903660001703},{\"type\":\"grass\",\"position\":[-14.173464430911073,0,48.77672936922413],\"scale\":1.144997605643336},{\"type\":\"grass\",\"position\":[-23.582480251772306,0,-13.645987426936674],\"scale\":0.9058485041520821},{\"type\":\"grass\",\"position\":[-146.60791719935543,0,-22.394118227311143],\"scale\":1.1151426178861013},{\"type\":\"grass\",\"position\":[76.57976831505617,0,-38.82436126812678],\"scale\":1.0003835143344288},{\"type\":\"grass\",\"position\":[50.12992849063207,0,-89.18077314895139],\"scale\":0.9089610514757647},{\"type\":\"grass\",\"position\":[28.420635555246303,0,12.298081523064184],\"scale\":1.0823226633511436},{\"type\":\"grass\",\"position\":[-11.131426925295246,0,-46.057374886830004],\"scale\":0.8392910297046704},{\"type\":\"grass\",\"position\":[60.805476871779405,0,-10.669914544103008],\"scale\":0.7937652276037894},{\"type\":\"grass\",\"position\":[76.49686789410987,0,23.895901138419077],\"scale\":1.0604017782112138},{\"type\":\"grass\",\"position\":[-80.36291438507307,0,-76.85538635813806],\"scale\":0.7304322748344078},{\"type\":\"grass\",\"position\":[3.350466576440241,0,-84.46964074504344],\"scale\":1.0071222389701615},{\"type\":\"grass\",\"position\":[116.36536061066197,0,-82.82807372004636],\"scale\":1.292753625383225},{\"type\":\"grass\",\"position\":[-47.14569462594779,0,-28.856356218930333],\"scale\":0.970016186734324},{\"type\":\"grass\",\"position\":[-37.95977834850706,0,-24.08874473467965],\"scale\":1.2434511066554357},{\"type\":\"grass\",\"position\":[92.08897887503103,0,100.49044907786484],\"scale\":1.2803346467527197},{\"type\":\"grass\",\"position\":[-93.62297101327874,0,-71.72669851035415],\"scale\":0.915331102763011},{\"type\":\"grass\",\"position\":[-9.413982053119792,0,23.490732987793425],\"scale\":1.2815500153861046},{\"type\":\"grass\",\"position\":[36.20038941870198,0,-63.96555678989532],\"scale\":1.1739725448094234},{\"type\":\"grass\",\"position\":[29.997018111607666,0,32.36985866573391],\"scale\":0.7612018153975982},{\"type\":\"grass\",\"position\":[-8.60824253743658,0,-2.4387507277392095],\"scale\":0.9294629606282787},{\"type\":\"grass\",\"position\":[-97.51725378768721,0,-66.15597483585434],\"scale\":1.2659459383468767},{\"type\":\"grass\",\"position\":[84.00550935376367,0,-115.11271350844076],\"scale\":0.8326885388100485},{\"type\":\"grass\",\"position\":[13.581770932452637,0,9.840595682291024],\"scale\":0.8974838999953011},{\"type\":\"grass\",\"position\":[8.895361460134133,0,-112.73394816071523],\"scale\":0.8498828432562999},{\"type\":\"grass\",\"position\":[105.01554886072508,0,8.890760107618165],\"scale\":0.8978474857067973},{\"type\":\"grass\",\"position\":[39.74898483882562,0,25.249372962004447],\"scale\":1.2922623573758023},{\"type\":\"grass\",\"position\":[-33.520975448985304,0,-76.68891911078846],\"scale\":1.0038779783295273},{\"type\":\"grass\",\"position\":[5.453876317586266,0,-3.907888762611546],\"scale\":1.1096223464541692},{\"type\":\"grass\",\"position\":[102.40831054578976,0,24.320725473010864],\"scale\":0.9655402126366518},{\"type\":\"grass\",\"position\":[-8.951317730129873,0,-121.74678675279553],\"scale\":1.2518960228751772},{\"type\":\"grass\",\"position\":[43.73878177171338,0,44.33275309328355],\"scale\":1.0056437582269884},{\"type\":\"grass\",\"position\":[16.09760425466127,0,68.19070081961615],\"scale\":0.9307734850632204},{\"type\":\"grass\",\"position\":[72.4150809253541,0,119.06627266400234],\"scale\":1.2661827138164718},{\"type\":\"grass\",\"position\":[119.20708074303481,0,42.67902789873911],\"scale\":0.8715489742669378},{\"type\":\"grass\",\"position\":[35.63999820263054,0,-21.546146507986776],\"scale\":1.278278147256343},{\"type\":\"grass\",\"position\":[-106.93821519150754,0,-27.064081333580166],\"scale\":1.0924943588621794},{\"type\":\"grass\",\"position\":[19.906374911852872,0,77.88717422654179],\"scale\":0.791409924609705},{\"type\":\"grass\",\"position\":[-4.0195670502587415,0,-149.3676336657027],\"scale\":1.269052947979671},{\"type\":\"grass\",\"position\":[-3.2843351778944103,0,25.49623924570742],\"scale\":0.9393438578602338},{\"type\":\"grass\",\"position\":[118.52655693540862,0,73.29934198259772],\"scale\":0.8354871689114063},{\"type\":\"grass\",\"position\":[34.26906071221056,0,-21.86808596205028],\"scale\":0.728001762186927},{\"type\":\"grass\",\"position\":[29.297295492544297,0,31.79557806219767],\"scale\":0.8246850460317198},{\"type\":\"grass\",\"position\":[11.24795828437448,0,-17.178522433376283],\"scale\":0.8098761425345852},{\"type\":\"grass\",\"position\":[-65.81479450474582,0,-46.92782309500839],\"scale\":0.9170016411481527},{\"type\":\"grass\",\"position\":[-12.974107501179573,0,25.18897620518209],\"scale\":0.717644879148623},{\"type\":\"grass\",\"position\":[74.2566456874823,0,29.883981763630672],\"scale\":1.0953525117558938},{\"type\":\"grass\",\"position\":[94.18422888855856,0,-85.22035784978353],\"scale\":0.8639300328476971},{\"type\":\"grass\",\"position\":[40.38711372428442,0,-83.99626331731811],\"scale\":1.057421582457127},{\"type\":\"grass\",\"position\":[-74.18042621281892,0,11.094826101651119],\"scale\":0.9089466578527963},{\"type\":\"grass\",\"position\":[-34.26599130421704,0,7.614860559268909],\"scale\":0.7373808659535905},{\"type\":\"grass\",\"position\":[11.53848983249545,0,1.7529495681621539],\"scale\":0.798983801733393},{\"type\":\"grass\",\"position\":[33.522027778839025,0,48.32663890305943],\"scale\":1.2284079664502348},{\"type\":\"grass\",\"position\":[0.07764935647425057,0,7.128466247056356],\"scale\":0.9099642071246908},{\"type\":\"grass\",\"position\":[42.3977377674615,0,-9.741336493675364],\"scale\":0.717441504886904},{\"type\":\"grass\",\"position\":[-26.884481427676235,0,143.71308939316836],\"scale\":0.7504698548424675},{\"type\":\"grass\",\"position\":[64.881331523161,0,3.5083520059418514],\"scale\":0.8709530325217805},{\"type\":\"grass\",\"position\":[-4.067077549890784,0,2.3455276848338755],\"scale\":1.1203598182703327},{\"type\":\"grass\",\"position\":[-2.108258865491586,0,65.09587087489832],\"scale\":0.7424351493601736},{\"type\":\"grass\",\"position\":[-3.3338777122453256,0,-50.91923824489952],\"scale\":0.8111022326207005},{\"type\":\"grass\",\"position\":[115.021569422446,0,2.2333621672894686],\"scale\":1.0504596401926334},{\"type\":\"grass\",\"position\":[-72.82661832304883,0,34.603052779191955],\"scale\":0.794826310436857},{\"type\":\"grass\",\"position\":[17.101161550113147,0,1.6571622553736438],\"scale\":1.0642512345164146},{\"type\":\"grass\",\"position\":[5.19429854189306,0,-9.912793924512638],\"scale\":1.0413244981694483},{\"type\":\"grass\",\"position\":[78.79910019003111,0,-68.86069991501559],\"scale\":0.8209065506054294},{\"type\":\"grass\",\"position\":[78.04256014437428,0,89.8038404054463],\"scale\":1.222825790827283},{\"type\":\"grass\",\"position\":[-136.6684547793245,0,-46.52084383649979],\"scale\":0.7707267787822033},{\"type\":\"grass\",\"position\":[91.84799371686779,0,-112.39166958035861],\"scale\":1.2201908523448153},{\"type\":\"grass\",\"position\":[54.75964200743654,0,-14.787258719877519],\"scale\":0.9116301980212489},{\"type\":\"grass\",\"position\":[115.96309182954337,0,-48.04795213045817],\"scale\":1.131438775178647},{\"type\":\"grass\",\"position\":[127.37208980268203,0,48.69188456701223],\"scale\":0.7552943218048493},{\"type\":\"grass\",\"position\":[-37.36570925169987,0,47.66341949318333],\"scale\":1.105312252863892},{\"type\":\"grass\",\"position\":[-59.41284669562678,0,-70.4108172805093],\"scale\":0.8453745575623927},{\"type\":\"grass\",\"position\":[49.78688185147987,0,67.21410600398643],\"scale\":0.9337502172859964},{\"type\":\"grass\",\"position\":[-9.026430973579684,0,3.05159271292247],\"scale\":1.199129590931958},{\"type\":\"grass\",\"position\":[-53.55051285005291,0,-99.5737281404222],\"scale\":0.9991362665405836},{\"type\":\"grass\",\"position\":[-70.01990635988159,0,51.566164934802956],\"scale\":0.8788653088006906},{\"type\":\"grass\",\"position\":[-51.5732838517017,0,25.019229617298397],\"scale\":1.2085250084732024},{\"type\":\"grass\",\"position\":[82.27986136598753,0,-32.80440475804184],\"scale\":1.1185344890456017},{\"type\":\"grass\",\"position\":[-43.140512244554465,0,-8.860326543407522],\"scale\":0.9087809688821766},{\"type\":\"grass\",\"position\":[26.921759869629643,0,-1.8546681087597068],\"scale\":0.8066888382933017},{\"type\":\"grass\",\"position\":[-7.606002296023024,0,-84.70671953453501],\"scale\":0.81464007280781},{\"type\":\"grass\",\"position\":[33.62652496243359,0,64.27902589415412],\"scale\":1.1695326190880753},{\"type\":\"grass\",\"position\":[47.809901817302126,0,27.336197413174112],\"scale\":0.9072522596182301},{\"type\":\"grass\",\"position\":[-128.7865155304062,0,-14.777245532845015],\"scale\":0.7355991490116485},{\"type\":\"grass\",\"position\":[82.97532180709061,0,92.86983522157281],\"scale\":0.990947544125975},{\"type\":\"grass\",\"position\":[-33.189744764891906,0,-25.843038028501432],\"scale\":1.0919373065777207},{\"type\":\"grass\",\"position\":[83.91047245323782,0,-22.5494939055695],\"scale\":1.1514790718900851},{\"type\":\"grass\",\"position\":[29.36440073297468,0,14.195165536759639],\"scale\":0.7612975445735515},{\"type\":\"grass\",\"position\":[-37.69959850412924,0,28.562899091359142],\"scale\":1.0751851554384153},{\"type\":\"grass\",\"position\":[1.7030730279497626,0,-1.0333889703193886],\"scale\":0.9203565166113326},{\"type\":\"grass\",\"position\":[53.62908685303213,0,-34.286641702694084],\"scale\":1.207771721185079},{\"type\":\"grass\",\"position\":[71.00642435864967,0,45.21772754870109],\"scale\":0.9012773465106164},{\"type\":\"grass\",\"position\":[-66.52082664027762,0,50.012272404377406],\"scale\":0.9297963890308754},{\"type\":\"grass\",\"position\":[-13.375600103766931,0,4.823446797074551],\"scale\":0.8015667249775404},{\"type\":\"grass\",\"position\":[25.689361355000678,0,57.52669914641888],\"scale\":1.2108306022212065},{\"type\":\"grass\",\"position\":[36.972279061469955,0,107.62697283657094],\"scale\":0.8246495391016978},{\"type\":\"grass\",\"position\":[0.7950377925693126,0,6.67564567499213],\"scale\":1.1582826356559568},{\"type\":\"grass\",\"position\":[-24.937614591313697,0,-142.91300329045572],\"scale\":0.7195134478358955},{\"type\":\"grass\",\"position\":[7.118392752022647,0,-141.20109529243172],\"scale\":0.9024769558962917},{\"type\":\"grass\",\"position\":[-73.58497405574258,0,51.73557748051474],\"scale\":1.1044578736497255},{\"type\":\"grass\",\"position\":[94.81071951344626,0,-22.114308107163577],\"scale\":0.8377433974574404},{\"type\":\"grass\",\"position\":[-11.409283756234084,0,0.9129212353663223],\"scale\":0.893718973561884},{\"type\":\"grass\",\"position\":[10.232913841294694,0,-91.04850298014166],\"scale\":0.9157670757717552},{\"type\":\"grass\",\"position\":[16.63879089872973,0,2.8982051436767087],\"scale\":0.8028095294124703},{\"type\":\"grass\",\"position\":[-117.72064055213987,0,15.678306434177957],\"scale\":0.9847963821832189},{\"type\":\"grass\",\"position\":[5.788762715024582,0,-6.1169461120361985],\"scale\":1.0090967174471404},{\"type\":\"grass\",\"position\":[-24.735884591993674,0,54.62385976150053],\"scale\":0.948827170972234},{\"type\":\"grass\",\"position\":[-61.69768353807235,0,55.1615524299688],\"scale\":0.7916558149222102},{\"type\":\"grass\",\"position\":[85.16017595639758,0,-48.25293421458384],\"scale\":1.0408225980108725},{\"type\":\"grass\",\"position\":[-18.24546070184506,0,24.254274313732836],\"scale\":1.2435016550109022},{\"type\":\"grass\",\"position\":[-2.5087550558868035,0,0.06601067292185431],\"scale\":0.7420971235733048},{\"type\":\"grass\",\"position\":[35.618388525252584,0,79.74290247132122],\"scale\":1.207247997884963},{\"type\":\"grass\",\"position\":[-95.94275105274835,0,-114.46879208887405],\"scale\":1.1524591956265218},{\"type\":\"grass\",\"position\":[-146.74438218799767,0,-18.767438526523232],\"scale\":1.2054517543712424},{\"type\":\"grass\",\"position\":[-25.40945727938845,0,28.683388274242184],\"scale\":1.133685458959354},{\"type\":\"grass\",\"position\":[-103.61707634159683,0,-73.50348197872393],\"scale\":0.8586213960443603},{\"type\":\"grass\",\"position\":[15.337991008494756,0,-106.66356227663715],\"scale\":0.7741648913416713},{\"type\":\"grass\",\"position\":[41.2887673325494,0,-76.41625464458103],\"scale\":1.2609407797801386},{\"type\":\"grass\",\"position\":[51.87476635903841,0,-43.6858802539777],\"scale\":0.9552375253429548},{\"type\":\"grass\",\"position\":[1.0817703458342514,0,66.1291434254109],\"scale\":1.2264835876884668},{\"type\":\"grass\",\"position\":[-61.343463254236454,0,-59.937386235638016],\"scale\":0.7013447464825914},{\"type\":\"grass\",\"position\":[20.38507750417578,0,138.2019153027098],\"scale\":1.1499068634938774},{\"type\":\"grass\",\"position\":[19.788038394980234,0,-20.367904248825628],\"scale\":0.9902757094402299},{\"type\":\"grass\",\"position\":[-10.41180387455428,0,30.973117763324645],\"scale\":1.2308827240578406},{\"type\":\"grass\",\"position\":[-62.172007113322074,0,-23.993953394321167],\"scale\":1.000282795804687},{\"type\":\"grass\",\"position\":[67.73807174937068,0,-48.79527287425637],\"scale\":0.8398999307328496},{\"type\":\"grass\",\"position\":[122.21015246259829,0,-53.48372879988962],\"scale\":0.714145058800153},{\"type\":\"grass\",\"position\":[-67.55785366034885,0,-22.53610282215907],\"scale\":1.094387054390329},{\"type\":\"grass\",\"position\":[-102.0714836340381,0,-73.58312725168463],\"scale\":0.8084641990567125},{\"type\":\"grass\",\"position\":[-11.923307512674088,0,-12.448843827422838],\"scale\":1.0167102428742294},{\"type\":\"grass\",\"position\":[26.780852088039236,0,-25.888862856090693],\"scale\":0.7374903111567577},{\"type\":\"grass\",\"position\":[-83.78789792644187,0,-64.42495604105659],\"scale\":1.0010362319437336},{\"type\":\"grass\",\"position\":[-59.55329549145232,0,52.43943976094777],\"scale\":1.1441722588196725},{\"type\":\"grass\",\"position\":[6.810219796042914,0,-114.24769488198234],\"scale\":0.877759052057797},{\"type\":\"grass\",\"position\":[-112.81861486694916,0,-30.710139830946517],\"scale\":1.0043161165730912},{\"type\":\"grass\",\"position\":[-44.545846318544726,0,-15.586949121080476],\"scale\":1.2567476067204078},{\"type\":\"grass\",\"position\":[-96.92269674548655,0,7.654295283490127],\"scale\":1.0635150826922084},{\"type\":\"grass\",\"position\":[-74.59682468984329,0,52.892239786445536],\"scale\":0.7949947675694022},{\"type\":\"grass\",\"position\":[3.923632984137352,0,5.628518933808761],\"scale\":0.8100347731755728},{\"type\":\"grass\",\"position\":[25.080400942930144,0,-90.4561237225217],\"scale\":1.0598146797878687},{\"type\":\"grass\",\"position\":[18.258948794345574,0,130.91050686246538],\"scale\":0.9014291506130042},{\"type\":\"grass\",\"position\":[18.52425721216761,0,48.99268769736478],\"scale\":0.8731568364852609},{\"type\":\"grass\",\"position\":[12.126945354603363,0,-104.35988249064127],\"scale\":0.7393057047310293},{\"type\":\"grass\",\"position\":[7.106385849593417,0,25.46838899392139],\"scale\":0.8910910310520676},{\"type\":\"grass\",\"position\":[42.61236219601713,0,-59.00688024515838],\"scale\":0.914672608108017},{\"type\":\"grass\",\"position\":[42.39494802393775,0,-134.07895751474786],\"scale\":0.7524664835438466},{\"type\":\"grass\",\"position\":[117.7262927984291,0,-34.6175426344416],\"scale\":0.9252518624743525},{\"type\":\"grass\",\"position\":[-16.29498080664696,0,15.882002319453738],\"scale\":0.839122603733353},{\"type\":\"grass\",\"position\":[-70.23161753833514,0,-10.521667567037008],\"scale\":1.0887145758246457},{\"type\":\"grass\",\"position\":[-16.803210922711386,0,-88.50197382351733],\"scale\":1.0513327696323085},{\"type\":\"grass\",\"position\":[-30.515901239294966,0,-81.32687807434559],\"scale\":1.102166818086327},{\"type\":\"grass\",\"position\":[84.44055406503176,0,-87.7380464036571],\"scale\":1.1231591290816216},{\"type\":\"grass\",\"position\":[-16.58784303646919,0,-54.90829246547961],\"scale\":1.1099780729848148},{\"type\":\"grass\",\"position\":[8.397575899817552,0,35.09871179249858],\"scale\":0.8858448503777592},{\"type\":\"grass\",\"position\":[-46.798217535713775,0,122.49881692626654],\"scale\":0.7260236756795496},{\"type\":\"grass\",\"position\":[88.47823385154709,0,-93.68226756007456],\"scale\":0.9932273084978979},{\"type\":\"grass\",\"position\":[70.63276273482954,0,47.5995419547698],\"scale\":1.1935548363591733},{\"type\":\"grass\",\"position\":[49.32924628085559,0,-122.82314264002586],\"scale\":0.8843899131619435},{\"type\":\"grass\",\"position\":[-64.36870624982285,0,67.16113060604013],\"scale\":1.1849848515364965},{\"type\":\"grass\",\"position\":[0.3563964959668734,0,122.88744922566195],\"scale\":1.2516684689429134},{\"type\":\"grass\",\"position\":[90.8488924947915,0,-33.043876552812655],\"scale\":0.7153369601309125},{\"type\":\"grass\",\"position\":[-4.308562044811939,0,27.332502112265814],\"scale\":1.2542262259940868},{\"type\":\"grass\",\"position\":[-30.96130204309298,0,-81.45661972753845],\"scale\":1.0807823958724438},{\"type\":\"grass\",\"position\":[54.70566933517269,0,-134.78452016799272],\"scale\":0.9644711448596882},{\"type\":\"grass\",\"position\":[-4.3703628049723,0,-111.05457470224978],\"scale\":1.1808199338424141},{\"type\":\"grass\",\"position\":[-84.17796262720307,0,-112.69623414255756],\"scale\":1.0598408017077157},{\"type\":\"grass\",\"position\":[-18.409762018690913,0,41.6537139751729],\"scale\":0.8212775786794781},{\"type\":\"grass\",\"position\":[-75.9860552450664,0,115.64474092891277],\"scale\":0.8779960496761041},{\"type\":\"grass\",\"position\":[72.34449135109722,0,95.2244338764526],\"scale\":0.791194391974393},{\"type\":\"grass\",\"position\":[21.53067908368996,0,-40.53811730492639],\"scale\":1.089429530482189},{\"type\":\"grass\",\"position\":[22.552851150540913,0,145.2174163629877],\"scale\":0.9473067257437782},{\"type\":\"grass\",\"position\":[17.449046601706538,0,-26.082842929658998],\"scale\":1.2803742075759792},{\"type\":\"grass\",\"position\":[84.71881936422078,0,53.594539741892106],\"scale\":0.7626348747919565},{\"type\":\"grass\",\"position\":[123.09503903908977,0,56.917244616647814],\"scale\":0.766386270238064},{\"type\":\"grass\",\"position\":[-16.178979333469453,0,99.90863014589365],\"scale\":1.053520545019818},{\"type\":\"grass\",\"position\":[78.710807985543,0,-53.54468086941323],\"scale\":0.7525981049355751},{\"type\":\"grass\",\"position\":[-111.8852747137404,0,-63.70202870014084],\"scale\":1.0837924386615292},{\"type\":\"grass\",\"position\":[-22.383668002201976,0,8.12739301521785],\"scale\":0.7268981240805367},{\"type\":\"grass\",\"position\":[-5.777239233606818,0,-31.797352565778887],\"scale\":0.8413042646747004},{\"type\":\"grass\",\"position\":[25.66710914805336,0,1.001088007857797],\"scale\":0.9599626959340395},{\"type\":\"grass\",\"position\":[85.01685901985391,0,19.66731598881522],\"scale\":0.9294145240310403},{\"type\":\"grass\",\"position\":[-18.244816761401832,0,-137.99287161553468],\"scale\":1.002249255710281},{\"type\":\"grass\",\"position\":[-32.204406290420614,0,-90.38089968637975],\"scale\":1.1344969874342608},{\"type\":\"grass\",\"position\":[-29.72053480339656,0,85.91459597645444],\"scale\":1.0754105849950673},{\"type\":\"grass\",\"position\":[-19.92158737242199,0,-3.7367094761120363],\"scale\":1.0093207238843083},{\"type\":\"grass\",\"position\":[-99.47161777158307,0,32.5886175521428],\"scale\":0.9984086315257588},{\"type\":\"grass\",\"position\":[44.32658384442833,0,-142.12423688794345],\"scale\":1.0106070819705741},{\"type\":\"grass\",\"position\":[-7.5474740409346905,0,-23.75733728529656],\"scale\":0.8590968405948973},{\"type\":\"grass\",\"position\":[27.632245493174793,0,5.065707163692902],\"scale\":1.2936093117339125},{\"type\":\"grass\",\"position\":[24.362302532029958,0,98.46989059224167],\"scale\":0.8651479710182124},{\"type\":\"grass\",\"position\":[45.70766014868149,0,26.949956971521992],\"scale\":1.1679409320984775},{\"type\":\"grass\",\"position\":[-79.30300307072717,0,54.2035983695269],\"scale\":0.7628256448954711},{\"type\":\"grass\",\"position\":[-11.317968104316142,0,11.028825648406132],\"scale\":0.7434872321651399},{\"type\":\"grass\",\"position\":[-28.45617984168664,0,-144.73017746888843],\"scale\":0.8741204212884257},{\"type\":\"grass\",\"position\":[-143.5050821449036,0,4.127303441935101],\"scale\":1.2538781860565336},{\"type\":\"grass\",\"position\":[7.2991594952389365,0,-84.3566222952057],\"scale\":0.8382623208763431},{\"type\":\"grass\",\"position\":[-36.272709268853795,0,2.5719287538871725],\"scale\":1.1746451623957044},{\"type\":\"grass\",\"position\":[5.161033771082242,0,90.10878696948515],\"scale\":1.1581447204886912},{\"type\":\"grass\",\"position\":[127.75922323160225,0,39.52949888819645],\"scale\":0.8732891762576662},{\"type\":\"grass\",\"position\":[104.54723217913487,0,-50.147027517496205],\"scale\":0.8913205123427174},{\"type\":\"grass\",\"position\":[-107.68186374836118,0,-101.23178635598698],\"scale\":1.2544491139511142},{\"type\":\"grass\",\"position\":[4.778850636254985,0,119.054917948652],\"scale\":1.0642483232036797},{\"type\":\"grass\",\"position\":[-120.96078806286614,0,67.84026607105083],\"scale\":1.035434775681093},{\"type\":\"grass\",\"position\":[135.3109019656919,0,64.6287534610399],\"scale\":0.9772209268033514},{\"type\":\"grass\",\"position\":[-15.304575295138113,0,98.94582875108173],\"scale\":0.7261609186592501},{\"type\":\"grass\",\"position\":[9.93704450121127,0,6.179254941248711],\"scale\":1.1994746302308184},{\"type\":\"grass\",\"position\":[-73.81990696378992,0,-99.6196419148675],\"scale\":1.0694112214240368},{\"type\":\"grass\",\"position\":[-7.699746600529911,0,-135.8680608735258],\"scale\":1.222710213611803},{\"type\":\"grass\",\"position\":[-77.2979979460973,0,-127.67318386390721],\"scale\":0.8275092026647225},{\"type\":\"grass\",\"position\":[-47.5538407806259,0,-46.93355519200062],\"scale\":0.9881919534586681},{\"type\":\"grass\",\"position\":[-1.7761144130897608,0,86.7991681141484],\"scale\":0.8691377268680252},{\"type\":\"grass\",\"position\":[0.4074108853471487,0,0.13844408126136626],\"scale\":1.2473923614528455},{\"type\":\"grass\",\"position\":[44.89375790335854,0,135.36629040764885],\"scale\":1.2247698171548778},{\"type\":\"grass\",\"position\":[20.377917300613436,0,-17.620621483928986],\"scale\":0.883932701268798},{\"type\":\"grass\",\"position\":[61.23381502976853,0,-57.55293666492288],\"scale\":1.0336032118966005},{\"type\":\"grass\",\"position\":[111.65347810507915,0,4.577646405597791],\"scale\":0.982914458915245},{\"type\":\"grass\",\"position\":[73.71376763347644,0,-123.4080273592796],\"scale\":1.2042095233759678},{\"type\":\"grass\",\"position\":[12.727932522571173,0,-89.34001836908818],\"scale\":0.8941622423536056},{\"type\":\"grass\",\"position\":[41.66645169849329,0,-26.105591493424093],\"scale\":1.058124827480858},{\"type\":\"grass\",\"position\":[-33.12905044642073,0,-84.48855072452407],\"scale\":1.1022270328697155},{\"type\":\"grass\",\"position\":[-96.70199590536433,0,50.301951763715344],\"scale\":0.7743552242504791},{\"type\":\"grass\",\"position\":[-106.99381575798827,0,-9.56783483187999],\"scale\":1.2896177376849907},{\"type\":\"grass\",\"position\":[-3.9063499674018254,0,-56.34365049417703],\"scale\":1.019789791396407},{\"type\":\"grass\",\"position\":[51.97668356982265,0,-62.78092057887245],\"scale\":0.8062928937947911},{\"type\":\"grass\",\"position\":[-2.4645522682373553,0,-15.993672215635302],\"scale\":0.90883134164193},{\"type\":\"grass\",\"position\":[61.517075628149286,0,47.16858499237733],\"scale\":1.0743087684511192},{\"type\":\"grass\",\"position\":[-1.9822867803203184,0,-21.68496773429103],\"scale\":0.7135117283598463},{\"type\":\"grass\",\"position\":[52.93635585562694,0,-3.6504995147022212],\"scale\":0.8196736211036599},{\"type\":\"grass\",\"position\":[23.90692524635887,0,4.711366034047614],\"scale\":0.8267032984486116},{\"type\":\"grass\",\"position\":[-6.169088337738785,0,67.18640531978193],\"scale\":0.9548674959145442},{\"type\":\"grass\",\"position\":[9.538177975730523,0,126.16509009748127],\"scale\":0.8059218250797138},{\"type\":\"grass\",\"position\":[10.15990609580003,0,0.5816348835716559],\"scale\":0.9956314077856645},{\"type\":\"grass\",\"position\":[84.64238558754143,0,-81.90352416381096],\"scale\":0.7031950705516855},{\"type\":\"grass\",\"position\":[58.14141877004118,0,-46.16974470790438],\"scale\":1.169313831187545},{\"type\":\"grass\",\"position\":[-62.903234474671656,0,-55.06865393878994],\"scale\":1.157133690417988},{\"type\":\"grass\",\"position\":[14.468867155229574,0,-36.75059426959389],\"scale\":1.0155479135436176},{\"type\":\"grass\",\"position\":[-26.36549359698065,0,128.69142821126223],\"scale\":1.2323281900615641},{\"type\":\"grass\",\"position\":[20.39940263708651,0,136.49458350200376],\"scale\":0.8172950549709703},{\"type\":\"grass\",\"position\":[67.76917372177603,0,100.15060968227283],\"scale\":1.032665218091325},{\"type\":\"grass\",\"position\":[-122.3166818706454,0,-84.87527402191856],\"scale\":1.1106746307031174},{\"type\":\"grass\",\"position\":[-46.74722138763449,0,64.26528545115687],\"scale\":1.0488496038541077},{\"type\":\"grass\",\"position\":[-121.83920513137119,0,-14.845621476951171],\"scale\":1.182494533641579},{\"type\":\"grass\",\"position\":[78.50747026146385,0,18.06819368310096],\"scale\":0.8954810089291165},{\"type\":\"grass\",\"position\":[-63.056309405494964,0,-37.32648307330151],\"scale\":0.833368668985873},{\"type\":\"grass\",\"position\":[-114.94164250467804,0,-96.05877551156638],\"scale\":1.1811871883047906},{\"type\":\"grass\",\"position\":[0.11283606950143468,0,1.4251257871607785],\"scale\":1.0324945659305873},{\"type\":\"grass\",\"position\":[-143.53281177683664,0,3.732614357877625],\"scale\":0.9986725906731522},{\"type\":\"grass\",\"position\":[100.05444257643033,0,62.40555194688554],\"scale\":1.1641687373267062},{\"type\":\"grass\",\"position\":[-83.588282537554,0,35.981712694266925],\"scale\":0.7895978479740267},{\"type\":\"grass\",\"position\":[28.927907869173332,0,18.814543584447087],\"scale\":0.8742353007497691},{\"type\":\"grass\",\"position\":[13.617656436299443,0,-51.59617850022439],\"scale\":1.1992412946335922},{\"type\":\"grass\",\"position\":[-69.53544565483665,0,19.27040270783283],\"scale\":0.7615910858573807},{\"type\":\"grass\",\"position\":[-123.99070665984854,0,76.8810417479112],\"scale\":1.2080028938005054},{\"type\":\"grass\",\"position\":[36.028188276309834,0,9.071067807734584],\"scale\":0.8062089290383079},{\"type\":\"grass\",\"position\":[44.84671660224612,0,-67.85439811848244],\"scale\":0.8767780653051951},{\"type\":\"grass\",\"position\":[1.719364658413858,0,-8.271127065800124],\"scale\":0.8954119045288533},{\"type\":\"grass\",\"position\":[-66.08912539871233,0,85.34845953588645],\"scale\":0.8847657686195368},{\"type\":\"grass\",\"position\":[-34.4514689470027,0,22.59658862387124],\"scale\":0.9152064138604487},{\"type\":\"grass\",\"position\":[-34.501459864280406,0,-27.679432955433775],\"scale\":1.204391373411943},{\"type\":\"grass\",\"position\":[-0.4686064431968773,0,25.1328991489947],\"scale\":1.2514516273480183},{\"type\":\"grass\",\"position\":[40.887225290372776,0,-67.0164598586594],\"scale\":1.0259545576109488},{\"type\":\"grass\",\"position\":[29.25671207794386,0,61.775915486786346],\"scale\":0.765893322116716},{\"type\":\"grass\",\"position\":[-72.20312087882016,0,59.677254674756306],\"scale\":0.7988675620719767},{\"type\":\"grass\",\"position\":[-22.366619059628324,0,-11.538859005216585],\"scale\":1.2461852469029402},{\"type\":\"grass\",\"position\":[4.049542279424871,0,-1.293892023854139],\"scale\":1.1117253384073795},{\"type\":\"grass\",\"position\":[31.704961527770806,0,-126.47546068736284],\"scale\":0.9981950675865712},{\"type\":\"grass\",\"position\":[-17.198942402368107,0,3.714462562131697],\"scale\":0.8776740480387029},{\"type\":\"grass\",\"position\":[-12.47081801310866,0,29.928837836261053],\"scale\":0.9915508483678058},{\"type\":\"grass\",\"position\":[-81.82390539000608,0,-81.16510178409007],\"scale\":0.9916527390059819},{\"type\":\"grass\",\"position\":[-85.6648582815219,0,-56.26586667050921],\"scale\":0.8140826244890598},{\"type\":\"grass\",\"position\":[-10.323990564061313,0,-11.472199167879559],\"scale\":1.1880626030391788},{\"type\":\"grass\",\"position\":[-24.363173017220547,0,-17.516997733766804],\"scale\":1.0208368953425841},{\"type\":\"grass\",\"position\":[-2.263621636189786,0,21.173224096481125],\"scale\":1.2298732883299097},{\"type\":\"grass\",\"position\":[-84.03734766686892,0,-67.9439876530119],\"scale\":0.8819016459957528},{\"type\":\"grass\",\"position\":[148.32658942862395,0,15.572457545131309],\"scale\":1.1396051209089437},{\"type\":\"grass\",\"position\":[-10.353004808420854,0,-33.95090382082223],\"scale\":1.1152844297553743},{\"type\":\"grass\",\"position\":[106.58535402282752,0,70.30111940164089],\"scale\":0.8076907281949925},{\"type\":\"grass\",\"position\":[5.358954197250572,0,2.921608845161109],\"scale\":1.2481665217020899},{\"type\":\"grass\",\"position\":[15.49919234869423,0,30.195140828994337],\"scale\":0.7427328955872134},{\"type\":\"grass\",\"position\":[13.500541712814599,0,-16.945009867894857],\"scale\":0.8811391379055548},{\"type\":\"grass\",\"position\":[-46.59391003764411,0,81.86915557212346],\"scale\":0.8165063848673355},{\"type\":\"grass\",\"position\":[1.2901922845640401,0,53.91392685819283],\"scale\":0.8456803061249754},{\"type\":\"grass\",\"position\":[22.22209380417853,0,-26.526798451155145],\"scale\":0.9622405091299893},{\"type\":\"grass\",\"position\":[72.33174530588796,0,-78.25365092195244],\"scale\":0.9816521123316464},{\"type\":\"grass\",\"position\":[95.78840198818462,0,-5.87719612717587],\"scale\":0.9006774935107903},{\"type\":\"grass\",\"position\":[-35.96873496967537,0,83.55747815692763],\"scale\":1.1915229222196766},{\"type\":\"grass\",\"position\":[-43.53663731953018,0,-52.15545198965645],\"scale\":1.0842916367058868},{\"type\":\"grass\",\"position\":[-77.12903089686746,0,2.1363751300663765],\"scale\":0.7536396058473076},{\"type\":\"grass\",\"position\":[-38.02096585504808,0,-114.38900353316664],\"scale\":0.9612148214795351},{\"type\":\"grass\",\"position\":[-119.77452744693281,0,-22.63311873268734],\"scale\":0.9291255054844517},{\"type\":\"grass\",\"position\":[146.01039168632596,0,-21.920735188823453],\"scale\":1.1266875467240647},{\"type\":\"grass\",\"position\":[-72.02786032573479,0,7.56405357196612],\"scale\":1.1408355372897896},{\"type\":\"grass\",\"position\":[-58.86845227566114,0,64.86174781249998],\"scale\":1.2474208827981665},{\"type\":\"grass\",\"position\":[23.50548274318352,0,81.73654641880037],\"scale\":1.0020271205255131},{\"type\":\"grass\",\"position\":[141.7193472839004,0,-1.0754850336293387],\"scale\":1.099519909429656},{\"type\":\"grass\",\"position\":[19.383693802440572,0,54.36999549455615],\"scale\":1.1787365317183514},{\"type\":\"grass\",\"position\":[-83.9637277851276,0,39.01582858604649],\"scale\":1.0741785181040866},{\"type\":\"grass\",\"position\":[38.76728654636167,0,28.652195324659502],\"scale\":0.8939643542725132},{\"type\":\"grass\",\"position\":[-124.38841326847758,0,13.341281525975141],\"scale\":1.1634082202469103},{\"type\":\"grass\",\"position\":[4.80912364046845,0,0.01989161913444188],\"scale\":0.9743269990722031},{\"type\":\"grass\",\"position\":[-37.8810212549656,0,32.87012498460877],\"scale\":1.2631806896476758},{\"type\":\"grass\",\"position\":[-63.12654736378066,0,24.98697912282546],\"scale\":1.2480428925694498},{\"type\":\"grass\",\"position\":[-1.2967788977689036,0,-2.066194316984059],\"scale\":0.9104280787603759},{\"type\":\"grass\",\"position\":[83.41506911192144,0,23.144227214201297],\"scale\":1.1360771547679511},{\"type\":\"grass\",\"position\":[2.9749028117101464,0,-21.69999148545673],\"scale\":0.725376578176629},{\"type\":\"grass\",\"position\":[83.76918706800016,0,-44.958218438890356],\"scale\":0.9203300832900704},{\"type\":\"grass\",\"position\":[-3.4132842168685373,0,1.7179531180753187],\"scale\":1.1303745253860595},{\"type\":\"grass\",\"position\":[-8.531937536252878,0,-20.249483845921414],\"scale\":1.1249554909422352},{\"type\":\"grass\",\"position\":[22.49054431820287,0,38.823561450738644],\"scale\":0.7814125682356687},{\"type\":\"grass\",\"position\":[-28.532298248761588,0,34.1560175132252],\"scale\":1.1294196296532406},{\"type\":\"grass\",\"position\":[65.7456238948262,0,-111.28760095262875],\"scale\":0.7227035837390353},{\"type\":\"grass\",\"position\":[-16.260525629631886,0,5.530194000749808],\"scale\":1.2436940154010125},{\"type\":\"grass\",\"position\":[-48.56042936081876,0,40.932333342561286],\"scale\":1.053048833515652},{\"type\":\"grass\",\"position\":[-89.00561992966226,0,-120.52954086847764],\"scale\":0.7368447696370453},{\"type\":\"grass\",\"position\":[27.47427979109133,0,-35.225622871809406],\"scale\":1.2778875271355497},{\"type\":\"grass\",\"position\":[-122.4172790361809,0,-53.48561324008749],\"scale\":0.7322908237750251},{\"type\":\"grass\",\"position\":[-104.81206516622218,0,106.62930651528626],\"scale\":0.9599601473230894},{\"type\":\"grass\",\"position\":[14.199809908857997,0,0.8292874233825157],\"scale\":1.1331012626158694},{\"type\":\"grass\",\"position\":[-22.8664254438985,0,131.77117764590457],\"scale\":1.201261394727791},{\"type\":\"grass\",\"position\":[-8.947812522107695,0,-14.562108495518984],\"scale\":1.0816458919623317},{\"type\":\"grass\",\"position\":[-101.04042472044682,0,-103.19544126175994],\"scale\":1.2732546072076283},{\"type\":\"grass\",\"position\":[-102.9088677031076,0,24.765397374503067],\"scale\":1.1077131707592969},{\"type\":\"grass\",\"position\":[-82.01727445492182,0,30.40303548655673],\"scale\":0.7730203303297837},{\"type\":\"grass\",\"position\":[-3.54555963933547,0,2.986988388876776],\"scale\":0.9426651274257842},{\"type\":\"grass\",\"position\":[41.9489451939163,0,-51.67122798968954],\"scale\":1.0593029456888496},{\"type\":\"grass\",\"position\":[-38.48357550364389,0,-15.569292488119345],\"scale\":1.0102725230319418},{\"type\":\"grass\",\"position\":[-29.02254948324336,0,14.934516179196578],\"scale\":0.9731696279150626},{\"type\":\"grass\",\"position\":[58.887889975243255,0,126.21267883876612],\"scale\":0.9764870081812624},{\"type\":\"grass\",\"position\":[-72.12889355907161,0,24.51651963294954],\"scale\":1.1007256973439858},{\"type\":\"grass\",\"position\":[-26.67609143775336,0,-117.67153775181801],\"scale\":1.0381341146905396},{\"type\":\"grass\",\"position\":[0.08187983345557277,0,148.64600932236024],\"scale\":1.2893686918402327},{\"type\":\"grass\",\"position\":[-2.903446353016912,0,-7.6856596617735695],\"scale\":1.1115967808451814},{\"type\":\"grass\",\"position\":[-66.99288938860722,0,-112.90723021030996],\"scale\":1.0896166517191788},{\"type\":\"grass\",\"position\":[73.3141459084694,0,79.17429559518523],\"scale\":1.1027416972860042},{\"type\":\"grass\",\"position\":[26.60858352870382,0,75.00742877299672],\"scale\":0.915235688406999},{\"type\":\"grass\",\"position\":[3.203592418416031,0,4.061810800578973],\"scale\":1.248524776021747},{\"type\":\"grass\",\"position\":[-34.47603807170862,0,-22.724503537389673],\"scale\":1.2546194025715354},{\"type\":\"grass\",\"position\":[35.637021340691255,0,9.5863842282279],\"scale\":1.1969587271935158},{\"type\":\"grass\",\"position\":[139.66691409273812,0,-34.69404938879251],\"scale\":0.7041030625057112},{\"type\":\"grass\",\"position\":[-54.911797049288815,0,85.65560281640433],\"scale\":0.8675397037443315},{\"type\":\"grass\",\"position\":[113.58553948624416,0,-47.53877979627987],\"scale\":0.8973625597093255},{\"type\":\"grass\",\"position\":[-2.664274725989727,0,87.56321372581696],\"scale\":0.8383357153104761},{\"type\":\"grass\",\"position\":[-74.52632609489841,0,60.86387950421072],\"scale\":1.0282484054051988},{\"type\":\"grass\",\"position\":[36.12164530587201,0,-2.9505281715612397],\"scale\":0.9168451833509736},{\"type\":\"grass\",\"position\":[79.97847015690512,0,49.107188150304204],\"scale\":1.2133583046191276},{\"type\":\"grass\",\"position\":[15.417149021645034,0,51.35028752043139],\"scale\":0.9667530723326502},{\"type\":\"grass\",\"position\":[45.94363179499905,0,-35.17697386861724],\"scale\":0.7293793471627706},{\"type\":\"grass\",\"position\":[54.75585156899558,0,70.74952680544202],\"scale\":0.8337687953495465},{\"type\":\"grass\",\"position\":[1.5243831898348756,0,-4.538968820720233],\"scale\":0.8596110066251543},{\"type\":\"grass\",\"position\":[-32.49380246454034,0,65.21623408434913],\"scale\":0.9982299776199809},{\"type\":\"grass\",\"position\":[-53.88492675462512,0,-59.18483816612964],\"scale\":0.7378717566723489},{\"type\":\"grass\",\"position\":[-58.01707334031674,0,119.19245660509857],\"scale\":0.9612856301099746},{\"type\":\"grass\",\"position\":[-86.91529795799637,0,-98.47187885300622],\"scale\":1.2487489336904747},{\"type\":\"grass\",\"position\":[-113.55461844096362,0,-56.92863015590214],\"scale\":1.0195890048055705},{\"type\":\"grass\",\"position\":[-98.57427713483338,0,27.952235922541057],\"scale\":0.889314418086623},{\"type\":\"grass\",\"position\":[12.65850089776046,0,-4.4343301002827475],\"scale\":1.2677590437249306},{\"type\":\"grass\",\"position\":[76.97579970255659,0,42.62051781549266],\"scale\":1.0185938308304605},{\"type\":\"grass\",\"position\":[-0.766997748416335,0,1.4715993679702721],\"scale\":1.182125686100273},{\"type\":\"grass\",\"position\":[46.50329820171249,0,-5.246441318096196],\"scale\":0.7524017505525711},{\"type\":\"grass\",\"position\":[-39.889328464647974,0,-12.395251256636675],\"scale\":1.076786763673235},{\"type\":\"grass\",\"position\":[4.113383201996271,0,-48.53260974591462],\"scale\":1.2822693713021638},{\"type\":\"grass\",\"position\":[0.20905013511813614,0,16.069156722177496],\"scale\":1.1986480242793558},{\"type\":\"grass\",\"position\":[-82.15515182231145,0,-82.6085120703149],\"scale\":0.8748170566548342},{\"type\":\"grass\",\"position\":[-31.275586521924126,0,44.210869090759985],\"scale\":0.9324386681199953},{\"type\":\"grass\",\"position\":[-53.289994410299585,0,-43.38380462943435],\"scale\":1.2558698929583114},{\"type\":\"grass\",\"position\":[-67.29821325046704,0,29.240973286591306],\"scale\":1.0102320339008646},{\"type\":\"grass\",\"position\":[-52.805781328903485,0,-66.58091387429332],\"scale\":0.9377971425715116},{\"type\":\"grass\",\"position\":[-6.298712023096624,0,-29.326632005024234],\"scale\":1.234430095145982},{\"type\":\"grass\",\"position\":[-18.28123856423177,0,-4.568218265500097],\"scale\":1.084371340822853},{\"type\":\"grass\",\"position\":[22.374040394983552,0,23.033214357632655],\"scale\":1.0397592173615355},{\"type\":\"grass\",\"position\":[-60.28121194998982,0,56.41664287985232],\"scale\":1.0490468647129467},{\"type\":\"grass\",\"position\":[-50.58743694386475,0,-78.48278737479038],\"scale\":1.284461021369323},{\"type\":\"grass\",\"position\":[-71.02915045975571,0,-27.28663792487379],\"scale\":1.1249475282226788},{\"type\":\"grass\",\"position\":[-13.824775227223435,0,53.465650972346886],\"scale\":0.8365316444380655},{\"type\":\"grass\",\"position\":[102.50703316100248,0,9.555113000023253],\"scale\":1.2135126798525309},{\"type\":\"grass\",\"position\":[-24.08865184962314,0,90.19800046047075],\"scale\":0.7589390527401196},{\"type\":\"grass\",\"position\":[-34.80805340476652,0,-33.4162440100238],\"scale\":0.9210913128816455},{\"type\":\"grass\",\"position\":[65.22895076237978,0,6.551784643605984],\"scale\":0.9588598005127049},{\"type\":\"grass\",\"position\":[70.34079170650574,0,12.648730011357085],\"scale\":0.9427250043359664},{\"type\":\"grass\",\"position\":[-21.25263728501412,0,-26.774927842400622],\"scale\":1.0018860296613772},{\"type\":\"grass\",\"position\":[72.30236530251322,0,76.7128635351982],\"scale\":1.1737681202523165},{\"type\":\"grass\",\"position\":[133.8131267099368,0,-40.3247925617952],\"scale\":0.9528610955933314},{\"type\":\"grass\",\"position\":[-19.674467865891252,0,-24.816681874726157],\"scale\":1.2105152992766737},{\"type\":\"grass\",\"position\":[-40.336353028202026,0,125.33399736462329],\"scale\":1.2899235264159246},{\"type\":\"grass\",\"position\":[3.781337486757665,0,75.59748729711762],\"scale\":1.1299675809037946},{\"type\":\"grass\",\"position\":[23.713397330504055,0,-68.84348433947814],\"scale\":0.9734163391884312},{\"type\":\"grass\",\"position\":[-1.966572049166075,0,-22.989771836279314],\"scale\":1.0753244804662758},{\"type\":\"grass\",\"position\":[82.35145892025616,0,-22.74098153831061],\"scale\":1.217103901239176},{\"type\":\"grass\",\"position\":[-8.318867113889038,0,145.96829321765657],\"scale\":0.8707765075506644},{\"type\":\"grass\",\"position\":[-48.341842247949636,0,-140.11594497879113],\"scale\":0.8073250829211376},{\"type\":\"grass\",\"position\":[-12.921112139216092,0,-73.4276900115082],\"scale\":1.2527344147542265},{\"type\":\"grass\",\"position\":[65.78904205767552,0,-89.58970648747481],\"scale\":1.1834102466947607},{\"type\":\"grass\",\"position\":[9.9048328632043,0,13.48305646233704],\"scale\":0.817185654783567},{\"type\":\"grass\",\"position\":[-73.85280287785505,0,38.93558124718571],\"scale\":0.7141671223164475},{\"type\":\"grass\",\"position\":[31.80546666193526,0,-125.23895274318235],\"scale\":0.9122698775047452},{\"type\":\"grass\",\"position\":[71.07513670810518,0,-43.02596439242727],\"scale\":0.7660843312661075},{\"type\":\"grass\",\"position\":[47.45966145937672,0,-12.805009288985847],\"scale\":1.220089212987527},{\"type\":\"grass\",\"position\":[19.836747027134678,0,51.195833489920275],\"scale\":1.2188278269689097},{\"type\":\"grass\",\"position\":[38.06166984179898,0,105.42248285603641],\"scale\":0.8347124485709001},{\"type\":\"grass\",\"position\":[31.817239883715047,0,35.52213062291286],\"scale\":1.1922176467575296},{\"type\":\"grass\",\"position\":[112.46683248489985,0,-6.179349897568211],\"scale\":1.2175917860030363},{\"type\":\"grass\",\"position\":[71.90957210137461,0,-82.0704467520935],\"scale\":1.0731592888561785},{\"type\":\"grass\",\"position\":[49.35961147291143,0,-99.23394448673297],\"scale\":1.1812400340470788},{\"type\":\"grass\",\"position\":[-91.24381260054157,0,-85.08294840358603],\"scale\":0.9342644044697272},{\"type\":\"grass\",\"position\":[-81.63167896682342,0,-72.18505659958812],\"scale\":1.0470373145456815},{\"type\":\"grass\",\"position\":[-6.294678743749874,0,-147.27955215984997],\"scale\":0.9923684157165468},{\"type\":\"grass\",\"position\":[144.8061930672784,0,-6.903891865610948],\"scale\":0.7352383142619542},{\"type\":\"grass\",\"position\":[-54.94062020061415,0,52.6906015031705],\"scale\":1.0810561216509007},{\"type\":\"grass\",\"position\":[103.27648118545747,0,47.675475871581675],\"scale\":0.775670777016059},{\"type\":\"grass\",\"position\":[-47.86131764924678,0,-67.77091480772953],\"scale\":1.083499009244517},{\"type\":\"grass\",\"position\":[3.630855462024745,0,35.68071813694371],\"scale\":1.0248124377890104},{\"type\":\"grass\",\"position\":[-48.23703925169193,0,-29.1011194255506],\"scale\":1.2889967558426405},{\"type\":\"grass\",\"position\":[-91.6351926946533,0,90.80760364440427],\"scale\":0.9341946314099997},{\"type\":\"grass\",\"position\":[2.4160181472050715,0,8.653549493942355],\"scale\":1.026584142809116},{\"type\":\"grass\",\"position\":[-57.258217937930574,0,-85.74249161414627],\"scale\":1.2837954937585887},{\"type\":\"grass\",\"position\":[-1.9417578956801724,0,6.621125824070948],\"scale\":0.8011285648500776},{\"type\":\"grass\",\"position\":[-58.30838647333431,0,-29.08413481841658],\"scale\":1.2470117471509816},{\"type\":\"grass\",\"position\":[-145.82710140164573,0,8.833667889706891],\"scale\":1.116773272571378},{\"type\":\"grass\",\"position\":[-78.34980783084606,0,-5.768289509471201],\"scale\":1.299248066992021},{\"type\":\"grass\",\"position\":[-35.22251994466374,0,-86.87941790066722],\"scale\":0.8888479255234544},{\"type\":\"grass\",\"position\":[-12.624853371535842,0,-108.93991118570128],\"scale\":1.1041744342420328},{\"type\":\"grass\",\"position\":[34.930104604695394,0,87.45939753761645],\"scale\":1.2110528399747704},{\"type\":\"grass\",\"position\":[-28.47269751948894,0,-19.749810411076886],\"scale\":0.9763886833761836},{\"type\":\"grass\",\"position\":[-22.85148463308132,0,34.368761539820646],\"scale\":0.9894250846142274},{\"type\":\"grass\",\"position\":[-39.253563155621016,0,-50.404347037717706],\"scale\":1.2968233245602625},{\"type\":\"grass\",\"position\":[-116.56251375163048,0,-43.21934851503136],\"scale\":1.2572729837760723},{\"type\":\"grass\",\"position\":[-2.2656280716496404,0,116.87440035518539],\"scale\":1.046035297498382},{\"type\":\"grass\",\"position\":[1.8184415973057833,0,-15.73208407308836],\"scale\":0.9086629768991247},{\"type\":\"grass\",\"position\":[-53.50003424358548,0,-80.319419866958],\"scale\":1.1647187840974156},{\"type\":\"grass\",\"position\":[-75.34481266380924,0,-94.97108368913976],\"scale\":0.8875241082071802},{\"type\":\"grass\",\"position\":[-78.03411595777213,0,-0.16900256064641986],\"scale\":1.1382763314267865},{\"type\":\"grass\",\"position\":[-90.0505335231835,0,-108.69771660538945],\"scale\":0.7326714971244205},{\"type\":\"grass\",\"position\":[-18.86678359841564,0,28.941864657494428],\"scale\":0.8888943073582094},{\"type\":\"grass\",\"position\":[-44.890446870941794,0,-40.80848201533567],\"scale\":1.1219724348364228},{\"type\":\"grass\",\"position\":[35.763054016579574,0,18.809819255087476],\"scale\":1.145796333412727},{\"type\":\"grass\",\"position\":[10.322736855687664,0,-13.49865073988207],\"scale\":0.7580530552874634},{\"type\":\"grass\",\"position\":[35.09343413284886,0,48.77699490895403],\"scale\":0.913472158054047},{\"type\":\"grass\",\"position\":[-65.9583129005049,0,-3.2720585557716646],\"scale\":0.7262449821856226},{\"type\":\"grass\",\"position\":[-16.9911277312312,0,-32.1341257379289],\"scale\":0.9923310525876063},{\"type\":\"grass\",\"position\":[-10.28646316481673,0,74.65590920450911],\"scale\":0.807255423292126},{\"type\":\"grass\",\"position\":[-6.373803281239288,0,18.610171272557416],\"scale\":1.1326663902327259},{\"type\":\"grass\",\"position\":[6.927329176870241,0,34.80160901536172],\"scale\":0.9283032701658751},{\"type\":\"grass\",\"position\":[-23.11916245858469,0,24.650482836247594],\"scale\":1.2757962697820333},{\"type\":\"grass\",\"position\":[0.6348908810097363,0,-17.257428457246665],\"scale\":1.2690183902720933},{\"type\":\"grass\",\"position\":[19.067202105081858,0,-11.984397602294598],\"scale\":0.7888982767521892},{\"type\":\"grass\",\"position\":[22.877794226996947,0,-11.217350268064745],\"scale\":0.9205204684425702},{\"type\":\"grass\",\"position\":[56.01641119562043,0,26.2612076506126],\"scale\":1.2767709577334991},{\"type\":\"grass\",\"position\":[-7.229146622313181,0,7.062915033365499],\"scale\":1.1161449087504662},{\"type\":\"grass\",\"position\":[3.991077380212415,0,6.995586237987706],\"scale\":0.8894530082608589},{\"type\":\"grass\",\"position\":[-30.188489375748624,0,34.242533916637775],\"scale\":1.119381090879323},{\"type\":\"grass\",\"position\":[64.89466194058886,0,59.06256304678491],\"scale\":1.0479694799868318},{\"type\":\"grass\",\"position\":[-7.800753977579939,0,-65.39630120623536],\"scale\":1.1790146685849205},{\"type\":\"grass\",\"position\":[10.93617682915882,0,-13.355602370367077],\"scale\":0.8234851478805086},{\"type\":\"grass\",\"position\":[76.87263952298532,0,109.53279365217232],\"scale\":0.7924085791336134},{\"type\":\"grass\",\"position\":[-32.04696168356745,0,19.472298649686174],\"scale\":1.227153530866063},{\"type\":\"grass\",\"position\":[-27.250643212246604,0,3.793695298717459],\"scale\":1.124893261991425},{\"type\":\"grass\",\"position\":[33.09291113771307,0,-93.68455722799256],\"scale\":0.7990328821158199},{\"type\":\"grass\",\"position\":[-53.92570464390631,0,-17.389241354082014],\"scale\":1.0520496533216024},{\"type\":\"grass\",\"position\":[61.15866016878453,0,-99.04147837212803],\"scale\":1.0862231904085697},{\"type\":\"grass\",\"position\":[0.10534829730814915,0,-0.7406977414278207],\"scale\":0.7421671864010981},{\"type\":\"grass\",\"position\":[-12.712146045203003,0,-29.431779387333545],\"scale\":0.9563663336647641},{\"type\":\"grass\",\"position\":[0.13042770771252854,0,1.444637618130164],\"scale\":1.091077389892077},{\"type\":\"grass\",\"position\":[-27.270062144137167,0,9.078776124623058],\"scale\":0.8682247528052713},{\"type\":\"grass\",\"position\":[2.4153652644447274,0,1.8955299410676179],\"scale\":1.0741702572204055},{\"type\":\"grass\",\"position\":[-18.29841235760859,0,-84.17935314790165],\"scale\":1.2320801722235626},{\"type\":\"grass\",\"position\":[29.60079422564501,0,-112.84436059077004],\"scale\":1.2762618516323152},{\"type\":\"grass\",\"position\":[29.011107818755814,0,88.73765605845982],\"scale\":1.0494504766979833},{\"type\":\"grass\",\"position\":[111.65607226118841,0,29.561583460557877],\"scale\":0.9119893443043284},{\"type\":\"grass\",\"position\":[91.8336721817143,0,-55.35237828397207],\"scale\":0.8308641397731361},{\"type\":\"grass\",\"position\":[-74.50228671602788,0,-23.46649184593321],\"scale\":1.2586789630893414},{\"type\":\"grass\",\"position\":[15.35036029952907,0,12.784901975751428],\"scale\":1.1390415050517153},{\"type\":\"grass\",\"position\":[48.2002327197928,0,16.737462377454346],\"scale\":0.8084015985582688},{\"type\":\"grass\",\"position\":[-40.130621717587125,0,50.21644163708909],\"scale\":1.0307823945006482},{\"type\":\"grass\",\"position\":[-24.425009663249906,0,44.63917017674392],\"scale\":0.921559839176888},{\"type\":\"grass\",\"position\":[5.902395564167275,0,-64.69381456713514],\"scale\":1.1557322128256715},{\"type\":\"grass\",\"position\":[103.18947528290927,0,-55.378582349670516],\"scale\":1.1426898538639025},{\"type\":\"grass\",\"position\":[-32.31579060196492,0,-66.81712437470465],\"scale\":1.000035183815651},{\"type\":\"grass\",\"position\":[133.0542434594918,0,-11.842931182412881],\"scale\":0.731117214052686},{\"type\":\"grass\",\"position\":[11.21441662019129,0,31.88761548939438],\"scale\":0.8332909546660039},{\"type\":\"grass\",\"position\":[83.07624947911496,0,-25.505300802069254],\"scale\":1.0461733956275945},{\"type\":\"grass\",\"position\":[42.301062197503775,0,-116.72668665221947],\"scale\":1.2611680426085916},{\"type\":\"grass\",\"position\":[-73.62652962905295,0,-72.42986468394986],\"scale\":1.1557817821290572},{\"type\":\"grass\",\"position\":[-58.922356444278805,0,-28.516636568915292],\"scale\":0.9068073576458333},{\"type\":\"grass\",\"position\":[-73.22852992138354,0,44.992703333799334],\"scale\":1.2410692776512624},{\"type\":\"grass\",\"position\":[-11.504370341742705,0,-36.751275045448814],\"scale\":0.7689053263751557},{\"type\":\"grass\",\"position\":[-59.837151421204695,0,65.24867630109514],\"scale\":0.7817088951685782},{\"type\":\"grass\",\"position\":[118.2733188402237,0,-80.62550025827696],\"scale\":0.7430079456036945},{\"type\":\"grass\",\"position\":[32.34181348227796,0,124.05570716763553],\"scale\":1.1878695754926916},{\"type\":\"grass\",\"position\":[-148.9337672267087,0,-0.5493359433688967],\"scale\":1.205030689774254},{\"type\":\"grass\",\"position\":[-12.199783341919922,0,67.73668583604436],\"scale\":0.7613105331124762},{\"type\":\"grass\",\"position\":[-39.51215970375504,0,15.850480090363423],\"scale\":1.2365340114698415},{\"type\":\"grass\",\"position\":[-14.396772993466152,0,-4.50549386549889],\"scale\":1.0777240546489215},{\"type\":\"grass\",\"position\":[16.290190976462505,0,-21.668257542341387],\"scale\":0.7332252810160901},{\"type\":\"grass\",\"position\":[81.928067483405,0,49.61520508861536],\"scale\":0.8260479609954484},{\"type\":\"grass\",\"position\":[-103.68042377073922,0,39.869682072977156],\"scale\":1.1194151243278427},{\"type\":\"grass\",\"position\":[87.76146397416768,0,-22.836252543410303],\"scale\":1.2185546294757044},{\"type\":\"grass\",\"position\":[-0.835144478228195,0,-100.88275394828051],\"scale\":1.2144151575601851},{\"type\":\"grass\",\"position\":[0.920697292962401,0,-53.824804331981014],\"scale\":1.2191615687155701},{\"type\":\"grass\",\"position\":[87.63882845381076,0,116.12266844182545],\"scale\":1.1599322677479926},{\"type\":\"grass\",\"position\":[-60.56158080499396,0,6.604291235555543],\"scale\":0.8044660466190641},{\"type\":\"grass\",\"position\":[-2.399953522113618,0,48.88699549340936],\"scale\":1.2689200808736576},{\"type\":\"grass\",\"position\":[-66.16304094458556,0,13.5007932258028],\"scale\":1.1823519058371967},{\"type\":\"grass\",\"position\":[1.4373191411440376,0,78.1936933095447],\"scale\":0.7312548101635882},{\"type\":\"grass\",\"position\":[-62.466978267092514,0,-114.77742611388884],\"scale\":1.2400778373996852},{\"type\":\"grass\",\"position\":[123.94469415284378,0,-12.175389151163259],\"scale\":1.0710890824468982},{\"type\":\"grass\",\"position\":[34.284281366490546,0,-31.745196317164606],\"scale\":1.0001158426156047},{\"type\":\"grass\",\"position\":[-114.38338962094656,0,38.46466207886541],\"scale\":0.9182317939762592},{\"type\":\"grass\",\"position\":[-63.067859171074055,0,97.50692975942427],\"scale\":1.2413521115159434},{\"type\":\"grass\",\"position\":[2.481651408933348,0,25.63417520566617],\"scale\":1.0873219184270686},{\"type\":\"grass\",\"position\":[-29.83628515223113,0,90.79709514225341],\"scale\":1.0383908096203167},{\"type\":\"grass\",\"position\":[-53.354056763164664,0,-113.72353883995153],\"scale\":0.9045038940877644},{\"type\":\"grass\",\"position\":[-4.47130213852506,0,-4.895281411782883],\"scale\":1.0595478522665704},{\"type\":\"grass\",\"position\":[86.86714149511168,0,-51.919273642221526],\"scale\":1.2505779886910335},{\"type\":\"grass\",\"position\":[75.03157151250193,0,-27.829003871477752],\"scale\":1.2472507255490448},{\"type\":\"grass\",\"position\":[-76.94279968339357,0,-109.81301882958371],\"scale\":1.023059117550823},{\"type\":\"grass\",\"position\":[-5.698316763290738,0,-0.08759302608396144],\"scale\":0.9526781075330142},{\"type\":\"grass\",\"position\":[110.41512516321369,0,-86.38575322899797],\"scale\":0.9753740856546219},{\"type\":\"grass\",\"position\":[6.838338052439023,0,19.85057039415733],\"scale\":0.7664004051665412},{\"type\":\"grass\",\"position\":[53.972555859004245,0,-107.54146654543325],\"scale\":1.049032673412602},{\"type\":\"grass\",\"position\":[75.84864118440134,0,-117.93343736136707],\"scale\":1.031844967511475},{\"type\":\"grass\",\"position\":[-13.77994217237672,0,11.263334444489555],\"scale\":1.1964216926599913},{\"type\":\"grass\",\"position\":[136.69273051091182,0,-38.37249628057358],\"scale\":0.7695192000094173},{\"type\":\"grass\",\"position\":[120.5145076084034,0,73.77423422342058],\"scale\":1.118008165667967},{\"type\":\"grass\",\"position\":[-131.67677979282973,0,53.48883811098744],\"scale\":1.105599092010899},{\"type\":\"grass\",\"position\":[7.625316525737636,0,3.023670075577595],\"scale\":1.1881954934169856},{\"type\":\"grass\",\"position\":[79.45344196484065,0,-25.481366029672348],\"scale\":0.719558825509329},{\"type\":\"grass\",\"position\":[64.45147311139874,0,22.472938665659232],\"scale\":1.069998209628014},{\"type\":\"grass\",\"position\":[28.660837588349455,0,-12.022432148211681],\"scale\":0.8322610654475711},{\"type\":\"grass\",\"position\":[1.4575011131909787,0,-10.58135659098792],\"scale\":0.8878924466688749},{\"type\":\"grass\",\"position\":[103.7161162539918,0,-64.21938702446151],\"scale\":0.7477671862655833},{\"type\":\"grass\",\"position\":[21.484442987325398,0,-141.67343733351905],\"scale\":0.9702938128921639},{\"type\":\"grass\",\"position\":[51.9083196103943,0,-15.199935275065291],\"scale\":0.9652231377206015},{\"type\":\"grass\",\"position\":[-5.747807544833315,0,0.12024445846880678],\"scale\":0.8030857153927828},{\"type\":\"grass\",\"position\":[78.5354737276434,0,12.861180735609489],\"scale\":1.0700726587931844},{\"type\":\"grass\",\"position\":[19.484470134472097,0,11.172852925751469],\"scale\":0.9311022684495662},{\"type\":\"grass\",\"position\":[-14.269038266986136,0,9.874654801742137],\"scale\":0.7295831861986507},{\"type\":\"grass\",\"position\":[9.170881348469246,0,9.075697604176902],\"scale\":1.0383587560357428},{\"type\":\"grass\",\"position\":[1.30683444131439,0,15.850575761249207],\"scale\":0.8997172782753142},{\"type\":\"grass\",\"position\":[-11.481089954150066,0,13.62963380001206],\"scale\":1.2549727278944545},{\"type\":\"grass\",\"position\":[-0.4569385867921809,0,0.3045189770106057],\"scale\":0.9467260515249677},{\"type\":\"grass\",\"position\":[26.362199625071806,0,-81.12171778036611],\"scale\":0.9679823814982523},{\"type\":\"grass\",\"position\":[32.47656755324425,0,-58.97820769431392],\"scale\":1.2038362424291915},{\"type\":\"grass\",\"position\":[6.7818269534545355,0,-7.354815017139881],\"scale\":0.7010241954183087},{\"type\":\"grass\",\"position\":[-111.3569965164411,0,-27.370137526539782],\"scale\":1.2433450340346544},{\"type\":\"grass\",\"position\":[18.93804236981958,0,-11.470461880568928],\"scale\":0.7930540698107166},{\"type\":\"grass\",\"position\":[-28.077759933293976,0,-51.88112913912836],\"scale\":0.7608306713576352},{\"type\":\"grass\",\"position\":[-51.536077372846336,0,78.58324037724839],\"scale\":0.8827284618752258},{\"type\":\"grass\",\"position\":[23.48453673662801,0,132.3195465630487],\"scale\":1.0030983468250674},{\"type\":\"grass\",\"position\":[-16.632587743199426,0,76.42301753256272],\"scale\":1.1317809288021743},{\"type\":\"grass\",\"position\":[-32.43042075535382,0,-45.1278349829471],\"scale\":0.8969448958353841},{\"type\":\"grass\",\"position\":[105.18899908657114,0,-27.422266643164583],\"scale\":0.7318059673927293},{\"type\":\"grass\",\"position\":[-4.954972929169624,0,-20.10296637588902],\"scale\":0.9130168441443919},{\"type\":\"grass\",\"position\":[20.30397266511035,0,17.161584564163476],\"scale\":1.1331991504609347},{\"type\":\"grass\",\"position\":[79.15234800992772,0,39.417374911885],\"scale\":1.2720017110773543},{\"type\":\"grass\",\"position\":[-71.54109780769535,0,-3.2739476709982327],\"scale\":0.9565525534449706},{\"type\":\"grass\",\"position\":[67.62207773477373,0,-16.115883595672656],\"scale\":0.7550257125853419},{\"type\":\"grass\",\"position\":[59.11578017865117,0,18.129190480775435],\"scale\":1.2166070467286845},{\"type\":\"grass\",\"position\":[-0.39679105382305424,0,-2.932861257268016],\"scale\":0.8343920966360603},{\"type\":\"grass\",\"position\":[5.290357225125866,0,16.434149011406536],\"scale\":1.1136018583689942},{\"type\":\"grass\",\"position\":[11.026972893351042,0,3.0638323273023307],\"scale\":1.1058480363044239},{\"type\":\"grass\",\"position\":[-59.75898598086426,0,28.541110861691994],\"scale\":0.9664054888933151},{\"type\":\"grass\",\"position\":[96.5864989323541,0,-84.96777779272664],\"scale\":1.2338175637088793},{\"type\":\"grass\",\"position\":[-45.53803017276687,0,2.05115443636148],\"scale\":0.9937865198094171},{\"type\":\"grass\",\"position\":[91.73777656463042,0,-19.5268153665625],\"scale\":0.9248696258194461},{\"type\":\"grass\",\"position\":[-0.6983483699005368,0,30.004634829803255],\"scale\":1.0753716982174784},{\"type\":\"grass\",\"position\":[-12.385301068376304,0,-80.1297553222501],\"scale\":1.0588453272612892},{\"type\":\"grass\",\"position\":[19.168513361824097,0,-122.52509447446585],\"scale\":1.1668423999437325},{\"type\":\"grass\",\"position\":[-23.52256468062644,0,-38.596277304631315],\"scale\":1.169167576899831},{\"type\":\"grass\",\"position\":[113.50276625653693,0,58.71164693674353],\"scale\":1.2947281508768271},{\"type\":\"grass\",\"position\":[-22.831415665395966,0,-45.83171115755013],\"scale\":0.8604793178294765},{\"type\":\"grass\",\"position\":[5.262880499107359,0,-130.64027068611347],\"scale\":0.8907574628252046},{\"type\":\"grass\",\"position\":[18.59443556513549,0,-7.648201312280767],\"scale\":0.7805289522145901},{\"type\":\"grass\",\"position\":[37.41439209051695,0,-24.693251347033716],\"scale\":1.0842017759657383},{\"type\":\"grass\",\"position\":[63.72188192034691,0,3.3200611673174425],\"scale\":0.9063845740429899},{\"type\":\"grass\",\"position\":[104.59202615734817,0,69.97447816719531],\"scale\":1.1038360291553748},{\"type\":\"grass\",\"position\":[-77.77361978481107,0,-27.728603266797563],\"scale\":1.1019738164532338},{\"type\":\"grass\",\"position\":[-52.004770854860155,0,21.680662118532595],\"scale\":1.018828855822401},{\"type\":\"grass\",\"position\":[-69.49802911304612,0,83.77276063751806],\"scale\":1.2829662135308304},{\"type\":\"grass\",\"position\":[-3.6533630307165073,0,2.0664206630376922],\"scale\":0.852519569758242},{\"type\":\"grass\",\"position\":[14.165605536216669,0,-63.034924224358534],\"scale\":1.0558344314385524},{\"type\":\"grass\",\"position\":[-38.79203239547953,0,-13.312735984042881],\"scale\":1.0600789267384096},{\"type\":\"grass\",\"position\":[-56.12463508440544,0,-34.926832909631145],\"scale\":1.1041879943357498},{\"type\":\"grass\",\"position\":[-124.86614041502062,0,-57.50885015086305],\"scale\":1.2672627318014387},{\"type\":\"grass\",\"position\":[146.58750189689036,0,-11.069696026402585],\"scale\":1.186247906988566},{\"type\":\"grass\",\"position\":[-12.541895592909906,0,41.957109817730384],\"scale\":0.9830289240575325},{\"type\":\"grass\",\"position\":[-47.84192546919307,0,-132.44910835594231],\"scale\":0.7802058684193587},{\"type\":\"grass\",\"position\":[-40.938062427355966,0,-113.89821398590648],\"scale\":1.2158653751890218},{\"type\":\"grass\",\"position\":[76.49190477787315,0,26.32219167188611],\"scale\":0.9690570093862751},{\"type\":\"grass\",\"position\":[-117.10489611773754,0,0.229345798403337],\"scale\":0.9511049288692296},{\"type\":\"grass\",\"position\":[41.659970945294326,0,-28.083276169057832],\"scale\":0.9818017115376244},{\"type\":\"grass\",\"position\":[40.66142046756411,0,-111.90424861483403],\"scale\":0.9373623179758123},{\"type\":\"grass\",\"position\":[-76.35163741904888,0,-102.75337584587189],\"scale\":0.8592201204533307},{\"type\":\"grass\",\"position\":[10.950011356260092,0,-143.89333495450808],\"scale\":0.7385664700079527},{\"type\":\"grass\",\"position\":[64.35902778772311,0,-101.34850113021048],\"scale\":0.8393448331298394},{\"type\":\"grass\",\"position\":[53.661198105979835,0,70.33585436145579],\"scale\":0.8988821766002689},{\"type\":\"grass\",\"position\":[-77.76289854982052,0,52.676387044331335],\"scale\":0.9779320486278793},{\"type\":\"grass\",\"position\":[-7.036204572476808,0,5.222228355757286],\"scale\":0.8280888676897231},{\"type\":\"grass\",\"position\":[-105.07672587239502,0,-36.67568392513753],\"scale\":1.1892522262099263},{\"type\":\"grass\",\"position\":[35.43867065662219,0,-19.190600058166233],\"scale\":0.9226455272992004},{\"type\":\"grass\",\"position\":[25.10412720011864,0,19.120842975451076],\"scale\":1.2713053988164278},{\"type\":\"grass\",\"position\":[-6.204421820794543,0,123.10126123892175],\"scale\":0.724312070129171},{\"type\":\"grass\",\"position\":[92.47940769239054,0,29.9683854391095],\"scale\":1.136251004024796},{\"type\":\"grass\",\"position\":[2.5007828785252757,0,-16.328419186019566],\"scale\":0.9052444162471596},{\"type\":\"grass\",\"position\":[75.63866822648505,0,121.647754514765],\"scale\":0.7172862924424437},{\"type\":\"grass\",\"position\":[16.54113837018155,0,7.9939838862437265],\"scale\":0.9849434135476087},{\"type\":\"grass\",\"position\":[-88.34493079571966,0,108.27285853354456],\"scale\":0.9301856911857977},{\"type\":\"grass\",\"position\":[20.510014055221493,0,50.79211063320649],\"scale\":0.829420860102047},{\"type\":\"grass\",\"position\":[70.88472531321786,0,-83.02658856882609],\"scale\":1.2666471309376122},{\"type\":\"grass\",\"position\":[20.32981385388582,0,-16.089982848204276],\"scale\":0.8702807082185108},{\"type\":\"grass\",\"position\":[101.45580622469534,0,103.40407958308786],\"scale\":0.9133277727456732},{\"type\":\"grass\",\"position\":[38.89940785490423,0,15.089445303844663],\"scale\":0.9419750598870141},{\"type\":\"grass\",\"position\":[32.641217902928105,0,114.15704429890789],\"scale\":0.9467835354289645},{\"type\":\"grass\",\"position\":[-70.00997119462754,0,25.30152621791395],\"scale\":0.9004492053045579},{\"type\":\"grass\",\"position\":[-20.956839109664912,0,25.412104425228968],\"scale\":0.9042532225973926},{\"type\":\"grass\",\"position\":[143.060193734337,0,-14.258741216994272],\"scale\":0.7233531306479062},{\"type\":\"grass\",\"position\":[32.89293826500134,0,55.929147887010494],\"scale\":1.1300386770673398},{\"type\":\"grass\",\"position\":[-46.59208014357408,0,13.42697905502325],\"scale\":1.2834300936077727},{\"type\":\"grass\",\"position\":[-123.97154396117115,0,-83.92223924000322],\"scale\":1.295433311939834},{\"type\":\"grass\",\"position\":[61.140747219869496,0,-68.01091332400028],\"scale\":1.173914245616415},{\"type\":\"grass\",\"position\":[66.33307582718088,0,4.7844524763999745],\"scale\":0.8013172117184406},{\"type\":\"grass\",\"position\":[6.30448667561496,0,-60.040295063411676],\"scale\":1.1422446883237747},{\"type\":\"grass\",\"position\":[69.1225235269577,0,-26.06424127144606],\"scale\":1.1800185614128647},{\"type\":\"grass\",\"position\":[37.589348590934875,0,-7.7250711784727395],\"scale\":0.8673659133110305},{\"type\":\"grass\",\"position\":[32.004193542529315,0,-29.438034007637306],\"scale\":1.1507181963275166},{\"type\":\"grass\",\"position\":[-78.00150846889717,0,50.151528126231646],\"scale\":0.738985633881622},{\"type\":\"grass\",\"position\":[-94.74949041556773,0,-56.377883268548416],\"scale\":0.752956619483847},{\"type\":\"grass\",\"position\":[-13.144183739611849,0,-41.790172276669786],\"scale\":1.2712638692507663},{\"type\":\"grass\",\"position\":[36.33937404980678,0,54.38740537750381],\"scale\":0.984480029143825},{\"type\":\"grass\",\"position\":[-31.78054926963821,0,-27.63157627349754],\"scale\":0.8095152996616258},{\"type\":\"grass\",\"position\":[32.30252348813282,0,-139.27685839916504],\"scale\":0.849847223572878},{\"type\":\"grass\",\"position\":[64.46046104728723,0,-36.48015956688232],\"scale\":0.9836511124094377},{\"type\":\"grass\",\"position\":[-50.634058634695144,0,83.06391501854488],\"scale\":1.1517063184422434},{\"type\":\"grass\",\"position\":[-51.434589502770564,0,-33.310442432855496],\"scale\":0.7589400110966964},{\"type\":\"grass\",\"position\":[-30.59057502393327,0,7.145046035646843],\"scale\":1.036299537421915},{\"type\":\"grass\",\"position\":[41.69954160513347,0,-75.51694030377702],\"scale\":1.2800776325128518},{\"type\":\"grass\",\"position\":[3.1696707870616234,0,-82.8725879826342],\"scale\":0.8608291594947381},{\"type\":\"grass\",\"position\":[-89.65087087428103,0,-51.447133673095884],\"scale\":0.7408381786549381},{\"type\":\"grass\",\"position\":[-4.50438631334001,0,-19.715441395697418],\"scale\":1.1505448577960624},{\"type\":\"grass\",\"position\":[-15.379297929663531,0,14.750509202486498],\"scale\":0.8774309635247356},{\"type\":\"grass\",\"position\":[-35.431582601234815,0,-75.25374665258637],\"scale\":0.7430375077141953},{\"type\":\"grass\",\"position\":[0.9223101566014031,0,59.11508425764875],\"scale\":1.0473722436839772},{\"type\":\"grass\",\"position\":[7.103582856637497,0,-99.8177738898059],\"scale\":1.0276112238493627},{\"type\":\"grass\",\"position\":[-43.37509394500224,0,72.76721789944033],\"scale\":0.7939149445374916},{\"type\":\"grass\",\"position\":[38.55447950698781,0,22.786871465485348],\"scale\":1.0570506889273272},{\"type\":\"grass\",\"position\":[-2.0193091205797247,0,-47.75519676028789],\"scale\":1.2842858656516298},{\"type\":\"grass\",\"position\":[-67.99406492157446,0,10.22954074959804],\"scale\":0.7938710316911347},{\"type\":\"grass\",\"position\":[28.4375063881264,0,-22.752403900772226],\"scale\":0.7054371517066965},{\"type\":\"grass\",\"position\":[-64.53084606984956,0,3.7254713739963967],\"scale\":0.9466790625379179},{\"type\":\"grass\",\"position\":[-23.392792848830382,0,129.6524966539101],\"scale\":1.2704511042524467},{\"type\":\"grass\",\"position\":[123.69317862063187,0,-47.959382620172335],\"scale\":1.2352527496599977},{\"type\":\"grass\",\"position\":[41.26531891088694,0,-108.69475125214782],\"scale\":1.2966340935669547},{\"type\":\"grass\",\"position\":[28.206442234929508,0,-27.355545501700828],\"scale\":1.1567658507202763},{\"type\":\"grass\",\"position\":[-18.640187895248573,0,61.984398160235976],\"scale\":1.1776804927210898},{\"type\":\"grass\",\"position\":[-132.19688114164927,0,37.877833569176204],\"scale\":0.888034052723904},{\"type\":\"grass\",\"position\":[-75.58123448486376,0,53.70929595814095],\"scale\":1.2297945093077032},{\"type\":\"grass\",\"position\":[-39.04464743326113,0,-65.33957317487535],\"scale\":1.2544087384886302},{\"type\":\"grass\",\"position\":[-118.84379080177595,0,20.829886617044238],\"scale\":0.9707277704571339},{\"type\":\"grass\",\"position\":[-8.455245222766896,0,9.727982623710735],\"scale\":0.8870289989583138},{\"type\":\"grass\",\"position\":[66.9246688007056,0,64.45574504914107],\"scale\":1.0428211517484542},{\"type\":\"grass\",\"position\":[0.6546231322232885,0,-105.42082742127215],\"scale\":0.774025370104928},{\"type\":\"grass\",\"position\":[23.141892430242105,0,36.46130324207002],\"scale\":1.118316911232169},{\"type\":\"grass\",\"position\":[7.500190807779323,0,3.7545580724666823],\"scale\":1.0815550017197957},{\"type\":\"grass\",\"position\":[61.98096387562852,0,80.48944347223765],\"scale\":1.0984315351413976},{\"type\":\"grass\",\"position\":[3.201292639009372,0,-0.07088048471343901],\"scale\":1.0902254275929215},{\"type\":\"grass\",\"position\":[87.25639757714727,0,71.9589196287131],\"scale\":0.8837765426505425},{\"type\":\"grass\",\"position\":[6.900058006750433,0,-16.446891282180264],\"scale\":0.7560300232102265},{\"type\":\"grass\",\"position\":[76.96709504332205,0,106.55769946034074],\"scale\":1.1622739238451103},{\"type\":\"grass\",\"position\":[52.52195326670505,0,-106.36731010959149],\"scale\":1.2524491107671096},{\"type\":\"grass\",\"position\":[-117.11419656859908,0,26.01851228053483],\"scale\":0.7927526346228267},{\"type\":\"grass\",\"position\":[-3.246358928603141,0,-5.9162050101297],\"scale\":1.1317225090492675},{\"type\":\"grass\",\"position\":[32.231182743869915,0,85.3814467758336],\"scale\":1.1828781781061735},{\"type\":\"grass\",\"position\":[-133.67532743466552,0,42.234864217524574],\"scale\":1.21110183615682},{\"type\":\"grass\",\"position\":[-51.28228144809696,0,12.604995646435304],\"scale\":1.0061249987776755},{\"type\":\"grass\",\"position\":[-28.10720402257156,0,-43.075554659548345],\"scale\":0.7980017350515386},{\"type\":\"grass\",\"position\":[-121.39202947250033,0,-12.516793555608345],\"scale\":0.9656483704670082},{\"type\":\"grass\",\"position\":[39.037199286604725,0,-53.29767407459855],\"scale\":0.7360589062948537},{\"type\":\"grass\",\"position\":[-69.3412169408797,0,-32.03169658699564],\"scale\":1.1953158642210924},{\"type\":\"grass\",\"position\":[21.421813263915887,0,-28.21999865488517],\"scale\":1.2247376332347328},{\"type\":\"grass\",\"position\":[-80.53031762944978,0,126.51472086858611],\"scale\":1.1385325137794224},{\"type\":\"grass\",\"position\":[-47.60157822247681,0,-21.73775735372446],\"scale\":0.8569764181579047},{\"type\":\"grass\",\"position\":[-45.78877559156961,0,13.634246543931154],\"scale\":0.9449989344549505},{\"type\":\"grass\",\"position\":[-34.019705281683045,0,125.12579933970304],\"scale\":0.7115833733407138},{\"type\":\"grass\",\"position\":[39.50561287073347,0,81.81570652766703],\"scale\":1.0368558862436108},{\"type\":\"grass\",\"position\":[19.237648262502024,0,-26.465162295131435],\"scale\":0.9907874780345785},{\"type\":\"grass\",\"position\":[40.054913665969835,0,62.83514888331365],\"scale\":1.1116625279202033},{\"type\":\"grass\",\"position\":[-87.99536885033892,0,-87.77540235249609],\"scale\":1.1035454483931937},{\"type\":\"grass\",\"position\":[-10.391674158080322,0,49.41763536639325],\"scale\":0.7087320476489337},{\"type\":\"grass\",\"position\":[51.47088090946645,0,-45.583309995613],\"scale\":0.8891164547087127},{\"type\":\"grass\",\"position\":[7.1443356727414775,0,1.39765503353658],\"scale\":1.055125140762192},{\"type\":\"grass\",\"position\":[-18.15520240457741,0,-66.03125806280259],\"scale\":0.9683745714203633},{\"type\":\"grass\",\"position\":[94.91393137672517,0,17.218303982514733],\"scale\":0.7751602530453905},{\"type\":\"grass\",\"position\":[9.631127418855836,0,139.75317355928829],\"scale\":1.1641465653379446},{\"type\":\"grass\",\"position\":[-57.9917042456565,0,56.90027210467145],\"scale\":0.7858630646865626},{\"type\":\"grass\",\"position\":[-6.63311582802154,0,-10.300419590340184],\"scale\":1.222985539383086},{\"type\":\"grass\",\"position\":[44.021866312151666,0,-97.73184422526617],\"scale\":0.7733629798380424},{\"type\":\"grass\",\"position\":[14.19034123425091,0,-11.331855602425119],\"scale\":0.8724353699813224},{\"type\":\"grass\",\"position\":[-81.34882797601217,0,-60.800782701833086],\"scale\":0.7170445009697258},{\"type\":\"grass\",\"position\":[19.216190884081907,0,-0.859560126818038],\"scale\":0.9585770137827734},{\"type\":\"grass\",\"position\":[116.04004476301938,0,4.965677659160453],\"scale\":1.25988505637158},{\"type\":\"grass\",\"position\":[1.8577052659285889,0,-135.11877599725673],\"scale\":0.7565335654286373},{\"type\":\"grass\",\"position\":[-54.50984843136861,0,-42.21579978455034],\"scale\":1.2538563787453767},{\"type\":\"grass\",\"position\":[-8.5485643074103,0,19.237515343186335],\"scale\":0.8736487255478141},{\"type\":\"grass\",\"position\":[47.05862758394351,0,84.23683613954513],\"scale\":1.1550213112397532},{\"type\":\"grass\",\"position\":[2.383068648974272,0,-25.84658108420793],\"scale\":1.0306599040791682},{\"type\":\"grass\",\"position\":[41.15914892227489,0,73.65763537421658],\"scale\":1.190977291574256},{\"type\":\"grass\",\"position\":[9.24058670759044,0,-3.6253229423396025],\"scale\":0.7076741237455553},{\"type\":\"grass\",\"position\":[-49.02837036802355,0,94.24870219703334],\"scale\":1.141012749025522},{\"type\":\"grass\",\"position\":[109.79989046372813,0,-61.18055967548877],\"scale\":1.0127240140595557},{\"type\":\"grass\",\"position\":[-15.543247529951378,0,2.7975131905518857],\"scale\":1.2619395829499718},{\"type\":\"grass\",\"position\":[-24.020887655423685,0,-42.644452114212115],\"scale\":1.030283959186801},{\"type\":\"grass\",\"position\":[-6.962035154160261,0,-15.10807487811431],\"scale\":1.2224840577126197},{\"type\":\"grass\",\"position\":[-78.5294041356567,0,-38.48329705297473],\"scale\":0.9084531948055514},{\"type\":\"grass\",\"position\":[-72.70305700974195,0,10.860199163120267],\"scale\":1.035334821390877},{\"type\":\"grass\",\"position\":[-10.169030256875796,0,-15.167568175550159],\"scale\":1.2615987205573553},{\"type\":\"grass\",\"position\":[44.06145982991894,0,-72.67843475368191],\"scale\":1.255468377224061},{\"type\":\"grass\",\"position\":[-75.14161465338019,0,46.07604382485425],\"scale\":0.9750596028943754},{\"type\":\"grass\",\"position\":[5.244441194571026,0,-85.69363219365621],\"scale\":0.9340872198038539},{\"type\":\"grass\",\"position\":[46.93915357812697,0,40.70476419560062],\"scale\":0.7402972030283326},{\"type\":\"grass\",\"position\":[9.065822270800004,0,38.04734327224157],\"scale\":0.8658829794260217},{\"type\":\"grass\",\"position\":[16.679199264936166,0,108.79063625147404],\"scale\":1.0591232318163173},{\"type\":\"grass\",\"position\":[-1.9377243900165948,0,-0.0013092543311352606],\"scale\":0.8832861535195549},{\"type\":\"grass\",\"position\":[-35.608570102149976,0,-28.370399697056424],\"scale\":0.8834247147672728},{\"type\":\"grass\",\"position\":[123.61063518260976,0,8.410348110354741],\"scale\":1.2540166053718185},{\"type\":\"grass\",\"position\":[-6.567585494982088,0,-59.0753454231756],\"scale\":0.9921397569021491},{\"type\":\"grass\",\"position\":[40.25079082847503,0,-69.39973222991647],\"scale\":0.7996588307198867},{\"type\":\"grass\",\"position\":[97.38161569672391,0,-42.340450169539835],\"scale\":1.0999821007716055},{\"type\":\"grass\",\"position\":[-61.60479272209487,0,105.60323524419029],\"scale\":0.9488664819023981},{\"type\":\"grass\",\"position\":[-114.41955953282041,0,-59.34429029655566],\"scale\":0.9899553592704984},{\"type\":\"grass\",\"position\":[-18.74495693802513,0,-12.391481364551874],\"scale\":0.8551557005230284},{\"type\":\"grass\",\"position\":[-84.55579811293642,0,58.02071729433486],\"scale\":1.2682949582304546},{\"type\":\"grass\",\"position\":[78.68604319640659,0,41.65616575794203],\"scale\":1.090000219229834},{\"type\":\"grass\",\"position\":[-98.66950720539705,0,60.329144303863906],\"scale\":0.7240832109972088},{\"type\":\"grass\",\"position\":[-57.193611951471404,0,-124.92684281529809],\"scale\":1.09005388320666},{\"type\":\"grass\",\"position\":[-2.05054902386417,0,-58.08672118734426],\"scale\":0.7723504301534633},{\"type\":\"grass\",\"position\":[78.16639901479643,0,40.220989669878215],\"scale\":1.1153635270781308},{\"type\":\"grass\",\"position\":[76.34666055961397,0,-32.38173370306848],\"scale\":1.0171377237794879},{\"type\":\"grass\",\"position\":[-31.280388328743463,0,-35.262785787714954],\"scale\":0.7394910336926739},{\"type\":\"grass\",\"position\":[-55.15257562065207,0,-28.672503685869625],\"scale\":1.0179661082076303},{\"type\":\"grass\",\"position\":[0.7859373499872728,0,21.12027384058715],\"scale\":0.9770213912931247},{\"type\":\"grass\",\"position\":[25.509819823916835,0,86.77903841671923],\"scale\":0.7429360575124265},{\"type\":\"grass\",\"position\":[25.446500490709475,0,-93.58108822815605],\"scale\":1.0755952733250156},{\"type\":\"grass\",\"position\":[15.047180713235191,0,120.84503806710103],\"scale\":0.9353186719467821},{\"type\":\"grass\",\"position\":[70.8540863953091,0,75.87290691034309],\"scale\":1.2416335534348866},{\"type\":\"grass\",\"position\":[39.08933083736304,0,-21.88209646720032],\"scale\":1.1851615801934656},{\"type\":\"grass\",\"position\":[-69.04885299294128,0,3.0659775925423056],\"scale\":1.1251855939959416},{\"type\":\"grass\",\"position\":[128.69613289994427,0,-72.80536145529385],\"scale\":1.059367639435608},{\"type\":\"grass\",\"position\":[82.38592307239746,0,-6.985622517083026],\"scale\":1.2520227275316744},{\"type\":\"grass\",\"position\":[-96.60074848626188,0,29.35920271436708],\"scale\":0.7132321129735406},{\"type\":\"grass\",\"position\":[1.0682689451097833,0,23.905411827954108],\"scale\":0.8331632206654653},{\"type\":\"grass\",\"position\":[107.17696236329449,0,75.6985125174121],\"scale\":0.7399606885217291},{\"type\":\"grass\",\"position\":[-0.8136629620758656,0,0.48594425934946384],\"scale\":1.2179941609754619},{\"type\":\"grass\",\"position\":[7.751264854786195,0,92.8084522942433],\"scale\":1.270018995040979},{\"type\":\"grass\",\"position\":[53.94983778771765,0,-24.3737975914273],\"scale\":0.7010408008439927},{\"type\":\"grass\",\"position\":[48.02971050977042,0,-15.216330341587646],\"scale\":0.8997149673380115},{\"type\":\"grass\",\"position\":[-58.83181051526941,0,16.1086751248707],\"scale\":0.8806325836155806},{\"type\":\"grass\",\"position\":[58.10808408411642,0,-58.83282668766686],\"scale\":0.7990894466701496},{\"type\":\"grass\",\"position\":[-31.33975987455217,0,-37.110791553125324],\"scale\":1.1016985584472412},{\"type\":\"grass\",\"position\":[88.10907348715945,0,109.86790947918959],\"scale\":1.2003985219042543},{\"type\":\"grass\",\"position\":[-137.3925689383962,0,-58.146549692248804],\"scale\":0.9611011645619568},{\"type\":\"grass\",\"position\":[5.63380801178166,0,-1.4797451175992966],\"scale\":1.1722941301071843},{\"type\":\"grass\",\"position\":[-20.74415322352426,0,14.890818884925977],\"scale\":0.9699231077594577},{\"type\":\"grass\",\"position\":[-0.3974360964296764,0,0.6240225755132072],\"scale\":0.815573137898271},{\"type\":\"grass\",\"position\":[65.4405777065554,0,-17.075873910547852],\"scale\":0.8060134828657446},{\"type\":\"grass\",\"position\":[9.18071905815321,0,-12.005964915512934],\"scale\":0.8081141831048523},{\"type\":\"grass\",\"position\":[15.725220993240567,0,-5.996431451388505],\"scale\":0.8556111454825036},{\"type\":\"grass\",\"position\":[-41.56943222280673,0,-3.7109496799386337],\"scale\":0.954410206529489},{\"type\":\"grass\",\"position\":[31.094397800310478,0,-41.740914802133354],\"scale\":1.23386278513996},{\"type\":\"grass\",\"position\":[-2.409904091519797,0,1.160278349208722],\"scale\":1.0930867621303029},{\"type\":\"grass\",\"position\":[-8.700183476376347,0,-81.9483755435166],\"scale\":1.0057992901949866},{\"type\":\"grass\",\"position\":[-67.0076425673603,0,70.41768713081646],\"scale\":1.1694835804049604},{\"type\":\"grass\",\"position\":[15.225323665627183,0,-106.00031551354036],\"scale\":1.1311861532470686},{\"type\":\"grass\",\"position\":[17.638902070180546,0,-44.71829988475759],\"scale\":1.0654467517966113},{\"type\":\"grass\",\"position\":[-101.87101017682477,0,95.46816366996579],\"scale\":1.0765943613481297},{\"type\":\"grass\",\"position\":[69.5910162221618,0,-60.80377352641729],\"scale\":0.838715017534609},{\"type\":\"grass\",\"position\":[-122.81143997806416,0,-6.229512171378202],\"scale\":0.9651070688328494},{\"type\":\"grass\",\"position\":[11.64626850734128,0,14.006209578426216],\"scale\":1.018222174899527},{\"type\":\"grass\",\"position\":[-140.97116120655667,0,-42.151728436484625],\"scale\":1.2973897022707452},{\"type\":\"grass\",\"position\":[50.14833215488168,0,104.81548718331634],\"scale\":1.1189558732006173},{\"type\":\"grass\",\"position\":[34.87303836085293,0,66.0512204473446],\"scale\":0.8320570558960844},{\"type\":\"grass\",\"position\":[1.3607585916123184,0,2.1446584938064635],\"scale\":0.86431223532516},{\"type\":\"grass\",\"position\":[-29.09016502362949,0,-63.40424182149813],\"scale\":0.7890792161607723},{\"type\":\"grass\",\"position\":[91.0686445182689,0,-43.49631811528232],\"scale\":1.1100652283769978},{\"type\":\"grass\",\"position\":[17.176365125460634,0,15.227821243015102],\"scale\":1.093144848596153},{\"type\":\"grass\",\"position\":[-0.4069786334171775,0,-0.02780790070135066],\"scale\":0.8081329669488915},{\"type\":\"grass\",\"position\":[-6.580364830054109,0,8.00962157860822],\"scale\":1.2929336028227523},{\"type\":\"grass\",\"position\":[6.7452817078716345,0,9.07198978084179],\"scale\":1.1298711916735336},{\"type\":\"grass\",\"position\":[-42.50807532540872,0,13.789802086653543],\"scale\":0.9145599484050875},{\"type\":\"grass\",\"position\":[18.497164902962684,0,143.20555121800822],\"scale\":0.8948388722329297},{\"type\":\"grass\",\"position\":[90.38661414085433,0,-80.30771817287435],\"scale\":0.8570889276906387},{\"type\":\"grass\",\"position\":[-7.839455860241051,0,-2.723279166448779],\"scale\":1.0020298337482738},{\"type\":\"grass\",\"position\":[-56.39993515089125,0,-17.36517186608823],\"scale\":1.0706784575325752},{\"type\":\"grass\",\"position\":[25.091604655910764,0,48.46121330604249],\"scale\":1.1325425845766857},{\"type\":\"grass\",\"position\":[105.97837535007011,0,-34.169847557844385],\"scale\":0.7237965024699873},{\"type\":\"grass\",\"position\":[-6.282473338296569,0,119.28192570323553],\"scale\":0.8933680912084185},{\"type\":\"grass\",\"position\":[-24.098428517409445,0,38.034027264537166],\"scale\":0.9729586999982318},{\"type\":\"grass\",\"position\":[-18.24184583814216,0,90.93312037797003],\"scale\":0.8589563739287117},{\"type\":\"grass\",\"position\":[6.003310719046306,0,10.82067496228003],\"scale\":1.065276808012681},{\"type\":\"grass\",\"position\":[30.273250898926193,0,-46.7613305583494],\"scale\":0.810154861960219},{\"type\":\"grass\",\"position\":[65.0734850218665,0,-44.35938100918231],\"scale\":0.9808974886351444},{\"type\":\"grass\",\"position\":[-57.776629133209774,0,-59.1013069543339],\"scale\":1.0565289361650656},{\"type\":\"grass\",\"position\":[-54.77546443461765,0,-85.1235586750897],\"scale\":0.9803256311268111},{\"type\":\"grass\",\"position\":[71.14419996679841,0,-111.02386846437231],\"scale\":0.940199070770418},{\"type\":\"grass\",\"position\":[-16.21732597353987,0,-5.117037153449362],\"scale\":1.1865427616987647},{\"type\":\"grass\",\"position\":[51.37380243339804,0,38.46433985327654],\"scale\":1.0642163782135612},{\"type\":\"grass\",\"position\":[-27.840871822751016,0,55.316439114196704],\"scale\":0.8840909077750299},{\"type\":\"grass\",\"position\":[51.35075618284242,0,4.617769051579994],\"scale\":1.1879038588760427},{\"type\":\"grass\",\"position\":[23.160642049735603,0,127.08909252253828],\"scale\":0.8387048869326431},{\"type\":\"grass\",\"position\":[-17.064837623747593,0,30.44580309270339],\"scale\":1.0382376088939835},{\"type\":\"grass\",\"position\":[1.198575725814814,0,-34.01489025590651],\"scale\":1.112788409982267},{\"type\":\"grass\",\"position\":[86.36660157891608,0,100.95312975192317],\"scale\":0.9948075690257008},{\"type\":\"grass\",\"position\":[-14.519939761071528,0,99.76357618715141],\"scale\":0.7029864227914857},{\"type\":\"grass\",\"position\":[6.028335928733958,0,-0.6535365855975973],\"scale\":0.9617871390824853},{\"type\":\"grass\",\"position\":[-90.33560980777797,0,75.09524797353748],\"scale\":1.016758875481067},{\"type\":\"grass\",\"position\":[-8.475538024289252,0,-3.062146821488324],\"scale\":1.1537896591354264},{\"type\":\"grass\",\"position\":[-93.59150804158162,0,-70.40883659893022],\"scale\":0.7435715257634453},{\"type\":\"grass\",\"position\":[-30.947510203756305,0,90.54355889537919],\"scale\":0.7495102337433456},{\"type\":\"grass\",\"position\":[-48.54245173601844,0,-26.31639765198794],\"scale\":1.1099439106683329},{\"type\":\"grass\",\"position\":[-91.07222366375264,0,84.16710113545197],\"scale\":0.7882000417411346},{\"type\":\"grass\",\"position\":[-91.82411505269648,0,-45.56341381935469],\"scale\":1.2348747221987653},{\"type\":\"grass\",\"position\":[-14.022366410419057,0,-38.16399361125054],\"scale\":1.2481825042503487},{\"type\":\"grass\",\"position\":[94.05827526803847,0,-86.63459386284458],\"scale\":1.0429621975056755},{\"type\":\"grass\",\"position\":[-70.65975708919609,0,16.795002164755005],\"scale\":0.7221983962212161},{\"type\":\"grass\",\"position\":[58.034789497687655,0,-89.4645340203976],\"scale\":0.7038209300502147},{\"type\":\"grass\",\"position\":[-11.847303401683906,0,-8.872809392679839],\"scale\":1.2929216985957144},{\"type\":\"grass\",\"position\":[-54.640859151424515,0,1.6994368666803321],\"scale\":0.9453359002626344},{\"type\":\"grass\",\"position\":[11.653450712290356,0,-0.9982458573298677],\"scale\":0.7995547639361569},{\"type\":\"grass\",\"position\":[122.38420824419325,0,64.84477052713045],\"scale\":1.1504350949212137},{\"type\":\"grass\",\"position\":[35.394931914592576,0,119.10362711289204],\"scale\":1.090824598942139},{\"type\":\"grass\",\"position\":[48.53619947599116,0,-26.303113294720145],\"scale\":1.0835589632858154},{\"type\":\"grass\",\"position\":[25.70846380564226,0,65.54683038873972],\"scale\":1.2513180208658938},{\"type\":\"grass\",\"position\":[-14.586960874456757,0,68.90524181113592],\"scale\":1.113333586233861},{\"type\":\"grass\",\"position\":[14.90844709024849,0,-143.5748313918324],\"scale\":1.0857600117102049},{\"type\":\"grass\",\"position\":[18.711089663898804,0,-82.15018458947519],\"scale\":0.8747349216270467},{\"type\":\"grass\",\"position\":[7.901414666863748,0,35.82349475733974],\"scale\":1.0574404622400495},{\"type\":\"grass\",\"position\":[4.514410932485721,0,-24.9857461611066],\"scale\":1.2895803620482713},{\"type\":\"grass\",\"position\":[6.701761212062467,0,0.2604887528533361],\"scale\":1.135821349001639},{\"type\":\"grass\",\"position\":[67.75188972715647,0,-29.536916979721475],\"scale\":0.90057982183026},{\"type\":\"grass\",\"position\":[124.45346778925946,0,-41.278136724747995],\"scale\":1.0420269303707363},{\"type\":\"grass\",\"position\":[36.48220011076591,0,-50.752963698576686],\"scale\":1.1835721822903627},{\"type\":\"grass\",\"position\":[9.99592071093126,0,-67.07059395503266],\"scale\":1.0277121652792442},{\"type\":\"grass\",\"position\":[42.23324759522411,0,-113.13053082238186],\"scale\":0.8437002973646691},{\"type\":\"grass\",\"position\":[-35.42484676274921,0,14.144604308834316],\"scale\":1.0879626598806504},{\"type\":\"grass\",\"position\":[5.05356378129044,0,-22.283451731152066],\"scale\":0.8536369035103399},{\"type\":\"grass\",\"position\":[-64.1510129070739,0,-15.751959415801055],\"scale\":1.2642919964354713},{\"type\":\"grass\",\"position\":[-15.668350031030702,0,0.9701783366295335],\"scale\":0.857818013807111},{\"type\":\"grass\",\"position\":[16.405825559033204,0,36.800451129846444],\"scale\":0.9889746568655684},{\"type\":\"grass\",\"position\":[-0.5045338384480276,0,-9.727931962743734],\"scale\":0.9274710242021023},{\"type\":\"grass\",\"position\":[3.604756467925082,0,11.680600805821824],\"scale\":1.1275626945494934},{\"type\":\"grass\",\"position\":[85.87945374846427,0,-61.606355309921476],\"scale\":0.9616642994575726},{\"type\":\"grass\",\"position\":[-39.16926261079487,0,11.792399077405161],\"scale\":1.1233002096201568},{\"type\":\"grass\",\"position\":[98.8475338463596,0,107.39715355572292],\"scale\":1.1625502472424953},{\"type\":\"grass\",\"position\":[-0.7728045132778932,0,-1.5101871442179944],\"scale\":0.720024598268681},{\"type\":\"grass\",\"position\":[-18.516090649121686,0,79.04997412517632],\"scale\":0.868719301454087},{\"type\":\"grass\",\"position\":[-37.61278510199167,0,17.22399043372635],\"scale\":0.8846437111001378},{\"type\":\"grass\",\"position\":[-22.157529742444694,0,36.583845364216536],\"scale\":1.247398321669839},{\"type\":\"grass\",\"position\":[61.54014683000239,0,-134.35219211253855],\"scale\":1.1577612531157695},{\"type\":\"grass\",\"position\":[134.34384350544346,0,24.803803484679964],\"scale\":0.9581626315404657},{\"type\":\"grass\",\"position\":[-47.99216780140546,0,-123.15308688122475],\"scale\":1.1363180547211438},{\"type\":\"grass\",\"position\":[25.00624084130385,0,-16.640132165372044],\"scale\":0.8747245892294828},{\"type\":\"grass\",\"position\":[9.16756991749629,0,-31.521945317225818],\"scale\":0.9517520212084092},{\"type\":\"grass\",\"position\":[-31.304701935249707,0,-79.70957952168084],\"scale\":1.1928815784223694},{\"type\":\"grass\",\"position\":[-44.08500513327364,0,-136.19255143351046],\"scale\":0.9093503258473058},{\"type\":\"grass\",\"position\":[96.66132524396245,0,-8.02394040715591],\"scale\":1.244241306114279},{\"type\":\"grass\",\"position\":[-129.2425903621467,0,-56.99400755841483],\"scale\":1.1274311160045465},{\"type\":\"grass\",\"position\":[52.07297485096703,0,-94.52419448788399],\"scale\":1.0684105936563368},{\"type\":\"grass\",\"position\":[72.83086251531905,0,12.117566153679622],\"scale\":1.2289781768549877},{\"type\":\"grass\",\"position\":[51.922356418553235,0,55.129669699766495],\"scale\":0.804035277246051},{\"type\":\"grass\",\"position\":[-11.018131263689433,0,87.11945720031946],\"scale\":0.7096655968703277},{\"type\":\"grass\",\"position\":[-2.161402986950756,0,42.408563449807275],\"scale\":1.0743185268808575},{\"type\":\"grass\",\"position\":[59.73062340914829,0,-17.064472817932735],\"scale\":0.9142216154896643},{\"type\":\"grass\",\"position\":[140.08123359636465,0,6.833105683927033],\"scale\":1.0744864627799806},{\"type\":\"grass\",\"position\":[127.75534752803293,0,-5.372586069149358],\"scale\":0.986516476553644},{\"type\":\"grass\",\"position\":[5.919120328161377,0,-8.290422871262907],\"scale\":0.8713002418524016},{\"type\":\"grass\",\"position\":[15.068193548770925,0,-82.16377880068352],\"scale\":1.0593670306146818},{\"type\":\"grass\",\"position\":[4.704985030073022,0,-19.7134619491203],\"scale\":0.8073033995849611},{\"type\":\"grass\",\"position\":[99.20870168017892,0,30.879965948358812],\"scale\":0.7039741626171784},{\"type\":\"grass\",\"position\":[-7.763499197561444,0,-11.378550799177187],\"scale\":1.0284161674367287},{\"type\":\"grass\",\"position\":[44.72944368418862,0,-103.22675755752095],\"scale\":0.8983020592037614},{\"type\":\"grass\",\"position\":[-48.43874522969494,0,-79.91213625063214],\"scale\":0.9568551353631789},{\"type\":\"grass\",\"position\":[-18.433752588225033,0,8.467529798104987],\"scale\":0.7983468624632151},{\"type\":\"grass\",\"position\":[-3.340028341488979,0,-96.36955622655383],\"scale\":1.0069571877145478},{\"type\":\"grass\",\"position\":[-27.237648547127858,0,-96.07904236586016],\"scale\":0.787757484404811},{\"type\":\"grass\",\"position\":[71.88341061988957,0,69.66005400562338],\"scale\":1.0066569369975613},{\"type\":\"grass\",\"position\":[-18.004853415504165,0,106.27870156033993],\"scale\":0.855286878752551},{\"type\":\"grass\",\"position\":[-59.534465660912694,0,133.79114004583897],\"scale\":0.801901348768214},{\"type\":\"grass\",\"position\":[-50.341950002657626,0,-6.852716725818871],\"scale\":0.7425579651549302},{\"type\":\"grass\",\"position\":[-61.81516075757984,0,40.24899429768175],\"scale\":1.1401901009030815},{\"type\":\"grass\",\"position\":[70.72606051356729,0,-24.971053993328297],\"scale\":0.7407562200615958},{\"type\":\"grass\",\"position\":[28.242964104081178,0,26.37390021044347],\"scale\":1.0836701563345514},{\"type\":\"grass\",\"position\":[21.673750510081458,0,-29.010505787263448],\"scale\":1.1792957901762127},{\"type\":\"grass\",\"position\":[17.956950078117295,0,-36.21942037562747],\"scale\":0.7972946438842075},{\"type\":\"grass\",\"position\":[8.965438416693356,0,116.77200111877144],\"scale\":1.1236378352781775},{\"type\":\"grass\",\"position\":[-66.61567062946615,0,-50.79255280039209],\"scale\":1.0275877559472555},{\"type\":\"grass\",\"position\":[95.22480251489179,0,-24.329854022893603],\"scale\":0.9577627921801845},{\"type\":\"grass\",\"position\":[82.62381688445247,0,-3.4134696610536173],\"scale\":1.209208972473446},{\"type\":\"grass\",\"position\":[-7.821566824816974,0,5.654055764936398],\"scale\":0.951588422877423},{\"type\":\"grass\",\"position\":[14.598541555223488,0,-68.36901475392132],\"scale\":0.9471754215967676},{\"type\":\"grass\",\"position\":[-69.06797742837927,0,81.01773114086703],\"scale\":0.7140362729324742},{\"type\":\"grass\",\"position\":[-26.384487045458567,0,17.850557766355998],\"scale\":1.188372118846253},{\"type\":\"grass\",\"position\":[-74.8262868764344,0,124.7026526906876],\"scale\":1.2830309078785387},{\"type\":\"grass\",\"position\":[34.88926426084372,0,-48.47914326829756],\"scale\":0.9164047341098482},{\"type\":\"grass\",\"position\":[110.82219788459174,0,-46.23975322137957],\"scale\":1.0346264936968819},{\"type\":\"grass\",\"position\":[-16.172461753227452,0,19.496078489111987],\"scale\":1.0711857612742512},{\"type\":\"grass\",\"position\":[-34.29159258685557,0,79.2739278172165],\"scale\":1.0031416444713344},{\"type\":\"grass\",\"position\":[-43.304379857264955,0,-4.752644170877539],\"scale\":0.7889336213669732},{\"type\":\"grass\",\"position\":[-113.91122465554986,0,24.788379272839446],\"scale\":0.8728102187678909},{\"type\":\"grass\",\"position\":[2.795263063942763,0,-41.176034566548736],\"scale\":0.7415583874247953},{\"type\":\"grass\",\"position\":[-70.67606755096011,0,110.66705692009718],\"scale\":0.7484009162617795},{\"type\":\"grass\",\"position\":[-103.54287071220504,0,-20.096073962101844],\"scale\":0.9629375565473857},{\"type\":\"grass\",\"position\":[-40.356681294397504,0,-121.75118753539707],\"scale\":1.1342730318226344},{\"type\":\"grass\",\"position\":[-147.90898136540972,0,7.5086319364696745],\"scale\":0.9400972700497975},{\"type\":\"grass\",\"position\":[101.78082737658318,0,-26.639749179236006],\"scale\":1.2824743587420042},{\"type\":\"grass\",\"position\":[37.32722883792908,0,4.208575698874107],\"scale\":0.9492220175431347},{\"type\":\"grass\",\"position\":[-140.00231351475705,0,32.84679193859335],\"scale\":1.1849178563188552},{\"type\":\"grass\",\"position\":[45.305619035048124,0,-11.769325619574968],\"scale\":1.216213505976588},{\"type\":\"grass\",\"position\":[14.550006013116585,0,-144.46281744300293],\"scale\":0.8007006318233988},{\"type\":\"grass\",\"position\":[-46.18033536863823,0,-4.609755662908014],\"scale\":0.9517709433484332},{\"type\":\"grass\",\"position\":[77.04788053475282,0,38.05905002548253],\"scale\":1.1633736317673242},{\"type\":\"grass\",\"position\":[-88.72079435556337,0,-75.66112456615554],\"scale\":0.8717778112756895},{\"type\":\"grass\",\"position\":[-50.795690771491635,0,42.85658810372942],\"scale\":1.257630215768578},{\"type\":\"grass\",\"position\":[-8.496396293342041,0,56.68740656498896],\"scale\":1.2399824062185467},{\"type\":\"grass\",\"position\":[-107.22554867831917,0,36.73022943813415],\"scale\":0.9806308074495759},{\"type\":\"grass\",\"position\":[-1.8639412198868817,0,-3.117658167084664],\"scale\":0.9959941691129471},{\"type\":\"grass\",\"position\":[-54.4946821762692,0,-78.2281879919587],\"scale\":1.0195892145417513},{\"type\":\"grass\",\"position\":[43.100641700442,0,-28.94306765842992],\"scale\":0.7500864853334678},{\"type\":\"grass\",\"position\":[-23.939617879559584,0,-134.4372869562551],\"scale\":0.8460717468869177},{\"type\":\"grass\",\"position\":[-111.7037911028788,0,-63.34818920743742],\"scale\":1.1447750318903789},{\"type\":\"grass\",\"position\":[-12.891116071006596,0,-1.790987585770908],\"scale\":0.7428951921830486},{\"type\":\"grass\",\"position\":[88.4207778897569,0,-18.01604110406944],\"scale\":0.7563717577100642},{\"type\":\"grass\",\"position\":[43.43755565816263,0,-89.90780670376229],\"scale\":0.8395733129624817},{\"type\":\"grass\",\"position\":[133.68613885818704,0,15.848926970399038],\"scale\":0.844530765957351},{\"type\":\"grass\",\"position\":[-0.3510919001707332,0,3.4809057789474176],\"scale\":0.7514910911432083},{\"type\":\"grass\",\"position\":[-7.282665263157427,0,5.144533875284409],\"scale\":0.9618340725635455},{\"type\":\"grass\",\"position\":[-9.255958440116308,0,53.8392927912602],\"scale\":0.9617756596794126},{\"type\":\"grass\",\"position\":[110.28335481323366,0,-1.0805479951851957],\"scale\":1.0961294192122448},{\"type\":\"grass\",\"position\":[23.490982339200833,0,13.751763451442711],\"scale\":0.9799004565576488},{\"type\":\"grass\",\"position\":[6.35022005766276,0,-0.9788547125232702],\"scale\":0.7178763323709967},{\"type\":\"grass\",\"position\":[-0.4638663784309838,0,19.02874294594193],\"scale\":0.7817317639846038},{\"type\":\"grass\",\"position\":[-1.236403177899661,0,-14.254727172604174],\"scale\":1.1864046442656182},{\"type\":\"grass\",\"position\":[-6.868971523439589,0,-5.715475404126642],\"scale\":1.0406872627202715},{\"type\":\"grass\",\"position\":[-42.97058710660232,0,11.1432346060702],\"scale\":1.2789737850234215},{\"type\":\"grass\",\"position\":[-58.003734609616075,0,75.27796681588016],\"scale\":1.2083914356396903},{\"type\":\"grass\",\"position\":[48.171511577908305,0,66.55276555913262],\"scale\":1.2063430787019471},{\"type\":\"grass\",\"position\":[-111.67588578671992,0,80.8373938808278],\"scale\":1.2861695622905849},{\"type\":\"grass\",\"position\":[-48.86890023459287,0,-39.81415116829419],\"scale\":0.8257930959241202},{\"type\":\"grass\",\"position\":[83.40040860293979,0,76.00730916938232],\"scale\":0.8384404090609755},{\"type\":\"grass\",\"position\":[-109.67232695953157,0,-9.977024500533693],\"scale\":0.939479159655972},{\"type\":\"grass\",\"position\":[70.85754761953342,0,-16.3574787057085],\"scale\":0.7441433687473306},{\"type\":\"grass\",\"position\":[-73.61208335716218,0,-20.877852063306747],\"scale\":0.7532656221710512},{\"type\":\"grass\",\"position\":[31.43222211222101,0,-56.54304223307588],\"scale\":0.7661235868562941},{\"type\":\"grass\",\"position\":[112.13848727586593,0,-64.44615550850376],\"scale\":1.0934845922113827},{\"type\":\"grass\",\"position\":[-121.30538437317541,0,-4.042567732138331],\"scale\":0.9353710056504518},{\"type\":\"grass\",\"position\":[38.64225165414593,0,-1.2957855040496606],\"scale\":0.8753381014701082},{\"type\":\"grass\",\"position\":[9.475776870023443,0,-3.6320696623336004],\"scale\":1.0602791399469482},{\"type\":\"grass\",\"position\":[-76.4259045350865,0,59.527583530064184],\"scale\":1.1053048222249948},{\"type\":\"grass\",\"position\":[129.30749222010894,0,-19.27669791409992],\"scale\":0.7441999410059297},{\"type\":\"grass\",\"position\":[28.804823316174154,0,-48.349370330222264],\"scale\":0.9177867837642124},{\"type\":\"grass\",\"position\":[-16.470068939708902,0,-97.43346078566826],\"scale\":0.9913549330002528},{\"type\":\"grass\",\"position\":[43.15270032655923,0,-42.35722501370725],\"scale\":0.7818781928120024},{\"type\":\"grass\",\"position\":[-40.625553761667945,0,70.84915227825557],\"scale\":0.8453682629581003},{\"type\":\"grass\",\"position\":[-112.27841513972135,0,-64.74057953366857],\"scale\":0.8902964992625144},{\"type\":\"grass\",\"position\":[-122.67033371758293,0,-80.1735536838808],\"scale\":0.8561424044814783},{\"type\":\"grass\",\"position\":[38.51954941521348,0,-128.48465749622412],\"scale\":0.8806573281994166},{\"type\":\"grass\",\"position\":[13.586587674577832,0,9.995432793713505],\"scale\":0.8801933398957993},{\"type\":\"grass\",\"position\":[33.851772867058315,0,-120.29094014595948],\"scale\":0.8803508727813432},{\"type\":\"grass\",\"position\":[128.50445046658461,0,23.938624197737056],\"scale\":0.7121083665467042},{\"type\":\"grass\",\"position\":[25.452523657846854,0,-70.58561867278151],\"scale\":1.1472237587847527},{\"type\":\"grass\",\"position\":[-129.9633876403626,0,26.589492384524558],\"scale\":1.258095496449037},{\"type\":\"grass\",\"position\":[-17.320898825657846,0,3.685293087166663],\"scale\":1.0327003824195229},{\"type\":\"grass\",\"position\":[83.0266714373688,0,-108.19440376612887],\"scale\":1.0131575753689068},{\"type\":\"grass\",\"position\":[86.54024284781444,0,-93.80413526174297],\"scale\":1.2741420198676134},{\"type\":\"grass\",\"position\":[31.419672075314566,0,-34.875014457757096],\"scale\":0.9133852767255946},{\"type\":\"grass\",\"position\":[-49.29460460313278,0,-33.19995389062773],\"scale\":0.7027868868716011},{\"type\":\"grass\",\"position\":[0.016035483056091513,0,-7.4601922706466235],\"scale\":1.2996130437578162},{\"type\":\"grass\",\"position\":[-137.54772390260203,0,38.5854963343394],\"scale\":0.8790492546340696},{\"type\":\"grass\",\"position\":[-11.66783996977345,0,107.53025302405088],\"scale\":0.8320219350104913},{\"type\":\"grass\",\"position\":[-73.42285161688582,0,-22.90045965556703],\"scale\":1.2255428486911846},{\"type\":\"grass\",\"position\":[-110.77845956446677,0,-54.86255041807176],\"scale\":1.2320946018476568},{\"type\":\"grass\",\"position\":[96.08491122710181,0,-54.62701255176287],\"scale\":0.7094800785390114},{\"type\":\"grass\",\"position\":[-34.365212459384544,0,0.5738979535110202],\"scale\":1.033289904373957},{\"type\":\"grass\",\"position\":[60.42702621098398,0,46.018977748222056],\"scale\":0.7005372886912904},{\"type\":\"grass\",\"position\":[-19.78067565423524,0,146.25151255800262],\"scale\":1.100653225380825},{\"type\":\"grass\",\"position\":[-18.68606719967356,0,-19.28344596610226],\"scale\":1.2549497357163917},{\"type\":\"grass\",\"position\":[-3.069952825241366,0,20.7475904808739],\"scale\":1.2908491768034043},{\"type\":\"grass\",\"position\":[-21.523485230319125,0,-102.48351407787125],\"scale\":1.103109728126228},{\"type\":\"grass\",\"position\":[22.617718201542623,0,-77.77510875409602],\"scale\":1.0850692983561996},{\"type\":\"grass\",\"position\":[68.7294463859652,0,0.23400710950148865],\"scale\":1.1922338646610056},{\"type\":\"grass\",\"position\":[-14.051181243457332,0,107.43982266357962],\"scale\":0.8110287811327594},{\"type\":\"grass\",\"position\":[11.290728341784298,0,77.00609922742521],\"scale\":0.9253668813298664},{\"type\":\"grass\",\"position\":[140.37576439394553,0,-31.55955268306266],\"scale\":0.9518647305208323},{\"type\":\"grass\",\"position\":[12.621850080444558,0,11.343324499573916],\"scale\":1.281275385292676},{\"type\":\"grass\",\"position\":[-9.360877327472377,0,8.157018751788703],\"scale\":1.2060894016613137},{\"type\":\"grass\",\"position\":[5.10679171133509,0,-7.2985800725641905],\"scale\":1.2606130377153781},{\"type\":\"grass\",\"position\":[15.617851531277195,0,2.7655371756936593],\"scale\":0.814035454391159},{\"type\":\"grass\",\"position\":[55.04909299224895,0,-72.55210238290145],\"scale\":0.7434785245423413},{\"type\":\"grass\",\"position\":[143.50469103958625,0,-27.972338128335974],\"scale\":1.2919088736135764},{\"type\":\"grass\",\"position\":[38.87551438876658,0,-133.76988369242747],\"scale\":1.162323069490943},{\"type\":\"grass\",\"position\":[57.131586773533016,0,-51.36013675538255],\"scale\":0.8528816000411117},{\"type\":\"grass\",\"position\":[1.2758021581197416,0,127.36966178860627],\"scale\":1.0330442478067985},{\"type\":\"grass\",\"position\":[-118.55505788410383,0,84.83704837932004],\"scale\":0.8920585513165412},{\"type\":\"grass\",\"position\":[-71.04671145035387,0,31.413426691656937],\"scale\":1.1751107759277206},{\"type\":\"grass\",\"position\":[-14.335814618657409,0,-6.120529554137224],\"scale\":1.1830957428173028},{\"type\":\"grass\",\"position\":[-38.618194950395726,0,-60.6623110589045],\"scale\":1.1735152050844626},{\"type\":\"grass\",\"position\":[59.59428121822298,0,-21.184569361955575],\"scale\":0.7028988377166786},{\"type\":\"grass\",\"position\":[19.736315076861626,0,-53.57280411920129],\"scale\":1.1351659768066833},{\"type\":\"grass\",\"position\":[78.51350337727028,0,64.08488015193116],\"scale\":1.1575224287743753},{\"type\":\"grass\",\"position\":[-4.735641822935065,0,-42.50426601191744],\"scale\":0.7899686924420134},{\"type\":\"grass\",\"position\":[59.75229175449355,0,-104.05122039745132],\"scale\":1.1577025378033818},{\"type\":\"grass\",\"position\":[-19.476580824360127,0,-85.01166715864548],\"scale\":1.1137725431045202},{\"type\":\"grass\",\"position\":[5.774109149105527,0,11.60221152572129],\"scale\":0.979240532401668},{\"type\":\"grass\",\"position\":[115.31610662867273,0,73.62865199521752],\"scale\":0.8950385772967173},{\"type\":\"grass\",\"position\":[-20.821596083619816,0,62.85363141477251],\"scale\":1.1489510699986991},{\"type\":\"grass\",\"position\":[-19.53146689104424,0,31.546341250306043],\"scale\":0.9095796062574959},{\"type\":\"grass\",\"position\":[-15.273899808355981,0,-1.9294043370140612],\"scale\":0.7761565510354886},{\"type\":\"grass\",\"position\":[14.75784443327525,0,-79.86688444929715],\"scale\":0.8148074059172025},{\"type\":\"grass\",\"position\":[-4.292401105673723,0,-14.865533222279335],\"scale\":1.0342047581221832},{\"type\":\"grass\",\"position\":[-112.10738779452178,0,16.337946628439003],\"scale\":1.0748343612879085},{\"type\":\"grass\",\"position\":[4.299374264325765,0,-4.463365378375398],\"scale\":0.7269656409565727},{\"type\":\"grass\",\"position\":[-23.93331215065501,0,101.48644105817232],\"scale\":0.9474593924367066},{\"type\":\"grass\",\"position\":[11.80507268748806,0,-8.06977236701984],\"scale\":1.0931036518378638},{\"type\":\"grass\",\"position\":[48.427467372247584,0,-30.892015478998832],\"scale\":1.2373731552631435},{\"type\":\"grass\",\"position\":[-20.694254499390663,0,-4.197377826391169],\"scale\":0.9805899972795797},{\"type\":\"grass\",\"position\":[53.882221689139364,0,4.1886907500467965],\"scale\":0.8408230648980799},{\"type\":\"grass\",\"position\":[100.02801630639317,0,-4.479924917102234],\"scale\":1.127305593272201},{\"type\":\"grass\",\"position\":[59.488749864530966,0,-73.22123744880727],\"scale\":1.1540975636933584},{\"type\":\"grass\",\"position\":[24.39756832683782,0,-124.94008432418555],\"scale\":0.8603393395357646},{\"type\":\"grass\",\"position\":[16.84145022304571,0,39.666176558481986],\"scale\":1.1640797063223762},{\"type\":\"grass\",\"position\":[-61.02653376217197,0,-69.82395241844199],\"scale\":0.7170484844683703},{\"type\":\"grass\",\"position\":[46.56554560409443,0,60.79657927135335],\"scale\":0.7155380986650882},{\"type\":\"grass\",\"position\":[146.6601619484394,0,30.403123826830655],\"scale\":1.1552998566250419},{\"type\":\"grass\",\"position\":[24.453853995281563,0,-5.790346072281672],\"scale\":1.1652625914164825},{\"type\":\"grass\",\"position\":[-91.65161390149817,0,-38.97393929999366],\"scale\":0.786972501573048},{\"type\":\"grass\",\"position\":[-90.78675017942732,0,19.15384468800347],\"scale\":1.0672452201087603},{\"type\":\"grass\",\"position\":[13.951111715518758,0,9.405765230446445],\"scale\":0.8306796907957373},{\"type\":\"grass\",\"position\":[-70.02970190283884,0,-89.75080729137734],\"scale\":0.8145896050454938},{\"type\":\"grass\",\"position\":[18.749851246613094,0,142.87298924589876],\"scale\":0.8311322093219778},{\"type\":\"grass\",\"position\":[106.08718328380762,0,56.780032326782674],\"scale\":0.9835645986885877},{\"type\":\"grass\",\"position\":[53.69958948133692,0,83.27949306972272],\"scale\":1.2362581684709628},{\"type\":\"grass\",\"position\":[4.823318292977849,0,39.54917376806199],\"scale\":1.0029576416420263},{\"type\":\"grass\",\"position\":[-8.794702665208742,0,39.77100189939801],\"scale\":1.0807632051484861},{\"type\":\"grass\",\"position\":[63.72955124419236,0,134.6514978551339],\"scale\":0.8732535463696562},{\"type\":\"grass\",\"position\":[14.09723772979178,0,21.109303487643665],\"scale\":0.7596950380093958},{\"type\":\"grass\",\"position\":[-84.69391442854027,0,7.195540906349817],\"scale\":0.7707843716226092},{\"type\":\"grass\",\"position\":[-32.71124536950327,0,-17.278881832115896],\"scale\":1.0216237594939963},{\"type\":\"grass\",\"position\":[-85.83214384639501,0,82.85378109221594],\"scale\":0.8658324070953266},{\"type\":\"grass\",\"position\":[61.52916195232356,0,-118.08359032285018],\"scale\":0.8850584842236466},{\"type\":\"grass\",\"position\":[-110.6949344036769,0,22.375228584261627],\"scale\":1.27498368037132},{\"type\":\"grass\",\"position\":[-35.605179635318294,0,67.06379702481341],\"scale\":0.9227478488543801},{\"type\":\"grass\",\"position\":[-34.96878384681471,0,-45.209044156225445],\"scale\":0.8050742619302903},{\"type\":\"grass\",\"position\":[54.106561727759455,0,74.4970051982703],\"scale\":1.1283013789368412},{\"type\":\"grass\",\"position\":[-39.38744412328705,0,-126.87283312208729],\"scale\":0.7304051933991812},{\"type\":\"grass\",\"position\":[38.367303308225075,0,31.3804782112814],\"scale\":0.9424606777511657},{\"type\":\"grass\",\"position\":[24.974167912511735,0,28.827577580336758],\"scale\":1.2352972428703333},{\"type\":\"grass\",\"position\":[29.995878379836594,0,-19.347021531241523],\"scale\":0.9737472361077433},{\"type\":\"grass\",\"position\":[-118.34685999447079,0,54.56472675047309],\"scale\":0.8223247591386381},{\"type\":\"grass\",\"position\":[-65.93181685903225,0,-89.27373513921827],\"scale\":1.2277564079561796},{\"type\":\"grass\",\"position\":[50.941782104137886,0,-52.81179894320129],\"scale\":1.0204106205898267},{\"type\":\"grass\",\"position\":[-49.441008914617726,0,-63.73023653535843],\"scale\":1.0822191817527533},{\"type\":\"grass\",\"position\":[-75.11807834793258,0,-29.822796307335732],\"scale\":0.8251896372276046},{\"type\":\"grass\",\"position\":[0.7441133144090243,0,8.28729736308489],\"scale\":0.8287859791275807},{\"type\":\"grass\",\"position\":[59.89472423639534,0,-24.392851893713093],\"scale\":0.9271729648530926},{\"type\":\"grass\",\"position\":[1.371960957436313,0,-11.122086397313685],\"scale\":1.2940669175905226},{\"type\":\"grass\",\"position\":[13.706174895824711,0,77.57154793242843],\"scale\":0.7780454033371914},{\"type\":\"grass\",\"position\":[41.84685172172019,0,50.43852428457031],\"scale\":1.0780731867125013},{\"type\":\"grass\",\"position\":[-53.983451031639966,0,1.5016767358025482],\"scale\":0.9704828645148059},{\"type\":\"grass\",\"position\":[-27.183133157134268,0,-142.29126963845928],\"scale\":1.213668651362669},{\"type\":\"grass\",\"position\":[-54.99575654216372,0,72.55217035300724],\"scale\":0.8952146994939183},{\"type\":\"grass\",\"position\":[34.55630040738376,0,1.4288334892652894],\"scale\":0.8738098215591059},{\"type\":\"grass\",\"position\":[-41.97614971402152,0,-109.92353015545743],\"scale\":0.9236701237970768},{\"type\":\"grass\",\"position\":[12.200610127382186,0,-5.030014008323234],\"scale\":0.89798373812659},{\"type\":\"grass\",\"position\":[-33.83997745917257,0,12.206616906990828],\"scale\":0.9473035856683244},{\"type\":\"grass\",\"position\":[7.70349525181538,0,30.76513818027427],\"scale\":1.2938808442650112},{\"type\":\"grass\",\"position\":[-58.251621887987376,0,-0.9841381088054022],\"scale\":1.2832820947559107},{\"type\":\"grass\",\"position\":[-50.686916616444336,0,11.167708609724592],\"scale\":0.7022779775670133},{\"type\":\"grass\",\"position\":[24.965796195029174,0,-9.8296350713594],\"scale\":1.2878326390790675},{\"type\":\"grass\",\"position\":[-11.19002485758024,0,22.770181879049264],\"scale\":0.9109572880399108},{\"type\":\"grass\",\"position\":[121.67601380468966,0,-40.74672668128108],\"scale\":0.9327560436326592},{\"type\":\"grass\",\"position\":[-28.173099185726546,0,72.11380929758096],\"scale\":0.8368174442502748},{\"type\":\"grass\",\"position\":[-4.042142940215002,0,-0.9627490879032509],\"scale\":0.9164339868564979},{\"type\":\"grass\",\"position\":[-0.5814311862298679,0,-0.6703180853743372],\"scale\":0.7877922366702338},{\"type\":\"grass\",\"position\":[-72.92341260334992,0,-112.24314974795766],\"scale\":0.753002480026342},{\"type\":\"grass\",\"position\":[109.95199243793769,0,93.07419114971202],\"scale\":0.756084801043168},{\"type\":\"grass\",\"position\":[2.2370238280347903,0,-26.15318277457981],\"scale\":1.2212267036646436},{\"type\":\"grass\",\"position\":[-61.810298320167355,0,-87.9793543060548],\"scale\":1.033081115851556},{\"type\":\"grass\",\"position\":[-24.320638749877634,0,21.16172848170957],\"scale\":1.0291111567137663},{\"type\":\"grass\",\"position\":[53.15511005091358,0,-48.775586569413065],\"scale\":1.2118415012540327},{\"type\":\"grass\",\"position\":[-48.754914259994266,0,39.04312069647993],\"scale\":1.0429091285652163},{\"type\":\"grass\",\"position\":[-8.580383306514124,0,6.783444539882013],\"scale\":1.197790554249805},{\"type\":\"grass\",\"position\":[-0.5652223841276662,0,-46.67245608389803],\"scale\":0.8579417181636946},{\"type\":\"grass\",\"position\":[-44.26006627613552,0,-99.47776937188848],\"scale\":0.8273350802735843},{\"type\":\"grass\",\"position\":[130.52050725519587,0,41.870533023102865],\"scale\":1.1742934394665394},{\"type\":\"grass\",\"position\":[-70.52210791362258,0,28.86145379428987],\"scale\":1.0015336414899876},{\"type\":\"grass\",\"position\":[56.82276089408957,0,130.8990900068013],\"scale\":1.0480794163321412},{\"type\":\"grass\",\"position\":[-5.052009801588151,0,-11.840219764737643],\"scale\":0.7419750710641637},{\"type\":\"grass\",\"position\":[-44.76035154656795,0,-32.5088922504676],\"scale\":0.9675992133605926},{\"type\":\"grass\",\"position\":[26.03190985109101,0,19.449646762901722],\"scale\":0.743673125117679},{\"type\":\"grass\",\"position\":[52.715021815415184,0,-75.87284719915358],\"scale\":1.2790661735916737},{\"type\":\"grass\",\"position\":[-29.788026924907587,0,-13.04061841313928],\"scale\":1.2030402113195755},{\"type\":\"grass\",\"position\":[8.073086818093902,0,8.058340513175974],\"scale\":0.7518619399871864},{\"type\":\"grass\",\"position\":[-71.38467981549509,0,112.77118938247777],\"scale\":0.7872889139895001},{\"type\":\"grass\",\"position\":[-37.833290907201565,0,32.79784579426174],\"scale\":0.9295066627036871},{\"type\":\"grass\",\"position\":[-3.454802248709701,0,-21.89797999325453],\"scale\":1.175142087404189},{\"type\":\"grass\",\"position\":[-69.73686331345777,0,-103.54629194962935],\"scale\":1.1071114477264241},{\"type\":\"grass\",\"position\":[-0.023578631203800528,0,0.6587469312918749],\"scale\":0.8439444553448721},{\"type\":\"grass\",\"position\":[-74.58111445735352,0,-123.24354876548891],\"scale\":1.1314090908456922},{\"type\":\"grass\",\"position\":[18.572048490177522,0,-33.51547453409668],\"scale\":1.2712715772184175},{\"type\":\"grass\",\"position\":[-28.66397196950579,0,30.194631867391177],\"scale\":0.7876524532585548},{\"type\":\"grass\",\"position\":[20.92718918693796,0,-123.57139602436956],\"scale\":1.1603657795816285},{\"type\":\"grass\",\"position\":[-17.39356899849261,0,145.21054440263134],\"scale\":1.010067595545857},{\"type\":\"grass\",\"position\":[14.756132878955524,0,-1.018580312903705],\"scale\":1.0283956579239795},{\"type\":\"grass\",\"position\":[26.021235242139237,0,28.13949331191455],\"scale\":0.7180694762179178},{\"type\":\"grass\",\"position\":[4.802789370263348,0,-27.448650557683376],\"scale\":1.226248849431413},{\"type\":\"grass\",\"position\":[-75.56903614947318,0,28.828943717910754],\"scale\":0.9606328138782217},{\"type\":\"grass\",\"position\":[-41.93486176056616,0,102.56931675368041],\"scale\":0.9348954963308521},{\"type\":\"grass\",\"position\":[-12.375292079819104,0,57.422289498444464],\"scale\":0.960379512675416},{\"type\":\"grass\",\"position\":[7.969467578122188,0,-6.748827413049064],\"scale\":1.2157910026045302},{\"type\":\"grass\",\"position\":[-120.54303273282292,0,75.81047787175422],\"scale\":1.2801291009830496},{\"type\":\"grass\",\"position\":[-63.61578706515428,0,-96.99198266894732],\"scale\":0.7844922050638792},{\"type\":\"grass\",\"position\":[-67.3455974704427,0,-54.86355203056728],\"scale\":1.0955732156766989},{\"type\":\"grass\",\"position\":[-62.289896599039686,0,-4.985597759613763],\"scale\":1.2035383782551266},{\"type\":\"grass\",\"position\":[-70.31816135141618,0,55.17853749114174],\"scale\":0.9481257468531544},{\"type\":\"grass\",\"position\":[-95.39997626413984,0,-78.68128413289519],\"scale\":1.1042673004842316},{\"type\":\"grass\",\"position\":[16.221745633292585,0,75.24786027573734],\"scale\":1.1208206353578287},{\"type\":\"grass\",\"position\":[91.17569818881071,0,-98.3641193017262],\"scale\":1.2002291789353352},{\"type\":\"grass\",\"position\":[15.83377016631946,0,26.76576511453041],\"scale\":1.1658713368022695},{\"type\":\"grass\",\"position\":[3.4639941803057024,0,-29.96592615881066],\"scale\":0.9636046644903442},{\"type\":\"grass\",\"position\":[2.1553397508118746,0,-19.59745977059656],\"scale\":0.7951022734856974},{\"type\":\"grass\",\"position\":[-11.790369625928992,0,37.22221175793305],\"scale\":1.183588779414554},{\"type\":\"grass\",\"position\":[-12.443430356943196,0,5.990189306516484],\"scale\":1.0471882081536776},{\"type\":\"grass\",\"position\":[7.563597978503731,0,-35.01631127643545],\"scale\":0.8139771187398243},{\"type\":\"grass\",\"position\":[-104.66814089434308,0,-59.51208183295623],\"scale\":0.74900771911162},{\"type\":\"grass\",\"position\":[-146.96574589987588,0,-16.844127109803235],\"scale\":1.0951749306253509},{\"type\":\"grass\",\"position\":[-6.908036526567588,0,93.46838250993427],\"scale\":1.0327109252083984},{\"type\":\"grass\",\"position\":[99.85155229640488,0,-34.664434016822796],\"scale\":0.9641332070532178},{\"type\":\"grass\",\"position\":[-33.47461873810897,0,-21.29695708192754],\"scale\":1.2887452387323686},{\"type\":\"grass\",\"position\":[-112.83665857399856,0,73.49110599567003],\"scale\":0.9262084040346523},{\"type\":\"grass\",\"position\":[-64.64577946933288,0,13.405051721803067],\"scale\":0.9170312729421525},{\"type\":\"grass\",\"position\":[-50.63969976072037,0,105.40120876887033],\"scale\":1.249771047864227},{\"type\":\"grass\",\"position\":[-91.67559345387376,0,85.09297232138584],\"scale\":1.221955453984569},{\"type\":\"grass\",\"position\":[-37.2137671417359,0,141.880693846238],\"scale\":0.9980014590668775},{\"type\":\"grass\",\"position\":[-4.68681000198175,0,-2.087935832266624],\"scale\":0.9201302257918244},{\"type\":\"grass\",\"position\":[-97.44252569180976,0,60.292470374176716],\"scale\":1.0295702227474752},{\"type\":\"grass\",\"position\":[-28.695656685541707,0,-44.00460806462055],\"scale\":1.2225498400526669},{\"type\":\"grass\",\"position\":[-108.37270984881913,0,-60.18063643761874],\"scale\":1.1379883734888714},{\"type\":\"grass\",\"position\":[103.81514178522968,0,48.39216155263407],\"scale\":1.000517344843924},{\"type\":\"grass\",\"position\":[-0.2080366142818262,0,105.32707645583078],\"scale\":0.7051931797396427},{\"type\":\"grass\",\"position\":[9.960818358290158,0,-6.435378367975616],\"scale\":0.7067734323701927},{\"type\":\"grass\",\"position\":[105.27371040466092,0,-20.713697326578277],\"scale\":0.7285716723247336},{\"type\":\"grass\",\"position\":[12.569613956665176,0,-37.719499766225155],\"scale\":0.9902738458510343},{\"type\":\"grass\",\"position\":[23.62310468014589,0,11.432025179578947],\"scale\":0.9210822932606322},{\"type\":\"grass\",\"position\":[5.5874130162351445,0,15.302110372017598],\"scale\":0.9914462943906857},{\"type\":\"grass\",\"position\":[-46.041146028893415,0,30.171556095355474],\"scale\":1.1064747292226504},{\"type\":\"grass\",\"position\":[54.55636635931792,0,26.950775793469113],\"scale\":0.8392430902614938},{\"type\":\"grass\",\"position\":[-56.415365321589626,0,-0.07845998774584038],\"scale\":0.7322396317889416},{\"type\":\"grass\",\"position\":[-26.98830884359311,0,-48.97143837522209],\"scale\":1.1193849727404497},{\"type\":\"grass\",\"position\":[-133.73231848215437,0,-57.24092486268551],\"scale\":1.0105180326265482},{\"type\":\"grass\",\"position\":[-127.71091835896628,0,-51.148170698939424],\"scale\":1.2471301368448617},{\"type\":\"grass\",\"position\":[22.125512326463607,0,-15.361299274594346],\"scale\":0.7963728115274149},{\"type\":\"grass\",\"position\":[-90.98160356496625,0,-2.9424091757053867],\"scale\":0.9016304832374897},{\"type\":\"grass\",\"position\":[58.30915729390048,0,-134.48437281947258],\"scale\":0.9415074816089692},{\"type\":\"grass\",\"position\":[24.363059646545235,0,-10.645467526634269],\"scale\":0.8059331714075078},{\"type\":\"grass\",\"position\":[11.13629381663949,0,-17.90663445329407],\"scale\":1.2217028635548928},{\"type\":\"grass\",\"position\":[30.159547673470463,0,-62.028970001737534],\"scale\":1.0579141192437418},{\"type\":\"grass\",\"position\":[-46.797141446822124,0,-111.9688055922113],\"scale\":1.2970861439880117},{\"type\":\"grass\",\"position\":[-72.54189638167723,0,27.960599814570674],\"scale\":1.0795439332020982},{\"type\":\"grass\",\"position\":[-122.96469574990374,0,-36.5967360964863],\"scale\":1.028870495307108},{\"type\":\"grass\",\"position\":[26.832267882102528,0,-64.51033210986004],\"scale\":1.159082573187456},{\"type\":\"grass\",\"position\":[38.738685739691256,0,-38.163285541725045],\"scale\":0.8949252438051859},{\"type\":\"grass\",\"position\":[-22.5950721558935,0,-28.804727282483483],\"scale\":1.0091903700353735},{\"type\":\"grass\",\"position\":[-83.03448730467412,0,19.424727049930073],\"scale\":1.067580153294526},{\"type\":\"grass\",\"position\":[7.814735678948298,0,1.13794337014759],\"scale\":1.0432191481365234},{\"type\":\"grass\",\"position\":[7.682703976521369,0,-66.06127718691586],\"scale\":1.0044096264595612},{\"type\":\"grass\",\"position\":[-50.10969044047162,0,92.5219278574832],\"scale\":1.2581651838532508},{\"type\":\"grass\",\"position\":[-16.17731846905429,0,45.56871004525921],\"scale\":1.1120824231249982},{\"type\":\"grass\",\"position\":[-86.53820796877471,0,-78.1185829484272],\"scale\":0.9999056350228386},{\"type\":\"grass\",\"position\":[64.69839165546628,0,36.12219727595533],\"scale\":0.7569169992581846},{\"type\":\"grass\",\"position\":[36.0728134048022,0,28.180557133492627],\"scale\":1.0876031913429767},{\"type\":\"grass\",\"position\":[71.48006322877903,0,36.840069812816104],\"scale\":0.8918595288967931},{\"type\":\"grass\",\"position\":[-9.479411184628695,0,-49.17273181420467],\"scale\":1.1790974658897044},{\"type\":\"grass\",\"position\":[13.988622138112623,0,98.9456528831264],\"scale\":0.9435277847140335},{\"type\":\"grass\",\"position\":[12.150947803002696,0,-0.5676786347489138],\"scale\":0.9482342462629952},{\"type\":\"grass\",\"position\":[-134.46097390311422,0,17.48373077383406],\"scale\":0.9779427637965079},{\"type\":\"grass\",\"position\":[30.40451187356897,0,-89.15550605005272],\"scale\":1.154063468372802},{\"type\":\"grass\",\"position\":[-8.743692388182403,0,-60.86026216516073],\"scale\":0.7069668785599144},{\"type\":\"grass\",\"position\":[-62.267647479382084,0,-60.955562001996554],\"scale\":1.0001247954962276},{\"type\":\"grass\",\"position\":[67.74280009193332,0,34.98862155442184],\"scale\":0.9027786753239158},{\"type\":\"grass\",\"position\":[-15.030280062120296,0,-26.22062867699337],\"scale\":0.9360741462622529},{\"type\":\"grass\",\"position\":[3.3001428161235604,0,24.071808184671124],\"scale\":0.7743824195369933},{\"type\":\"grass\",\"position\":[-96.98062259175971,0,-0.5183835396238184],\"scale\":1.0732050506046917},{\"type\":\"grass\",\"position\":[107.38634940582217,0,-27.600710326374067],\"scale\":1.2093964845745022},{\"type\":\"grass\",\"position\":[-29.067612402236772,0,-14.05087701797366],\"scale\":1.2458787784288297},{\"type\":\"grass\",\"position\":[-4.938215137451794,0,45.59694695316852],\"scale\":0.9305774306320315},{\"type\":\"grass\",\"position\":[91.70026706442768,0,87.98682000895644],\"scale\":1.2628991757952703},{\"type\":\"grass\",\"position\":[-0.28082538804922874,0,4.3716341309190865],\"scale\":1.2972912132373824},{\"type\":\"grass\",\"position\":[-6.438035340541023,0,-2.7200754751426945],\"scale\":0.969899350656217},{\"type\":\"grass\",\"position\":[9.957487461130683,0,-60.60995234104484],\"scale\":1.2360685938834424},{\"type\":\"grass\",\"position\":[27.539672282813726,0,-53.49842019478731],\"scale\":0.7703439091191343},{\"type\":\"grass\",\"position\":[-32.98735340462844,0,-77.13198665964046],\"scale\":1.1209909884394609},{\"type\":\"grass\",\"position\":[44.14524369666124,0,120.73366384062909],\"scale\":1.1982551524222753},{\"type\":\"grass\",\"position\":[-15.082748058325175,0,26.585376337836813],\"scale\":0.8381882378455279},{\"type\":\"grass\",\"position\":[114.41817490936779,0,66.64483354890451],\"scale\":0.78700741416644},{\"type\":\"grass\",\"position\":[-28.84881248098816,0,-15.872657424002849],\"scale\":1.2501958325722127},{\"type\":\"grass\",\"position\":[-27.483950684498254,0,15.724075799632086],\"scale\":1.2398475390057855},{\"type\":\"grass\",\"position\":[28.47597773547495,0,56.62790620546764],\"scale\":1.1410773716033944},{\"type\":\"grass\",\"position\":[42.49949440461023,0,61.30910236936684],\"scale\":0.982055985988257},{\"type\":\"grass\",\"position\":[145.12472894860258,0,27.899488304491882],\"scale\":0.721891801792352},{\"type\":\"grass\",\"position\":[-117.13524841900927,0,38.65312650506894],\"scale\":0.8675648979921925},{\"type\":\"grass\",\"position\":[68.41786757751925,0,41.82930038467802],\"scale\":0.8280023617331198},{\"type\":\"grass\",\"position\":[-5.3966671664231045,0,30.28513851671437],\"scale\":1.197199370852732},{\"type\":\"grass\",\"position\":[0.5549024564528113,0,-43.0636565321362],\"scale\":1.0295178221717438},{\"type\":\"grass\",\"position\":[-46.359737156844695,0,72.18168089410845],\"scale\":1.0427098631263796},{\"type\":\"grass\",\"position\":[41.41135017190275,0,-35.83670606535196],\"scale\":0.8920128214282339},{\"type\":\"grass\",\"position\":[59.3671008046537,0,-75.89330771122216],\"scale\":0.9880809045223052},{\"type\":\"grass\",\"position\":[63.234696595944904,0,-40.05415237195822],\"scale\":1.1575462259719496},{\"type\":\"grass\",\"position\":[-12.149101384946139,0,-9.602697570260512],\"scale\":0.9311918053655811},{\"type\":\"grass\",\"position\":[-35.61318704241926,0,-15.563847419087862],\"scale\":0.815771270646244},{\"type\":\"grass\",\"position\":[-53.96258574063263,0,5.592378299129908],\"scale\":1.1097553170554348},{\"type\":\"grass\",\"position\":[-37.6704801515817,0,-20.892534776591216],\"scale\":0.7995815460273257},{\"type\":\"grass\",\"position\":[-53.04734019791438,0,-138.8950624682311],\"scale\":0.7821573507790567},{\"type\":\"grass\",\"position\":[28.501015452742163,0,-24.96614095201262],\"scale\":0.8509081553326965},{\"type\":\"grass\",\"position\":[135.23598954873705,0,54.80894683497399],\"scale\":1.025848295931584},{\"type\":\"grass\",\"position\":[13.645269869296943,0,-71.70408054089584],\"scale\":1.1900765285395125},{\"type\":\"grass\",\"position\":[-2.137327568652377,0,-50.765842347738314],\"scale\":0.9957254418249525},{\"type\":\"grass\",\"position\":[-93.08392249452085,0,-58.06696225622575],\"scale\":1.2252422137773293},{\"type\":\"grass\",\"position\":[-47.79406424779815,0,-67.7185608531867],\"scale\":0.9069777241000068},{\"type\":\"grass\",\"position\":[-90.04537781802381,0,-64.4328978117119],\"scale\":1.2478845081847862},{\"type\":\"grass\",\"position\":[85.84341615296871,0,-86.44679613688517],\"scale\":0.9785118904713156},{\"type\":\"grass\",\"position\":[-99.33609588094605,0,42.60329350194985],\"scale\":1.274238587161579},{\"type\":\"grass\",\"position\":[-22.78907193339136,0,-71.26480524967015],\"scale\":1.292937419432745},{\"type\":\"grass\",\"position\":[35.99145131180913,0,70.4601181492665],\"scale\":1.1827765886913981},{\"type\":\"grass\",\"position\":[-90.04391096722124,0,119.85296738928146],\"scale\":1.131729498936095},{\"type\":\"grass\",\"position\":[0.15220182674375524,0,0.16842311171606084],\"scale\":1.0500096380061867},{\"type\":\"grass\",\"position\":[-38.578329019066345,0,-37.61152855217627],\"scale\":1.0150520112846},{\"type\":\"grass\",\"position\":[-111.22816113594493,0,91.68061963088637],\"scale\":0.7313210966519561},{\"type\":\"grass\",\"position\":[59.73093388302829,0,-136.45132344107213],\"scale\":1.1214786193063238},{\"type\":\"grass\",\"position\":[99.92702801348844,0,96.93139204512238],\"scale\":0.9851840128339993},{\"type\":\"grass\",\"position\":[-25.606617157688017,0,-43.42136483830828],\"scale\":1.174526515271419},{\"type\":\"grass\",\"position\":[-123.19528923551258,0,26.69173366169519],\"scale\":0.7452407134820064},{\"type\":\"grass\",\"position\":[-86.31047051266155,0,18.523114904286675],\"scale\":0.7626895813792798},{\"type\":\"grass\",\"position\":[-23.119063522321024,0,25.3068672298179],\"scale\":1.061015435712614},{\"type\":\"grass\",\"position\":[0.06591559162748924,0,129.8163490597867],\"scale\":1.2258093688213159},{\"type\":\"grass\",\"position\":[-42.10321723413588,0,-102.7586810699276],\"scale\":1.13006615264559},{\"type\":\"grass\",\"position\":[53.988644951995546,0,-90.84942322358947],\"scale\":1.0084110874215888},{\"type\":\"grass\",\"position\":[-90.36250636197747,0,-31.32701369242384],\"scale\":1.2462492617656358},{\"type\":\"grass\",\"position\":[8.917032289863679,0,55.24967162898015],\"scale\":1.2458096977547202},{\"type\":\"grass\",\"position\":[-10.026024859587721,0,24.321300361071582],\"scale\":0.79157471086384},{\"type\":\"grass\",\"position\":[6.923669801133859,0,-21.209498960300575],\"scale\":0.8369159047240927},{\"type\":\"grass\",\"position\":[9.667060801763451,0,-53.28371455678906],\"scale\":1.2093581562783284},{\"type\":\"grass\",\"position\":[6.481793595700254,0,5.418396008641806],\"scale\":1.1792859417715955},{\"type\":\"grass\",\"position\":[58.46098272936664,0,-75.28527536484823],\"scale\":0.7003964456667248},{\"type\":\"grass\",\"position\":[-28.387212585580976,0,-7.336727240047997],\"scale\":1.1930087658611448},{\"type\":\"grass\",\"position\":[-50.88121125129478,0,-61.809064667287686],\"scale\":0.7353645166627748},{\"type\":\"grass\",\"position\":[-95.99039085133306,0,69.70938350991118],\"scale\":1.139694511991989},{\"type\":\"grass\",\"position\":[14.605413143679206,0,-133.51497759916586],\"scale\":1.1116343133665583},{\"type\":\"grass\",\"position\":[-118.82556998042566,0,-70.08188494550149],\"scale\":0.963082823641025},{\"type\":\"grass\",\"position\":[-43.50376846110051,0,141.40704250130185],\"scale\":0.7654511877181457},{\"type\":\"grass\",\"position\":[92.23938863284502,0,-76.8081050661861],\"scale\":0.8014176672666462},{\"type\":\"grass\",\"position\":[-22.03908645175895,0,13.59609191019687],\"scale\":0.7799820318124869},{\"type\":\"grass\",\"position\":[-11.265191696805081,0,-18.941548906573573],\"scale\":0.7684031037324396},{\"type\":\"grass\",\"position\":[17.009573798899158,0,-23.070599428595134],\"scale\":0.7452922932797861},{\"type\":\"grass\",\"position\":[4.311043051064518,0,49.019760818260046],\"scale\":1.1061265081700382},{\"type\":\"grass\",\"position\":[-76.32986007144993,0,-49.40334802389993],\"scale\":1.2259994611815186},{\"type\":\"grass\",\"position\":[120.53592396557109,0,-52.537078446702445],\"scale\":1.2424696930171308},{\"type\":\"grass\",\"position\":[2.4280673944661535,0,25.608798223312377],\"scale\":0.8102583237549782},{\"type\":\"grass\",\"position\":[35.16739460932471,0,56.45320385078163],\"scale\":1.154423294224352},{\"type\":\"grass\",\"position\":[35.978949832368265,0,14.926117824702661],\"scale\":1.2168891794663987},{\"type\":\"grass\",\"position\":[39.839477890524975,0,43.38601404229134],\"scale\":0.949911731320593},{\"type\":\"grass\",\"position\":[-9.517037312378218,0,-4.323524127966103],\"scale\":1.287572674914996},{\"type\":\"grass\",\"position\":[14.024894931225312,0,-94.46732022182383],\"scale\":1.0222883555330688},{\"type\":\"grass\",\"position\":[17.001607204266705,0,15.805490593375158],\"scale\":0.8232118049019054},{\"type\":\"grass\",\"position\":[51.128093393225434,0,77.20843641655051],\"scale\":0.9254680225185449},{\"type\":\"grass\",\"position\":[28.314418218102595,0,65.1298379062934],\"scale\":1.0599823813619893},{\"type\":\"grass\",\"position\":[37.26082632984623,0,-90.34959243770194],\"scale\":0.8033519582204538},{\"type\":\"grass\",\"position\":[10.04640119394608,0,35.53820836182482],\"scale\":1.0395285487664825},{\"type\":\"grass\",\"position\":[-125.04870071528029,0,-24.760368925352708],\"scale\":1.0143899140341035},{\"type\":\"grass\",\"position\":[43.150376728460735,0,-87.74968698402354],\"scale\":1.1328813678192655},{\"type\":\"grass\",\"position\":[-14.65477555912179,0,-20.89155981568045],\"scale\":1.1195493053170724},{\"type\":\"grass\",\"position\":[-27.961823440715605,0,-9.670608616577567],\"scale\":1.269440044182643},{\"type\":\"grass\",\"position\":[-3.7055917406181447,0,110.23989903416235],\"scale\":0.7948541500162919},{\"type\":\"grass\",\"position\":[24.723940561892256,0,-4.621601576905358],\"scale\":0.7738225000081146},{\"type\":\"grass\",\"position\":[-4.95477856004737,0,-20.19021985258965],\"scale\":1.103019166531996},{\"type\":\"grass\",\"position\":[17.172209220888753,0,22.044783292236417],\"scale\":0.9558375805794062},{\"type\":\"grass\",\"position\":[-2.378280722291071,0,-1.6146231527468513],\"scale\":1.191284694555943},{\"type\":\"grass\",\"position\":[44.38853496680003,0,40.74455386631703],\"scale\":1.1129946191501334},{\"type\":\"grass\",\"position\":[8.869908349642845,0,-16.106670190897333],\"scale\":1.0195906364108152},{\"type\":\"grass\",\"position\":[-88.83549101068611,0,6.147389481629931],\"scale\":0.799580335314157},{\"type\":\"grass\",\"position\":[-96.62081326390677,0,-76.73357024196751],\"scale\":0.8654799145189513},{\"type\":\"grass\",\"position\":[9.014020967418505,0,-45.95929276672106],\"scale\":0.7571037875627088},{\"type\":\"grass\",\"position\":[1.6239609523301513,0,-1.2405941229438002],\"scale\":1.13534247160375},{\"type\":\"grass\",\"position\":[-23.223459238167138,0,28.25683075095296],\"scale\":0.978817154935833},{\"type\":\"grass\",\"position\":[-49.03964464059199,0,139.79107514916564],\"scale\":0.7506220795358186},{\"type\":\"grass\",\"position\":[-34.28892911316021,0,9.6924116163734],\"scale\":1.053412055870155},{\"type\":\"grass\",\"position\":[51.24616646137458,0,105.92793228374019],\"scale\":0.9985505862063759},{\"type\":\"grass\",\"position\":[42.67690986720052,0,-69.16897716471703],\"scale\":1.044795884431013},{\"type\":\"grass\",\"position\":[12.958748129577092,0,-5.284519174946746],\"scale\":1.198153266541292},{\"type\":\"grass\",\"position\":[3.1092811969302288,0,1.304456986789259],\"scale\":1.1911705843756382},{\"type\":\"grass\",\"position\":[-2.233836632354109,0,7.436919449447979],\"scale\":0.9938879056110759},{\"type\":\"grass\",\"position\":[50.31766856946557,0,123.14346628565598],\"scale\":1.0865761530771496},{\"type\":\"grass\",\"position\":[49.79124141973128,0,-63.090627448528565],\"scale\":0.9960797004735351},{\"type\":\"grass\",\"position\":[33.038987382618345,0,40.5647352876761],\"scale\":1.0061782050706998},{\"type\":\"grass\",\"position\":[-3.8140507976303955,0,-12.28257718713888],\"scale\":0.8588468868692462},{\"type\":\"grass\",\"position\":[60.23969507124807,0,-120.29407549526509],\"scale\":1.0762617086729158},{\"type\":\"grass\",\"position\":[13.455801802188438,0,-19.438552286925272],\"scale\":0.8146900512279218},{\"type\":\"grass\",\"position\":[2.8798698765439936,0,-20.826944749940864],\"scale\":0.7001093872350835},{\"type\":\"grass\",\"position\":[-35.06531732229094,0,3.610002714592618],\"scale\":0.7084405970409796},{\"type\":\"grass\",\"position\":[44.327523850128074,0,-20.604394704689344],\"scale\":1.1156002301220047},{\"type\":\"grass\",\"position\":[0.8943455742300752,0,1.9336611939622335],\"scale\":0.830712255871096},{\"type\":\"grass\",\"position\":[-19.65047144044617,0,57.55124346022532],\"scale\":1.0063922365500537},{\"type\":\"grass\",\"position\":[-68.98693298569171,0,-118.09563795565597],\"scale\":1.0780912592327376},{\"type\":\"grass\",\"position\":[91.60057077914503,0,3.560846340448913],\"scale\":1.0922510323242842},{\"type\":\"grass\",\"position\":[3.1693621249884365,0,-8.079931905914473],\"scale\":1.0491170690825573},{\"type\":\"grass\",\"position\":[6.189208807922646,0,-4.038554045834877],\"scale\":0.8177815959182996},{\"type\":\"grass\",\"position\":[35.89836951492229,0,-55.33148915109631],\"scale\":0.7027209825599835},{\"type\":\"grass\",\"position\":[-3.2300248969221896,0,19.17596094097894],\"scale\":0.7378350875155156},{\"type\":\"grass\",\"position\":[1.5327593075431454,0,3.063534866045135],\"scale\":1.1563242574877934},{\"type\":\"grass\",\"position\":[-67.13070771996729,0,-4.616709870209541],\"scale\":0.7165520458846085},{\"type\":\"grass\",\"position\":[-63.7577775250723,0,-28.57772783567846],\"scale\":0.942747507195499},{\"type\":\"grass\",\"position\":[25.046770226755868,0,-95.66643648446626],\"scale\":1.1072019775335245},{\"type\":\"grass\",\"position\":[88.75394452129748,0,110.8560745274796],\"scale\":1.2660911142112385},{\"type\":\"grass\",\"position\":[31.09656098690642,0,88.14512181822371],\"scale\":0.7577686120474982},{\"type\":\"grass\",\"position\":[-61.29031856929003,0,-81.55696855783408],\"scale\":1.1020115317012626},{\"type\":\"grass\",\"position\":[-14.985063183809704,0,2.612879831676454],\"scale\":0.8562485150470858},{\"type\":\"grass\",\"position\":[-2.2081116058117836,0,-142.3678625107722],\"scale\":1.0848666736783343},{\"type\":\"grass\",\"position\":[0.8393117551434283,0,59.10059663742872],\"scale\":1.2174594738730706},{\"type\":\"grass\",\"position\":[-55.550757693073365,0,22.38752365132022],\"scale\":0.7510242132883459},{\"type\":\"grass\",\"position\":[97.73836172081663,0,47.110898828611376],\"scale\":1.0377063736833712},{\"type\":\"grass\",\"position\":[23.67805228282518,0,-6.0765160508020015],\"scale\":1.2012356912694235},{\"type\":\"grass\",\"position\":[-22.98160567146579,0,-9.341446826096123],\"scale\":1.1519801571263921},{\"type\":\"grass\",\"position\":[67.98149551294497,0,-67.14872282537254],\"scale\":0.9221764369970322},{\"type\":\"grass\",\"position\":[106.5614002449882,0,-71.8528257131282],\"scale\":1.250996742628827},{\"type\":\"grass\",\"position\":[-26.050999447839786,0,14.069843959328377],\"scale\":0.8658012938548365},{\"type\":\"grass\",\"position\":[53.106158987735576,0,61.073765161695015],\"scale\":0.7201676888644885},{\"type\":\"grass\",\"position\":[-32.5487070558591,0,15.86513920270907],\"scale\":1.1806398993157736},{\"type\":\"grass\",\"position\":[96.05964785053045,0,21.983816885597243],\"scale\":1.266169338957328},{\"type\":\"grass\",\"position\":[36.08097217320396,0,24.52989469945909],\"scale\":0.8592310227632656},{\"type\":\"grass\",\"position\":[-4.677873160883359,0,-116.85516303710851],\"scale\":1.132615921125779},{\"type\":\"grass\",\"position\":[9.854608530738656,0,36.858577989724324],\"scale\":0.7950716401265213},{\"type\":\"grass\",\"position\":[38.35305086333062,0,54.835044868656496],\"scale\":1.047412481802733},{\"type\":\"grass\",\"position\":[-40.478733525278024,0,132.00324541544956],\"scale\":1.0685699127014974},{\"type\":\"grass\",\"position\":[-81.09623063622134,0,-103.3292806514948],\"scale\":1.291647393668355},{\"type\":\"grass\",\"position\":[-37.43013060804045,0,-37.72552558809644],\"scale\":1.0203144959189527},{\"type\":\"grass\",\"position\":[117.21278033466426,0,-19.734575107134514],\"scale\":0.8837017972742105},{\"type\":\"grass\",\"position\":[34.398688802661155,0,-117.64339918272661],\"scale\":1.053920881683533},{\"type\":\"grass\",\"position\":[-3.6365805892008822,0,6.899513074102465],\"scale\":0.9343124522859279},{\"type\":\"grass\",\"position\":[-10.360614848096153,0,-21.208418933058894],\"scale\":1.1595828716854872},{\"type\":\"grass\",\"position\":[-46.04971413876992,0,22.937493347211543],\"scale\":0.9391196402174694},{\"type\":\"grass\",\"position\":[72.9324504828895,0,80.29337547893378],\"scale\":1.0214013955264876},{\"type\":\"grass\",\"position\":[-26.132298304144776,0,28.585381508238353],\"scale\":0.7369396318805933},{\"type\":\"grass\",\"position\":[64.64246618492719,0,-41.81221260039235],\"scale\":1.2828420740548163},{\"type\":\"grass\",\"position\":[49.43312320851979,0,-4.656640769372229],\"scale\":0.9435187066098687},{\"type\":\"grass\",\"position\":[37.53795046379662,0,38.17391504092505],\"scale\":1.2301605364422463},{\"type\":\"grass\",\"position\":[-68.9767667977892,0,-104.51844352632483],\"scale\":0.8186434799013389},{\"type\":\"grass\",\"position\":[-40.07711503019073,0,128.62568194934124],\"scale\":1.278372339613608},{\"type\":\"grass\",\"position\":[4.828011683921868,0,-36.308882945500294],\"scale\":1.2045313919874254},{\"type\":\"grass\",\"position\":[-19.7928189157114,0,49.65820621813925],\"scale\":1.2467708508483277},{\"type\":\"grass\",\"position\":[10.750052681507656,0,13.895591690265304],\"scale\":1.01187423538449},{\"type\":\"grass\",\"position\":[132.48492538587084,0,-29.42790491029541],\"scale\":0.7138916401042695},{\"type\":\"grass\",\"position\":[52.36812065882015,0,-81.7508842704054],\"scale\":1.2442279077899496},{\"type\":\"grass\",\"position\":[-21.146669297609662,0,21.94547061293201],\"scale\":1.0649772252253964},{\"type\":\"grass\",\"position\":[126.99657048624945,0,75.87637996249231],\"scale\":1.1925721490241277},{\"type\":\"grass\",\"position\":[-14.57429343735927,0,86.72161267422142],\"scale\":0.8016824329147765},{\"type\":\"grass\",\"position\":[-27.23020284673156,0,2.716639292913204],\"scale\":0.9077432701854549},{\"type\":\"grass\",\"position\":[-3.7246018979694484,0,-34.78412229921232],\"scale\":1.0530736359829616},{\"type\":\"grass\",\"position\":[5.841822256952947,0,122.76742068086021],\"scale\":0.9888083246073355},{\"type\":\"grass\",\"position\":[121.62041195158571,0,37.097531815512475],\"scale\":1.1275130793705699},{\"type\":\"grass\",\"position\":[-40.56120103512828,0,-77.32323252113382],\"scale\":0.9672511434516465},{\"type\":\"grass\",\"position\":[10.991667318523486,0,141.11857390505506],\"scale\":1.0100340098874083},{\"type\":\"grass\",\"position\":[3.2226105880027136,0,34.281063651385175],\"scale\":0.7911305143027992},{\"type\":\"grass\",\"position\":[-35.644801061687296,0,77.95137776443896],\"scale\":0.9353546640414138},{\"type\":\"grass\",\"position\":[17.911177827340826,0,-136.39674898960232],\"scale\":1.2667948966916998},{\"type\":\"grass\",\"position\":[-64.01437675352005,0,-16.71553775462611],\"scale\":1.0488717031656623},{\"type\":\"grass\",\"position\":[80.60446866398951,0,-1.2818100471752039],\"scale\":0.8503700123029394},{\"type\":\"grass\",\"position\":[-89.87612939890973,0,88.91602976490194],\"scale\":0.8749518270734722},{\"type\":\"grass\",\"position\":[-16.12460158256311,0,-73.98873802610234],\"scale\":0.7838842069200765},{\"type\":\"grass\",\"position\":[-96.88472209052864,0,-78.48023464950882],\"scale\":1.2331658095786482},{\"type\":\"grass\",\"position\":[29.103258685597094,0,5.810793154762278],\"scale\":1.1624217984447263},{\"type\":\"grass\",\"position\":[-6.135293436480533,0,-5.28938365940991],\"scale\":0.8951132780076043},{\"type\":\"grass\",\"position\":[47.15916941465925,0,34.53389549696945],\"scale\":1.0418871183046778},{\"type\":\"grass\",\"position\":[49.185180765799245,0,38.85340304025644],\"scale\":1.296004057042067},{\"type\":\"grass\",\"position\":[-5.180335647905354,0,-10.461410731776379],\"scale\":1.200176212614029},{\"type\":\"grass\",\"position\":[-10.806498631276105,0,119.24209766137955],\"scale\":0.7589556605530468},{\"type\":\"grass\",\"position\":[-61.03301026370856,0,-47.91788537705987],\"scale\":0.9786968346413344},{\"type\":\"grass\",\"position\":[-136.89452158737214,0,41.902464412439514],\"scale\":1.1117402033529833},{\"type\":\"grass\",\"position\":[6.2271723394532374,0,-1.5066925923636012],\"scale\":1.2208076151816898},{\"type\":\"grass\",\"position\":[141.82522887228077,0,-4.604623398049937],\"scale\":0.8988172250836705},{\"type\":\"grass\",\"position\":[-21.249863592691227,0,53.817884380648444],\"scale\":0.9933476338442523},{\"type\":\"grass\",\"position\":[37.7088689716236,0,-63.57871608209828],\"scale\":1.2812828665600353},{\"type\":\"grass\",\"position\":[-67.50446602653498,0,32.413884590631824],\"scale\":1.065285629262637},{\"type\":\"grass\",\"position\":[95.19564331912797,0,14.004114686221154],\"scale\":1.099650311142702},{\"type\":\"grass\",\"position\":[0.954098823999878,0,15.97312740205839],\"scale\":1.029502453857064},{\"type\":\"grass\",\"position\":[-0.8528864288813415,0,4.058122996940471],\"scale\":1.298052256425561},{\"type\":\"grass\",\"position\":[-11.455686300315472,0,32.76995394288825],\"scale\":1.2966603492583249},{\"type\":\"grass\",\"position\":[137.0959727805367,0,-14.581946941631196],\"scale\":1.1357601763204546},{\"type\":\"grass\",\"position\":[91.36537249035071,0,-38.36444805629956],\"scale\":0.9199805835523921},{\"type\":\"grass\",\"position\":[12.92118899229289,0,-110.06070002699832],\"scale\":0.7350075774858155},{\"type\":\"grass\",\"position\":[4.575133965117276,0,8.110532649423122],\"scale\":1.0635963987180383},{\"type\":\"grass\",\"position\":[108.96901851929312,0,14.08829953767537],\"scale\":0.9115474323826117},{\"type\":\"grass\",\"position\":[-70.39700614199167,0,-75.60753201645983],\"scale\":0.9896186865117333},{\"type\":\"grass\",\"position\":[-92.29516684336768,0,59.18397966193114],\"scale\":0.7146049096666994},{\"type\":\"grass\",\"position\":[37.9245218761053,0,-42.13698455856874],\"scale\":0.9897016847565704},{\"type\":\"grass\",\"position\":[-21.460178318305047,0,-4.341764113638694],\"scale\":1.2134613145051296},{\"type\":\"grass\",\"position\":[-28.772767912217233,0,-44.23736246437485],\"scale\":0.9574265820510673},{\"type\":\"grass\",\"position\":[-4.529779718346433,0,10.183704744357899],\"scale\":1.1978628820536967},{\"type\":\"grass\",\"position\":[-34.760795692984445,0,93.39522753830983],\"scale\":0.8911422765669971},{\"type\":\"grass\",\"position\":[-85.69131231584362,0,-68.563772172096],\"scale\":0.8968783975360309},{\"type\":\"grass\",\"position\":[-31.01418148903676,0,-33.48108522742858],\"scale\":1.2422357029074695},{\"type\":\"grass\",\"position\":[47.325967578823295,0,124.03687191133497],\"scale\":0.8309511556888267},{\"type\":\"grass\",\"position\":[81.20633518344448,0,113.94321047546418],\"scale\":1.023562062478242},{\"type\":\"grass\",\"position\":[-6.2945846600333715,0,-17.431195312304528],\"scale\":0.9077349245212414},{\"type\":\"grass\",\"position\":[84.1571199821741,0,-81.92133583868628],\"scale\":1.0685600930821648},{\"type\":\"grass\",\"position\":[-80.70523975621279,0,109.99096281545012],\"scale\":1.142707788792297},{\"type\":\"grass\",\"position\":[-27.59936144815774,0,99.06302036753743],\"scale\":1.2229019271415087},{\"type\":\"grass\",\"position\":[2.135532547788902,0,4.682568853627898],\"scale\":0.9231687667102628},{\"type\":\"grass\",\"position\":[107.33823151012545,0,61.444244975390475],\"scale\":0.8090259673585096},{\"type\":\"grass\",\"position\":[-63.047123460946096,0,1.8601211783314981],\"scale\":0.933549093679386},{\"type\":\"grass\",\"position\":[95.17400912537327,0,-80.90063027485576],\"scale\":1.2675782064442433},{\"type\":\"grass\",\"position\":[9.771369257132086,0,-8.603801832011444],\"scale\":1.1301053656762838},{\"type\":\"grass\",\"position\":[-58.40355898573479,0,-35.33665750111874],\"scale\":0.8372994664119897},{\"type\":\"grass\",\"position\":[-28.220476103117996,0,112.77538329213232],\"scale\":0.8752849465363345},{\"type\":\"grass\",\"position\":[22.92947360139325,0,-88.80011092984763],\"scale\":1.0224734387193708},{\"type\":\"grass\",\"position\":[-61.66334568276731,0,87.74356291231054],\"scale\":1.1399208877161835},{\"type\":\"grass\",\"position\":[-23.53725346284168,0,27.726327941116335],\"scale\":1.0930253717720346},{\"type\":\"grass\",\"position\":[15.647746786262145,0,-7.099984148561607],\"scale\":0.9223836509386001},{\"type\":\"grass\",\"position\":[-67.06967637868274,0,86.34920450643797],\"scale\":0.7424471532919842},{\"type\":\"grass\",\"position\":[-12.51376087111426,0,-13.661376931963714],\"scale\":1.0717947187438395},{\"type\":\"grass\",\"position\":[58.316726179679534,0,-78.08725349226866],\"scale\":1.2059896544100122},{\"type\":\"grass\",\"position\":[119.43685992097464,0,11.006590985333151],\"scale\":1.0228758112582306},{\"type\":\"grass\",\"position\":[5.234916848830142,0,-26.252089629860873],\"scale\":1.1421747166344518},{\"type\":\"grass\",\"position\":[-35.32152383888711,0,-77.85261722836913],\"scale\":0.705970860174178},{\"type\":\"grass\",\"position\":[-8.973813698580589,0,68.78460108705788],\"scale\":0.7653581373884957},{\"type\":\"grass\",\"position\":[-73.7656006872468,0,90.11559613797581],\"scale\":1.144016379745504},{\"type\":\"grass\",\"position\":[-123.23302648062285,0,25.483733129860212],\"scale\":0.7621042908038007},{\"type\":\"grass\",\"position\":[-79.94410184786105,0,31.4873577787158],\"scale\":0.7825838321237915},{\"type\":\"grass\",\"position\":[-32.841334842253495,0,133.2236160457179],\"scale\":0.8640828483003029},{\"type\":\"grass\",\"position\":[-18.881301650205998,0,13.378292995034254],\"scale\":0.8835639612510473},{\"type\":\"grass\",\"position\":[-51.10854177619286,0,-3.8974484709570527],\"scale\":0.7190711305187122},{\"type\":\"grass\",\"position\":[-4.299885368620266,0,-31.655513916803873],\"scale\":0.9365885239401044},{\"type\":\"grass\",\"position\":[108.27920007838232,0,-8.67375805360426],\"scale\":0.8082218129887218},{\"type\":\"grass\",\"position\":[7.503512764953696,0,-129.12806333221457],\"scale\":0.8525411486304995},{\"type\":\"grass\",\"position\":[-82.32382639939559,0,-92.67245971034245],\"scale\":1.2361518176682178},{\"type\":\"grass\",\"position\":[-9.359180986387809,0,67.78400553899131],\"scale\":0.8264328046360506},{\"type\":\"grass\",\"position\":[3.3783287131642896,0,-36.97691701848849],\"scale\":0.7960115803213721},{\"type\":\"grass\",\"position\":[116.2922790242473,0,74.71278148070974],\"scale\":1.197614140246626},{\"type\":\"grass\",\"position\":[-9.789776105573988,0,122.11705885418178],\"scale\":1.2429311420167695},{\"type\":\"grass\",\"position\":[-35.71600099643074,0,55.18529657403895],\"scale\":0.7632603973033454},{\"type\":\"grass\",\"position\":[48.32168222555477,0,10.402119565531205],\"scale\":1.2240679024278958},{\"type\":\"grass\",\"position\":[-61.74228809877678,0,-52.92391539422593],\"scale\":1.0327986065042083},{\"type\":\"grass\",\"position\":[75.05727132237232,0,-94.8731036981616],\"scale\":0.7074535782206265},{\"type\":\"grass\",\"position\":[-56.05413350982459,0,11.055632976278543],\"scale\":1.2413329277525396},{\"type\":\"grass\",\"position\":[30.697553335104587,0,-66.35204962711917],\"scale\":0.8807412671942695},{\"type\":\"grass\",\"position\":[-108.88342078479312,0,-33.04985215309755],\"scale\":0.9566976980874462},{\"type\":\"grass\",\"position\":[8.950609469713466,0,-41.99110574902429],\"scale\":1.1627506365255387},{\"type\":\"grass\",\"position\":[-75.41123967130687,0,35.441653548494386],\"scale\":1.1531015209869797},{\"type\":\"grass\",\"position\":[-109.1244200120848,0,-55.159506045430454],\"scale\":0.9903138701113016},{\"type\":\"grass\",\"position\":[130.09049896264068,0,-12.730021243695761],\"scale\":0.7232602040503765},{\"type\":\"grass\",\"position\":[6.617053861963287,0,4.403535396833594],\"scale\":1.0584704623866914},{\"type\":\"grass\",\"position\":[71.06616185453353,0,-32.84393110360233],\"scale\":0.895221943600988},{\"type\":\"grass\",\"position\":[68.09975398541208,0,19.07290821205243],\"scale\":0.8167277639210605},{\"type\":\"grass\",\"position\":[-80.21100800560015,0,68.2175065858264],\"scale\":1.1500814091607747},{\"type\":\"grass\",\"position\":[-103.30555013302462,0,-24.98034320869814],\"scale\":0.8536045604666614},{\"type\":\"grass\",\"position\":[-12.041845886361676,0,-19.62623606534387],\"scale\":1.1367938087898972},{\"type\":\"grass\",\"position\":[-6.998062508813618,0,-97.60523782130653],\"scale\":1.1317488214033582},{\"type\":\"grass\",\"position\":[63.72636434335037,0,-132.61495843832913],\"scale\":1.0464868824423708},{\"type\":\"grass\",\"position\":[-28.998206920401028,0,-80.42962707735659],\"scale\":0.7894871644811197},{\"type\":\"grass\",\"position\":[85.68513590940985,0,7.609820354844911],\"scale\":0.8909384633308087},{\"type\":\"grass\",\"position\":[-17.2223593461408,0,-22.39736703877814],\"scale\":0.8693392942265264},{\"type\":\"grass\",\"position\":[83.87264255268887,0,-33.177646652318785],\"scale\":0.8986887643235896},{\"type\":\"grass\",\"position\":[1.2911724468352255,0,-22.61348419786636],\"scale\":1.1869071116084968},{\"type\":\"grass\",\"position\":[0.5964375648318109,0,0.9548921233925173],\"scale\":1.2821869552681275},{\"type\":\"grass\",\"position\":[-34.157613763937,0,-67.73939209726235],\"scale\":0.8313070636002277},{\"type\":\"grass\",\"position\":[-0.15432367779325304,0,-0.5161529688885063],\"scale\":1.2325442687939647},{\"type\":\"grass\",\"position\":[84.35577257600174,0,25.263149320461164],\"scale\":1.043365623718532},{\"type\":\"grass\",\"position\":[-120.56008226289259,0,-4.840386801563765],\"scale\":0.8747473219192865},{\"type\":\"grass\",\"position\":[5.537442947704899,0,38.975746230898324],\"scale\":0.9869758413798602},{\"type\":\"grass\",\"position\":[-55.311726513725475,0,122.82779130402777],\"scale\":1.0570172864004288},{\"type\":\"grass\",\"position\":[36.62762745714076,0,-127.91559613563545],\"scale\":1.1652195143933968},{\"type\":\"grass\",\"position\":[110.37353746619776,0,-48.963160482881904],\"scale\":1.147166659082767},{\"type\":\"grass\",\"position\":[-78.19782897259107,0,102.03503638600228],\"scale\":1.185513963782772},{\"type\":\"grass\",\"position\":[0.5035339138061574,0,-1.5945274992891738],\"scale\":1.2913774174125687},{\"type\":\"grass\",\"position\":[70.02645752978587,0,93.15510474591444],\"scale\":1.265459085184618},{\"type\":\"grass\",\"position\":[-9.917290424591599,0,-107.38772202066667],\"scale\":0.7987779231113461},{\"type\":\"grass\",\"position\":[-48.39674958219789,0,-2.8244801117168064],\"scale\":0.9024810505057228},{\"type\":\"grass\",\"position\":[50.78330429609923,0,-91.00535480140123],\"scale\":0.8760280550031205},{\"type\":\"grass\",\"position\":[-129.0664095553368,0,43.037055940495684],\"scale\":1.2098100106074423},{\"type\":\"grass\",\"position\":[-80.14788366752846,0,104.06679223278516],\"scale\":0.7088948654453338},{\"type\":\"grass\",\"position\":[-87.0026733812787,0,-49.20018099474959],\"scale\":1.1793555330084171},{\"type\":\"grass\",\"position\":[-96.64527593112636,0,80.35336200466102],\"scale\":0.8389745259534482},{\"type\":\"grass\",\"position\":[118.78633335215625,0,52.8255851797009],\"scale\":0.880818404167035},{\"type\":\"grass\",\"position\":[8.109267552232101,0,49.1055738983901],\"scale\":1.0755077014989496},{\"type\":\"grass\",\"position\":[9.893208965957216,0,-1.2553523292678572],\"scale\":0.7136340158478375},{\"type\":\"grass\",\"position\":[79.33957796720051,0,-82.64816357305918],\"scale\":1.0495874220879418},{\"type\":\"grass\",\"position\":[81.33349640991348,0,-24.235187896436813],\"scale\":0.8201139989217257},{\"type\":\"grass\",\"position\":[-26.524306243368958,0,18.23170288557422],\"scale\":0.736375189503127},{\"type\":\"grass\",\"position\":[18.22279222026441,0,36.23927819403158],\"scale\":1.1652711995717617},{\"type\":\"grass\",\"position\":[15.780691861590336,0,7.431570683259795],\"scale\":0.9044145318240832},{\"type\":\"grass\",\"position\":[-27.24001943323163,0,-104.5236664696501],\"scale\":0.7947642339223271},{\"type\":\"grass\",\"position\":[137.2140697580064,0,-58.01673166169023],\"scale\":0.9791489455323807},{\"type\":\"grass\",\"position\":[-29.559035897335935,0,36.61057985311032],\"scale\":0.9319601007382738},{\"type\":\"grass\",\"position\":[57.76772821575594,0,12.494772694521613],\"scale\":0.8827383280438038},{\"type\":\"grass\",\"position\":[46.395172498313315,0,83.21574425072481],\"scale\":1.1116400554845467},{\"type\":\"grass\",\"position\":[58.6444566277541,0,108.01817079650476],\"scale\":1.1011927862417759},{\"type\":\"grass\",\"position\":[-3.3873243220536784,0,-5.033463325620654],\"scale\":0.9004932350834454},{\"type\":\"grass\",\"position\":[50.35572709174182,0,-57.02956097267322],\"scale\":0.8474161404932727},{\"type\":\"grass\",\"position\":[-34.71407820712455,0,-17.830618589781604],\"scale\":1.1566811354391837},{\"type\":\"grass\",\"position\":[-43.811462345631774,0,-23.65903141594753],\"scale\":0.8528498936292339},{\"type\":\"grass\",\"position\":[26.604593773222458,0,-16.04213564069389],\"scale\":0.9609448356615234},{\"type\":\"grass\",\"position\":[-34.83709722989944,0,103.45388390125123],\"scale\":0.8644854392415438},{\"type\":\"grass\",\"position\":[-0.29467448093299065,0,-79.54778038892377],\"scale\":0.7559762724084789},{\"type\":\"grass\",\"position\":[66.40251816096486,0,127.8517153331235],\"scale\":1.2727979802197522},{\"type\":\"grass\",\"position\":[-135.52620099523344,0,10.989636812296796],\"scale\":0.9658257273020325},{\"type\":\"grass\",\"position\":[36.81253271158167,0,42.70692246534691],\"scale\":1.0739543827831222},{\"type\":\"grass\",\"position\":[71.73240864806425,0,98.02264173904985],\"scale\":1.2921647008317854},{\"type\":\"grass\",\"position\":[-36.33116036136975,0,33.59547255927587],\"scale\":1.1921786024184464},{\"type\":\"grass\",\"position\":[-13.216801329135672,0,-44.89261053874058],\"scale\":0.7818026590089688},{\"type\":\"grass\",\"position\":[9.631377145927159,0,105.98699536115292],\"scale\":0.8662349120409935},{\"type\":\"grass\",\"position\":[28.417045944707077,0,-70.91521447990954],\"scale\":0.7929967464289273},{\"type\":\"grass\",\"position\":[19.47375749416336,0,71.72176600654987],\"scale\":0.7890179010633682},{\"type\":\"grass\",\"position\":[46.10578813581108,0,-12.877048786178447],\"scale\":0.7068022220850418},{\"type\":\"grass\",\"position\":[-88.2347507385863,0,14.66021681944339],\"scale\":0.9255800233069892},{\"type\":\"grass\",\"position\":[-0.03793984977268089,0,-0.00877338770210786],\"scale\":1.0768909215669338},{\"type\":\"grass\",\"position\":[74.59548585304296,0,-3.5649722111252955],\"scale\":0.9658893009048429},{\"type\":\"grass\",\"position\":[30.431328608755695,0,62.676859764513075],\"scale\":1.1770872125848466},{\"type\":\"grass\",\"position\":[-60.59015961829057,0,-68.49445791982613],\"scale\":0.9909460098602323},{\"type\":\"grass\",\"position\":[58.853438668315746,0,71.05918822854632],\"scale\":0.7954905100235938},{\"type\":\"grass\",\"position\":[26.88897019849233,0,147.41504747718676],\"scale\":1.2581010953965208},{\"type\":\"grass\",\"position\":[-4.564742476085816,0,29.973976209824443],\"scale\":1.2978097025105584},{\"type\":\"grass\",\"position\":[-0.9489062260870964,0,-7.475312982768636],\"scale\":1.2649059661316724},{\"type\":\"grass\",\"position\":[88.55028748743494,0,-55.2277958640338],\"scale\":1.0388808802115006},{\"type\":\"grass\",\"position\":[-63.2196146657891,0,97.48780993311075],\"scale\":0.7911169850155407},{\"type\":\"grass\",\"position\":[82.85051586896208,0,-30.714678843872356],\"scale\":0.7374189982339194},{\"type\":\"grass\",\"position\":[-96.01256438425133,0,-54.26081505394388],\"scale\":1.0694388855206927},{\"type\":\"grass\",\"position\":[-74.53178677658259,0,13.58904254400501],\"scale\":1.1823173722742002},{\"type\":\"grass\",\"position\":[16.064882244307924,0,53.80121578982736],\"scale\":0.9440859485966628},{\"type\":\"grass\",\"position\":[-33.73646726531914,0,136.18475901105967],\"scale\":1.1647968624737808},{\"type\":\"grass\",\"position\":[16.177338094816594,0,3.818964754154076],\"scale\":0.8891129888544748},{\"type\":\"grass\",\"position\":[-15.125401527936162,0,16.24891824790047],\"scale\":1.2786028597315975},{\"type\":\"grass\",\"position\":[12.686448861310517,0,-79.61551788404854],\"scale\":0.9089627470110404},{\"type\":\"grass\",\"position\":[-4.706987011622678,0,36.780606054842195],\"scale\":1.243877657110187},{\"type\":\"grass\",\"position\":[33.040392052581566,0,2.086990643788519],\"scale\":0.7128649476717035},{\"type\":\"grass\",\"position\":[-49.23846995319008,0,-11.502484783112356],\"scale\":0.9405339584008244},{\"type\":\"grass\",\"position\":[16.93955734542479,0,2.278230999007192],\"scale\":1.1954660599407878},{\"type\":\"grass\",\"position\":[-43.398673902559814,0,-46.82334944368982],\"scale\":0.8225235066605865},{\"type\":\"grass\",\"position\":[41.07208048277062,0,-56.38032602920863],\"scale\":1.2763919523823697},{\"type\":\"grass\",\"position\":[63.33965894683665,0,78.3241714897116],\"scale\":1.0945094873656422},{\"type\":\"grass\",\"position\":[89.0040514509455,0,13.3236464660445],\"scale\":0.7754627350790039},{\"type\":\"grass\",\"position\":[-8.11610061493762,0,-9.02760787413848],\"scale\":0.9574591129516845},{\"type\":\"grass\",\"position\":[-41.2009312218143,0,14.478475668972452],\"scale\":0.7975685324754312},{\"type\":\"grass\",\"position\":[57.75599161730172,0,-47.73740856749953],\"scale\":1.2720922196394742},{\"type\":\"grass\",\"position\":[-65.41911818303555,0,16.68217227907543],\"scale\":1.162300259161257},{\"type\":\"grass\",\"position\":[-2.6850310262046904,0,-30.749929040456927],\"scale\":1.1640006003855337},{\"type\":\"grass\",\"position\":[72.4165366254966,0,-5.799073477513144],\"scale\":0.7557945808942426},{\"type\":\"grass\",\"position\":[74.6512311985251,0,-109.40673719039872],\"scale\":1.2462110505832102},{\"type\":\"grass\",\"position\":[-55.44907979856402,0,4.90249334429109],\"scale\":1.1722508366523132},{\"type\":\"grass\",\"position\":[39.41991708799735,0,57.8071267831997],\"scale\":1.0468092002517335},{\"type\":\"grass\",\"position\":[59.15134716541447,0,55.55787065948665],\"scale\":0.9323236611812806},{\"type\":\"grass\",\"position\":[21.587752465504426,0,12.789002448371495],\"scale\":0.7361492188313867},{\"type\":\"grass\",\"position\":[-50.96422661670211,0,88.12239300164336],\"scale\":0.8357291007139691},{\"type\":\"grass\",\"position\":[-35.52399319334899,0,-56.63339676148932],\"scale\":1.241541853758216},{\"type\":\"grass\",\"position\":[-131.65383653763843,0,-33.43772903167236],\"scale\":1.063909587997494},{\"type\":\"grass\",\"position\":[6.440018500750394,0,-5.832747414067027],\"scale\":0.9528158608071006},{\"type\":\"grass\",\"position\":[98.38496973847198,0,89.3700259043108],\"scale\":0.8197571686131192},{\"type\":\"grass\",\"position\":[-14.348126564541444,0,-106.3180112965442],\"scale\":1.2029991783821712},{\"type\":\"grass\",\"position\":[-52.37376171951702,0,42.16862923937993],\"scale\":1.1903233406288842},{\"type\":\"grass\",\"position\":[-5.3139665266352125,0,-29.908818134559684],\"scale\":0.944934823799463},{\"type\":\"grass\",\"position\":[-31.566461662688774,0,-5.22601722398646],\"scale\":1.069049509205272},{\"type\":\"grass\",\"position\":[7.083493867361407,0,-47.764696327925094],\"scale\":1.239811975820132},{\"type\":\"grass\",\"position\":[98.53499362075799,0,52.52574931213004],\"scale\":0.9718021465501672},{\"type\":\"grass\",\"position\":[-5.082302794832832,0,-9.714205058141378],\"scale\":1.0941801509518874},{\"type\":\"grass\",\"position\":[7.8527428928374645,0,1.7054515093952944],\"scale\":0.867367437308221},{\"type\":\"grass\",\"position\":[106.20737066605668,0,15.441493056078063],\"scale\":0.7285322399364255},{\"type\":\"grass\",\"position\":[73.9796632803243,0,25.348667316307303],\"scale\":0.7291898364270489},{\"type\":\"grass\",\"position\":[4.09922761311588,0,6.558109177427388],\"scale\":1.186827899468599},{\"type\":\"grass\",\"position\":[-41.213977384604505,0,-83.20260254792528],\"scale\":0.8821454466310726},{\"type\":\"grass\",\"position\":[-148.57183386668808,0,-16.24483529148487],\"scale\":0.9031039609747982},{\"type\":\"grass\",\"position\":[-112.13279566332878,0,-54.4900423219542],\"scale\":1.1260626709809891},{\"type\":\"grass\",\"position\":[-49.43527459804401,0,38.53220767595025],\"scale\":0.9233965029005073},{\"type\":\"grass\",\"position\":[-5.789304622698318,0,20.751689254494213],\"scale\":0.8576019380816516},{\"type\":\"grass\",\"position\":[-53.87213204787044,0,-124.82953116112414],\"scale\":0.9379062745553985},{\"type\":\"grass\",\"position\":[-29.08628543870859,0,6.044817464247439],\"scale\":1.1910429401711187},{\"type\":\"grass\",\"position\":[31.58760373221016,0,-2.422996283100785],\"scale\":1.2641124652251552},{\"type\":\"grass\",\"position\":[-57.292756567674175,0,56.36861889956108],\"scale\":0.9442284525624023},{\"type\":\"grass\",\"position\":[-40.33394072495099,0,-69.95217287579693],\"scale\":1.1242309222986895},{\"type\":\"grass\",\"position\":[71.20079182599444,0,59.21762181723293],\"scale\":0.9315608251582372},{\"type\":\"grass\",\"position\":[-114.1823511250569,0,0.9569716741766101],\"scale\":1.090950594610284},{\"type\":\"grass\",\"position\":[-53.34217901004017,0,89.82731957818244],\"scale\":1.2609468848652279},{\"type\":\"grass\",\"position\":[3.0359087242397513,0,3.522156053097446],\"scale\":0.93061755346947},{\"type\":\"grass\",\"position\":[5.413928774126355,0,28.36154734459217],\"scale\":1.2697077082400932},{\"type\":\"grass\",\"position\":[36.362143663789645,0,100.6343918117287],\"scale\":1.011124295129831},{\"type\":\"grass\",\"position\":[28.18078438331853,0,-23.61752033018171],\"scale\":1.102338166673103},{\"type\":\"grass\",\"position\":[-2.0205163745307546,0,-15.930880165612443],\"scale\":1.155408744321698},{\"type\":\"grass\",\"position\":[144.61472305588555,0,-0.846627020433316],\"scale\":1.135799997796969},{\"type\":\"grass\",\"position\":[86.46770008710591,0,7.808980337127191],\"scale\":0.9338727817837883},{\"type\":\"grass\",\"position\":[-19.114880274177203,0,83.43001059863919],\"scale\":0.9751952163296328},{\"type\":\"grass\",\"position\":[-3.606537107518061,0,-23.25257196574008],\"scale\":0.872010138938967},{\"type\":\"grass\",\"position\":[-15.52423286860705,0,0.0532520037655522],\"scale\":0.928568918243894},{\"type\":\"grass\",\"position\":[-42.55347008036532,0,-44.99210402677101],\"scale\":1.2292663455056814},{\"type\":\"grass\",\"position\":[20.257969653173756,0,-59.234032013714796],\"scale\":0.806414242595502},{\"type\":\"grass\",\"position\":[123.22838233087359,0,-67.85713463429975],\"scale\":0.7837447220885729},{\"type\":\"grass\",\"position\":[81.92436202769018,0,-117.45295987741574],\"scale\":1.0031774501694026},{\"type\":\"grass\",\"position\":[9.381458145003728,0,4.051927159969126],\"scale\":0.8207477269725123},{\"type\":\"grass\",\"position\":[6.8452439139964865,0,-5.283715694247334],\"scale\":1.263863345931179},{\"type\":\"grass\",\"position\":[18.683507819182825,0,11.609797367008023],\"scale\":1.2660834865772106},{\"type\":\"grass\",\"position\":[58.111947651477294,0,-125.22979429189428],\"scale\":0.9669834446614768},{\"type\":\"grass\",\"position\":[-10.984430985616601,0,-13.951074243848538],\"scale\":0.8011944683368675},{\"type\":\"grass\",\"position\":[2.5797127394225496,0,85.75982721698747],\"scale\":1.231385901801378},{\"type\":\"grass\",\"position\":[42.2079613835137,0,32.95063753568697],\"scale\":1.1143850893692073},{\"type\":\"grass\",\"position\":[125.87821072462896,0,-60.86548580206362],\"scale\":1.2276109104951713},{\"type\":\"grass\",\"position\":[25.233205473477604,0,56.00801216940076],\"scale\":0.8901525838552544},{\"type\":\"grass\",\"position\":[-60.12935137156412,0,-12.047764501275644],\"scale\":0.9040388610812677},{\"type\":\"grass\",\"position\":[97.58675020126171,0,-76.89315301500709],\"scale\":0.7149879335697834},{\"type\":\"grass\",\"position\":[-1.7069071592305294,0,1.3718420081497333],\"scale\":1.0668021085693598},{\"type\":\"grass\",\"position\":[-89.18539701212008,0,47.61463612611112],\"scale\":1.066571216248304},{\"type\":\"grass\",\"position\":[32.030000370359666,0,2.546608258739999],\"scale\":0.9903698751278882},{\"type\":\"grass\",\"position\":[62.525506373817755,0,-66.828818635036],\"scale\":0.7392709578381225},{\"type\":\"grass\",\"position\":[64.23899836303465,0,-47.22994069027299],\"scale\":0.9233539706305318},{\"type\":\"grass\",\"position\":[19.497868271827663,0,-22.584505941155932],\"scale\":1.1707806060281363},{\"type\":\"grass\",\"position\":[27.768403229845738,0,-69.41733124182085],\"scale\":1.121165399077431},{\"type\":\"grass\",\"position\":[17.74375211395474,0,-40.59359023203294],\"scale\":1.0382708467328707},{\"type\":\"grass\",\"position\":[-44.81945966802017,0,142.2635726226668],\"scale\":1.2225770977909591},{\"type\":\"grass\",\"position\":[7.605643665000366,0,-8.564011574938021],\"scale\":0.7956061496189949},{\"type\":\"grass\",\"position\":[-28.72898607575601,0,-102.84019926484207],\"scale\":1.2846616875411194},{\"type\":\"grass\",\"position\":[-57.12626620213961,0,128.0485608482598],\"scale\":0.7745648874811218},{\"type\":\"grass\",\"position\":[69.47651968852472,0,84.70272878490564],\"scale\":0.9563091526715144},{\"type\":\"grass\",\"position\":[17.235338695451762,0,-2.4791331669160024],\"scale\":1.1917406386052203},{\"type\":\"grass\",\"position\":[-113.29855328444569,0,39.12438249406837],\"scale\":0.8065851615557923},{\"type\":\"grass\",\"position\":[35.27647641728853,0,30.506668633162256],\"scale\":0.8434360039412554},{\"type\":\"grass\",\"position\":[3.0285543877903165,0,15.88700062668553],\"scale\":1.006023726790099},{\"type\":\"grass\",\"position\":[-18.551069710862873,0,-1.624548642453785],\"scale\":1.0208928703702778},{\"type\":\"grass\",\"position\":[10.680121829538178,0,-115.5229038631119],\"scale\":1.0323484649233525},{\"type\":\"grass\",\"position\":[19.580246239179957,0,-7.493601945551393],\"scale\":0.9644094940161854},{\"type\":\"grass\",\"position\":[93.56743410244354,0,-47.83884119263076],\"scale\":0.7156365001519406},{\"type\":\"grass\",\"position\":[-2.7409614623040044,0,-19.048652729745655],\"scale\":0.9335495064891621},{\"type\":\"grass\",\"position\":[-95.907102499663,0,-60.841273336603905],\"scale\":1.2337324163942989},{\"type\":\"grass\",\"position\":[15.93324829634655,0,76.96434721139855],\"scale\":0.7171906410429045},{\"type\":\"grass\",\"position\":[109.93344180355356,0,-46.63465148551539],\"scale\":1.0321589484463218},{\"type\":\"grass\",\"position\":[-47.107127744664766,0,17.236644953940154],\"scale\":0.9637956661853894},{\"type\":\"grass\",\"position\":[39.32295745229944,0,36.138859290624815],\"scale\":0.8982383759599497},{\"type\":\"grass\",\"position\":[5.6776675294748635,0,-4.450682791834938],\"scale\":1.2010231588879556},{\"type\":\"grass\",\"position\":[-33.94176712486358,0,-82.9484279406344],\"scale\":0.8354692877665368},{\"type\":\"grass\",\"position\":[-12.338853565125653,0,-25.918554159822595],\"scale\":1.292426931782563},{\"type\":\"grass\",\"position\":[116.34905620148149,0,-72.5399889161752],\"scale\":1.2963081767842743},{\"type\":\"grass\",\"position\":[-7.940469564408657,0,-107.8474378806433],\"scale\":0.7454859794150395},{\"type\":\"grass\",\"position\":[-58.642178692299375,0,82.54194750775437],\"scale\":1.0336078948308847},{\"type\":\"grass\",\"position\":[-3.3073995923102553,0,-21.999619108745723],\"scale\":1.0987306438692186},{\"type\":\"grass\",\"position\":[2.3199563544672297,0,86.36131197144896],\"scale\":1.2145129960403032},{\"type\":\"grass\",\"position\":[32.09484207490068,0,-17.60670543171015],\"scale\":0.8260838165613122},{\"type\":\"grass\",\"position\":[-9.87916787709947,0,-4.858291417999775],\"scale\":1.0296358523638038},{\"type\":\"grass\",\"position\":[-78.3013966013689,0,-66.24976786314521],\"scale\":1.2959572299055542},{\"type\":\"grass\",\"position\":[-4.640512999161775,0,-7.389290857585841],\"scale\":1.0399488853195158},{\"type\":\"grass\",\"position\":[54.51505471888637,0,93.10361284176238],\"scale\":1.2899500177039718},{\"type\":\"grass\",\"position\":[9.797260860739119,0,47.36696717606646],\"scale\":0.9801186152468668},{\"type\":\"grass\",\"position\":[-23.288904297978185,0,-9.281974552417315],\"scale\":1.0980926589042044},{\"type\":\"grass\",\"position\":[2.940336120998425,0,-25.25274072080938],\"scale\":1.0975756700770425},{\"type\":\"grass\",\"position\":[74.47704866727403,0,38.32984873740301],\"scale\":0.9134976875156097},{\"type\":\"grass\",\"position\":[14.897100707349962,0,-92.65490911056773],\"scale\":1.2176984231370565},{\"type\":\"grass\",\"position\":[-19.623965020433506,0,13.217282533963003],\"scale\":0.7906552682614567},{\"type\":\"grass\",\"position\":[-0.2343296131738309,0,0.732824736795437],\"scale\":0.8341303649351566},{\"type\":\"grass\",\"position\":[-25.41656515397821,0,-126.34758898285092],\"scale\":1.1066779301151624},{\"type\":\"grass\",\"position\":[-113.17860283398862,0,-4.770767766079477],\"scale\":0.8601299135898863},{\"type\":\"grass\",\"position\":[-62.88960296057457,0,93.66064299655302],\"scale\":1.0942438942769557},{\"type\":\"grass\",\"position\":[110.97339344564125,0,83.34300846136723],\"scale\":1.15029741634786},{\"type\":\"grass\",\"position\":[24.01679911697344,0,-7.933990297176231],\"scale\":1.1025898083878174},{\"type\":\"grass\",\"position\":[-35.91009342805451,0,101.81685198089014],\"scale\":1.0240894087338828},{\"type\":\"grass\",\"position\":[1.3072008072492043,0,-75.57150823041884],\"scale\":0.7619922086249759},{\"type\":\"grass\",\"position\":[-1.5026599463820582,0,-100.35413345418158],\"scale\":1.1121167534403773},{\"type\":\"grass\",\"position\":[84.76860408218802,0,9.716215628122008],\"scale\":1.281525567018257},{\"type\":\"grass\",\"position\":[-73.8254517431295,0,80.0359377316298],\"scale\":0.8771757170912009},{\"type\":\"grass\",\"position\":[-3.1104383039819408,0,18.40158913009521],\"scale\":1.0254600957569875},{\"type\":\"grass\",\"position\":[7.4072150178437575,0,47.54327402871907],\"scale\":1.0598193975438444},{\"type\":\"grass\",\"position\":[42.37796312394666,0,-40.82450543214397],\"scale\":1.1080467223520065},{\"type\":\"grass\",\"position\":[100.48828209858272,0,-29.298502703738126],\"scale\":1.1631700633121687},{\"type\":\"grass\",\"position\":[-41.11699319980952,0,-16.671741629104574],\"scale\":1.1476858245048465},{\"type\":\"grass\",\"position\":[-4.722741972158184,0,-13.873459616328413],\"scale\":1.232586494792649},{\"type\":\"grass\",\"position\":[144.52078251605909,0,24.83151513551944],\"scale\":0.9456346479288452},{\"type\":\"grass\",\"position\":[29.771513564708563,0,-7.421009667021365],\"scale\":0.8459026013437062},{\"type\":\"grass\",\"position\":[-26.624065778141343,0,2.403831759368382],\"scale\":1.0926257421480827},{\"type\":\"grass\",\"position\":[-46.58168587460497,0,14.3026603708851],\"scale\":0.8230421846715374},{\"type\":\"grass\",\"position\":[-59.48042427947578,0,77.41671070714223],\"scale\":1.1388513163783502},{\"type\":\"grass\",\"position\":[-2.5151406803583143,0,-4.6543575535308515],\"scale\":0.7860159941540107},{\"type\":\"grass\",\"position\":[23.972055957567154,0,-37.19202240012063],\"scale\":0.9307948073381274},{\"type\":\"grass\",\"position\":[-15.338249288062322,0,-6.054922892818753],\"scale\":0.8509235052037739},{\"type\":\"grass\",\"position\":[27.634405667643932,0,35.607297254057706],\"scale\":1.1448258812196952},{\"type\":\"grass\",\"position\":[-102.84602555993025,0,-1.2709022184512357],\"scale\":1.078757910499956},{\"type\":\"grass\",\"position\":[-16.656610047544785,0,25.11118446094592],\"scale\":0.7881923173466878},{\"type\":\"grass\",\"position\":[123.12180276101012,0,63.64710997488425],\"scale\":1.1303856871424247},{\"type\":\"grass\",\"position\":[61.62869429300768,0,-27.813302307927348],\"scale\":1.2400543135903705},{\"type\":\"grass\",\"position\":[30.532808297854316,0,-33.41394390831989],\"scale\":1.007976895884405},{\"type\":\"grass\",\"position\":[3.617951363802914,0,-31.887283710497996],\"scale\":0.7661773134231843},{\"type\":\"grass\",\"position\":[-5.051442571979663,0,106.33474562272988],\"scale\":0.8900164717201589},{\"type\":\"grass\",\"position\":[128.97054951761237,0,40.37956567527148],\"scale\":0.8763208769791002},{\"type\":\"grass\",\"position\":[-34.83312664801639,0,19.00212557565277],\"scale\":1.0389845639592656},{\"type\":\"grass\",\"position\":[97.1600424827777,0,24.42994328453655],\"scale\":1.241984061152075},{\"type\":\"grass\",\"position\":[33.120050262244256,0,-58.14447461305313],\"scale\":0.9411248860335567},{\"type\":\"grass\",\"position\":[-115.07922352896416,0,18.74354400411067],\"scale\":0.7679532578302319},{\"type\":\"grass\",\"position\":[62.87694612989288,0,-2.2569325081705585],\"scale\":0.7703018485567472},{\"type\":\"grass\",\"position\":[-23.707399150993503,0,-91.5847345324663],\"scale\":0.9696905603090886},{\"type\":\"grass\",\"position\":[24.291162849750375,0,1.1843331695736061],\"scale\":0.9652334056989178},{\"type\":\"grass\",\"position\":[-87.55028418701546,0,117.03508880365126],\"scale\":1.273737451406534},{\"type\":\"grass\",\"position\":[-4.2344347832104186,0,-4.911487861632785],\"scale\":1.085255732265963},{\"type\":\"grass\",\"position\":[-17.70839463320368,0,21.496157596837563],\"scale\":1.2414560877822773},{\"type\":\"grass\",\"position\":[-142.06688528820692,0,35.31420539345581],\"scale\":1.1198417453729093},{\"type\":\"grass\",\"position\":[79.9846667770541,0,99.4713905677638],\"scale\":1.174207698990088},{\"type\":\"grass\",\"position\":[19.41888997973413,0,46.01825406042097],\"scale\":1.134783187996395},{\"type\":\"grass\",\"position\":[0.7417381195712726,0,21.15857458594487],\"scale\":0.9005558671392164},{\"type\":\"grass\",\"position\":[13.401778798377373,0,-31.941380679543883],\"scale\":1.0040554519026468},{\"type\":\"grass\",\"position\":[21.155118616222808,0,-14.954037893941498],\"scale\":0.728958707007831},{\"type\":\"grass\",\"position\":[108.80778386805204,0,46.70394825488651],\"scale\":0.8836688430937357},{\"type\":\"grass\",\"position\":[-44.41449905121117,0,-100.76419181357078],\"scale\":0.8579042203919689},{\"type\":\"grass\",\"position\":[107.18185071908682,0,-71.06011587336391],\"scale\":0.9825077177930728},{\"type\":\"grass\",\"position\":[56.27506994762582,0,-102.74958941932137],\"scale\":0.8746694179333266},{\"type\":\"grass\",\"position\":[61.497918692202326,0,102.93881580428784],\"scale\":1.122141967277951},{\"type\":\"grass\",\"position\":[-31.606548911109474,0,-27.641212278897612],\"scale\":1.1866270884751553},{\"type\":\"grass\",\"position\":[67.9116014939739,0,-100.69701842489863],\"scale\":1.2333533599076527},{\"type\":\"grass\",\"position\":[4.550977243053364,0,-20.588635328863596],\"scale\":1.2970423245397544},{\"type\":\"grass\",\"position\":[15.643132368979861,0,-22.16056798876434],\"scale\":1.2550698246323282},{\"type\":\"grass\",\"position\":[-68.53637854864664,0,107.56423964163824],\"scale\":1.1706953155093207},{\"type\":\"grass\",\"position\":[-6.655807977361789,0,-0.292730442737243],\"scale\":1.1567510094307156},{\"type\":\"grass\",\"position\":[85.9405023188703,0,-74.93908359740982],\"scale\":1.1760163662786645},{\"type\":\"grass\",\"position\":[-143.6942550481503,0,-2.3136960032766156],\"scale\":0.9894014862690286},{\"type\":\"grass\",\"position\":[99.88234776428003,0,-84.18841493857802],\"scale\":0.7018331140102559},{\"type\":\"grass\",\"position\":[-148.76005363039314,0,-7.223884342459188],\"scale\":0.8347413480876544},{\"type\":\"grass\",\"position\":[16.33440357068166,0,-18.060869359879465],\"scale\":0.9362786428347789},{\"type\":\"grass\",\"position\":[33.9123736275187,0,-95.24445562672912],\"scale\":0.8937582854178914},{\"type\":\"grass\",\"position\":[8.630934064315866,0,-41.719835017241614],\"scale\":1.2432114538406664},{\"type\":\"grass\",\"position\":[73.54367755209005,0,13.234098669720108],\"scale\":1.2999596337054764},{\"type\":\"grass\",\"position\":[35.035370658926965,0,62.30818613538035],\"scale\":0.8797564520931828},{\"type\":\"grass\",\"position\":[-88.01184073217814,0,-41.373293754682344],\"scale\":0.8388166782992668},{\"type\":\"grass\",\"position\":[-53.422271430262775,0,61.11594704786315],\"scale\":1.0658968527789094},{\"type\":\"grass\",\"position\":[-44.91702483532065,0,-61.81803289339253],\"scale\":1.0471782827683955},{\"type\":\"grass\",\"position\":[-2.401245841624212,0,65.4041370974825],\"scale\":1.243241041299075},{\"type\":\"grass\",\"position\":[36.23695849840192,0,22.6901350358796],\"scale\":1.2306755686541795},{\"type\":\"grass\",\"position\":[145.5711108845979,0,-33.386966168647696],\"scale\":1.2430373929179557},{\"type\":\"grass\",\"position\":[55.753195448279,0,83.11505555715087],\"scale\":0.8120607738068261},{\"type\":\"grass\",\"position\":[23.110655325974914,0,135.94562950351482],\"scale\":1.217377890990924},{\"type\":\"grass\",\"position\":[-12.068028326498144,0,83.61731733249832],\"scale\":1.2331102477653322},{\"type\":\"grass\",\"position\":[-12.6465812586456,0,80.57067405357644],\"scale\":1.1946737130380662},{\"type\":\"grass\",\"position\":[-48.971379684819965,0,6.08280779503498],\"scale\":0.872088467092253},{\"type\":\"grass\",\"position\":[-4.342226533445662,0,-14.770555108534033],\"scale\":0.8713768578521486},{\"type\":\"grass\",\"position\":[46.36019377907304,0,62.240447957171064],\"scale\":0.7032513938908418},{\"type\":\"grass\",\"position\":[-97.46859725949172,0,-54.35325670452165],\"scale\":0.8062423076480885},{\"type\":\"grass\",\"position\":[35.33895354588103,0,2.8216262081368986],\"scale\":1.0608263127005344},{\"type\":\"grass\",\"position\":[58.817024951658944,0,-92.0916196938575],\"scale\":1.0611666588391615},{\"type\":\"grass\",\"position\":[117.85620596026173,0,38.3799605460192],\"scale\":0.8016824693843112},{\"type\":\"grass\",\"position\":[-127.983471899814,0,47.615012112654306],\"scale\":1.2315277216159284},{\"type\":\"grass\",\"position\":[-36.88007093248078,0,91.29686466761129],\"scale\":0.8788704344353084},{\"type\":\"grass\",\"position\":[-76.42346215915282,0,-18.48856417636327],\"scale\":1.0358662890435837},{\"type\":\"grass\",\"position\":[18.020925288363284,0,28.915937925819865],\"scale\":1.178370463881084},{\"type\":\"grass\",\"position\":[-5.426860278628467,0,9.498082115993029],\"scale\":0.9882084366681219},{\"type\":\"grass\",\"position\":[35.729552038840175,0,41.16053981175486],\"scale\":1.166372094850964},{\"type\":\"grass\",\"position\":[61.3311364569171,0,24.962250504530214],\"scale\":1.1922104561631726},{\"type\":\"grass\",\"position\":[-126.60686674657622,0,-74.94071935561921],\"scale\":1.1300002391358919},{\"type\":\"grass\",\"position\":[97.25325646768553,0,-54.18734421301565],\"scale\":0.7386284892265601},{\"type\":\"grass\",\"position\":[50.65764657225973,0,117.88353103575706],\"scale\":0.8371293890695115},{\"type\":\"grass\",\"position\":[-103.81873517078263,0,-29.200004192275145],\"scale\":0.8102694244746639},{\"type\":\"grass\",\"position\":[-0.2332772130426538,0,-108.24784763389717],\"scale\":0.7079898655780936},{\"type\":\"grass\",\"position\":[-23.777406910933323,0,112.61181044989662],\"scale\":0.8988457767543205},{\"type\":\"grass\",\"position\":[26.741969517634278,0,-3.0800581821201325],\"scale\":0.9574459792970036},{\"type\":\"grass\",\"position\":[-4.49456194526869,0,-12.828531504028216],\"scale\":1.1447664254921726},{\"type\":\"grass\",\"position\":[18.606425726014585,0,113.020078048984],\"scale\":1.222475108189839},{\"type\":\"grass\",\"position\":[-49.65239132754358,0,-66.04627000832066],\"scale\":1.0471840558073708},{\"type\":\"grass\",\"position\":[122.26437716111586,0,-71.58379787451359],\"scale\":0.9387645106025283},{\"type\":\"grass\",\"position\":[118.12161541168821,0,-49.314688791858416],\"scale\":0.9434180984728064},{\"type\":\"grass\",\"position\":[-7.40019719359491,0,-16.932316151752662],\"scale\":0.9441142714028354},{\"type\":\"grass\",\"position\":[-17.7999723785942,0,11.480108580519127],\"scale\":1.0457230663930044},{\"type\":\"grass\",\"position\":[47.4201069595568,0,15.527681144536112],\"scale\":0.8834554027432232},{\"type\":\"grass\",\"position\":[68.00610663380417,0,-19.368141433717778],\"scale\":1.2694804558666326},{\"type\":\"grass\",\"position\":[11.145670486220032,0,-89.89976365224442],\"scale\":1.0301120784555358},{\"type\":\"grass\",\"position\":[16.138856467125294,0,-97.73897182431938],\"scale\":1.1256659676427052}]");

function initWorld(scene, weatherSystem) {
  validateFoliageMaterials();
  const sky = createSky();
  scene.add(sky);
  const stars = createStars();
  scene.add(stars);
  const moon = createMoon();
  moon.position.set(-50, 60, -30);
  scene.add(moon);
  const groundGeo = new PlaneGeometry(400, 400, 128, 128);
  const posAttribute = groundGeo.attributes.position;
  for (let i = 0; i < posAttribute.count; i++) {
    const x = posAttribute.getX(i);
    const y = posAttribute.getY(i);
    const zWorld = -y;
    const height = getGroundHeight(x, zWorld);
    posAttribute.setZ(i, height);
  }
  groundGeo.computeVertexNormals();
  const groundMat = new MeshPhysicalMaterial({
    color: CONFIG.colors.ground,
    roughness: 0.4,
    metalness: 0,
    clearcoat: 0.3,
    clearcoatRoughness: 0.6,
    flatShading: false
  });
  const ground = new Mesh(groundGeo, groundMat);
  ground.rotation.x = -Math.PI / 2;
  ground.receiveShadow = true;
  scene.add(ground);
  const fogColor = new Color(CONFIG.colors.fog || 16762323);
  scene.fog = new FogExp2(fogColor, 0.012);
  scene.background = fogColor;
  initGrassSystem(scene, 1e4);
  scene.add(createFireflies(150, 100));
  const melodyLake = createWaveformWater(400, 400);
  melodyLake.position.set(0, 2.5, 0);
  scene.add(melodyLake);
  initFallingBerries(scene);
  scene.add(worldGroup);
  generateMap(weatherSystem);
  spawnCave(weatherSystem);
  populateProceduralExtras(weatherSystem);
  return { sky, moon, ground };
}
async function initWorldAsync(scene, weatherSystem, onProgress) {
  validateFoliageMaterials();
  const sky = createSky();
  scene.add(sky);
  const stars = createStars();
  scene.add(stars);
  const moon = createMoon();
  moon.position.set(-50, 60, -30);
  scene.add(moon);
  const groundGeo = new PlaneGeometry(400, 400, 128, 128);
  const posAttribute = groundGeo.attributes.position;
  for (let i = 0; i < posAttribute.count; i++) {
    const x = posAttribute.getX(i);
    const y = posAttribute.getY(i);
    const zWorld = -y;
    const height = getGroundHeight(x, zWorld);
    posAttribute.setZ(i, height);
  }
  groundGeo.computeVertexNormals();
  const groundMat = new MeshPhysicalMaterial({
    color: CONFIG.colors.ground,
    roughness: 0.4,
    metalness: 0,
    clearcoat: 0.3,
    clearcoatRoughness: 0.6,
    flatShading: false
  });
  const ground = new Mesh(groundGeo, groundMat);
  ground.rotation.x = -Math.PI / 2;
  ground.receiveShadow = true;
  scene.add(ground);
  const fogColor = new Color(CONFIG.colors.fog || 16762323);
  scene.fog = new FogExp2(fogColor, 0.012);
  scene.background = fogColor;
  initGrassSystem(scene, 1e4);
  scene.add(createFireflies(150, 100));
  const melodyLake = createWaveformWater(400, 400);
  melodyLake.position.set(0, 2.5, 0);
  scene.add(melodyLake);
  initFallingBerries(scene);
  scene.add(worldGroup);
  if (onProgress) onProgress("map", 0, mapData.length);
  await generateMapAsync(weatherSystem, (loaded, total) => {
    if (onProgress) onProgress("map", loaded, total);
  });
  if (onProgress) onProgress("cave", 1, 1);
  spawnCave(weatherSystem);
  if (onProgress) onProgress("extras", 0, 40);
  await populateProceduralExtrasAsync(weatherSystem, (loaded, total) => {
    if (onProgress) onProgress("extras", loaded, total);
  });
  return { sky, moon, ground };
}
function safeAddFoliage(obj, isObstacle = false, radius = 1, weatherSystem = null) {
  if (animatedFoliage.length > 1e3) return;
  foliageGroup.add(obj);
  animatedFoliage.push(obj);
  if (isObstacle) obstacles.push({ position: obj.position.clone(), radius });
  if (obj.userData.type === "mushroom") foliageMushrooms.push(obj);
  if (obj.userData.type === "cloud") foliageClouds.push(obj);
  if (obj.userData.isTrampoline) foliageTrampolines.push(obj);
  if (weatherSystem) {
    if (obj.userData.type === "tree") {
      weatherSystem.registerTree(obj);
    } else if (obj.userData.type === "shrub") {
      weatherSystem.registerShrub(obj);
    } else if (obj.userData.type === "mushroom") {
      weatherSystem.registerMushroom(obj);
    } else if (obj.userData.type === "cave") {
      weatherSystem.registerCave(obj);
      registerPhysicsCave(obj);
    }
  }
}
function isPositionValid(x, z, radius) {
  const distFromCenterSq = x * x + z * z;
  if (distFromCenterSq < 15 * 15) return false;
  for (const obs of obstacles) {
    const dx = x - obs.position.x;
    const dz = z - obs.position.z;
    const distSq = dx * dx + dz * dz;
    const minDistance = obs.radius + radius + 1.5;
    if (distSq < minDistance * minDistance) return false;
  }
  return true;
}
async function generateMapAsync(weatherSystem, onProgress) {
  const entities = mapData;
  const total = entities.length;
  console.log(`[World] Loading map with ${total} entities (async batched)...`);
  const BATCH_SIZE = 50;
  for (let i = 0; i < total; i += BATCH_SIZE) {
    const batchEnd = Math.min(i + BATCH_SIZE, total);
    const batch = entities.slice(i, batchEnd);
    batch.forEach((item) => {
      processMapEntity(item, weatherSystem);
    });
    if (onProgress) {
      onProgress(batchEnd, total);
    }
    await new Promise((resolve) => setTimeout(resolve, 0));
  }
  console.log(`[World] Finished loading ${total} entities`);
}
function generateMap(weatherSystem) {
  console.log(`[World] Loading map with ${mapData.length} entities...`);
  mapData.forEach((item) => {
    processMapEntity(item, weatherSystem);
  });
}
function processMapEntity(item, weatherSystem) {
  const [x, yInput, z] = item.position;
  const groundY = getGroundHeight(x, z);
  let y = groundY;
  if (item.type === "cloud") y = yInput;
  try {
    let obj = null;
    let isObstacle = false;
    let radius = 0.5;
    if (item.type === "mushroom") {
      const isGiant = item.variant === "giant";
      const scale = item.scale || 1;
      const hasFace = item.hasFace !== void 0 ? item.hasFace : isGiant || Math.random() < 0.1;
      const isBouncy = isGiant || hasFace;
      obj = createMushroom({
        size: isGiant ? "giant" : "regular",
        scale,
        hasFace,
        isBouncy,
        note: item.note,
        noteIndex: item.noteIndex
      });
      isObstacle = true;
      radius = isGiant ? 2 : 0.5;
    } else if (item.type === "flower") {
      const isGlowing = item.variant === "glowing";
      obj = isGlowing ? createGlowingFlower() : createFlower();
    } else if (item.type === "cloud") {
      obj = createRainingCloud({ size: item.size || 1.5 });
    } else if (item.type === "grass") {
      addGrassInstance(x, y, z);
      return;
    } else if (item.type === "subwoofer_lotus") {
      obj = createSubwooferLotus({ scale: item.scale || 1 });
    } else if (item.type === "accordion_palm") {
      obj = createAccordionPalm({ color: 16766720 });
      isObstacle = true;
    } else if (item.type === "fiber_optic_willow") {
      obj = createFiberOpticWillow();
      isObstacle = true;
    } else if (item.type === "floating_orb") {
      obj = createFloatingOrb({ size: 0.5 });
      y += 1.5;
    } else if (item.type === "swingable_vine") {
      obj = createSwingableVine({ length: 8 });
      y += 8;
      if (vineSwings) vineSwings.push(new VineSwing(obj, 8));
    } else if (item.type === "prism_rose_bush") {
      obj = createPrismRoseBush();
      isObstacle = true;
    } else if (item.type === "starflower") {
      obj = createStarflower();
    } else if (item.type === "vibrato_violet") {
      obj = createVibratoViolet();
    } else if (item.type === "tremolo_tulip") {
      obj = createTremoloTulip();
    } else if (item.type === "kick_drum_geyser") {
      obj = createKickDrumGeyser();
    } else if (item.type === "arpeggio_fern") {
      obj = createArpeggioFern({ scale: item.scale || 1 });
    } else if (item.type === "portamento_pine") {
      obj = createPortamentoPine({ height: 4 });
      isObstacle = true;
    } else if (item.type === "cymbal_dandelion") {
      obj = createCymbalDandelion();
    } else if (item.type === "snare_trap") {
      obj = createSnareTrap();
    } else if (item.type === "panning_pad") {
      const panBias = x < 0 ? -1 : 1;
      obj = createPanningPad({ radius: item.scale || 1, panBias });
      if (y < 2) y = 1;
    } else if (item.type === "silence_spirit") {
      obj = createSilenceSpirit({ scale: item.scale || 1 });
    } else if (item.type === "instrument_shrine") {
      const id = parseInt(item.variant || "0", 10);
      obj = createInstrumentShrine({ instrumentID: id, scale: item.scale || 1 });
      isObstacle = true;
      radius = 1;
    } else if (item.type === "bubble_willow") {
      obj = createBubbleWillow();
      isObstacle = true;
    } else if (item.type === "helix_plant") {
      obj = createHelixPlant();
    } else if (item.type === "balloon_bush") {
      obj = createBalloonBush();
    } else if (item.type === "wisteria_cluster") {
      obj = createWisteriaCluster();
      y += 4;
    }
    if (obj) {
      obj.position.set(x, y, z);
      obj.rotation.y = Math.random() * Math.PI * 2;
      if (item.scale && item.type !== "mushroom" && item.type !== "flower") {
        obj.scale.setScalar(item.scale);
      }
      safeAddFoliage(obj, isObstacle, radius, weatherSystem);
    }
  } catch (e) {
    console.warn(`[World] Failed to spawn ${item.type} at ${x},${z}`, e);
  }
}
function spawnCave(weatherSystem) {
  const cave = createCaveEntrance({ scale: 2 });
  const caveX = 25;
  const caveZ = 25;
  const caveY = getGroundHeight(caveX, caveZ);
  cave.position.set(caveX, caveY, caveZ);
  cave.lookAt(0, caveY, 0);
  safeAddFoliage(cave, false, 0, weatherSystem);
  console.log("[World] Cave spawned at ", caveX, caveZ);
}
async function populateProceduralExtrasAsync(weatherSystem, onProgress) {
  console.log("[World] Populating procedural extras (async)...");
  if (window.setLoadingStatus) window.setLoadingStatus("Growing Procedural Flora...");
  const extrasCount = 200;
  const range = 150;
  const BATCH_SIZE = 5;
  for (let i = 0; i < extrasCount; i += BATCH_SIZE) {
    const batchEnd = Math.min(i + BATCH_SIZE, extrasCount);
    for (let j = i; j < batchEnd; j++) {
      processProceduralExtra(j, range, weatherSystem);
    }
    if (onProgress) {
      onProgress(batchEnd, extrasCount);
    }
    await new Promise((resolve) => setTimeout(resolve, 0));
  }
  console.log("[World] Finished populating procedural extras.");
}
function processProceduralExtra(index, range, weatherSystem) {
  let obj = null;
  let isObstacle = false;
  let radius = 0.5;
  let x = 0, z = 0, y = 0;
  let attempts = 0;
  let validPosition = false;
  while (attempts < 10) {
    x = (Math.random() - 0.5) * range;
    z = (Math.random() - 0.5) * range;
    if (isPositionValid(x, z, 1.5)) {
      validPosition = true;
      break;
    }
    attempts++;
  }
  if (!validPosition) return;
  const groundY = getGroundHeight(x, z);
  try {
    const rand = Math.random();
    if (rand < 0.3) {
      obj = Math.random() < 0.5 ? createFlower() : createGlowingFlower();
      obj.position.set(x, groundY, z);
    } else if (rand < 0.45) {
      obj = createMushroom({
        size: "regular",
        scale: 0.8 + Math.random() * 0.5,
        hasFace: true,
        isBouncy: true
      });
      obj.position.set(x, groundY, z);
      isObstacle = true;
    } else if (rand < 0.55) {
      const treeType = Math.random();
      if (treeType < 0.33) obj = createBubbleWillow();
      else if (treeType < 0.66) obj = createBalloonBush();
      else obj = createHelixPlant();
      obj.position.set(x, groundY, z);
      isObstacle = true;
      radius = 1.5;
    } else if (rand < 0.75) {
      const type = Math.random();
      if (type < 0.2) {
        obj = createArpeggioFern({ scale: 1 + Math.random() * 0.5 });
      } else if (type < 0.35) {
        obj = createKickDrumGeyser({ maxHeight: 5 + Math.random() * 3 });
        radius = 1;
      } else if (type < 0.5) {
        obj = createSnareTrap({ scale: 0.8 + Math.random() * 0.4 });
        isObstacle = true;
        radius = 0.8;
      } else if (type < 0.6) {
        obj = createPortamentoPine({ height: 4 + Math.random() * 2 });
        isObstacle = true;
        radius = 0.5;
      } else if (type < 0.75) {
        obj = createTremoloTulip({ size: 1 + Math.random() * 0.5 });
      } else if (type < 0.85) {
        obj = createCymbalDandelion({ scale: 0.8 + Math.random() * 0.4 });
      } else {
        const panBias = x < 0 ? -1 : 1;
        obj = createPanningPad({ radius: 1.2 + Math.random(), panBias });
        obj.position.y = groundY + 0.5;
      }
      if (obj) obj.position.set(x, obj.position.y || groundY, z);
    } else if (rand < 0.9) {
      const isHigh = Math.random() < 0.5;
      y = isHigh ? 35 + Math.random() * 20 : 12 + Math.random() * 10;
      obj = createRainingCloud({ size: 1 + Math.random() });
      obj.position.set(x, y, z);
    } else if (rand < 0.95) {
      obj = createSilenceSpirit();
      obj.position.set(x, groundY, z);
    } else {
      const id = Math.floor(Math.random() * 16);
      obj = createInstrumentShrine({ instrumentID: id });
      obj.position.set(x, groundY, z);
      isObstacle = true;
    }
    if (obj) {
      obj.rotation.y = Math.random() * Math.PI * 2;
      safeAddFoliage(obj, isObstacle, radius, weatherSystem);
    }
  } catch (e) {
    console.warn(`[World] Failed to spawn procedural extra at ${x},${z}`, e);
  }
}
function populateProceduralExtras(weatherSystem) {
  console.log("[World] Populating procedural extras...");
  if (window.setLoadingStatus) window.setLoadingStatus("Growing Procedural Flora...");
  const extrasCount = 200;
  const range = 150;
  for (let i = 0; i < extrasCount; i++) {
    processProceduralExtra(i, range, weatherSystem);
  }
  console.log("[World] Finished populating procedural extras.");
}

const PROJECTILES = [];
const SPEED = 60.0;
const RADIUS = 0.5;

// Reusable Geometry/Material
const projectileGeo = new SphereGeometry(RADIUS, 8, 8);
const projectileMat = createCandyMaterial(0xFFFFFF); // Base white, we'll color it per shot

function fireRainbow(scene, origin, direction) {
    const mesh = new Mesh(projectileGeo, projectileMat.clone());
    
    // Rainbow Colors!
    const time = performance.now() / 1000;
    const hue = (time * 0.5) % 1.0;
    mesh.material.color.setHSL(hue, 1.0, 0.5);
    mesh.material.emissive.setHSL(hue, 1.0, 0.8);
    mesh.material.emissiveIntensity = 2.0;

    mesh.position.copy(origin);
    mesh.userData.velocity = direction.clone().normalize().multiplyScalar(SPEED);
    mesh.userData.life = 3.0; // Seconds before disappearing

    scene.add(mesh);
    PROJECTILES.push(mesh);

    // Sound effect hook (optional)
    // playSound('pew'); 
}

function updateBlaster(dt, scene, weatherSystem, currentTime) {
    const celestial = getCelestialState(currentTime);
    const isDay = celestial.sunIntensity > 0.5;

    for (let i = PROJECTILES.length - 1; i >= 0; i--) {
        const p = PROJECTILES[i];
        
        // Move
        p.position.addScaledVector(p.userData.velocity, dt);
        p.userData.life -= dt;

        let hit = false;

        // Check Collision with Clouds
        for (let j = foliageClouds.length - 1; j >= 0; j--) {
            const cloud = foliageClouds[j];
            const cloudRadius = 3.0 * (cloud.scale.x || 1.0);
            const distSq = p.position.distanceToSquared(cloud.position);

            if (distSq < (cloudRadius * cloudRadius)) {
                hit = true;
                
                // --- NEW: Trigger Different Effects based on Time ---
                if (isDay) {
                    knockDownCloudMist(cloud, scene); // Day: Evaporate into Mist
                } else {
                    knockDownCloudDeluge(cloud, scene); // Night: Heavy Rain Burst
                }

                // Notify Weather System to reduce rain density
                if (weatherSystem && weatherSystem.notifyCloudShot) {
                    weatherSystem.notifyCloudShot(isDay);
                }
                // ----------------------------------------------------
                break; 
            }
        }

        if (hit || p.userData.life <= 0) {
            scene.remove(p);
            PROJECTILES.splice(i, 1);
        }
    }
    
    // Update Burst Effects (Simple particle cleanup)
    updateBursts(dt, scene);
}

// --- NEW: Visual Effects for Cloud Destruction ---

const BURSTS = [];

function createBurst(scene, position, color, type) {
    const count = 15;
    const geo = new BufferGeometry();
    const posArray = new Float32Array(count * 3);
    const normArray = new Float32Array(count * 3);
    const velArray = [];
    
    for(let i=0; i<count; i++) {
        posArray[i*3] = position.x + (Math.random()-0.5)*2;
        posArray[i*3+1] = position.y + (Math.random()-0.5)*2;
        posArray[i*3+2] = position.z + (Math.random()-0.5)*2;
        
        // Dummy Normal
        normArray[i*3] = 0; normArray[i*3+1] = 1; normArray[i*3+2] = 0;

        if (type === 'mist') {
            // Float up/out
            velArray.push(new Vector3((Math.random()-0.5)*2, Math.random()*2, (Math.random()-0.5)*2));
        } else {
            // Rain down hard
            velArray.push(new Vector3((Math.random()-0.5)*1, -10 - Math.random()*5, (Math.random()-0.5)*1));
        }
    }
    
    geo.setAttribute('position', new BufferAttribute(posArray, 3));
    geo.setAttribute('normal', new BufferAttribute(normArray, 3));
    
    const mat = new PointsMaterial({
        color: color,
        size: type === 'mist' ? 1.5 : 0.5,
        transparent: true,
        opacity: 0.8,
        blending: AdditiveBlending
    });
    
    const points = new Points(geo, mat);
    points.userData = { velocities: velArray, life: 1.5, type: type };
    
    scene.add(points);
    BURSTS.push(points);
}

function updateBursts(dt, scene) {
    for (let i = BURSTS.length - 1; i >= 0; i--) {
        const b = BURSTS[i];
        b.userData.life -= dt;
        
        const pos = b.geometry.attributes.position.array;
        const vels = b.userData.velocities;
        
        for(let k=0; k<vels.length; k++) {
            pos[k*3] += vels[k].x * dt;
            pos[k*3+1] += vels[k].y * dt;
            pos[k*3+2] += vels[k].z * dt;
        }
        b.geometry.attributes.position.needsUpdate = true;
        b.material.opacity = b.userData.life; // Fade out

        if (b.userData.life <= 0) {
            scene.remove(b);
            b.geometry.dispose();
            b.material.dispose();
            BURSTS.splice(i, 1);
        }
    }
}

function knockDownCloudMist(cloud, scene) {
    if (cloud.userData.isFalling) return;
    cloud.userData.isFalling = true; // Mark as "dead" so we don't hit it again
    
    // Visual: Flash then shrinking/fading up
    cloud.userData.velocity = new Vector3(0, 5.0, 0); // Float UP (Evaporate)
    
    // Create Mist Burst
    createBurst(scene, cloud.position, 0xFFFFFF, 'mist');
    
    // Scale down rapidly in update loop (handled by clouds.js logic mostly, but we can override velocity)
    cloud.traverse(c => {
        if (c.isMesh && c.material) {
            c.material.transparent = true;
            c.material.opacity = 0.5; // Ghostly
        }
    });
}

function knockDownCloudDeluge(cloud, scene) {
    if (cloud.userData.isFalling) return;
    cloud.userData.isFalling = true;

    // Visual: Heavy Drop
    cloud.userData.velocity = new Vector3(0, -20, 0); // Slam down
    
    // Create Rain Burst
    createBurst(scene, cloud.position, 0x0000FF, 'rain');

    cloud.traverse(c => {
        if (c.isMesh && c.material) {
            c.material.color.setHex(0x000088); // Turn dark blue
            c.material.emissive.setHex(0x0000FF);
        }
    });
}

// Optimization: Hoist reusable objects to module scope to prevent GC in animation loop
const COLOR_STORM_SKY_TOP = new Color(0x1A1A2E);
const COLOR_STORM_SKY_BOT = new Color(0x2E3A59);
const COLOR_STORM_FOG = new Color(0x4A5568);
const COLOR_RAIN = new Color(0xA0B5C8);
const COLOR_RAIN_FOG = new Color(0xC0D0E0);
new Vector3(0, 1, 0);

const _scratchBaseSkyTop = new Color();
const _scratchBaseSkyBot = new Color();
const _scratchBaseFog = new Color();
const _scratchSunVector = new Vector3();
const _scratchAuroraColor = new Color();

const _weatherBiasOutput = { biasState: 'clear', biasIntensity: 0, type: 'clear' };

// --- Initialization ---

// 1. Scene & Render Loop Setup
const { scene, camera, renderer, ambientLight, sunLight, sunGlow, sunCorona, lightShaftGroup, sunGlowMat, coronaMat } = initScene();

// [3] ADD THIS BLOCK immediately after initScene():
// -----------------------------------------------------
// Expose for debugging
window.scene = scene;
window.renderer = renderer;

// Install the TSL Diagnostic tool immediately using the local 'scene' variable
installDiagnostics(scene);
console.log(" TSL Diagnostics installed. Call window.scanForTSLErrors() to debug.");
// -----------------------------------------------------

// 2. Audio & Systems (Initialize but defer heavy loading)
const audioSystem = new AudioSystem();
const beatSync = new BeatSync(audioSystem);
const musicReactivity = new MusicReactivitySystem(scene, {}); // Config moved to internal default or passed if needed
const weatherSystem = new WeatherSystem(scene);

// Note-Trail Ribbons (Category 4)
// We need the player camera as the target.
const melodyRibbon = new MelodyRibbon(scene, camera, 50, 0.2);

// Chromatic Aberration Pulse (Category 4)
// Creates a lens overlay parented to camera
createKickOverlay(camera);

// 3. World Generation (Critical - load asynchronously with progress)
// We need to pass weatherSystem so foliage can register themselves
if (window.setLoadingStatus) window.setLoadingStatus("Loading World Map...");

// Use async world generation with progress updates
const worldLoadPromise = initWorldAsync(scene, weatherSystem, (phase, loaded, total) => {
    const percentage = Math.round((loaded / total) * 100);
    if (phase === 'map') {
        if (window.setLoadingStatus) {
            window.setLoadingStatus(`Loading World Map... ${percentage}% (${loaded}/${total})`);
        }
    } else if (phase === 'extras') {
        if (window.setLoadingStatus) {
            window.setLoadingStatus(`Growing Procedural Flora... ${percentage}% (${loaded}/${total})`);
        }
    } else if (phase === 'cave') {
        if (window.setLoadingStatus) {
            window.setLoadingStatus("Carving out caves...");
        }
    }
});

// Continue initialization while world loads
let moon, fireflies;
worldLoadPromise.then((worldObjects) => {
    moon = worldObjects.moon;
    fireflies = scene.children.find(c => c.userData?.type === 'fireflies');
    console.log('[World] Async world generation complete');
}).catch(err => {
    console.error('[World] Failed to load world:', err);
    // Fallback to synchronous loading
    const result = initWorld(scene, weatherSystem);
    moon = result.moon;
    fireflies = scene.children.find(c => c.userData?.type === 'fireflies');
});

// Validate node material geometries to avoid TSL attribute errors
validateNodeGeometries(scene);
// Note: world generation populates animatedFoliage, obstacles, etc. via state.js

// Defer non-critical visual elements to load after basic scene is ready
let aurora = null;
let celestialBodiesInitialized = false;

// Function to initialize deferred visual elements
function initDeferredVisuals() {
    if (!aurora) {
        // Add Spectrum Aurora
        aurora = createAurora();
        scene.add(aurora);
        console.log('[Deferred] Aurora initialized');
    }
    
    if (!celestialBodiesInitialized) {
        // Add Celestial Bodies
        initCelestialBodies(scene);
        celestialBodiesInitialized = true;
        console.log('[Deferred] Celestial bodies initialized');
    }
}

// 4. Input Handling
let isNight = false;
let timeOffset = 0;

function toggleDayNight() {
    timeOffset += CYCLE_DURATION / 2;
    // Update UI state
    const currentIsNight = !isNight; // Toggle logic approx
    inputSystem.updateDayNightButtonState(currentIsNight);
}

const inputSystem = initInput(camera, audioSystem, toggleDayNight);
const controls = inputSystem.controls;

// DEV: Demo triggers  press 'F' to trigger a 'C4' note on nearest flower; 'G' to spawn a flower in front of the camera
// This is intentionally small and safe for local testing; remove before production
window.addEventListener('keydown', (e) => {
    try {
        if (!e.key) return;
        const key = e.key.toLowerCase();
        if (key === 'p') {
            profiler.toggle();
        } else if (key === 'f') {
            let nearest = null;
            let bestDist = Infinity;
            const camPos = camera.position;
            for (let i = 0, l = animatedFoliage.length; i < l; i++) {
                const f = animatedFoliage[i];
                if (!f || f.userData?.type !== 'flower') continue;
                const d = f.position.distanceToSquared(camPos);
                if (d < bestDist) { bestDist = d; nearest = f; }
            }
            if (nearest) {
                musicReactivity.reactObject(nearest, 'C4', 1.0);
                console.log('Demo: triggered C4 on nearest flower', nearest);
            } else {
                console.log('Demo: no flowers found nearby');
            }
        } else if (key === 'g') {
            const dir = new Vector3();
            camera.getWorldDirection(dir);
            const pos = camera.position.clone().add(dir.multiplyScalar(3));
            const f = createFlower({ shape: 'layered' });
            f.position.copy(pos);
            f.rotation.y = Math.random() * Math.PI * 2;
            foliageGroup.add(f);
            animatedFoliage.push(f);
            console.log('Demo: spawned a flower at', f.position);
        } else if (key === 'h') {
            // Spawn a mushroom in front of the camera for mushroom palette testing
            const dir = new Vector3();
            camera.getWorldDirection(dir);
            const pos = camera.position.clone().add(dir.multiplyScalar(3));
            const m = createMushroom({ size: 'regular' });
            m.position.copy(pos);
            m.rotation.y = Math.random() * Math.PI * 2;
            foliageGroup.add(m);
            animatedFoliage.push(m);
            console.log('Demo: spawned a mushroom at', m.position);
        } else if (key === 't') {
            // Trigger C4 on nearest mushroom
            let nearest = null;
            let bestDist = Infinity;
            const camPos = camera.position;
            for (let i = 0, l = animatedFoliage.length; i < l; i++) {
                const f = animatedFoliage[i];
                if (!f || f.userData?.type !== 'mushroom') continue;
                const d = f.position.distanceToSquared(camPos);
                if (d < bestDist) { bestDist = d; nearest = f; }
            }
            if (nearest) {
                musicReactivity.reactObject(nearest, 'C4', 1.0);
                console.log('Demo: triggered C4 on nearest mushroom', nearest);
            } else {
                console.log('Demo: no mushrooms found nearby');
            }
        }
    } catch (err) {
        console.warn('Demo trigger error', err);
    }
});

// Mouse input: Rainbow Blaster (click while pointer locked)
window.addEventListener('mousedown', (e) => {
    if (document.pointerLockElement) {
        const dir = new Vector3();
        camera.getWorldDirection(dir);
        const origin = camera.position.clone().add(dir.clone().multiplyScalar(1.0));
        origin.y -= 0.2; // Lower slightly
        fireRainbow(scene, origin, dir);
    }
});

// --- Animation Loop State ---
const clock = new Clock();
let gameTime = 0; // Accumulates based on BPM
let audioState = null;
let lastBeatPhase = 0;
let beatFlashIntensity = 0;
let cameraZoomPulse = 0;
const baseFOV = 75;

// Register Beat Effects
beatSync.onBeat((state) => {
    const kickTrigger = state?.kickTrigger || 0;
    if (kickTrigger > 0.2) {
        beatFlashIntensity = Math.max(beatFlashIntensity, 0.4 + kickTrigger * 0.5);
        cameraZoomPulse = Math.max(cameraZoomPulse, 1 + kickTrigger * 3);
    }
    if (typeof uStarPulse !== 'undefined') {
        uStarPulse.value += 0.5 * (kickTrigger + 0.1);
    }
});

function getWeatherForTimeOfDay(cyclePos, audioData) {
    // Duplicate logic from original main.js for now, or move to weather.js as a static helper?
    // It's used to drive weather bias.
    // Let's keep it here for now as it orchestrates the cycle.
    const SUNRISE = DURATION_SUNRISE;
    const DAY = DURATION_DAY;
    const SUNSET = DURATION_SUNSET;
    const DUSK = 180; // DURATION_DUSK_NIGHT
    
    // Default reset
    _weatherBiasOutput.biasState = 'clear';
    _weatherBiasOutput.biasIntensity = 0;
    _weatherBiasOutput.type = 'clear';

    if (cyclePos < SUNRISE + 60) {
        const progress = (cyclePos / (SUNRISE + 60));
        _weatherBiasOutput.biasState = 'rain';
        _weatherBiasOutput.biasIntensity = 0.3 * (1 - progress);
        _weatherBiasOutput.type = 'mist';
    }
    else if (cyclePos > SUNRISE + 120 && cyclePos < SUNRISE + DAY - 60) {
        const stormChance = 0.0003;
        if (Math.random() < stormChance) {
             _weatherBiasOutput.biasState = 'storm';
             _weatherBiasOutput.biasIntensity = 0.7 + Math.random() * 0.3;
             _weatherBiasOutput.type = 'thunderstorm';
        }
    }
    else if (cyclePos > SUNRISE + DAY && cyclePos < SUNRISE + DAY + SUNSET + DUSK / 2) {
        const progress = (cyclePos - SUNRISE - DAY) / (SUNSET + DUSK / 2);
         _weatherBiasOutput.biasState = 'rain';
         _weatherBiasOutput.biasIntensity = 0.3 + progress * 0.2;
         _weatherBiasOutput.type = 'drizzle';
    }

    return _weatherBiasOutput;
}

function animate() {
    profiler.startFrame();

    const rawDelta = clock.getDelta();
    const delta = Math.min(rawDelta, 0.1);

    audioState = profiler.measure('Audio', () => audioSystem.update());
    profiler.measure('BeatSync', () => beatSync.update());

    // Time Dilation based on BPM (Inverse: Higher BPM = Slower Time)
    // Base BPM = 120. At 240 BPM, speed is 0.5. At 60 BPM, speed is 2.0.
    const currentBPM = audioState?.bpm || 120;
    const timeFactor = 120 / Math.max(10, currentBPM);
    gameTime += delta * timeFactor;
    
    const t = gameTime; // Use gameTime instead of clock.getElapsedTime()

    // Cycle Update
    const effectiveTime = t + timeOffset;
    const cyclePos = effectiveTime % CYCLE_DURATION;
    const cycleWeatherBias = getWeatherForTimeOfDay(cyclePos);

    // Update Melody Ribbon
    melodyRibbon.update(t);

    // Weather Update
    profiler.measure('Weather', () => {
        weatherSystem.update(t, audioState, cycleWeatherBias);
        weatherSystem.updateBerrySeasonalSize(cyclePos, CYCLE_DURATION);
    });

    // Sync TSL Wind with BPM modulation
    // Map BPM (60-180 range approx) to a wind multiplier
    const activeBPM = audioState?.bpm || 120; // Renamed to avoid confusion and ensure definition
    const bpmWindFactor = MathUtils.clamp((activeBPM - 60) / 120, 0, 1.5);
    const baseWind = 1.0 + weatherSystem.windSpeed * 4.0;

    // Smoothly interpolate wind speed changes to avoid jerky TSL updates
    const targetWindSpeed = baseWind * (1.0 + bpmWindFactor * 0.5);
    // Use a simple lerp for smoothing, assuming 60fps
    uWindSpeed.value = MathUtils.lerp(uWindSpeed.value, targetWindSpeed, 0.05);

    uWindDirection.value.copy(weatherSystem.windDirection);

    const currentBeatPhase = audioState?.beatPhase || 0;

    // Beat Detection
    if (currentBeatPhase < lastBeatPhase && lastBeatPhase > 0.8) {
        const kickTrigger = audioState?.kickTrigger || 0;
        if (kickTrigger > 0.3) {
            beatFlashIntensity = 0.5 + kickTrigger * 0.5;
            cameraZoomPulse = 2 + kickTrigger * 3;
            // Pulse the overlay intensity
            uKickIntensity.value = 1.0;
        }
    }
    lastBeatPhase = currentBeatPhase;

    // Effects Decay
    if (beatFlashIntensity > 0) {
        beatFlashIntensity *= 0.9;
        if (beatFlashIntensity < 0.01) beatFlashIntensity = 0;
    }
    // Decay Kick Overlay
    uKickIntensity.value = MathUtils.lerp(uKickIntensity.value, 0.0, delta * 5.0);

    if (cameraZoomPulse > 0) {
        camera.fov = baseFOV - cameraZoomPulse;
        camera.updateProjectionMatrix();
        cameraZoomPulse *= 0.85;
        if (cameraZoomPulse < 0.1) {
            cameraZoomPulse = 0;
            camera.fov = baseFOV;
            camera.updateProjectionMatrix();
        }
    }

    // Cycle & Visuals
    // Use weatherSystem's target palette mode (from pattern)
    const currentState = getCycleState(effectiveTime, weatherSystem.targetPaletteMode || 'standard');
    // weatherSystem.updateBerrySeasonalSize called earlier in Weather block

    const nightStart = DURATION_SUNRISE + DURATION_DAY + DURATION_SUNSET;
    isNight = (cyclePos > nightStart - 30) || (cyclePos < DURATION_SUNRISE);

    // Weather Visuals
    const weatherIntensity = weatherSystem.getIntensity();
    const weatherState = weatherSystem.getState();
    
    // Bolt: Use scratch objects to prevent GC
    const baseSkyTop = _scratchBaseSkyTop.copy(currentState.skyTop);
    const baseSkyBot = _scratchBaseSkyBot.copy(currentState.skyBot);
    const baseFog = _scratchBaseFog.copy(currentState.fog);
    
    if (weatherState === WeatherState.STORM) {
        baseSkyTop.lerp(COLOR_STORM_SKY_TOP, weatherIntensity * 0.6);
        baseSkyBot.lerp(COLOR_STORM_SKY_BOT, weatherIntensity * 0.5);
        baseFog.lerp(COLOR_STORM_FOG, weatherIntensity * 0.4);
    } else if (weatherState === WeatherState.RAIN) {
        baseSkyTop.lerp(COLOR_RAIN, weatherIntensity * 0.3);
        baseSkyBot.lerp(COLOR_RAIN, weatherIntensity * 0.25);
        baseFog.lerp(COLOR_RAIN_FOG, weatherIntensity * 0.2);
    }
    
    uSkyTopColor.value.copy(baseSkyTop);
    uSkyBottomColor.value.copy(baseSkyBot);
    uHorizonColor.value.copy(currentState.horizon);
    uAtmosphereIntensity.value = currentState.atmosphereIntensity;
    scene.fog.color.copy(baseFog);

    const targetNear = isNight ? 5 : 20;
    const targetFar = isNight ? 40 : 100;
    scene.fog.near += (targetNear - scene.fog.near) * delta * 0.5;
    scene.fog.far += (targetFar - scene.fog.far) * delta * 0.5;

    let sunIntensity = currentState.sunInt;
    let ambIntensity = currentState.ambInt;
    
    if (weatherState === WeatherState.STORM) {
        sunIntensity *= (1 - weatherIntensity * 0.7);
        ambIntensity *= (1 - weatherIntensity * 0.5);
    } else if (weatherState === WeatherState.RAIN) {
        sunIntensity *= (1 - weatherIntensity * 0.3);
        ambIntensity *= (1 - weatherIntensity * 0.2);
    }
    
    sunLight.color.copy(currentState.sun);
    sunLight.intensity = sunIntensity;
    ambientLight.color.copy(currentState.amb);
    ambientLight.intensity = ambIntensity + beatFlashIntensity * 0.5;

    // Sun/Moon Position
    if (cyclePos < 540) {
        const sunProgress = cyclePos / 540;
        const angle = sunProgress * Math.PI;
        const r = 100;
        sunLight.position.set(Math.cos(angle) * -r, Math.sin(angle) * r, 20);
        sunLight.visible = true;
        sunGlow.visible = true;
        sunCorona.visible = true;
        moon.visible = false;

        // Bolt: Reuse scratch vector to prevent GC (3 vectors per frame)
        _scratchSunVector.copy(sunLight.position).normalize();

        sunGlow.position.copy(_scratchSunVector).multiplyScalar(400);
        sunGlow.lookAt(camera.position);
        sunCorona.position.copy(_scratchSunVector).multiplyScalar(390);
        sunCorona.lookAt(camera.position);
        lightShaftGroup.position.copy(_scratchSunVector).multiplyScalar(380);
        lightShaftGroup.lookAt(camera.position);

        // Sun Visual Tweaks (Glow/Shafts)
        let glowIntensity = 0.25;
        let coronaIntensity = 0.15;
        let shaftIntensity = 0.0;
        let shaftVisible = false;
        
        if (sunProgress < 0.15) {
            const factor = 1.0 - (sunProgress / 0.15);
            glowIntensity = 0.25 + factor * 0.35;
            coronaIntensity = 0.15 + factor * 0.25;
            shaftIntensity = factor * 0.12;
            shaftVisible = false; // DISABLED: Light shafts cause 2-5s freeze during sunrise when viewing sun directly
            sunGlowMat.color.setHex(0xFFB366);
            coronaMat.color.setHex(0xFFD6A3);
        } else if (sunProgress > 0.85) {
            const factor = (sunProgress - 0.85) / 0.15;
            glowIntensity = 0.25 + factor * 0.45;
            coronaIntensity = 0.15 + factor * 0.35;
            shaftIntensity = factor * 0.18;
            shaftVisible = false; // DISABLED: Light shafts cause 2-5s freeze during sunset when viewing sun directly
            sunGlowMat.color.setHex(0xFF9966);
            coronaMat.color.setHex(0xFFCC99);
        } else {
            sunGlowMat.color.setHex(0xFFE599);
            coronaMat.color.setHex(0xFFF4D6);
        }
        
        sunGlowMat.opacity = glowIntensity;
        coronaMat.opacity = coronaIntensity;
        lightShaftGroup.visible = shaftVisible;
        if (shaftVisible) {
            lightShaftGroup.rotation.z += delta * 0.1;
            lightShaftGroup.children.forEach(shaft => {
                shaft.material.opacity = shaftIntensity;
            });
        }
    } else {
        sunLight.visible = false;
        sunGlow.visible = false;
        sunCorona.visible = false;
        lightShaftGroup.visible = false;
        moon.visible = true;

        const nightProgress = (cyclePos - 540) / (CYCLE_DURATION - 540);
        const moonAngle = nightProgress * Math.PI;
        const r = 90;
        moon.position.set(Math.cos(moonAngle) * -r, Math.sin(moonAngle) * r, -30);
        moon.lookAt(0,0,0);
        updateMoon(moon, delta, audioState);
    }

    // Star Opacity
    const progress = cyclePos / CYCLE_DURATION;
    let starOp = 0;
    const starDuskStart = 0.50;
    const starNightStart = 0.60;
    const starNightEnd = 0.90;
    const starDawnEnd = 0.98;
    
    if (progress >= starNightStart && progress <= starNightEnd) {
        starOp = 1.0;
    } else if (progress > starDuskStart && progress < starNightStart) {
        starOp = (progress - starDuskStart) / (starNightStart - starDuskStart);
    } else if (progress > starNightEnd && progress < starDawnEnd) {
        starOp = 1.0 - ((progress - starNightEnd) / (starDawnEnd - starNightEnd));
    }
    uStarOpacity.value = MathUtils.lerp(uStarOpacity.value, starOp * 0.95, delta * 2);

    // Aurora Update (Visible only at night, intensity driven by high-freq/melody channels if avail)
    // We'll base it on star opacity for visibility, and mix in some audio reactivity
    const baseAuroraVis = starOp * 0.8; // Max 0.8 visibility at night

    // Update Water Uniforms
    if (audioState) {
        const kick = audioState.kickTrigger || 0;
        uAudioLow.value = MathUtils.lerp(uAudioLow.value, kick, 0.2);

        let high = 0;
        if (audioState.channelData && audioState.channelData.length > 5) {
             const ch5 = audioState.channelData[5].trigger || 0;
             const ch6 = audioState.channelData[6] ? (audioState.channelData[6].trigger || 0) : 0;
             high = Math.max(ch5, ch6);
        }
        uAudioHigh.value = MathUtils.lerp(uAudioHigh.value, high, 0.2);
    }

    // Simple audio reactivity for Aurora (using generic audioState.energy or high channels)
    // If we have channels, grab a high-freq one (e.g. 5 or 6)
    let auroraAudioBoost = 0.0;
    if (audioState && audioState.channelData && audioState.channelData.length > 4) {
        // Use channel 5 (often leads/pads)
        auroraAudioBoost = audioState.channelData[4].trigger || 0;
    } else if (audioState) {
        // Fallback to average energy
        auroraAudioBoost = (audioState.energy || 0) * 2.0;
    }

    const targetAuroraInt = baseAuroraVis * (0.3 + auroraAudioBoost * 0.7); // Base glow + reactive boost
    uAuroraIntensity.value = MathUtils.lerp(uAuroraIntensity.value, targetAuroraInt, delta * 2);

    // Aurora Color Shift (Slowly rotate hue or react to chords)
    // For now, let's just shift hue slowly with time
    const hue = (t * 0.05) % 1.0;
    // Bolt Optimization: Use scratch color to avoid per-frame GC
    _scratchAuroraColor.setHSL(hue, 1.0, 0.5);
    // If heavy bass, shift to purple/red?
    if (beatFlashIntensity > 0.2) {
        _scratchAuroraColor.setHSL(0.8 + beatFlashIntensity * 0.1, 1.0, 0.6); // Pink/Red shift
    }
    uAuroraColor.value.copy(_scratchAuroraColor);

    // Foliage Materials
    let weatherStateStr = 'clear';
    if (weatherState === WeatherState.STORM) weatherStateStr = 'storm';
    else if (weatherState === WeatherState.RAIN) weatherStateStr = 'rain';
    updateFoliageMaterials(audioState, isNight, weatherStateStr, weatherIntensity);

    // Deep Night
    const deepNightStart = DURATION_SUNRISE + DURATION_DAY + DURATION_SUNSET + DURATION_DUSK_NIGHT;
    const deepNightEnd = deepNightStart + DURATION_DEEP_NIGHT;
    const isDeepNight = (cyclePos >= deepNightStart && cyclePos < deepNightEnd);

    // Foliage Animation & Reactivity (Delegated to MusicReactivitySystem)
    profiler.measure('MusicReact', () => {
        musicReactivity.update(t, audioState, weatherSystem, animatedFoliage, camera, isNight, isDeepNight, moon);
    });

    // Fireflies
    if (fireflies) {
        fireflies.visible = isDeepNight;
        if (isDeepNight) {
            updateFireflies(fireflies, t);
        }
    }

    // Player Physics
    profiler.measure('Physics', () => {
        updatePhysics(delta, camera, controls, keyStates, audioState);
    });

    // Gameplay: Blaster projectiles & falling clouds & Berries
    // Reordered slightly to group them as per profiler instruction
    profiler.measure('Gameplay', () => {
        updateFallingBerries(delta);
        const berriesCollected = collectFallingBerries(camera.position, 1.5);
        if (berriesCollected > 0) {
            player.energy = Math.min(player.maxEnergy, player.energy + berriesCollected * 0.5);
        }
        player.energy = Math.max(0, player.energy - delta * 0.1);

        updateBlaster(delta, scene, weatherSystem, t);
        updateFallingClouds(delta, foliageClouds, getGroundHeight);
    });

    profiler.measure('Render', () => renderer.render(scene, camera));

    profiler.endFrame();
}

initWasmParallel().then(async (wasmLoaded) => { // Using parallel WASM loading for faster startup
    console.log(`WASM modules ${wasmLoaded ? 'active (loaded in parallel)' : 'using JS fallbacks'}`);

    // Initialize camera position to ground height (ensures player doesn't start in mid-air or underground)
    const initialGroundY = getGroundHeight(camera.position.x, camera.position.z);
    camera.position.y = initialGroundY + 1.8; // Player eye height is 1.8 above ground
    console.log(`[Startup] Camera positioned at ground height: y=${camera.position.y.toFixed(2)}`);

    if (window.setLoadingStatus) window.setLoadingStatus("Preparing Scene...");

    // Wait for world to load before starting animation
    await worldLoadPromise;
    
    // Start animation loop after world is loaded
    renderer.setAnimationLoop(animate);
    try { window.__sceneReady = true; } catch (e) {}

    // Hide loading screen after world is fully loaded
    if (window.setLoadingStatus) window.setLoadingStatus("Entering Candy World...");
    
    setTimeout(() => {
        if (window.hideLoadingScreen) window.hideLoadingScreen();
    }, 200); // Shorter delay for faster perceived load

    const startButton = document.getElementById('startButton');
    if (startButton) {
        startButton.disabled = false;
        startButton.innerText = 'Start Exploration ';
    }

    // Defer shader compilation and non-critical initialization
    setTimeout(async () => {
        console.log('[Deferred] Starting shader pre-compilation...');
        
        // --- NUCLEAR WARMUP: FORCE SHADER COMPILATION ---
        // Create dummy objects for everything that might spawn later
        const dummyGroup = new Group();
        dummyGroup.position.set(0, -9999, 0); // Hide underground
        scene.add(dummyGroup);

        // 1. Spawn Dummy Flora
        const dummyFlower = createFlower({ shape: 'layered' });
        const dummyMushroom = createMushroom({ size: 'regular' });
        dummyGroup.add(dummyFlower);
        dummyGroup.add(dummyMushroom);

        // 2. Fire Dummy Projectile
        const dummyOrigin = new Vector3(0, -9999, 0);
        const dummyDir = new Vector3(0, 1, 0);
        fireRainbow(scene, dummyOrigin, dummyDir);

        // 3. FORCE COMPILATION
        // This makes the renderer look at the whole scene and build shaders NOW.
        try {
            await renderer.compileAsync(scene, camera);
            await forceFullSceneWarmup(renderer, scene, camera);
            console.log(" Scene shaders pre-compiled (Nuclear Warmup complete).");
        } catch (e) {
            console.warn("Shader compile error:", e);
        }

        // 4. Cleanup (Remove from scene, but DO NOT Dispose geometries/materials)
        scene.remove(dummyGroup);
        
        console.log('[Deferred] Shader compilation complete');
    }, 100); // Defer shader compilation by 100ms

    // Defer celestial bodies and aurora initialization
    setTimeout(() => {
        console.log('[Deferred] Loading celestial bodies and aurora...');
        initDeferredVisuals();
    }, 300);

    // Note: libopenmpt audio library is loaded via script tag in index.html with a 500ms delay
    // No additional initialization needed here - it's handled by the index.html script
});
//# sourceMappingURL=index-jHJgv_V5.js.map
